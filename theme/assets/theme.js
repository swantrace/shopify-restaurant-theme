(function (factory) {
  typeof define === 'function' && define.amd ? define('index', factory) :
  factory();
}((function () { 'use strict';

  /*!
    * Native JavaScript for Bootstrap v3.0.10 (https://thednp.github.io/bootstrap.native/)
    * Copyright 2015-2020 © dnp_theme
    * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)
    */
  var transitionEndEvent = 'webkitTransition' in document.head.style ? 'webkitTransitionEnd' : 'transitionend';
  var supportTransition = 'webkitTransition' in document.head.style || 'transition' in document.head.style;
  var transitionDuration = 'webkitTransition' in document.head.style ? 'webkitTransitionDuration' : 'transitionDuration';

  function getElementTransitionDuration(element) {
    var duration = supportTransition ? parseFloat(getComputedStyle(element)[transitionDuration]) : 0;
    duration = typeof duration === 'number' && !isNaN(duration) ? duration * 1000 : 0;
    return duration;
    
  }

  function emulateTransitionEnd(element, handler) {
    var called = 0,
        duration = getElementTransitionDuration(element);
    duration ? element.addEventListener(transitionEndEvent, function transitionEndWrapper(e) {
      !called && handler(e), called = 1;
      element.removeEventListener(transitionEndEvent, transitionEndWrapper);
    }) : setTimeout(function () {
      !called && handler(), called = 1;
    }, 17);
  }

  function queryElement(selector, parent) {
    var lookUp = parent && parent instanceof Element ? parent : document;
    return selector instanceof Element ? selector : lookUp.querySelector(selector);
  }

  function bootstrapCustomEvent(eventName, componentName, related) {
    var OriginalCustomEvent = new CustomEvent(eventName + '.bs.' + componentName, {
      cancelable: true
    });
    OriginalCustomEvent.relatedTarget = related;
    return OriginalCustomEvent;
  }

  function dispatchCustomEvent(customEvent) {
    this && this.dispatchEvent(customEvent);
  }

  function Alert(element) {
    var self = this,
        alert,
        closeCustomEvent = bootstrapCustomEvent('close', 'alert'),
        closedCustomEvent = bootstrapCustomEvent('closed', 'alert');

    function triggerHandler() {
      alert.classList.contains('fade') ? emulateTransitionEnd(alert, transitionEndHandler) : transitionEndHandler();
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      element[action]('click', clickHandler, false);
    }

    function clickHandler(e) {
      alert = e && e.target.closest(".alert");
      element = queryElement('[data-dismiss="alert"]', alert);
      element && alert && (element === e.target || element.contains(e.target)) && self.close();
    }

    function transitionEndHandler() {
      toggleEvents();
      alert.parentNode.removeChild(alert);
      dispatchCustomEvent.call(alert, closedCustomEvent);
    }

    self.close = function () {
      if (alert && element && alert.classList.contains('show')) {
        dispatchCustomEvent.call(alert, closeCustomEvent);

        if (closeCustomEvent.defaultPrevented) {
          return;
        }

        self.dispose();
        alert.classList.remove('show');
        triggerHandler();
      }
    };

    self.dispose = function () {
      toggleEvents();
      delete element.Alert;
    };

    element = queryElement(element);
    alert = element.closest('.alert');
    element.Alert && element.Alert.dispose();

    if (!element.Alert) {
      toggleEvents(1);
    }

    self.element = element;
    element.Alert = self;
  }

  function Button(element) {
    var self = this,
        labels,
        changeCustomEvent = bootstrapCustomEvent('change', 'button');

    function toggle(e) {
      var input,
          label = e.target.tagName === 'LABEL' ? e.target : e.target.closest('LABEL') ? e.target.closest('LABEL') : null;
      input = label && label.getElementsByTagName('INPUT')[0];

      if (!input) {
        return;
      }

      dispatchCustomEvent.call(input, changeCustomEvent);
      dispatchCustomEvent.call(element, changeCustomEvent);

      if (input.type === 'checkbox') {
        if (changeCustomEvent.defaultPrevented) {
          return;
        }

        if (!input.checked) {
          label.classList.add('active');
          input.getAttribute('checked');
          input.setAttribute('checked', 'checked');
          input.checked = true;
        } else {
          label.classList.remove('active');
          input.getAttribute('checked');
          input.removeAttribute('checked');
          input.checked = false;
        }

        if (!element.toggled) {
          element.toggled = true;
        }
      }

      if (input.type === 'radio' && !element.toggled) {
        if (changeCustomEvent.defaultPrevented) {
          return;
        }

        if (!input.checked || e.screenX === 0 && e.screenY == 0) {
          label.classList.add('active');
          label.classList.add('focus');
          input.setAttribute('checked', 'checked');
          input.checked = true;
          element.toggled = true;
          Array.from(labels).map(function (otherLabel) {
            var otherInput = otherLabel.getElementsByTagName('INPUT')[0];

            if (otherLabel !== label && otherLabel.classList.contains('active')) {
              dispatchCustomEvent.call(otherInput, changeCustomEvent);
              otherLabel.classList.remove('active');
              otherInput.removeAttribute('checked');
              otherInput.checked = false;
            }
          });
        }
      }

      setTimeout(function () {
        element.toggled = false;
      }, 50);
    }

    function keyHandler(e) {
      var key = e.which || e.keyCode;
      key === 32 && e.target === document.activeElement && toggle(e);
    }

    function preventScroll(e) {
      var key = e.which || e.keyCode;
      key === 32 && e.preventDefault();
    }

    function focusToggle(e) {
      if (e.target.tagName === 'INPUT') {
        var action = e.type === 'focusin' ? 'add' : 'remove';
        e.target.closest('.btn').classList[action]('focus');
      }
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      element[action]('click', toggle, false);
      element[action]('keyup', keyHandler, false), element[action]('keydown', preventScroll, false);
      element[action]('focusin', focusToggle, false), element[action]('focusout', focusToggle, false);
    }

    self.dispose = function () {
      toggleEvents();
      delete element.Button;
    };

    element = queryElement(element);
    element.Button && element.Button.dispose();
    labels = element.getElementsByClassName('btn');

    if (!labels.length) {
      return;
    }

    if (!element.Button) {
      toggleEvents(1);
    }

    element.toggled = false;
    element.Button = self;
    Array.from(labels).map(function (btn) {
      !btn.classList.contains('active') && queryElement('input:checked', btn) && btn.classList.add('active');
      btn.classList.contains('active') && !queryElement('input:checked', btn) && btn.classList.remove('active');
    });
  }

  var mouseHoverEvents = 'onmouseleave' in document ? ['mouseenter', 'mouseleave'] : ['mouseover', 'mouseout'];

  var supportPassive = function () {
    var result = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          result = true;
        }
      });
      document.addEventListener('DOMContentLoaded', function wrap() {
        document.removeEventListener('DOMContentLoaded', wrap, opts);
      }, opts);
    } catch (e) {}

    return result;
  }();

  var passiveHandler = supportPassive ? {
    passive: true
  } : false;

  function isElementInScrollRange(element) {
    var bcr = element.getBoundingClientRect(),
        viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    return bcr.top <= viewportHeight && bcr.bottom >= 0;
  }

  function Carousel(element, options) {
    options = options || {};
    var self = this,
        vars,
        ops,
        slideCustomEvent,
        slidCustomEvent,
        slides,
        leftArrow,
        rightArrow,
        indicator,
        indicators;

    function pauseHandler() {
      if (ops.interval !== false && !element.classList.contains('paused')) {
        element.classList.add('paused');
        !vars.isSliding && (clearInterval(vars.timer), vars.timer = null);
      }
    }

    function resumeHandler() {
      if (ops.interval !== false && element.classList.contains('paused')) {
        element.classList.remove('paused');
        !vars.isSliding && (clearInterval(vars.timer), vars.timer = null);
        !vars.isSliding && self.cycle();
      }
    }

    function indicatorHandler(e) {
      e.preventDefault();

      if (vars.isSliding) {
        return;
      }

      var eventTarget = e.target;

      if (eventTarget && !eventTarget.classList.contains('active') && eventTarget.getAttribute('data-slide-to')) {
        vars.index = parseInt(eventTarget.getAttribute('data-slide-to'));
      } else {
        return false;
      }

      self.slideTo(vars.index);
    }

    function controlsHandler(e) {
      e.preventDefault();

      if (vars.isSliding) {
        return;
      }

      var eventTarget = e.currentTarget || e.srcElement;

      if (eventTarget === rightArrow) {
        vars.index++;
      } else if (eventTarget === leftArrow) {
        vars.index--;
      }

      self.slideTo(vars.index);
    }

    function keyHandler(ref) {
      var which = ref.which;

      if (vars.isSliding) {
        return;
      }

      switch (which) {
        case 39:
          vars.index++;
          break;

        case 37:
          vars.index--;
          break;

        default:
          return;
      }

      self.slideTo(vars.index);
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';

      if (ops.pause && ops.interval) {
        element[action](mouseHoverEvents[0], pauseHandler, false);
        element[action](mouseHoverEvents[1], resumeHandler, false);
        element[action]('touchstart', pauseHandler, passiveHandler);
        element[action]('touchend', resumeHandler, passiveHandler);
      }

      ops.touch && slides.length > 1 && element[action]('touchstart', touchDownHandler, passiveHandler);
      rightArrow && rightArrow[action]('click', controlsHandler, false);
      leftArrow && leftArrow[action]('click', controlsHandler, false);
      indicator && indicator[action]('click', indicatorHandler, false);
      ops.keyboard && window[action]('keydown', keyHandler, false);
    }

    function toggleTouchEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      element[action]('touchmove', touchMoveHandler, passiveHandler);
      element[action]('touchend', touchEndHandler, passiveHandler);
    }

    function touchDownHandler(e) {
      if (vars.isTouch) {
        return;
      }

      vars.touchPosition.startX = e.changedTouches[0].pageX;

      if (element.contains(e.target)) {
        vars.isTouch = true;
        toggleTouchEvents(1);
      }
    }

    function touchMoveHandler(e) {
      if (!vars.isTouch) {
        e.preventDefault();
        return;
      }

      vars.touchPosition.currentX = e.changedTouches[0].pageX;

      if (e.type === 'touchmove' && e.changedTouches.length > 1) {
        e.preventDefault();
        return false;
      }
    }

    function touchEndHandler(e) {
      if (!vars.isTouch || vars.isSliding) {
        return;
      }

      vars.touchPosition.endX = vars.touchPosition.currentX || e.changedTouches[0].pageX;

      if (vars.isTouch) {
        if ((!element.contains(e.target) || !element.contains(e.relatedTarget)) && Math.abs(vars.touchPosition.startX - vars.touchPosition.endX) < 75) {
          return false;
        } else {
          if (vars.touchPosition.currentX < vars.touchPosition.startX) {
            vars.index++;
          } else if (vars.touchPosition.currentX > vars.touchPosition.startX) {
            vars.index--;
          }

          vars.isTouch = false;
          self.slideTo(vars.index);
        }

        toggleTouchEvents();
      }
    }

    function setActivePage(pageIndex) {
      Array.from(indicators).map(function (x) {
        x.classList.remove('active');
      });
      indicators[pageIndex] && indicators[pageIndex].classList.add('active');
    }

    function transitionEndHandler(e) {
      if (vars.touchPosition) {
        var next = vars.index,
            timeout = e && e.target !== slides[next] ? e.elapsedTime * 1000 + 100 : 20,
            activeItem = self.getActiveIndex(),
            orientation = vars.direction === 'left' ? 'next' : 'prev';
        vars.isSliding && setTimeout(function () {
          if (vars.touchPosition) {
            vars.isSliding = false;
            slides[next].classList.add('active');
            slides[activeItem].classList.remove('active');
            slides[next].classList.remove("carousel-item-" + orientation);
            slides[next].classList.remove("carousel-item-" + vars.direction);
            slides[activeItem].classList.remove("carousel-item-" + vars.direction);
            dispatchCustomEvent.call(element, slidCustomEvent);

            if (!document.hidden && ops.interval && !element.classList.contains('paused')) {
              self.cycle();
            }
          }
        }, timeout);
      }
    }

    self.cycle = function () {
      if (vars.timer) {
        clearInterval(vars.timer);
        vars.timer = null;
      }

      vars.timer = setInterval(function () {
        var idx = vars.index || self.getActiveIndex();
        isElementInScrollRange(element) && (idx++, self.slideTo(idx));
      }, ops.interval);
    };

    self.slideTo = function (next) {
      if (vars.isSliding) {
        return;
      }

      var activeItem = self.getActiveIndex(),
          orientation;

      if (activeItem === next) {
        return;
      } else if (activeItem < next || activeItem === 0 && next === slides.length - 1) {
        vars.direction = 'left';
      } else if (activeItem > next || activeItem === slides.length - 1 && next === 0) {
        vars.direction = 'right';
      }

      if (next < 0) {
        next = slides.length - 1;
      } else if (next >= slides.length) {
        next = 0;
      }

      orientation = vars.direction === 'left' ? 'next' : 'prev';
      slideCustomEvent = bootstrapCustomEvent('slide', 'carousel', slides[next]);
      slidCustomEvent = bootstrapCustomEvent('slid', 'carousel', slides[next]);
      dispatchCustomEvent.call(element, slideCustomEvent);

      if (slideCustomEvent.defaultPrevented) {
        return;
      }

      vars.index = next;
      vars.isSliding = true;
      clearInterval(vars.timer);
      vars.timer = null;
      setActivePage(next);

      if (getElementTransitionDuration(slides[next]) && element.classList.contains('slide')) {
        slides[next].classList.add("carousel-item-" + orientation);
        slides[next].offsetWidth;
        slides[next].classList.add("carousel-item-" + vars.direction);
        slides[activeItem].classList.add("carousel-item-" + vars.direction);
        emulateTransitionEnd(slides[next], transitionEndHandler);
      } else {
        slides[next].classList.add('active');
        slides[next].offsetWidth;
        slides[activeItem].classList.remove('active');
        setTimeout(function () {
          vars.isSliding = false;

          if (ops.interval && element && !element.classList.contains('paused')) {
            self.cycle();
          }

          dispatchCustomEvent.call(element, slidCustomEvent);
        }, 100);
      }
    };

    self.getActiveIndex = function () {
      return Array.from(slides).indexOf(element.getElementsByClassName('carousel-item active')[0]) || 0;
    };

    self.dispose = function () {
      var itemClasses = ['left', 'right', 'prev', 'next'];
      Array.from(slides).map(function (slide, idx) {
        slide.classList.contains('active') && setActivePage(idx);
        itemClasses.map(function (cls) {
          return slide.classList.remove("carousel-item-" + cls);
        });
      });
      clearInterval(vars.timer);
      toggleEvents();
      vars = {};
      ops = {};
      delete element.Carousel;
    };

    element = queryElement(element);
    element.Carousel && element.Carousel.dispose();
    slides = element.getElementsByClassName('carousel-item');
    leftArrow = element.getElementsByClassName('carousel-control-prev')[0];
    rightArrow = element.getElementsByClassName('carousel-control-next')[0];
    indicator = element.getElementsByClassName('carousel-indicators')[0];
    indicators = indicator && indicator.getElementsByTagName("LI") || [];

    if (slides.length < 2) {
      return;
    }

    var intervalAttribute = element.getAttribute('data-interval'),
        intervalData = intervalAttribute === 'false' ? 0 : parseInt(intervalAttribute),
        touchData = element.getAttribute('data-touch') === 'false' ? 0 : 1,
        pauseData = element.getAttribute('data-pause') === 'hover' || false,
        keyboardData = element.getAttribute('data-keyboard') === 'true' || false,
        intervalOption = options.interval,
        touchOption = options.touch;
    ops = {};
    ops.keyboard = options.keyboard === true || keyboardData;
    ops.pause = options.pause === 'hover' || pauseData ? 'hover' : false;
    ops.touch = touchOption || touchData;
    ops.interval = typeof intervalOption === 'number' ? intervalOption : intervalOption === false || intervalData === 0 || intervalData === false ? 0 : isNaN(intervalData) ? 5000 : intervalData;

    if (self.getActiveIndex() < 0) {
      slides.length && slides[0].classList.add('active');
      indicators.length && setActivePage(0);
    }

    vars = {};
    vars.direction = 'left';
    vars.index = 0;
    vars.timer = null;
    vars.isSliding = false;
    vars.isTouch = false;
    vars.touchPosition = {
      startX: 0,
      currentX: 0,
      endX: 0
    };
    toggleEvents(1);

    if (ops.interval) {
      self.cycle();
    }

    element.Carousel = self;
  }

  function Collapse(element, options) {
    options = options || {};
    var self = this;
    var accordion = null,
        collapse = null,
        activeCollapse,
        activeElement,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent;

    function openAction(collapseElement, toggle) {
      dispatchCustomEvent.call(collapseElement, showCustomEvent);

      if (showCustomEvent.defaultPrevented) {
        return;
      }

      collapseElement.isAnimating = true;
      collapseElement.classList.add('collapsing');
      collapseElement.classList.remove('collapse');
      collapseElement.style.height = collapseElement.scrollHeight + "px";
      emulateTransitionEnd(collapseElement, function () {
        collapseElement.isAnimating = false;
        collapseElement.setAttribute('aria-expanded', 'true');
        toggle.setAttribute('aria-expanded', 'true');
        collapseElement.classList.remove('collapsing');
        collapseElement.classList.add('collapse');
        collapseElement.classList.add('show');
        collapseElement.style.height = '';
        dispatchCustomEvent.call(collapseElement, shownCustomEvent);
      });
    }

    function closeAction(collapseElement, toggle) {
      dispatchCustomEvent.call(collapseElement, hideCustomEvent);

      if (hideCustomEvent.defaultPrevented) {
        return;
      }

      collapseElement.isAnimating = true;
      collapseElement.style.height = collapseElement.scrollHeight + "px";
      collapseElement.classList.remove('collapse');
      collapseElement.classList.remove('show');
      collapseElement.classList.add('collapsing');
      collapseElement.offsetWidth;
      collapseElement.style.height = '0px';
      emulateTransitionEnd(collapseElement, function () {
        collapseElement.isAnimating = false;
        collapseElement.setAttribute('aria-expanded', 'false');
        toggle.setAttribute('aria-expanded', 'false');
        collapseElement.classList.remove('collapsing');
        collapseElement.classList.add('collapse');
        collapseElement.style.height = '';
        dispatchCustomEvent.call(collapseElement, hiddenCustomEvent);
      });
    }

    self.toggle = function (e) {
      if (e && e.target.tagName === 'A' || element.tagName === 'A') {
        e.preventDefault();
      }

      if (element.contains(e.target) || e.target === element) {
        if (!collapse.classList.contains('show')) {
          self.show();
        } else {
          self.hide();
        }
      }
    };

    self.hide = function () {
      if (collapse.isAnimating) {
        return;
      }

      closeAction(collapse, element);
      element.classList.add('collapsed');
    };

    self.show = function () {
      if (accordion) {
        activeCollapse = accordion.getElementsByClassName("collapse show")[0];
        activeElement = activeCollapse && (queryElement("[data-target=\"#" + activeCollapse.id + "\"]", accordion) || queryElement("[href=\"#" + activeCollapse.id + "\"]", accordion));
      }

      if (!collapse.isAnimating) {
        if (activeElement && activeCollapse !== collapse) {
          closeAction(activeCollapse, activeElement);
          activeElement.classList.add('collapsed');
        }

        openAction(collapse, element);
        element.classList.remove('collapsed');
      }
    };

    self.dispose = function () {
      element.removeEventListener('click', self.toggle, false);
      delete element.Collapse;
    };

    element = queryElement(element);
    element.Collapse && element.Collapse.dispose();
    var accordionData = element.getAttribute('data-parent');
    showCustomEvent = bootstrapCustomEvent('show', 'collapse');
    shownCustomEvent = bootstrapCustomEvent('shown', 'collapse');
    hideCustomEvent = bootstrapCustomEvent('hide', 'collapse');
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'collapse');
    collapse = queryElement(options.target || element.getAttribute('data-target') || element.getAttribute('href'));
    collapse.isAnimating = false;
    accordion = element.closest(options.parent || accordionData);

    if (!element.Collapse) {
      element.addEventListener('click', self.toggle, false);
    }

    element.Collapse = self;
  }

  function setFocus(element) {
    element.focus ? element.focus() : element.setActive();
  }

  function Dropdown(element, option) {
    var self = this,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent,
        relatedTarget = null,
        parent,
        menu,
        menuItems = [],
        persist;

    function preventEmptyAnchor(anchor) {
      (anchor.href && anchor.href.slice(-1) === '#' || anchor.parentNode && anchor.parentNode.href && anchor.parentNode.href.slice(-1) === '#') && this.preventDefault();
    }

    function toggleDismiss() {
      var action = element.open ? 'addEventListener' : 'removeEventListener';
      document[action]('click', dismissHandler, false);
      document[action]('keydown', preventScroll, false);
      document[action]('keyup', keyHandler, false);
      document[action]('focus', dismissHandler, false);
    }

    function dismissHandler(e) {
      var eventTarget = e.target,
          hasData = eventTarget && (eventTarget.getAttribute('data-toggle') || eventTarget.parentNode && eventTarget.parentNode.getAttribute && eventTarget.parentNode.getAttribute('data-toggle'));

      if (e.type === 'focus' && (eventTarget === element || eventTarget === menu || menu.contains(eventTarget))) {
        return;
      }

      if ((eventTarget === menu || menu.contains(eventTarget)) && (persist || hasData)) {
        return;
      } else {
        relatedTarget = eventTarget === element || element.contains(eventTarget) ? element : null;
        self.hide();
      }

      preventEmptyAnchor.call(e, eventTarget);
    }

    function clickHandler(e) {
      relatedTarget = element;
      self.show();
      preventEmptyAnchor.call(e, e.target);
    }

    function preventScroll(e) {
      var key = e.which || e.keyCode;

      if (key === 38 || key === 40) {
        e.preventDefault();
      }
    }

    function keyHandler(e) {
      var key = e.which || e.keyCode,
          activeItem = document.activeElement,
          isSameElement = activeItem === element,
          isInsideMenu = menu.contains(activeItem),
          isMenuItem = activeItem.parentNode === menu || activeItem.parentNode.parentNode === menu,
          idx = menuItems.indexOf(activeItem);

      if (isMenuItem) {
        idx = isSameElement ? 0 : key === 38 ? idx > 1 ? idx - 1 : 0 : key === 40 ? idx < menuItems.length - 1 ? idx + 1 : idx : idx;
        menuItems[idx] && setFocus(menuItems[idx]);
      }

      if ((menuItems.length && isMenuItem || !menuItems.length && (isInsideMenu || isSameElement) || !isInsideMenu) && element.open && key === 27) {
        self.toggle();
        relatedTarget = null;
      }
    }

    self.show = function () {
      showCustomEvent = bootstrapCustomEvent('show', 'dropdown', relatedTarget);
      dispatchCustomEvent.call(parent, showCustomEvent);

      if (showCustomEvent.defaultPrevented) {
        return;
      }

      menu.classList.add('show');
      parent.classList.add('show');
      element.setAttribute('aria-expanded', true);
      element.open = true;
      element.removeEventListener('click', clickHandler, false);
      setTimeout(function () {
        setFocus(menu.getElementsByTagName('INPUT')[0] || element);
        toggleDismiss();
        shownCustomEvent = bootstrapCustomEvent('shown', 'dropdown', relatedTarget);
        dispatchCustomEvent.call(parent, shownCustomEvent);
      }, 1);
    };

    self.hide = function () {
      hideCustomEvent = bootstrapCustomEvent('hide', 'dropdown', relatedTarget);
      dispatchCustomEvent.call(parent, hideCustomEvent);

      if (hideCustomEvent.defaultPrevented) {
        return;
      }

      menu.classList.remove('show');
      parent.classList.remove('show');
      element.setAttribute('aria-expanded', false);
      element.open = false;
      toggleDismiss();
      setFocus(element);
      setTimeout(function () {
        element.Dropdown && element.addEventListener('click', clickHandler, false);
      }, 1);
      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'dropdown', relatedTarget);
      dispatchCustomEvent.call(parent, hiddenCustomEvent);
    };

    self.toggle = function () {
      if (parent.classList.contains('show') && element.open) {
        self.hide();
      } else {
        self.show();
      }
    };

    self.dispose = function () {
      if (parent.classList.contains('show') && element.open) {
        self.hide();
      }

      element.removeEventListener('click', clickHandler, false);
      delete element.Dropdown;
    };

    element = queryElement(element);
    element.Dropdown && element.Dropdown.dispose();
    parent = element.parentNode;
    menu = queryElement('.dropdown-menu', parent);
    Array.from(menu.children).map(function (child) {
      child.children.length && child.children[0].tagName === 'A' && menuItems.push(child.children[0]);
      child.tagName === 'A' && menuItems.push(child);
    });

    if (!element.Dropdown) {
      !('tabindex' in menu) && menu.setAttribute('tabindex', '0');
      element.addEventListener('click', clickHandler, false);
    }

    persist = option === true || element.getAttribute('data-persist') === 'true' || false;
    element.open = false;
    element.Dropdown = self;
  }

  function Modal(element, options) {
    options = options || {};
    var self = this,
        modal,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent,
        relatedTarget = null,
        scrollBarWidth,
        overlay,
        overlayDelay,
        fixedItems,
        ops = {};

    function setScrollbar() {
      var openModal = document.body.classList.contains('modal-open'),
          bodyPad = parseInt(getComputedStyle(document.body).paddingRight),
          bodyOverflow = document.documentElement.clientHeight !== document.documentElement.scrollHeight || document.body.clientHeight !== document.body.scrollHeight,
          modalOverflow = modal.clientHeight !== modal.scrollHeight;
      scrollBarWidth = measureScrollbar();
      modal.style.paddingRight = !modalOverflow && scrollBarWidth ? scrollBarWidth + "px" : '';
      document.body.style.paddingRight = modalOverflow || bodyOverflow ? bodyPad + (openModal ? 0 : scrollBarWidth) + "px" : '';
      fixedItems.length && fixedItems.map(function (fixed) {
        var itemPad = getComputedStyle(fixed).paddingRight;
        fixed.style.paddingRight = modalOverflow || bodyOverflow ? parseInt(itemPad) + (openModal ? 0 : scrollBarWidth) + "px" : parseInt(itemPad) + "px";
      });
    }

    function resetScrollbar() {
      document.body.style.paddingRight = '';
      modal.style.paddingRight = '';
      fixedItems.length && fixedItems.map(function (fixed) {
        fixed.style.paddingRight = '';
      });
    }

    function measureScrollbar() {
      var scrollDiv = document.createElement('div'),
          widthValue;
      scrollDiv.className = 'modal-scrollbar-measure';
      document.body.appendChild(scrollDiv);
      widthValue = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return widthValue;
    }

    function createOverlay() {
      var newOverlay = document.createElement('div');
      overlay = queryElement('.modal-backdrop');

      if (overlay === null) {
        newOverlay.setAttribute('class', 'modal-backdrop' + (ops.animation ? ' fade' : ''));
        overlay = newOverlay;
        document.body.appendChild(overlay);
      }

      return overlay;
    }

    function removeOverlay() {
      overlay = queryElement('.modal-backdrop');

      if (overlay && !document.getElementsByClassName('modal show')[0]) {
        document.body.removeChild(overlay);
        overlay = null;
      }

      overlay === null && (document.body.classList.remove('modal-open'), resetScrollbar());
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      window[action]('resize', self.update, passiveHandler);
      modal[action]('click', dismissHandler, false);
      document[action]('keydown', keyHandler, false);
    }

    function beforeShow() {
      modal.style.display = 'block';
      setScrollbar();
      !document.getElementsByClassName('modal show')[0] && document.body.classList.add('modal-open');
      modal.classList.add('show');
      modal.setAttribute('aria-hidden', false);
      modal.classList.contains('fade') ? emulateTransitionEnd(modal, triggerShow) : triggerShow();
    }

    function triggerShow() {
      setFocus(modal);
      modal.isAnimating = false;
      toggleEvents(1);
      shownCustomEvent = bootstrapCustomEvent('shown', 'modal', relatedTarget);
      dispatchCustomEvent.call(modal, shownCustomEvent);
    }

    function triggerHide(force) {
      modal.style.display = '';
      element && setFocus(element);
      overlay = queryElement('.modal-backdrop');

      if (force !== 1 && overlay && overlay.classList.contains('show') && !document.getElementsByClassName('modal show')[0]) {
        overlay.classList.remove('show');
        emulateTransitionEnd(overlay, removeOverlay);
      } else {
        removeOverlay();
      }

      toggleEvents();
      modal.isAnimating = false;
      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'modal');
      dispatchCustomEvent.call(modal, hiddenCustomEvent);
    }

    function clickHandler(e) {
      if (modal.isAnimating) {
        return;
      }

      var clickTarget = e.target,
          modalID = "#" + modal.getAttribute('id'),
          targetAttrValue = clickTarget.getAttribute('data-target') || clickTarget.getAttribute('href'),
          elemAttrValue = element.getAttribute('data-target') || element.getAttribute('href');

      if (!modal.classList.contains('show') && (clickTarget === element && targetAttrValue === modalID || element.contains(clickTarget) && elemAttrValue === modalID)) {
        modal.modalTrigger = element;
        relatedTarget = element;
        self.show();
        e.preventDefault();
      }
    }

    function keyHandler(ref) {
      var which = ref.which;

      if (!modal.isAnimating && ops.keyboard && which == 27 && modal.classList.contains('show')) {
        self.hide();
      }
    }

    function dismissHandler(e) {
      if (modal.isAnimating) {
        return;
      }

      var clickTarget = e.target,
          hasData = clickTarget.getAttribute('data-dismiss') === 'modal',
          parentWithData = clickTarget.closest('[data-dismiss="modal"]');

      if (modal.classList.contains('show') && (parentWithData || hasData || clickTarget === modal && ops.backdrop !== 'static')) {
        self.hide();
        relatedTarget = null;
        e.preventDefault();
      }
    }

    self.toggle = function () {
      if (modal.classList.contains('show')) {
        self.hide();
      } else {
        self.show();
      }
    };

    self.show = function () {
      if (modal.classList.contains('show') && !!modal.isAnimating) {
        return;
      }

      showCustomEvent = bootstrapCustomEvent('show', 'modal', relatedTarget);
      dispatchCustomEvent.call(modal, showCustomEvent);

      if (showCustomEvent.defaultPrevented) {
        return;
      }

      modal.isAnimating = true;
      var currentOpen = document.getElementsByClassName('modal show')[0];

      if (currentOpen && currentOpen !== modal) {
        currentOpen.modalTrigger && currentOpen.modalTrigger.Modal.hide();
        currentOpen.Modal && currentOpen.Modal.hide();
      }

      if (ops.backdrop) {
        overlay = createOverlay();
      }

      if (overlay && !currentOpen && !overlay.classList.contains('show')) {
        overlay.offsetWidth;
        overlayDelay = getElementTransitionDuration(overlay);
        overlay.classList.add('show');
      }

      !currentOpen ? setTimeout(beforeShow, overlay && overlayDelay ? overlayDelay : 0) : beforeShow();
    };

    self.hide = function (force) {
      if (!modal.classList.contains('show')) {
        return;
      }

      hideCustomEvent = bootstrapCustomEvent('hide', 'modal');
      dispatchCustomEvent.call(modal, hideCustomEvent);

      if (hideCustomEvent.defaultPrevented) {
        return;
      }

      modal.isAnimating = true;
      modal.classList.remove('show');
      modal.setAttribute('aria-hidden', true);
      modal.classList.contains('fade') && force !== 1 ? emulateTransitionEnd(modal, triggerHide) : triggerHide();
    };

    self.setContent = function (content) {
      queryElement('.modal-content', modal).innerHTML = content;
    };

    self.update = function () {
      if (modal.classList.contains('show')) {
        setScrollbar();
      }
    };

    self.dispose = function () {
      self.hide(1);

      if (element) {
        element.removeEventListener('click', clickHandler, false);
        delete element.Modal;
      } else {
        delete modal.Modal;
      }
    };

    element = queryElement(element);
    var checkModal = queryElement(element.getAttribute('data-target') || element.getAttribute('href'));
    modal = element.classList.contains('modal') ? element : checkModal;
    fixedItems = Array.from(document.getElementsByClassName('fixed-top')).concat(Array.from(document.getElementsByClassName('fixed-bottom')));

    if (element.classList.contains('modal')) {
      element = null;
    }

    element && element.Modal && element.Modal.dispose();
    modal && modal.Modal && modal.Modal.dispose();
    ops.keyboard = options.keyboard === false || modal.getAttribute('data-keyboard') === 'false' ? false : true;
    ops.backdrop = options.backdrop === 'static' || modal.getAttribute('data-backdrop') === 'static' ? 'static' : true;
    ops.backdrop = options.backdrop === false || modal.getAttribute('data-backdrop') === 'false' ? false : ops.backdrop;
    ops.animation = modal.classList.contains('fade') ? true : false;
    ops.content = options.content;
    modal.isAnimating = false;

    if (element && !element.Modal) {
      element.addEventListener('click', clickHandler, false);
    }

    if (ops.content) {
      self.setContent(ops.content.trim());
    }

    if (element) {
      modal.modalTrigger = element;
      element.Modal = self;
    } else {
      modal.Modal = self;
    }
  }

  var mouseClickEvents = {
    down: 'mousedown',
    up: 'mouseup'
  };

  function getScroll() {
    return {
      y: window.pageYOffset || document.documentElement.scrollTop,
      x: window.pageXOffset || document.documentElement.scrollLeft
    };
  }

  function styleTip(link, element, position, parent) {
    var tipPositions = /\b(top|bottom|left|right)+/,
        elementDimensions = {
      w: element.offsetWidth,
      h: element.offsetHeight
    },
        windowWidth = document.documentElement.clientWidth || document.body.clientWidth,
        windowHeight = document.documentElement.clientHeight || document.body.clientHeight,
        rect = link.getBoundingClientRect(),
        scroll = parent === document.body ? getScroll() : {
      x: parent.offsetLeft + parent.scrollLeft,
      y: parent.offsetTop + parent.scrollTop
    },
        linkDimensions = {
      w: rect.right - rect.left,
      h: rect.bottom - rect.top
    },
        isPopover = element.classList.contains('popover'),
        arrow = element.getElementsByClassName('arrow')[0],
        halfTopExceed = rect.top + linkDimensions.h / 2 - elementDimensions.h / 2 < 0,
        halfLeftExceed = rect.left + linkDimensions.w / 2 - elementDimensions.w / 2 < 0,
        halfRightExceed = rect.left + elementDimensions.w / 2 + linkDimensions.w / 2 >= windowWidth,
        halfBottomExceed = rect.top + elementDimensions.h / 2 + linkDimensions.h / 2 >= windowHeight,
        topExceed = rect.top - elementDimensions.h < 0,
        leftExceed = rect.left - elementDimensions.w < 0,
        bottomExceed = rect.top + elementDimensions.h + linkDimensions.h >= windowHeight,
        rightExceed = rect.left + elementDimensions.w + linkDimensions.w >= windowWidth;
    position = (position === 'left' || position === 'right') && leftExceed && rightExceed ? 'top' : position;
    position = position === 'top' && topExceed ? 'bottom' : position;
    position = position === 'bottom' && bottomExceed ? 'top' : position;
    position = position === 'left' && leftExceed ? 'right' : position;
    position = position === 'right' && rightExceed ? 'left' : position;
    var topPosition, leftPosition, arrowTop, arrowLeft, arrowWidth, arrowHeight;
    element.className.indexOf(position) === -1 && (element.className = element.className.replace(tipPositions, position));
    arrowWidth = arrow.offsetWidth;
    arrowHeight = arrow.offsetHeight;

    if (position === 'left' || position === 'right') {
      if (position === 'left') {
        leftPosition = rect.left + scroll.x - elementDimensions.w - (isPopover ? arrowWidth : 0);
      } else {
        leftPosition = rect.left + scroll.x + linkDimensions.w;
      }

      if (halfTopExceed) {
        topPosition = rect.top + scroll.y;
        arrowTop = linkDimensions.h / 2 - arrowWidth;
      } else if (halfBottomExceed) {
        topPosition = rect.top + scroll.y - elementDimensions.h + linkDimensions.h;
        arrowTop = elementDimensions.h - linkDimensions.h / 2 - arrowWidth;
      } else {
        topPosition = rect.top + scroll.y - elementDimensions.h / 2 + linkDimensions.h / 2;
        arrowTop = elementDimensions.h / 2 - (isPopover ? arrowHeight * 0.9 : arrowHeight / 2);
      }
    } else if (position === 'top' || position === 'bottom') {
      if (position === 'top') {
        topPosition = rect.top + scroll.y - elementDimensions.h - (isPopover ? arrowHeight : 0);
      } else {
        topPosition = rect.top + scroll.y + linkDimensions.h;
      }

      if (halfLeftExceed) {
        leftPosition = 0;
        arrowLeft = rect.left + linkDimensions.w / 2 - arrowWidth;
      } else if (halfRightExceed) {
        leftPosition = windowWidth - elementDimensions.w * 1.01;
        arrowLeft = elementDimensions.w - (windowWidth - rect.left) + linkDimensions.w / 2 - arrowWidth / 2;
      } else {
        leftPosition = rect.left + scroll.x - elementDimensions.w / 2 + linkDimensions.w / 2;
        arrowLeft = elementDimensions.w / 2 - (isPopover ? arrowWidth : arrowWidth / 2);
      }
    }

    element.style.top = topPosition + 'px';
    element.style.left = leftPosition + 'px';
    arrowTop && (arrow.style.top = arrowTop + 'px');
    arrowLeft && (arrow.style.left = arrowLeft + 'px');
  }

  function Popover(element, options) {
    options = options || {};
    var self = this;
    var popover = null,
        timer = 0,
        isIphone = /(iPhone|iPod|iPad)/.test(navigator.userAgent),
        titleString,
        contentString,
        ops = {};
    var triggerData, animationData, placementData, dismissibleData, delayData, containerData, closeBtn, showCustomEvent, shownCustomEvent, hideCustomEvent, hiddenCustomEvent, containerElement, containerDataElement, modal, navbarFixedTop, navbarFixedBottom, placementClass;

    function dismissibleHandler(e) {
      if (popover !== null && e.target === queryElement('.close', popover)) {
        self.hide();
      }
    }

    function getContents() {
      return {
        0: options.title || element.getAttribute('data-title') || null,
        1: options.content || element.getAttribute('data-content') || null
      };
    }

    function removePopover() {
      ops.container.removeChild(popover);
      timer = null;
      popover = null;
    }

    function createPopover() {
      titleString = getContents()[0] || null;
      contentString = getContents()[1];
      contentString = !!contentString ? contentString.trim() : null;
      popover = document.createElement('div');
      var popoverArrow = document.createElement('div');
      popoverArrow.classList.add('arrow');
      popover.appendChild(popoverArrow);

      if (contentString !== null && ops.template === null) {
        popover.setAttribute('role', 'tooltip');

        if (titleString !== null) {
          var popoverTitle = document.createElement('h3');
          popoverTitle.classList.add('popover-header');
          popoverTitle.innerHTML = ops.dismissible ? titleString + closeBtn : titleString;
          popover.appendChild(popoverTitle);
        }

        var popoverBodyMarkup = document.createElement('div');
        popoverBodyMarkup.classList.add('popover-body');
        popoverBodyMarkup.innerHTML = ops.dismissible && titleString === null ? contentString + closeBtn : contentString;
        popover.appendChild(popoverBodyMarkup);
      } else {
        var popoverTemplate = document.createElement('div');
        popoverTemplate.innerHTML = ops.template.trim();
        popover.className = popoverTemplate.firstChild.className;
        popover.innerHTML = popoverTemplate.firstChild.innerHTML;
        var popoverHeader = queryElement('.popover-header', popover),
            popoverBody = queryElement('.popover-body', popover);
        titleString && popoverHeader && (popoverHeader.innerHTML = titleString.trim());
        contentString && popoverBody && (popoverBody.innerHTML = contentString.trim());
      }

      ops.container.appendChild(popover);
      popover.style.display = 'block';
      !popover.classList.contains('popover') && popover.classList.add('popover');
      !popover.classList.contains(ops.animation) && popover.classList.add(ops.animation);
      !popover.classList.contains(placementClass) && popover.classList.add(placementClass);
    }

    function showPopover() {
      !popover.classList.contains('show') && popover.classList.add('show');
    }

    function updatePopover() {
      styleTip(element, popover, ops.placement, ops.container);
    }

    function forceFocus() {
      if (popover === null) {
        element.focus();
      }
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';

      if (ops.trigger === 'hover') {
        element[action](mouseClickEvents.down, self.show);
        element[action](mouseHoverEvents[0], self.show);

        if (!ops.dismissible) {
          element[action](mouseHoverEvents[1], self.hide);
        }
      } else if ('click' == ops.trigger) {
        element[action](ops.trigger, self.toggle);
      } else if ('focus' == ops.trigger) {
        isIphone && element[action]('click', forceFocus, false);
        element[action](ops.trigger, self.toggle);
      }
    }

    function touchHandler(e) {
      if (popover && popover.contains(e.target) || e.target === element || element.contains(e.target)) ;else {
        self.hide();
      }
    }

    function dismissHandlerToggle(action) {
      action = action ? 'addEventListener' : 'removeEventListener';

      if (ops.dismissible) {
        document[action]('click', dismissibleHandler, false);
      } else {
        'focus' == ops.trigger && element[action]('blur', self.hide);
        'hover' == ops.trigger && document[action]('touchstart', touchHandler, passiveHandler);
      }

      window[action]('resize', self.hide, passiveHandler);
    }

    function showTrigger() {
      dismissHandlerToggle(1);
      dispatchCustomEvent.call(element, shownCustomEvent);
    }

    function hideTrigger() {
      dismissHandlerToggle();
      removePopover();
      dispatchCustomEvent.call(element, hiddenCustomEvent);
    }

    self.toggle = function () {
      if (popover === null) {
        self.show();
      } else {
        self.hide();
      }
    };

    self.show = function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        if (popover === null) {
          dispatchCustomEvent.call(element, showCustomEvent);

          if (showCustomEvent.defaultPrevented) {
            return;
          }

          createPopover();
          updatePopover();
          showPopover();
          !!ops.animation ? emulateTransitionEnd(popover, showTrigger) : showTrigger();
        }
      }, 20);
    };

    self.hide = function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        if (popover && popover !== null && popover.classList.contains('show')) {
          dispatchCustomEvent.call(element, hideCustomEvent);

          if (hideCustomEvent.defaultPrevented) {
            return;
          }

          popover.classList.remove('show');
          !!ops.animation ? emulateTransitionEnd(popover, hideTrigger) : hideTrigger();
        }
      }, ops.delay);
    };

    self.dispose = function () {
      self.hide();
      toggleEvents();
      delete element.Popover;
    };

    element = queryElement(element);
    element.Popover && element.Popover.dispose();
    triggerData = element.getAttribute('data-trigger');
    animationData = element.getAttribute('data-animation');
    placementData = element.getAttribute('data-placement');
    dismissibleData = element.getAttribute('data-dismissible');
    delayData = element.getAttribute('data-delay');
    containerData = element.getAttribute('data-container');
    closeBtn = '<button type="button" class="close">×</button>';
    showCustomEvent = bootstrapCustomEvent('show', 'popover');
    shownCustomEvent = bootstrapCustomEvent('shown', 'popover');
    hideCustomEvent = bootstrapCustomEvent('hide', 'popover');
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'popover');
    containerElement = queryElement(options.container);
    containerDataElement = queryElement(containerData);
    modal = element.closest('.modal');
    navbarFixedTop = element.closest('.fixed-top');
    navbarFixedBottom = element.closest('.fixed-bottom');
    ops.template = options.template ? options.template : null;
    ops.trigger = options.trigger ? options.trigger : triggerData || 'hover';
    ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';
    ops.placement = options.placement ? options.placement : placementData || 'top';
    ops.delay = parseInt(options.delay || delayData) || 200;
    ops.dismissible = options.dismissible || dismissibleData === 'true' ? true : false;
    ops.container = containerElement ? containerElement : containerDataElement ? containerDataElement : navbarFixedTop ? navbarFixedTop : navbarFixedBottom ? navbarFixedBottom : modal ? modal : document.body;
    placementClass = "bs-popover-" + ops.placement;
    var popoverContents = getContents();
    titleString = popoverContents[0];
    contentString = popoverContents[1];

    if (!contentString && !ops.template) {
      return;
    }

    if (!element.Popover) {
      toggleEvents(1);
    }

    element.Popover = self;
  }

  function ScrollSpy(element, options) {
    options = options || {};
    var self = this,
        vars,
        targetData,
        offsetData,
        spyTarget,
        scrollTarget,
        ops = {};

    function updateTargets() {
      var links = spyTarget.getElementsByTagName('A');

      if (vars.length !== links.length) {
        vars.items = [];
        vars.targets = [];
        Array.from(links).map(function (link) {
          var href = link.getAttribute('href'),
              targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#' && queryElement(href);

          if (targetItem) {
            vars.items.push(link);
            vars.targets.push(targetItem);
          }
        });
        vars.length = links.length;
      }
    }

    function updateItem(index) {
      var item = vars.items[index],
          targetItem = vars.targets[index],
          dropmenu = item.classList.contains('dropdown-item') && item.closest('.dropdown-menu'),
          dropLink = dropmenu && dropmenu.previousElementSibling,
          nextSibling = item.nextElementSibling,
          activeSibling = nextSibling && nextSibling.getElementsByClassName('active').length,
          targetRect = vars.isWindow && targetItem.getBoundingClientRect(),
          isActive = item.classList.contains('active') || false,
          topEdge = (vars.isWindow ? targetRect.top + vars.scrollOffset : targetItem.offsetTop) - ops.offset,
          bottomEdge = vars.isWindow ? targetRect.bottom + vars.scrollOffset - ops.offset : vars.targets[index + 1] ? vars.targets[index + 1].offsetTop - ops.offset : element.scrollHeight,
          inside = activeSibling || vars.scrollOffset >= topEdge && bottomEdge > vars.scrollOffset;

      if (!isActive && inside) {
        item.classList.add('active');

        if (dropLink && !dropLink.classList.contains('active')) {
          dropLink.classList.add('active');
        }

        dispatchCustomEvent.call(element, bootstrapCustomEvent('activate', 'scrollspy', vars.items[index]));
      } else if (isActive && !inside) {
        item.classList.remove('active');

        if (dropLink && dropLink.classList.contains('active') && !item.parentNode.getElementsByClassName('active').length) {
          dropLink.classList.remove('active');
        }
      } else if (isActive && inside || !inside && !isActive) {
        return;
      }
    }

    function updateItems() {
      updateTargets();
      vars.scrollOffset = vars.isWindow ? getScroll().y : element.scrollTop;
      vars.items.map(function (l, idx) {
        return updateItem(idx);
      });
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      scrollTarget[action]('scroll', self.refresh, passiveHandler);
      window[action]('resize', self.refresh, passiveHandler);
    }

    self.refresh = function () {
      updateItems();
    };

    self.dispose = function () {
      toggleEvents();
      delete element.ScrollSpy;
    };

    element = queryElement(element);
    element.ScrollSpy && element.ScrollSpy.dispose();
    targetData = element.getAttribute('data-target');
    offsetData = element.getAttribute('data-offset');
    spyTarget = queryElement(options.target || targetData);
    scrollTarget = element.offsetHeight < element.scrollHeight ? element : window;

    if (!spyTarget) {
      return;
    }

    ops.target = spyTarget;
    ops.offset = parseInt(options.offset || offsetData) || 10;
    vars = {};
    vars.length = 0;
    vars.items = [];
    vars.targets = [];
    vars.isWindow = scrollTarget === window;

    if (!element.ScrollSpy) {
      toggleEvents(1);
    }

    self.refresh();
    element.ScrollSpy = self;
  }

  function Tab(element, options) {
    options = options || {};
    var self = this,
        heightData,
        tabs,
        dropdown,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent,
        next,
        tabsContentContainer = false,
        activeTab,
        activeContent,
        nextContent,
        containerHeight,
        equalContents,
        nextHeight,
        animateHeight;

    function triggerEnd() {
      tabsContentContainer.style.height = '';
      tabsContentContainer.classList.remove('collapsing');
      tabs.isAnimating = false;
    }

    function triggerShow() {
      if (tabsContentContainer) {
        if (equalContents) {
          triggerEnd();
        } else {
          setTimeout(function () {
            tabsContentContainer.style.height = nextHeight + "px";
            tabsContentContainer.offsetWidth;
            emulateTransitionEnd(tabsContentContainer, triggerEnd);
          }, 50);
        }
      } else {
        tabs.isAnimating = false;
      }

      shownCustomEvent = bootstrapCustomEvent('shown', 'tab', activeTab);
      dispatchCustomEvent.call(next, shownCustomEvent);
    }

    function triggerHide() {
      if (tabsContentContainer) {
        activeContent.style["float"] = 'left';
        nextContent.style["float"] = 'left';
        containerHeight = activeContent.scrollHeight;
      }

      showCustomEvent = bootstrapCustomEvent('show', 'tab', activeTab);
      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tab', next);
      dispatchCustomEvent.call(next, showCustomEvent);

      if (showCustomEvent.defaultPrevented) {
        return;
      }

      nextContent.classList.add('active');
      activeContent.classList.remove('active');

      if (tabsContentContainer) {
        nextHeight = nextContent.scrollHeight;
        equalContents = nextHeight === containerHeight;
        tabsContentContainer.classList.add('collapsing');
        tabsContentContainer.style.height = containerHeight + "px";
        tabsContentContainer.offsetHeight;
        activeContent.style["float"] = '';
        nextContent.style["float"] = '';
      }

      if (nextContent.classList.contains('fade')) {
        setTimeout(function () {
          nextContent.classList.add('show');
          emulateTransitionEnd(nextContent, triggerShow);
        }, 20);
      } else {
        triggerShow();
      }

      dispatchCustomEvent.call(activeTab, hiddenCustomEvent);
    }

    function getActiveTab() {
      var activeTabs = tabs.getElementsByClassName('active'),
          activeTab;

      if (activeTabs.length === 1 && !activeTabs[0].parentNode.classList.contains('dropdown')) {
        activeTab = activeTabs[0];
      } else if (activeTabs.length > 1) {
        activeTab = activeTabs[activeTabs.length - 1];
      }

      return activeTab;
    }

    function getActiveContent() {
      return queryElement(getActiveTab().getAttribute('href'));
    }

    function clickHandler(e) {
      e.preventDefault();
      next = e.currentTarget;
      !tabs.isAnimating && self.show();
    }

    self.show = function () {
      next = next || element;

      if (!next.classList.contains('active')) {
        nextContent = queryElement(next.getAttribute('href'));
        activeTab = getActiveTab();
        activeContent = getActiveContent();
        hideCustomEvent = bootstrapCustomEvent('hide', 'tab', next);
        dispatchCustomEvent.call(activeTab, hideCustomEvent);

        if (hideCustomEvent.defaultPrevented) {
          return;
        }

        tabs.isAnimating = true;
        activeTab.classList.remove('active');
        activeTab.setAttribute('aria-selected', 'false');
        next.classList.add('active');
        next.setAttribute('aria-selected', 'true');

        if (dropdown) {
          if (!element.parentNode.classList.contains('dropdown-menu')) {
            if (dropdown.classList.contains('active')) {
              dropdown.classList.remove('active');
            }
          } else {
            if (!dropdown.classList.contains('active')) {
              dropdown.classList.add('active');
            }
          }
        }

        if (activeContent.classList.contains('fade')) {
          activeContent.classList.remove('show');
          emulateTransitionEnd(activeContent, triggerHide);
        } else {
          triggerHide();
        }
      }
    };

    self.dispose = function () {
      element.removeEventListener('click', clickHandler, false);
      delete element.Tab;
    };

    element = queryElement(element);
    element.Tab && element.Tab.dispose();
    heightData = element.getAttribute('data-height');
    tabs = element.closest('.nav');
    dropdown = tabs && queryElement('.dropdown-toggle', tabs);
    animateHeight = !supportTransition || options.height === false || heightData === 'false' ? false : true;
    tabs.isAnimating = false;

    if (!element.Tab) {
      element.addEventListener('click', clickHandler, false);
    }

    if (animateHeight) {
      tabsContentContainer = getActiveContent().parentNode;
    }

    element.Tab = self;
  }

  function Toast(element, options) {
    options = options || {};
    var self = this,
        toast,
        timer = 0,
        animationData,
        autohideData,
        delayData,
        showCustomEvent,
        hideCustomEvent,
        shownCustomEvent,
        hiddenCustomEvent,
        ops = {};

    function showComplete() {
      toast.classList.remove('showing');
      toast.classList.add('show');
      dispatchCustomEvent.call(toast, shownCustomEvent);

      if (ops.autohide) {
        self.hide();
      }
    }

    function hideComplete() {
      toast.classList.add('hide');
      dispatchCustomEvent.call(toast, hiddenCustomEvent);
    }

    function close() {
      toast.classList.remove('show');
      ops.animation ? emulateTransitionEnd(toast, hideComplete) : hideComplete();
    }

    function disposeComplete() {
      clearTimeout(timer);
      element.removeEventListener('click', self.hide, false);
      delete element.Toast;
    }

    self.show = function () {
      if (toast && !toast.classList.contains('show')) {
        dispatchCustomEvent.call(toast, showCustomEvent);

        if (showCustomEvent.defaultPrevented) {
          return;
        }

        ops.animation && toast.classList.add('fade');
        toast.classList.remove('hide');
        toast.offsetWidth;
        toast.classList.add('showing');
        ops.animation ? emulateTransitionEnd(toast, showComplete) : showComplete();
      }
    };

    self.hide = function (noTimer) {
      if (toast && toast.classList.contains('show')) {
        dispatchCustomEvent.call(toast, hideCustomEvent);

        if (hideCustomEvent.defaultPrevented) {
          return;
        }

        noTimer ? close() : timer = setTimeout(close, ops.delay);
      }
    };

    self.dispose = function () {
      ops.animation ? emulateTransitionEnd(toast, disposeComplete) : disposeComplete();
    };

    element = queryElement(element);
    element.Toast && element.Toast.dispose();
    toast = element.closest('.toast');
    animationData = element.getAttribute('data-animation');
    autohideData = element.getAttribute('data-autohide');
    delayData = element.getAttribute('data-delay');
    showCustomEvent = bootstrapCustomEvent('show', 'toast');
    hideCustomEvent = bootstrapCustomEvent('hide', 'toast');
    shownCustomEvent = bootstrapCustomEvent('shown', 'toast');
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'toast');
    ops.animation = options.animation === false || animationData === 'false' ? 0 : 1;
    ops.autohide = options.autohide === false || autohideData === 'false' ? 0 : 1;
    ops.delay = parseInt(options.delay || delayData) || 500;

    if (!element.Toast) {
      element.addEventListener('click', self.hide, false);
    }

    element.Toast = self;
  }

  function Tooltip(element, options) {
    options = options || {};
    var self = this,
        tooltip = null,
        timer = 0,
        titleString,
        animationData,
        placementData,
        delayData,
        containerData,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent,
        containerElement,
        containerDataElement,
        modal,
        navbarFixedTop,
        navbarFixedBottom,
        placementClass,
        ops = {};

    function getTitle() {
      return element.getAttribute('title') || element.getAttribute('data-title') || element.getAttribute('data-original-title');
    }

    function removeToolTip() {
      ops.container.removeChild(tooltip);
      tooltip = null;
      timer = null;
    }

    function createToolTip() {
      titleString = getTitle();

      if (titleString) {
        tooltip = document.createElement('div');

        if (ops.template) {
          var tooltipMarkup = document.createElement('div');
          tooltipMarkup.innerHTML = ops.template.trim();
          tooltip.className = tooltipMarkup.firstChild.className;
          tooltip.innerHTML = tooltipMarkup.firstChild.innerHTML;
          queryElement('.tooltip-inner', tooltip).innerHTML = titleString.trim();
        } else {
          var tooltipArrow = document.createElement('div');
          tooltipArrow.classList.add('arrow');
          tooltip.appendChild(tooltipArrow);
          var tooltipInner = document.createElement('div');
          tooltipInner.classList.add('tooltip-inner');
          tooltip.appendChild(tooltipInner);
          tooltipInner.innerHTML = titleString;
        }

        tooltip.style.left = '0';
        tooltip.style.top = '0';
        tooltip.setAttribute('role', 'tooltip');
        !tooltip.classList.contains('tooltip') && tooltip.classList.add('tooltip');
        !tooltip.classList.contains(ops.animation) && tooltip.classList.add(ops.animation);
        !tooltip.classList.contains(placementClass) && tooltip.classList.add(placementClass);
        ops.container.appendChild(tooltip);
      }
    }

    function updateTooltip() {
      styleTip(element, tooltip, ops.placement, ops.container);
    }

    function showTooltip() {
      !tooltip.classList.contains('show') && tooltip.classList.add('show');
    }

    function touchHandler(e) {
      if (tooltip && tooltip.contains(e.target) || e.target === element || element.contains(e.target)) ;else {
        self.hide();
      }
    }

    function toggleAction(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      document[action]('touchstart', touchHandler, passiveHandler);
      window[action]('resize', self.hide, passiveHandler);
    }

    function showAction() {
      toggleAction(1);
      dispatchCustomEvent.call(element, shownCustomEvent);
    }

    function hideAction() {
      toggleAction();
      removeToolTip();
      dispatchCustomEvent.call(element, hiddenCustomEvent);
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      element[action](mouseClickEvents.down, self.show, false);
      element[action](mouseHoverEvents[0], self.show, false);
      element[action](mouseHoverEvents[1], self.hide, false);
    }

    self.show = function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        if (tooltip === null) {
          dispatchCustomEvent.call(element, showCustomEvent);

          if (showCustomEvent.defaultPrevented) {
            return;
          }

          if (createToolTip() !== false) {
            updateTooltip();
            showTooltip();
            !!ops.animation ? emulateTransitionEnd(tooltip, showAction) : showAction();
          }
        }
      }, 20);
    };

    self.hide = function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        if (tooltip && tooltip.classList.contains('show')) {
          dispatchCustomEvent.call(element, hideCustomEvent);

          if (hideCustomEvent.defaultPrevented) {
            return;
          }

          tooltip.classList.remove('show');
          !!ops.animation ? emulateTransitionEnd(tooltip, hideAction) : hideAction();
        }
      }, ops.delay);
    };

    self.toggle = function () {
      if (!tooltip) {
        self.show();
      } else {
        self.hide();
      }
    };

    self.dispose = function () {
      toggleEvents();
      self.hide();
      element.setAttribute('title', element.getAttribute('data-original-title'));
      element.removeAttribute('data-original-title');
      delete element.Tooltip;
    };

    element = queryElement(element);
    element.Tooltip && element.Tooltip.dispose();
    animationData = element.getAttribute('data-animation');
    placementData = element.getAttribute('data-placement');
    delayData = element.getAttribute('data-delay');
    containerData = element.getAttribute('data-container');
    showCustomEvent = bootstrapCustomEvent('show', 'tooltip');
    shownCustomEvent = bootstrapCustomEvent('shown', 'tooltip');
    hideCustomEvent = bootstrapCustomEvent('hide', 'tooltip');
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tooltip');
    containerElement = queryElement(options.container);
    containerDataElement = queryElement(containerData);
    modal = element.closest('.modal');
    navbarFixedTop = element.closest('.fixed-top');
    navbarFixedBottom = element.closest('.fixed-bottom');
    ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';
    ops.placement = options.placement ? options.placement : placementData || 'top';
    ops.template = options.template ? options.template : null;
    ops.delay = parseInt(options.delay || delayData) || 200;
    ops.container = containerElement ? containerElement : containerDataElement ? containerDataElement : navbarFixedTop ? navbarFixedTop : navbarFixedBottom ? navbarFixedBottom : modal ? modal : document.body;
    placementClass = "bs-tooltip-" + ops.placement;
    titleString = getTitle();

    if (!titleString) {
      return;
    }

    if (!element.Tooltip) {
      element.setAttribute('data-original-title', titleString);
      element.removeAttribute('title');
      toggleEvents(1);
    }

    element.Tooltip = self;
  }

  var componentsInit = {};

  function initializeDataAPI(Constructor, collection) {
    Array.from(collection).map(function (x) {
      return new Constructor(x);
    });
  }

  function initCallback(lookUp) {
    lookUp = lookUp || document;

    for (var component in componentsInit) {
      initializeDataAPI(componentsInit[component][0], lookUp.querySelectorAll(componentsInit[component][1]));
    }
  }

  componentsInit.Alert = [Alert, '[data-dismiss="alert"]'];
  componentsInit.Button = [Button, '[data-toggle="buttons"]'];
  componentsInit.Carousel = [Carousel, '[data-ride="carousel"]'];
  componentsInit.Collapse = [Collapse, '[data-toggle="collapse"]'];
  componentsInit.Dropdown = [Dropdown, '[data-toggle="dropdown"]'];
  componentsInit.Modal = [Modal, '[data-toggle="modal"]'];
  componentsInit.Popover = [Popover, '[data-toggle="popover"],[data-tip="popover"]'];
  componentsInit.ScrollSpy = [ScrollSpy, '[data-spy="scroll"]'];
  componentsInit.Tab = [Tab, '[data-toggle="tab"]'];
  componentsInit.Toast = [Toast, '[data-dismiss="toast"]'];
  componentsInit.Tooltip = [Tooltip, '[data-toggle="tooltip"],[data-tip="tooltip"]'];
  document.body ? initCallback() : document.addEventListener('DOMContentLoaded', function initWrapper() {
    initCallback();
    document.removeEventListener('DOMContentLoaded', initWrapper, false);
  }, false);

  function removeElementDataAPI(ConstructorName, collection) {
    Array.from(collection).map(function (x) {
      return x[ConstructorName].dispose();
    });
  }

  function removeDataAPI(lookUp) {
    lookUp = lookUp || document;

    for (var component in componentsInit) {
      removeElementDataAPI(component, lookUp.querySelectorAll(componentsInit[component][1]));
    }
  }

  var version = "3.0.10";
  var index = {
    Alert: Alert,
    Button: Button,
    Carousel: Carousel,
    Collapse: Collapse,
    Dropdown: Dropdown,
    Modal: Modal,
    Popover: Popover,
    ScrollSpy: ScrollSpy,
    Tab: Tab,
    Toast: Toast,
    Tooltip: Tooltip,
    initCallback: initCallback,
    removeDataAPI: removeDataAPI,
    componentsInit: componentsInit,
    Version: version
  };

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var bind = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      return fn.apply(thisArg, args);
    };
  };

  /*global toString:true*/
  // utils is a library of generic helper functions non-specific to axios


  var toString = Object.prototype.toString;
  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */

  function isArray(val) {
    return toString.call(val) === '[object Array]';
  }
  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */


  function isUndefined(val) {
    return typeof val === 'undefined';
  }
  /**
   * Determine if a value is a Buffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Buffer, otherwise false
   */


  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
  }
  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */


  function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
  }
  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */


  function isFormData(val) {
    return typeof FormData !== 'undefined' && val instanceof FormData;
  }
  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */


  function isArrayBufferView(val) {
    var result;

    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }

    return result;
  }
  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */


  function isString(val) {
    return typeof val === 'string';
  }
  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */


  function isNumber(val) {
    return typeof val === 'number';
  }
  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */


  function isObject(val) {
    return val !== null && _typeof(val) === 'object';
  }
  /**
   * Determine if a value is a plain Object
   *
   * @param {Object} val The value to test
   * @return {boolean} True if value is a plain Object, otherwise false
   */


  function isPlainObject(val) {
    if (toString.call(val) !== '[object Object]') {
      return false;
    }

    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */


  function isDate(val) {
    return toString.call(val) === '[object Date]';
  }
  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */


  function isFile(val) {
    return toString.call(val) === '[object File]';
  }
  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */


  function isBlob(val) {
    return toString.call(val) === '[object Blob]';
  }
  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */


  function isFunction(val) {
    return toString.call(val) === '[object Function]';
  }
  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */


  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */


  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }
  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */


  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }
  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */


  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
      return false;
    }

    return typeof window !== 'undefined' && typeof document !== 'undefined';
  }
  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */


  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    } // Force an array if not already something iterable


    if (_typeof(obj) !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */


  function merge()
  /* obj1, obj2, obj3, ... */
  {
    var result = {};

    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }

    return result;
  }
  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */


  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  /**
   * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
   *
   * @param {string} content with BOM
   * @return {string} content value without BOM
   */


  function stripBOM(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
      content = content.slice(1);
    }

    return content;
  }

  var utils = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM
  };

  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  }
  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */


  var buildURL = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;

    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }

          parts.push(encode(key) + '=' + encode(v));
        });
      });
      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');

      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  function InterceptorManager() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */


  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */


  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */


  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager;

  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */


  var transformData = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };

  var isCancel = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */

  var enhanceError = function enhanceError(error, config, code, request, response) {
    error.config = config;

    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };

    return error;
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */


  var createError = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */


  var settle = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;

    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
    }
  };

  var cookies = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  }() : // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() {
        return null;
      },
      remove: function remove() {}
    };
  }();

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */

  var isAbsoluteURL = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */

  var combineURLs = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
  };

  /**
   * Creates a new URL by combining the baseURL with the requestedURL,
   * only when the requestedURL is not already an absolute URL.
   * If the requestURL is absolute, this function returns the requestedURL untouched.
   *
   * @param {string} baseURL The base URL
   * @param {string} requestedURL Absolute or relative URL to combine
   * @returns {string} The combined full path
   */


  var buildFullPath = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }

    return requestedURL;
  };

  // c.f. https://nodejs.org/api/http.html#http_message_headers


  var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */

  var parseHeaders = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) {
      return parsed;
    }

    utils.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }

        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });
    return parsed;
  };

  var isURLSameOrigin = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */

    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */

    return function isURLSameOrigin(requestURL) {
      var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();

  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      if ((utils.isBlob(requestData) || utils.isFile(requestData)) && requestData.type) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest(); // HTTP basic authentication

      if (config.auth) {
        var username = config.auth.username || '';
        var password = unescape(encodeURIComponent(config.auth.password)) || '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

      request.timeout = config.timeout; // Listen for ready state

      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        } // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request


        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        } // Prepare the response


        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };
        settle(resolve, reject, response); // Clean up request

        request = null;
      }; // Handle browser request cancellation (as opposed to a manual cancellation)


      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Handle low level network errors


      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request)); // Clean up request

        request = null;
      }; // Handle timeout


      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }

        reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.


      if (utils.isStandardBrowserEnv()) {
        // Add xsrf header
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      } // Add headers to the request


      if ('setRequestHeader' in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      } // Add withCredentials to request if needed


      if (!utils.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      } // Add responseType to request if needed


      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
          // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      } // Handle progress if needed


      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      } // Not all browsers support upload events


      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel); // Clean up request

          request = null;
        });
      }

      if (!requestData) {
        requestData = null;
      } // Send the request


      request.send(requestData);
    });
  };

  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter;

    if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    }

    return adapter;
  }

  var defaults = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');

      if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
        return data;
      }

      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }

      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }

      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
        return JSON.stringify(data);
      }

      return data;
    }],
    transformResponse: [function transformResponse(data) {
      /*eslint no-param-reassign:0*/
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) {
          /* Ignore */
        }
      }

      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };
  utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });
  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults;

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */


  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */


  var dispatchRequest = function dispatchRequest(config) {
    throwIfCancellationRequested(config); // Ensure headers exist

    config.headers = config.headers || {}; // Transform request data

    config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults_1.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config); // Transform response data

      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config); // Transform response data

        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }

      return Promise.reject(reason);
    });
  };

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */


  var mergeConfig = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ['url', 'method', 'data'];
    var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
    var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
    var directMergeKeys = ['validateStatus'];

    function getMergedValue(target, source) {
      if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
        return utils.merge(target, source);
      } else if (utils.isPlainObject(source)) {
        return utils.merge({}, source);
      } else if (utils.isArray(source)) {
        return source.slice();
      }

      return source;
    }

    function mergeDeepProperties(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    }

    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(undefined, config2[prop]);
      }
    });
    utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(undefined, config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    });
    utils.forEach(directMergeKeys, function merge(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils.forEach(otherKeys, mergeDeepProperties);
    return config;
  };

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */


  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_1(),
      response: new InterceptorManager_1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */


  Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig(this.defaults, config); // Set config.method

    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = 'get';
    } // Hook up interceptors middleware


    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  };

  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  }; // Provide aliases for supported request methods


  utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function (url, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        url: url
      }));
    };
  });
  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function (url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });
  var Axios_1 = Axios;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */

  function Cancel(message) {
    this.message = message;
  }

  Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */


  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel_1(message);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `Cancel` if cancellation has been requested.
   */


  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */


  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */

  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */


  function createInstance(defaultConfig) {
    var context = new Axios_1(defaultConfig);
    var instance = bind(Axios_1.prototype.request, context); // Copy axios.prototype to instance

    utils.extend(instance, Axios_1.prototype, context); // Copy context to instance

    utils.extend(instance, context);
    return instance;
  } // Create the default instance to be exported


  var axios = createInstance(defaults_1); // Expose Axios class to allow class inheritance

  axios.Axios = Axios_1; // Factory for creating new instances

  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  }; // Expose Cancel & CancelToken


  axios.Cancel = Cancel_1;
  axios.CancelToken = CancelToken_1;
  axios.isCancel = isCancel; // Expose all/spread

  axios.all = function all(promises) {
    return Promise.all(promises);
  };

  axios.spread = spread;
  var axios_1 = axios; // Allow use of default import syntax in TypeScript

  var _default = axios;
  axios_1["default"] = _default;

  var axios$1 = axios_1;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var lodash=createCommonjsModule(function(module,exports){(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined$1;/** Used as the semantic version number. */var VERSION='4.17.20';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
     * Used to match
     * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
     */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange="\\ud800-\\udfff",rsComboMarksRange="\\u0300-\\u036f",reComboHalfMarksRange="\\ufe20-\\ufe2f",rsComboSymbolsRange="\\u20d0-\\u20ff",rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange="\\u2700-\\u27bf",rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange="\\u2000-\\u206f",rsSpaceRange=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange="\\ufe0e\\ufe0f",rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz="\\ud83c[\\udffb-\\udfff]",rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}",rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]",rsUpper='['+rsUpperRange+']',rsZWJ="\\u200d";/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
  '\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
  "\u0100":'A',"\u0102":'A',"\u0104":'A',"\u0101":'a',"\u0103":'a',"\u0105":'a',"\u0106":'C',"\u0108":'C',"\u010A":'C',"\u010C":'C',"\u0107":'c',"\u0109":'c',"\u010B":'c',"\u010D":'c',"\u010E":'D',"\u0110":'D',"\u010F":'d',"\u0111":'d',"\u0112":'E',"\u0114":'E',"\u0116":'E',"\u0118":'E',"\u011A":'E',"\u0113":'e',"\u0115":'e',"\u0117":'e',"\u0119":'e',"\u011B":'e',"\u011C":'G',"\u011E":'G',"\u0120":'G',"\u0122":'G',"\u011D":'g',"\u011F":'g',"\u0121":'g',"\u0123":'g',"\u0124":'H',"\u0126":'H',"\u0125":'h',"\u0127":'h',"\u0128":'I',"\u012A":'I',"\u012C":'I',"\u012E":'I',"\u0130":'I',"\u0129":'i',"\u012B":'i',"\u012D":'i',"\u012F":'i',"\u0131":'i',"\u0134":'J',"\u0135":'j',"\u0136":'K',"\u0137":'k',"\u0138":'k',"\u0139":'L',"\u013B":'L',"\u013D":'L',"\u013F":'L',"\u0141":'L',"\u013A":'l',"\u013C":'l',"\u013E":'l',"\u0140":'l',"\u0142":'l',"\u0143":'N',"\u0145":'N',"\u0147":'N',"\u014A":'N',"\u0144":'n',"\u0146":'n',"\u0148":'n',"\u014B":'n',"\u014C":'O',"\u014E":'O',"\u0150":'O',"\u014D":'o',"\u014F":'o',"\u0151":'o',"\u0154":'R',"\u0156":'R',"\u0158":'R',"\u0155":'r',"\u0157":'r',"\u0159":'r',"\u015A":'S',"\u015C":'S',"\u015E":'S',"\u0160":'S',"\u015B":'s',"\u015D":'s',"\u015F":'s',"\u0161":'s',"\u0162":'T',"\u0164":'T',"\u0166":'T',"\u0163":'t',"\u0165":'t',"\u0167":'t',"\u0168":'U',"\u016A":'U',"\u016C":'U',"\u016E":'U',"\u0170":'U',"\u0172":'U',"\u0169":'u',"\u016B":'u',"\u016D":'u',"\u016F":'u',"\u0171":'u',"\u0173":'u',"\u0174":'W',"\u0175":'w',"\u0176":'Y',"\u0177":'y',"\u0178":'Y',"\u0179":'Z',"\u017B":'Z',"\u017D":'Z',"\u017A":'z',"\u017C":'z',"\u017E":'z',"\u0132":'IJ',"\u0133":'ij',"\u0152":'Oe',"\u0153":'oe',"\u0149":"'n","\u017F":'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r',"\u2028":'u2028',"\u2029":'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(commonjsGlobal)=='object'&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&'object'=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
  var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
  return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
     * A specialized version of `baseAggregator` for arrays.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
     * A specialized version of `_.forEachRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
     * A specialized version of `_.every` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */function arrayIncludes(array,value){var length=array==null?0:array.length;return !!length&&baseIndexOf(array,value,0)>-1;}/**
     * This function is like `arrayIncludes` except that it accepts a comparator.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
     * A specialized version of `_.reduceRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the last element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */var asciiSize=baseProperty('length');/**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function asciiToArray(string){return string.split('');}/**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
     * The base implementation of methods like `_.findKey` and `_.findLastKey`,
     * without support for iteratee shorthands, which iterates over `collection`
     * using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return -1;}/**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
     * This function is like `baseIndexOf` except that it accepts a comparator.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return -1;}/**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */function baseIsNaN(value){return value!==value;}/**
     * The base implementation of `_.mean` and `_.meanBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the mean.
     */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function baseProperty(key){return function(object){return object==null?undefined$1:object[key];};}/**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyOf(object){return function(key){return object==null?undefined$1:object[key];};}/**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of
     *  `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
     * The base implementation of `_.sortBy` which uses `comparer` to define the
     * sort order of `array` and replaces criteria objects with their corresponding
     * values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
     * The base implementation of `_.sum` and `_.sumBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined$1){result=result===undefined$1?current:result+current;}}return result;}/**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
     * of key-value pairs for `object` corresponding to the property names of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the key-value pairs.
     */function baseToPairs(object,props){return arrayMap(props,function(key){return [key,object[key]];});}/**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */function baseUnary(func){return function(value){return func(value);};}/**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function cacheHas(cache,key){return cache.has(key);}/**
     * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the first unmatched string symbol.
     */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the last unmatched string symbol.
     */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
     * Gets the number of `placeholder` occurrences in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} placeholder The placeholder to search for.
     * @returns {number} Returns the placeholder count.
     */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */var deburrLetter=basePropertyOf(deburredLetters);/**
     * Used by `_.escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
     * Used by `_.template` to escape characters for inclusion in compiled string literals.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */function escapeStringChar(chr){return '\\'+stringEscapes[chr];}/**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function getValue(object,key){return object==null?undefined$1:object[key];}/**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */function hasUnicode(string){return reHasUnicode.test(string);}/**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
     * Converts `set` to its value-value pairs.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the value-value pairs.
     */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return -1;}/**
     * A specialized version of `_.lastIndexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
     * Used by `_.unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} chr The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
     * Create a new pristine `lodash` function using the `context` object.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Util
     * @param {Object} [context=root] The context object.
     * @returns {Function} Returns a new `lodash` function.
     * @example
     *
     * _.mixin({ 'foo': _.constant('foo') });
     *
     * var lodash = _.runInContext();
     * lodash.mixin({ 'bar': lodash.constant('bar') });
     *
     * _.isFunction(_.foo);
     * // => true
     * _.isFunction(_.bar);
     * // => false
     *
     * lodash.isFunction(lodash.foo);
     * // => false
     * lodash.isFunction(lodash.bar);
     * // => true
     *
     * // Create a suped-up `defer` in Node.js.
     * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
     */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined$1,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined$1,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=_Symbol?_Symbol.isConcatSpreadable:undefined$1,symIterator=_Symbol?_Symbol.iterator:undefined$1,symToStringTag=_Symbol?_Symbol.toStringTag:undefined$1;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined$1,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined$1,symbolValueOf=symbolProto?symbolProto.valueOf:undefined$1,symbolToString=symbolProto?symbolProto.toString:undefined$1;/*------------------------------------------------------------------------*/ /**
       * Creates a `lodash` object which wraps `value` to enable implicit method
       * chain sequences. Methods that operate on and return arrays, collections,
       * and functions can be chained together. Methods that retrieve a single value
       * or may return a primitive value will automatically end the chain sequence
       * and return the unwrapped value. Otherwise, the value must be unwrapped
       * with `_#value`.
       *
       * Explicit chain sequences, which must be unwrapped with `_#value`, may be
       * enabled using `_.chain`.
       *
       * The execution of chained methods is lazy, that is, it's deferred until
       * `_#value` is implicitly or explicitly called.
       *
       * Lazy evaluation allows several methods to support shortcut fusion.
       * Shortcut fusion is an optimization to merge iteratee calls; this avoids
       * the creation of intermediate arrays and can greatly reduce the number of
       * iteratee executions. Sections of a chain sequence qualify for shortcut
       * fusion if the section is applied to an array and iteratees accept only
       * one argument. The heuristic for whether a section qualifies for shortcut
       * fusion is subject to change.
       *
       * Chaining is supported in custom builds as long as the `_#value` method is
       * directly or indirectly included in the build.
       *
       * In addition to lodash methods, wrappers have `Array` and `String` methods.
       *
       * The wrapper `Array` methods are:
       * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
       *
       * The wrapper `String` methods are:
       * `replace` and `split`
       *
       * The wrapper methods that support shortcut fusion are:
       * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
       * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
       * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
       *
       * The chainable wrapper methods are:
       * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
       * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
       * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
       * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
       * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
       * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
       * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
       * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
       * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
       * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
       * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
       * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
       * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
       * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
       * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
       * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
       * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
       * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
       * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
       * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
       * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
       * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
       * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
       * `zipObject`, `zipObjectDeep`, and `zipWith`
       *
       * The wrapper methods that are **not** chainable by default are:
       * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
       * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
       * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
       * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
       * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
       * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
       * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
       * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
       * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
       * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
       * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
       * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
       * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
       * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
       * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
       * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
       * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
       * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
       * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
       * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
       * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
       * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
       * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
       * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
       * `upperFirst`, `value`, and `words`
       *
       * @name _
       * @constructor
       * @category Seq
       * @param {*} value The value to wrap in a `lodash` instance.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2, 3]);
       *
       * // Returns an unwrapped value.
       * wrapped.reduce(_.add);
       * // => 6
       *
       * // Returns a wrapped value.
       * var squares = wrapped.map(square);
       *
       * _.isArray(squares);
       * // => false
       *
       * _.isArray(squares.value());
       * // => true
       */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
       * The base implementation of `_.create` without support for assigning
       * properties to the created object.
       *
       * @private
       * @param {Object} proto The object to inherit from.
       * @returns {Object} Returns the new object.
       */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return {};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined$1;return result;};}();/**
       * The function whose prototype chain sequence wrappers inherit from.
       *
       * @private
       */function baseLodash(){// No operation performed.
  }/**
       * The base constructor for creating `lodash` wrapper objects.
       *
       * @private
       * @param {*} value The value to wrap.
       * @param {boolean} [chainAll] Enable explicit method chain sequences.
       */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined$1;}/**
       * By default, the template delimiters used by lodash are like those in
       * embedded Ruby (ERB) as well as ES2015 template strings. Change the
       * following template settings to use alternative delimiters.
       *
       * @static
       * @memberOf _
       * @type {Object}
       */lodash.templateSettings={/**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'escape':reEscape,/**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'evaluate':reEvaluate,/**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'interpolate':reInterpolate,/**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */'variable':'',/**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */'imports':{/**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
  lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
       * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
       *
       * @private
       * @constructor
       * @param {*} value The value to wrap.
       */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
       * Creates a clone of the lazy wrapper object.
       *
       * @private
       * @name clone
       * @memberOf LazyWrapper
       * @returns {Object} Returns the cloned `LazyWrapper` object.
       */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
       * Reverses the direction of lazy iteration.
       *
       * @private
       * @name reverse
       * @memberOf LazyWrapper
       * @returns {Object} Returns the new reversed `LazyWrapper` object.
       */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else {result=this.clone();result.__dir__*=-1;}return result;}/**
       * Extracts the unwrapped value from its lazy wrapper.
       *
       * @private
       * @name value
       * @memberOf LazyWrapper
       * @returns {*} Returns the unwrapped value.
       */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else {break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
  LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
       * Creates a hash object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the hash.
       *
       * @private
       * @name clear
       * @memberOf Hash
       */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
       * Removes `key` and its value from the hash.
       *
       * @private
       * @name delete
       * @memberOf Hash
       * @param {Object} hash The hash to modify.
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
       * Gets the hash value for `key`.
       *
       * @private
       * @name get
       * @memberOf Hash
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined$1:result;}return hasOwnProperty.call(data,key)?data[key]:undefined$1;}/**
       * Checks if a hash value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Hash
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined$1:hasOwnProperty.call(data,key);}/**
       * Sets the hash `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Hash
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the hash instance.
       */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined$1?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
  Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
       * Creates an list cache object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the list cache.
       *
       * @private
       * @name clear
       * @memberOf ListCache
       */function listCacheClear(){this.__data__=[];this.size=0;}/**
       * Removes `key` and its value from the list cache.
       *
       * @private
       * @name delete
       * @memberOf ListCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else {splice.call(data,index,1);}--this.size;return true;}/**
       * Gets the list cache value for `key`.
       *
       * @private
       * @name get
       * @memberOf ListCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined$1:data[index][1];}/**
       * Checks if a list cache value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf ListCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
       * Sets the list cache `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf ListCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the list cache instance.
       */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else {data[index][1]=value;}return this;}// Add methods to `ListCache`.
  ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
       * Creates a map cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the map.
       *
       * @private
       * @name clear
       * @memberOf MapCache
       */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
       * Removes `key` and its value from the map.
       *
       * @private
       * @name delete
       * @memberOf MapCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
       * Gets the map value for `key`.
       *
       * @private
       * @name get
       * @memberOf MapCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
       * Checks if a map value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf MapCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
       * Sets the map `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf MapCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the map cache instance.
       */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
  MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
       *
       * Creates an array cache object to store unique values.
       *
       * @private
       * @constructor
       * @param {Array} [values] The values to cache.
       */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
       * Adds `value` to the array cache.
       *
       * @private
       * @name add
       * @memberOf SetCache
       * @alias push
       * @param {*} value The value to cache.
       * @returns {Object} Returns the cache instance.
       */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
       * Checks if `value` is in the array cache.
       *
       * @private
       * @name has
       * @memberOf SetCache
       * @param {*} value The value to search for.
       * @returns {number} Returns `true` if `value` is found, else `false`.
       */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
  SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
       * Creates a stack cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
       * Removes all key-value entries from the stack.
       *
       * @private
       * @name clear
       * @memberOf Stack
       */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
       * Removes `key` and its value from the stack.
       *
       * @private
       * @name delete
       * @memberOf Stack
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
       * Gets the stack value for `key`.
       *
       * @private
       * @name get
       * @memberOf Stack
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function stackGet(key){return this.__data__.get(key);}/**
       * Checks if a stack value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Stack
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function stackHas(key){return this.__data__.has(key);}/**
       * Sets the stack `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Stack
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the stack cache instance.
       */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
  Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
       * Creates an array of the enumerable property names of the array-like `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @param {boolean} inherited Specify returning inherited property names.
       * @returns {Array} Returns the array of property names.
       */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
  key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
  isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
  isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
  isIndex(key,length)))){result.push(key);}}return result;}/**
       * A specialized version of `_.sample` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @returns {*} Returns the random element.
       */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined$1;}/**
       * A specialized version of `_.sampleSize` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
       * A specialized version of `_.shuffle` for arrays.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
       * This function is like `assignValue` except that it doesn't assign
       * `undefined` values.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function assignMergeValue(object,key,value){if(value!==undefined$1&&!eq(object[key],value)||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
       * Assigns `value` to `key` of `object` if the existing value is not equivalent
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
       * Gets the index at which the `key` is found in `array` of key-value pairs.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} key The key to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return -1;}/**
       * Aggregates elements of `collection` on `accumulator` with keys transformed
       * by `iteratee` and values set by `setter`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
       * The base implementation of `_.assign` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
       * The base implementation of `_.assignIn` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
       * The base implementation of `assignValue` and `assignMergeValue` without
       * value checks.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else {object[key]=value;}}/**
       * The base implementation of `_.at` without support for individual paths.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {string[]} paths The property paths to pick.
       * @returns {Array} Returns the picked elements.
       */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined$1:get(object,paths[index]);}return result;}/**
       * The base implementation of `_.clamp` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined$1){number=number<=upper?number:upper;}if(lower!==undefined$1){number=number>=lower?number:lower;}}return number;}/**
       * The base implementation of `_.clone` and `_.cloneDeep` which tracks
       * traversed objects.
       *
       * @private
       * @param {*} value The value to clone.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Deep clone
       *  2 - Flatten inherited properties
       *  4 - Clone symbols
       * @param {Function} [customizer] The function to customize cloning.
       * @param {string} [key] The key of `value`.
       * @param {Object} [object] The parent object of `value`.
       * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
       * @returns {*} Returns the cloned value.
       */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined$1){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else {var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else {if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
  stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined$1:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
  assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
       * The base implementation of `_.conforms` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
       * The base implementation of `_.conformsTo` which accepts `props` to check.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return !length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined$1&&!(key in object)||!predicate(value)){return false;}}return true;}/**
       * The base implementation of `_.delay` and `_.defer` which accepts `args`
       * to provide to `func`.
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {Array} args The arguments to provide to `func`.
       * @returns {number|Object} Returns the timer id or timeout object.
       */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined$1,args);},wait);}/**
       * The base implementation of methods like `_.difference` without support
       * for excluding multiple arrays or iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Array} values The values to exclude.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
       * The base implementation of `_.forEach` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */var baseEach=createBaseEach(baseForOwn);/**
       * The base implementation of `_.forEachRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
       * The base implementation of `_.every` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`
       */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
       * The base implementation of methods like `_.max` and `_.min` which accepts a
       * `comparator` to determine the extremum value.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The iteratee invoked per iteration.
       * @param {Function} comparator The comparator used to compare values.
       * @returns {*} Returns the extremum value.
       */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined$1?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
       * The base implementation of `_.fill` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined$1||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
       * The base implementation of `_.filter` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
       * The base implementation of `_.flatten` with support for restricting flattening.
       *
       * @private
       * @param {Array} array The array to flatten.
       * @param {number} depth The maximum recursion depth.
       * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
       * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
       * @param {Array} [result=[]] The initial result value.
       * @returns {Array} Returns the new flattened array.
       */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
  baseFlatten(value,depth-1,predicate,isStrict,result);}else {arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
       * The base implementation of `baseForOwn` which iterates over `object`
       * properties returned by `keysFunc` and invokes `iteratee` for each property.
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */var baseFor=createBaseFor();/**
       * This function is like `baseFor` except that it iterates over properties
       * in the opposite order.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */var baseForRight=createBaseFor(true);/**
       * The base implementation of `_.forOwn` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
       * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
       * The base implementation of `_.functions` which creates an array of
       * `object` function property names filtered from `props`.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Array} props The property names to filter.
       * @returns {Array} Returns the function names.
       */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
       * The base implementation of `_.get` without support for default values.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @returns {*} Returns the resolved value.
       */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined$1;}/**
       * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
       * `keysFunc` and `symbolsFunc` to get the enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @param {Function} symbolsFunc The function to get the symbols of `object`.
       * @returns {Array} Returns the array of property names and symbols.
       */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */function baseGetTag(value){if(value==null){return value===undefined$1?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
       * The base implementation of `_.gt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       */function baseGt(value,other){return value>other;}/**
       * The base implementation of `_.has` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
       * The base implementation of `_.hasIn` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
       * The base implementation of `_.inRange` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to check.
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
       * The base implementation of methods like `_.intersection`, without support
       * for iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of shared values.
       */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined$1;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
       * The base implementation of `_.invert` and `_.invertBy` which inverts
       * `object` with values transformed by `iteratee` and set by `setter`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform values.
       * @param {Object} accumulator The initial inverted object.
       * @returns {Function} Returns `accumulator`.
       */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
       * The base implementation of `_.invoke` without support for individual
       * method arguments.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {Array} args The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined$1:apply(func,object,args);}/**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
       * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
       * The base implementation of `_.isDate` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
       * The base implementation of `_.isEqual` which supports partial comparisons
       * and tracks traversed objects.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Unordered comparison
       *  2 - Partial comparison
       * @param {Function} [customizer] The function to customize comparisons.
       * @param {Object} [stack] Tracks traversed `value` and `other` objects.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
       * A specialized version of `baseIsEqual` for arrays and objects which performs
       * deep comparisons and tracks traversed objects enabling objects with circular
       * references to be compared.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} [stack] Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
       * The base implementation of `_.isMap` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
       * The base implementation of `_.isMatch` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Array} matchData The property names, values, and compare flags to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return !length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined$1&&!(key in object)){return false;}}else {var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined$1?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
       * The base implementation of `_.isRegExp` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
       * The base implementation of `_.isSet` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
       * The base implementation of `_.isTypedArray` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
       * The base implementation of `_.iteratee`.
       *
       * @private
       * @param {*} [value=_.identity] The value to convert to an iteratee.
       * @returns {Function} Returns the iteratee.
       */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if(typeof value=='function'){return value;}if(value==null){return identity;}if(_typeof(value)=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
       * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
       * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
       * The base implementation of `_.lt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       */function baseLt(value,other){return value<other;}/**
       * The base implementation of `_.map` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
       * The base implementation of `_.matches` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
       * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
       *
       * @private
       * @param {string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined$1&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
       * The base implementation of `_.merge` without support for multiple sources.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} [customizer] The function to customize merged values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else {var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined$1;if(newValue===undefined$1){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
       * A specialized version of `baseMerge` for arrays and objects which performs
       * deep merges and tracks traversed objects enabling objects with circular
       * references to be merged.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {string} key The key of the value to merge.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} mergeFunc The function to merge values.
       * @param {Function} [customizer] The function to customize assigned values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined$1;var isCommon=newValue===undefined$1;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else {newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else {isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
  stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
       * The base implementation of `_.nth` which doesn't coerce arguments.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {number} n The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined$1;}/**
       * The base implementation of `_.orderBy` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
       * @param {string[]} orders The sort orders of `iteratees`.
       * @returns {Array} Returns the new sorted array.
       */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else {iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return {'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
       * The base implementation of `_.pick` without support for individual
       * property identifiers.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @returns {Object} Returns the new object.
       */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
       * The base implementation of  `_.pickBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @param {Function} predicate The function invoked per property.
       * @returns {Object} Returns the new object.
       */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
       * A specialized version of `baseProperty` which supports deep paths.
       *
       * @private
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
       * The base implementation of `_.pullAllBy` without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
       * The base implementation of `_.pullAt` without support for individual
       * indexes or capturing the removed elements.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {number[]} indexes The indexes of elements to remove.
       * @returns {Array} Returns `array`.
       */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else {baseUnset(array,index);}}}return array;}/**
       * The base implementation of `_.random` without support for returning
       * floating-point numbers.
       *
       * @private
       * @param {number} lower The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the random number.
       */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
       * The base implementation of `_.range` and `_.rangeRight` which doesn't
       * coerce arguments.
       *
       * @private
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @param {number} step The value to increment or decrement by.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the range of numbers.
       */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
       * The base implementation of `_.repeat` which doesn't coerce arguments.
       *
       * @private
       * @param {string} string The string to repeat.
       * @param {number} n The number of times to repeat the string.
       * @returns {string} Returns the repeated string.
       */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
       * The base implementation of `_.sample`.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       */function baseSample(collection){return arraySample(values(collection));}/**
       * The base implementation of `_.sampleSize` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
       * The base implementation of `_.set`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined$1;if(newValue===undefined$1){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
       * The base implementation of `setData` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
       * The base implementation of `_.shuffle`.
       *
       * @private
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
       * The base implementation of `_.slice` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
       * The base implementation of `_.some` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return !result;});return !!result;}/**
       * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
       * performs a binary search of `array` to determine the index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else {high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
       * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
       * which invokes `iteratee` for `value` and each element of `array` to compute
       * their sort ranking. The iteratee is invoked with one argument; (value).
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} iteratee The iteratee invoked per element.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined$1;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined$1,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else {setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else {high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
       * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
       * The base implementation of `_.toNumber` which doesn't ensure correct
       * conversions of binary, hexadecimal, or octal string values.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return +value;}/**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
  if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
  return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
       * The base implementation of `_.uniqBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else {seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
       * The base implementation of `_.unset`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The property path to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
       * The base implementation of `_.update`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to update.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
       * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
       * without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {Function} predicate The function invoked per iteration.
       * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the slice of `array`.
       */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
       * The base implementation of `wrapperValue` which returns the result of
       * performing a sequence of actions on the unwrapped `value`, where each
       * successive action is supplied the return value of the previous.
       *
       * @private
       * @param {*} value The unwrapped value.
       * @param {Array} actions Actions to perform to resolve the unwrapped value.
       * @returns {*} Returns the resolved value.
       */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
       * The base implementation of methods like `_.xor`, without support for
       * iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of values.
       */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
       * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
       *
       * @private
       * @param {Array} props The property identifiers.
       * @param {Array} values The property values.
       * @param {Function} assignFunc The function to assign values.
       * @returns {Object} Returns the new object.
       */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined$1;assignFunc(result,props[index],value);}return result;}/**
       * Casts `value` to an empty array if it's not an array like object.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Array|Object} Returns the cast array-like object.
       */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
       * Casts `value` to `identity` if it's not a function.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Function} Returns cast function.
       */function castFunction(value){return typeof value=='function'?value:identity;}/**
       * Casts `value` to a path array if it's not one.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {Object} [object] The object to query keys on.
       * @returns {Array} Returns the cast property path array.
       */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
       * A `baseRest` alias which can be replaced with `identity` by module
       * replacement plugins.
       *
       * @private
       * @type {Function}
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */var castRest=baseRest;/**
       * Casts `array` to a slice if it's needed.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {number} start The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the cast slice.
       */function castSlice(array,start,end){var length=array.length;end=end===undefined$1?length:end;return !start&&end>=length?array:baseSlice(array,start,end);}/**
       * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
       *
       * @private
       * @param {number|Object} id The timer id or timeout object of the timer to clear.
       */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
       * Creates a clone of  `buffer`.
       *
       * @private
       * @param {Buffer} buffer The buffer to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Buffer} Returns the cloned buffer.
       */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
       * Creates a clone of `arrayBuffer`.
       *
       * @private
       * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
       * @returns {ArrayBuffer} Returns the cloned array buffer.
       */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
       * Creates a clone of `dataView`.
       *
       * @private
       * @param {Object} dataView The data view to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned data view.
       */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
       * Creates a clone of `regexp`.
       *
       * @private
       * @param {Object} regexp The regexp to clone.
       * @returns {Object} Returns the cloned regexp.
       */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
       * Creates a clone of the `symbol` object.
       *
       * @private
       * @param {Object} symbol The symbol object to clone.
       * @returns {Object} Returns the cloned symbol object.
       */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
       * Creates a clone of `typedArray`.
       *
       * @private
       * @param {Object} typedArray The typed array to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned typed array.
       */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
       * Compares values to sort them in ascending order.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined$1,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined$1,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return -1;}}return 0;}/**
       * Used by `_.orderBy` to compare multiple properties of a value to another
       * and stable sort them.
       *
       * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
       * specify an order of "desc" for descending or "asc" for ascending sort order
       * of corresponding values.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {boolean[]|string[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index-other.index;}/**
       * Creates an array that is the composition of partially applied arguments,
       * placeholders, and provided arguments into a single array of arguments.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to prepend to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
       * This function is like `composeArgs` except that the arguments composition
       * is tailored for `_.partialRight`.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to append to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
       * Copies the values of `source` to `array`.
       *
       * @private
       * @param {Array} source The array to copy values from.
       * @param {Array} [array=[]] The array to copy values to.
       * @returns {Array} Returns `array`.
       */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
       * Copies properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Array} props The property identifiers to copy.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Function} [customizer] The function to customize copied values.
       * @returns {Object} Returns `object`.
       */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined$1;if(newValue===undefined$1){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else {assignValue(object,key,newValue);}}return object;}/**
       * Copies own symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
       * Copies own and inherited symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
       * Creates a function like `_.groupBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} [initializer] The accumulator object initializer.
       * @returns {Function} Returns the new aggregator function.
       */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
       * Creates a function like `_.assign`.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined$1,guard=length>2?sources[2]:undefined$1;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined$1:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
       * Creates a `baseEach` or `baseEachRight` function.
       *
       * @private
       * @param {Function} eachFunc The function to iterate over a collection.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
       * Creates a base function for methods like `_.forIn` and `_.forOwn`.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
       * Creates a function that wraps `func` to invoke it with the optional `this`
       * binding of `thisArg`.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
       * Creates a function like `_.lowerFirst`.
       *
       * @private
       * @param {string} methodName The name of the `String` case method to use.
       * @returns {Function} Returns the new case function.
       */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined$1;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
       * Creates a function like `_.camelCase`.
       *
       * @private
       * @param {Function} callback The function to combine each word.
       * @returns {Function} Returns the new compounder function.
       */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
       * Creates a function that produces an instance of `Ctor` regardless of
       * whether it was invoked as part of a `new` expression or by `call` or `apply`.
       *
       * @private
       * @param {Function} Ctor The constructor to wrap.
       * @returns {Function} Returns the new wrapped function.
       */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
  // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
  // for more details.
  var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
  // See https://es5.github.io/#x13.2.2 for more details.
  return isObject(result)?result:thisBinding;};}/**
       * Creates a function that wraps `func` to enable currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {number} arity The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined$1,args,holders,undefined$1,undefined$1,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
       * Creates a `_.find` or `_.findLast` function.
       *
       * @private
       * @param {Function} findIndexFunc The function to find the collection index.
       * @returns {Function} Returns the new find function.
       */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined$1;};}/**
       * Creates a `_.flow` or `_.flowRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new flow function.
       */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined$1;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else {wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
       * Creates a function that wraps `func` to invoke it with optional `this`
       * binding of `thisArg`, partial application, and currying.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [partialsRight] The arguments to append to those provided
       *  to the new function.
       * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined$1:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
       * Creates a function like `_.invertBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} toIteratee The function to resolve iteratees.
       * @returns {Function} Returns the new inverter function.
       */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
       * Creates a function that performs a mathematical operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @param {number} [defaultValue] The value used for `undefined` arguments.
       * @returns {Function} Returns the new mathematical operation function.
       */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined$1&&other===undefined$1){return defaultValue;}if(value!==undefined$1){result=value;}if(other!==undefined$1){if(result===undefined$1){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else {value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
       * Creates a function like `_.over`.
       *
       * @private
       * @param {Function} arrayFunc The function to iterate over iteratees.
       * @returns {Function} Returns the new over function.
       */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
       * Creates the padding for `string` based on `length`. The `chars` string
       * is truncated if the number of characters exceeds `length`.
       *
       * @private
       * @param {number} length The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padding for `string`.
       */function createPadding(length,chars){chars=chars===undefined$1?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
       * Creates a function that wraps `func` to invoke it with the `this` binding
       * of `thisArg` and `partials` prepended to the arguments it receives.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} partials The arguments to prepend to those provided to
       *  the new function.
       * @returns {Function} Returns the new wrapped function.
       */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
       * Creates a `_.range` or `_.rangeRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new range function.
       */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined$1;}// Ensure the sign of `-0` is preserved.
  start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}step=step===undefined$1?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
       * Creates a function that performs a relational operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @returns {Function} Returns the new relational operation function.
       */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
       * Creates a function that wraps `func` to continue currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {Function} wrapFunc The function to create the `func` wrapper.
       * @param {*} placeholder The placeholder value.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined$1,newHoldersRight=isCurry?undefined$1:holders,newPartials=isCurry?partials:undefined$1,newPartialsRight=isCurry?undefined$1:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined$1,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
       * Creates a function like `_.round`.
       *
       * @private
       * @param {string} methodName The name of the `Math` method to use when rounding.
       * @returns {Function} Returns the new round function.
       */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
  // See [MDN](https://mdn.io/round#Examples) for more details.
  var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return +(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
       * Creates a set object of `values`.
       *
       * @private
       * @param {Array} values The values to add to the set.
       * @returns {Object} Returns the new set.
       */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
       * Creates a `_.toPairs` or `_.toPairsIn` function.
       *
       * @private
       * @param {Function} keysFunc The function to get the keys of a given object.
       * @returns {Function} Returns the new pairs function.
       */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
       * Creates a function that either curries or invokes `func` with optional
       * `this` binding and partially applied arguments.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags.
       *    1 - `_.bind`
       *    2 - `_.bindKey`
       *    4 - `_.curry` or `_.curryRight` of a bound function
       *    8 - `_.curry`
       *   16 - `_.curryRight`
       *   32 - `_.partial`
       *   64 - `_.partialRight`
       *  128 - `_.rearg`
       *  256 - `_.ary`
       *  512 - `_.flip`
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to be partially applied.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined$1;}ary=ary===undefined$1?ary:nativeMax(toInteger(ary),0);arity=arity===undefined$1?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined$1;}var data=isBindKey?undefined$1:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined$1?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else {result=createHybrid.apply(undefined$1,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
       * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
       * of source objects to the destination object for all destination properties
       * that resolve to `undefined`.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to assign.
       * @param {Object} object The parent object of `objValue`.
       * @returns {*} Returns the value to assign.
       */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined$1||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
       * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
       * objects into destination objects that are passed thru.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to merge.
       * @param {Object} object The parent object of `objValue`.
       * @param {Object} source The parent object of `srcValue`.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       * @returns {*} Returns the value to assign.
       */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
  stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined$1,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
       * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
       * objects.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {string} key The key of the property to inspect.
       * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
       */function customOmitClone(value){return isPlainObject(value)?undefined$1:value;}/**
       * A specialized version of `baseIsEqualDeep` for arrays with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Array} array The array to compare.
       * @param {Array} other The other array to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `array` and `other` objects.
       * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
       */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
  var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined$1;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
  while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined$1){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
  if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
       * A specialized version of `baseIsEqualDeep` for comparing objects of
       * the same `toStringTag`.
       *
       * **Note:** This function only supports comparing values with tags of
       * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {string} tag The `toStringTag` of the objects to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
  // Invalid dates are coerced to `NaN`.
  return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
  // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
  // for more details.
  return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
  var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
  stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
       * A specialized version of `baseIsEqualDeep` for objects with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
  var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
  if(!(compared===undefined$1?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
  if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
       * A specialized version of `baseRest` which flattens the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */function flatRest(func){return setToString(overRest(func,undefined$1,flatten),func+'');}/**
       * Creates an array of own enumerable property names and symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
       * Creates an array of own and inherited enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
       * Gets metadata for `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {*} Returns the metadata for `func`.
       */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
       * Gets the name of `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {string} Returns the function name.
       */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
       * Gets the argument placeholder value for `func`.
       *
       * @private
       * @param {Function} func The function to inspect.
       * @returns {*} Returns the placeholder value.
       */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
       * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
       * this function returns the custom method, otherwise it returns `baseIteratee`.
       * If arguments are provided, the chosen function is invoked with them and
       * its result is returned.
       *
       * @private
       * @param {*} [value] The value to convert to an iteratee.
       * @param {number} [arity] The arity of the created iteratee.
       * @returns {Function} Returns the chosen function or its result.
       */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
       * Gets the data for `map`.
       *
       * @private
       * @param {Object} map The map to query.
       * @param {string} key The reference key.
       * @returns {*} Returns the map data.
       */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
       * Gets the property names, values, and compare flags of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the match data of `object`.
       */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined$1;}/**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined$1;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else {delete value[symToStringTag];}}return result;}/**
       * Creates an array of the own enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return [];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
       * Creates an array of the own and inherited enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
       * Gets the `toStringTag` of `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined$1,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
       * Gets the view, applying any `transforms` to the `start` and `end` positions.
       *
       * @private
       * @param {number} start The start of the view.
       * @param {number} end The end of the view.
       * @param {Array} transforms The transformations to apply to the view.
       * @returns {Object} Returns an object containing the `start` and `end`
       *  positions of the view.
       */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return {'start':start,'end':end};}/**
       * Extracts wrapper details from the `source` body comment.
       *
       * @private
       * @param {string} source The source to inspect.
       * @returns {Array} Returns the wrapper details.
       */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
       * Checks if `path` exists on `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @param {Function} hasFunc The function to check properties.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return !!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
       * Initializes an array clone.
       *
       * @private
       * @param {Array} array The array to clone.
       * @returns {Array} Returns the initialized clone.
       */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
  if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
       * Initializes an object clone.
       *
       * @private
       * @param {Object} object The object to clone.
       * @returns {Object} Returns the initialized clone.
       */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
       * Initializes an object clone based on its `toStringTag`.
       *
       * **Note:** This function only supports cloning values with tags of
       * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
       *
       * @private
       * @param {Object} object The object to clone.
       * @param {string} tag The `toStringTag` of the object to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the initialized clone.
       */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
       * Inserts wrapper `details` in a comment at the top of the `source` body.
       *
       * @private
       * @param {string} source The source to modify.
       * @returns {Array} details The details to insert.
       * @returns {string} Returns the modified source.
       */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
       * Checks if `value` is a flattenable `arguments` object or array.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
       */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */function isIndex(value,length){var type=_typeof(value);length=length==null?MAX_SAFE_INTEGER:length;return !!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
       * Checks if `value` is a property name and not a property path.
       *
       * @private
       * @param {*} value The value to check.
       * @param {Object} [object] The object to query keys on.
       * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
       */function isKey(value,object){if(isArray(value)){return false;}var type=_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
       * Checks if `value` is suitable for use as unique object key.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
       */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
       * Checks if `func` has a lazy counterpart.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
       *  else `false`.
       */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return !!data&&func===data[0];}/**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */function isMasked(func){return !!maskSrcKey&&maskSrcKey in func;}/**
       * Checks if `func` is capable of being masked.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
       */var isMaskable=coreJsData?isFunction:stubFalse;/**
       * Checks if `value` is likely a prototype object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
       */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
       * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` if suitable for strict
       *  equality comparisons, else `false`.
       */function isStrictComparable(value){return value===value&&!isObject(value);}/**
       * A specialized version of `matchesProperty` for source values suitable
       * for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined$1||key in Object(object));};}/**
       * A specialized version of `_.memoize` which clears the memoized function's
       * cache when it exceeds `MAX_MEMOIZE_SIZE`.
       *
       * @private
       * @param {Function} func The function to have its output memoized.
       * @returns {Function} Returns the new memoized function.
       */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
       * Merges the function metadata of `source` into `data`.
       *
       * Merging metadata reduces the number of wrappers used to invoke a function.
       * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
       * may be applied regardless of execution order. Methods like `_.ary` and
       * `_.rearg` modify function arguments, making the order in which they are
       * executed important, preventing the merging of metadata. However, we make
       * an exception for a safe combined case where curried functions have `_.ary`
       * and or `_.rearg` applied.
       *
       * @private
       * @param {Array} data The destination metadata.
       * @param {Array} source The source metadata.
       * @returns {Array} Returns `data`.
       */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
  if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
  if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
  newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
  var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
  value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
  value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
  if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
  if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
  data[0]=source[0];data[1]=newBitmask;return data;}/**
       * This function is like
       * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * except that it includes inherited enumerable properties.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */function objectToString(value){return nativeObjectToString.call(value);}/**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */function overRest(func,start,transform){start=nativeMax(start===undefined$1?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
       * Gets the parent value at `path` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} path The path to get the parent value of.
       * @returns {*} Returns the parent value.
       */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
       * Reorder `array` according to the specified indexes where the element at
       * the first index is assigned as the first element, the element at
       * the second index is assigned as the second element, and so on.
       *
       * @private
       * @param {Array} array The array to reorder.
       * @param {Array} indexes The arranged array indexes.
       * @returns {Array} Returns `array`.
       */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined$1;}return array;}/**
       * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
       * Sets metadata for `func`.
       *
       * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
       * period of time, it will trip its breaker and transition to an identity
       * function to avoid garbage collection pauses in V8. See
       * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
       * for more details.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */var setData=shortOut(baseSetData);/**
       * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @returns {number|Object} Returns the timer id or timeout object.
       */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */var setToString=shortOut(baseSetToString);/**
       * Sets the `toString` method of `wrapper` to mimic the source of `reference`
       * with wrapper details in a comment at the top of the source body.
       *
       * @private
       * @param {Function} wrapper The function to modify.
       * @param {Function} reference The reference function.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Function} Returns `wrapper`.
       */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else {count=0;}return func.apply(undefined$1,arguments);};}/**
       * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @param {number} [size=array.length] The size of `array`.
       * @returns {Array} Returns `array`.
       */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined$1?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
       * Converts `string` to a property path array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the property path array.
       */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
       * Converts `value` to a string key if it's not a string or symbol.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {string|symbol} Returns the key.
       */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return '';}/**
       * Updates wrapper `details` based on `bitmask` flags.
       *
       * @private
       * @returns {Array} details The details to modify.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Array} Returns `details`.
       */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
       * Creates a clone of `wrapper`.
       *
       * @private
       * @param {Object} wrapper The wrapper to clone.
       * @returns {Object} Returns the cloned wrapper.
       */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
       * Creates an array of elements split into groups the length of `size`.
       * If `array` can't be split evenly, the final chunk will be the remaining
       * elements.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to process.
       * @param {number} [size=1] The length of each chunk
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the new array of chunks.
       * @example
       *
       * _.chunk(['a', 'b', 'c', 'd'], 2);
       * // => [['a', 'b'], ['c', 'd']]
       *
       * _.chunk(['a', 'b', 'c', 'd'], 3);
       * // => [['a', 'b', 'c'], ['d']]
       */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined$1){size=1;}else {size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return [];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
       * Creates an array with all falsey values removed. The values `false`, `null`,
       * `0`, `""`, `undefined`, and `NaN` are falsey.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to compact.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.compact([0, 1, false, 2, '', 3]);
       * // => [1, 2, 3]
       */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
       * Creates a new array concatenating `array` with any additional arrays
       * and/or values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to concatenate.
       * @param {...*} [values] The values to concatenate.
       * @returns {Array} Returns the new concatenated array.
       * @example
       *
       * var array = [1];
       * var other = _.concat(array, 2, [3], [[4]]);
       *
       * console.log(other);
       * // => [1, 2, 3, [4]]
       *
       * console.log(array);
       * // => [1]
       */function concat(){var length=arguments.length;if(!length){return [];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
       * Creates an array of `array` values not included in the other given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * **Note:** Unlike `_.pullAll`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.without, _.xor
       * @example
       *
       * _.difference([2, 1], [2, 3]);
       * // => [1]
       */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
       * This method is like `_.difference` except that it accepts `iteratee` which
       * is invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
       * This method is like `_.difference` except that it accepts `comparator`
       * which is invoked to compare elements of `array` to `values`. The order and
       * references of result values are determined by the first array. The comparator
       * is invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       *
       * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }]
       */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined$1,comparator):[];});/**
       * Creates a slice of `array` with `n` elements dropped from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.drop([1, 2, 3]);
       * // => [2, 3]
       *
       * _.drop([1, 2, 3], 2);
       * // => [3]
       *
       * _.drop([1, 2, 3], 5);
       * // => []
       *
       * _.drop([1, 2, 3], 0);
       * // => [1, 2, 3]
       */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
       * Creates a slice of `array` with `n` elements dropped from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.dropRight([1, 2, 3]);
       * // => [1, 2]
       *
       * _.dropRight([1, 2, 3], 2);
       * // => [1]
       *
       * _.dropRight([1, 2, 3], 5);
       * // => []
       *
       * _.dropRight([1, 2, 3], 0);
       * // => [1, 2, 3]
       */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
       * Creates a slice of `array` excluding elements dropped from the end.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.dropRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropRightWhile(users, ['active', false]);
       * // => objects for ['barney']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropRightWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
       * Creates a slice of `array` excluding elements dropped from the beginning.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.dropWhile(users, function(o) { return !o.active; });
       * // => objects for ['pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropWhile(users, ['active', false]);
       * // => objects for ['pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
       * Fills elements of `array` with `value` from `start` up to, but not
       * including, `end`.
       *
       * **Note:** This method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Array
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.fill(array, 'a');
       * console.log(array);
       * // => ['a', 'a', 'a']
       *
       * _.fill(Array(3), 2);
       * // => [2, 2, 2]
       *
       * _.fill([4, 6, 8, 10], '*', 1, 3);
       * // => [4, '*', '*', 10]
       */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return [];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
       * This method is like `_.find` except that it returns the index of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.findIndex(users, function(o) { return o.user == 'barney'; });
       * // => 0
       *
       * // The `_.matches` iteratee shorthand.
       * _.findIndex(users, { 'user': 'fred', 'active': false });
       * // => 1
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findIndex(users, ['active', false]);
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.findIndex(users, 'active');
       * // => 2
       */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
       * This method is like `_.findIndex` except that it iterates over elements
       * of `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
       * // => 2
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastIndex(users, { 'user': 'barney', 'active': true });
       * // => 0
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastIndex(users, ['active', false]);
       * // => 2
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastIndex(users, 'active');
       * // => 0
       */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length-1;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
       * Flattens `array` a single level deep.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flatten([1, [2, [3, [4]], 5]]);
       * // => [1, 2, [3, [4]], 5]
       */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
       * Recursively flattens `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flattenDeep([1, [2, [3, [4]], 5]]);
       * // => [1, 2, 3, 4, 5]
       */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
       * Recursively flatten `array` up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * var array = [1, [2, [3, [4]], 5]];
       *
       * _.flattenDepth(array, 1);
       * // => [1, 2, [3, [4]], 5]
       *
       * _.flattenDepth(array, 2);
       * // => [1, 2, 3, [4], 5]
       */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return [];}depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(array,depth);}/**
       * The inverse of `_.toPairs`; this method returns an object composed
       * from key-value `pairs`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} pairs The key-value pairs.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.fromPairs([['a', 1], ['b', 2]]);
       * // => { 'a': 1, 'b': 2 }
       */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
       * Gets the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias first
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the first element of `array`.
       * @example
       *
       * _.head([1, 2, 3]);
       * // => 1
       *
       * _.head([]);
       * // => undefined
       */function head(array){return array&&array.length?array[0]:undefined$1;}/**
       * Gets the index at which the first occurrence of `value` is found in `array`
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. If `fromIndex` is negative, it's used as the
       * offset from the end of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.indexOf([1, 2, 1, 2], 2);
       * // => 1
       *
       * // Search from the `fromIndex`.
       * _.indexOf([1, 2, 1, 2], 2, 2);
       * // => 3
       */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
       * Gets all but the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.initial([1, 2, 3]);
       * // => [1, 2]
       */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
       * Creates an array of unique values that are included in all given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersection([2, 1], [2, 3]);
       * // => [2]
       */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
       * This method is like `_.intersection` except that it accepts `iteratee`
       * which is invoked for each element of each `arrays` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [2.1]
       *
       * // The `_.property` iteratee shorthand.
       * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }]
       */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined$1;}else {mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
       * This method is like `_.intersection` except that it accepts `comparator`
       * which is invoked to compare elements of `arrays`. The order and references
       * of result values are determined by the first array. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.intersectionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }]
       */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined$1;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined$1,comparator):[];});/**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
       * Gets the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the last element of `array`.
       * @example
       *
       * _.last([1, 2, 3]);
       * // => 3
       */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined$1;}/**
       * This method is like `_.indexOf` except that it iterates over elements of
       * `array` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.lastIndexOf([1, 2, 1, 2], 2);
       * // => 3
       *
       * // Search from the `fromIndex`.
       * _.lastIndexOf([1, 2, 1, 2], 2, 2);
       * // => 1
       */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
       * Gets the element at index `n` of `array`. If `n` is negative, the nth
       * element from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.11.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=0] The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       *
       * _.nth(array, 1);
       * // => 'b'
       *
       * _.nth(array, -2);
       * // => 'c';
       */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined$1;}/**
       * Removes all given values from `array` using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
       * to remove elements from an array by predicate.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...*} [values] The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pull(array, 'a', 'c');
       * console.log(array);
       * // => ['b', 'b']
       */var pull=baseRest(pullAll);/**
       * This method is like `_.pull` except that it accepts an array of values to remove.
       *
       * **Note:** Unlike `_.difference`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pullAll(array, ['a', 'c']);
       * console.log(array);
       * // => ['b', 'b']
       */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
       * This method is like `_.pullAll` except that it accepts `iteratee` which is
       * invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The iteratee is invoked with one argument: (value).
       *
       * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
       *
       * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
       * console.log(array);
       * // => [{ 'x': 2 }]
       */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
       * This method is like `_.pullAll` except that it accepts `comparator` which
       * is invoked to compare elements of `array` to `values`. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
       *
       * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
       * console.log(array);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
       */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined$1,comparator):array;}/**
       * Removes elements from `array` corresponding to `indexes` and returns an
       * array of removed elements.
       *
       * **Note:** Unlike `_.at`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...(number|number[])} [indexes] The indexes of elements to remove.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       * var pulled = _.pullAt(array, [1, 3]);
       *
       * console.log(array);
       * // => ['a', 'c']
       *
       * console.log(pulled);
       * // => ['b', 'd']
       */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
       * Removes all elements from `array` that `predicate` returns truthy for
       * and returns an array of the removed elements. The predicate is invoked
       * with three arguments: (value, index, array).
       *
       * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
       * to pull elements from an array by value.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = [1, 2, 3, 4];
       * var evens = _.remove(array, function(n) {
       *   return n % 2 == 0;
       * });
       *
       * console.log(array);
       * // => [1, 3]
       *
       * console.log(evens);
       * // => [2, 4]
       */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
       * Reverses `array` so that the first element becomes the last, the second
       * element becomes the second to last, and so on.
       *
       * **Note:** This method mutates `array` and is based on
       * [`Array#reverse`](https://mdn.io/Array/reverse).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.reverse(array);
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
       * Creates a slice of `array` from `start` up to, but not including, `end`.
       *
       * **Note:** This method is used instead of
       * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
       * returned.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return [];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else {start=start==null?0:toInteger(start);end=end===undefined$1?length:toInteger(end);}return baseSlice(array,start,end);}/**
       * Uses a binary search to determine the lowest index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedIndex([30, 50], 40);
       * // => 1
       */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
       * This method is like `_.sortedIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
       * // => 0
       */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
       * This method is like `_.indexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
       * // => 1
       */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return -1;}/**
       * This method is like `_.sortedIndex` except that it returns the highest
       * index at which `value` should be inserted into `array` in order to
       * maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
       * // => 4
       */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
       * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 1
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
       * // => 1
       */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
       * This method is like `_.lastIndexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
       * // => 3
       */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return -1;}/**
       * This method is like `_.uniq` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniq([1, 1, 2]);
       * // => [1, 2]
       */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
       * This method is like `_.uniqBy` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
       * // => [1.1, 2.3]
       */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
       * Gets all but the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.tail([1, 2, 3]);
       * // => [2, 3]
       */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
       * Creates a slice of `array` with `n` elements taken from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.take([1, 2, 3]);
       * // => [1]
       *
       * _.take([1, 2, 3], 2);
       * // => [1, 2]
       *
       * _.take([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.take([1, 2, 3], 0);
       * // => []
       */function take(array,n,guard){if(!(array&&array.length)){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
       * Creates a slice of `array` with `n` elements taken from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.takeRight([1, 2, 3]);
       * // => [3]
       *
       * _.takeRight([1, 2, 3], 2);
       * // => [2, 3]
       *
       * _.takeRight([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.takeRight([1, 2, 3], 0);
       * // => []
       */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
       * Creates a slice of `array` with elements taken from the end. Elements are
       * taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.takeRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeRightWhile(users, ['active', false]);
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeRightWhile(users, 'active');
       * // => []
       */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
       * Creates a slice of `array` with elements taken from the beginning. Elements
       * are taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.takeWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeWhile(users, ['active', false]);
       * // => objects for ['barney', 'fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeWhile(users, 'active');
       * // => []
       */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
       * Creates an array of unique values, in order, from all given arrays using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.union([2], [1, 2]);
       * // => [2, 1]
       */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
       * This method is like `_.union` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which uniqueness is computed. Result values are chosen from the first
       * array in which the value occurs. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.unionBy([2.1], [1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
       * This method is like `_.union` except that it accepts `comparator` which
       * is invoked to compare elements of `arrays`. Result values are chosen from
       * the first array in which the value occurs. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.unionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined$1,comparator);});/**
       * Creates a duplicate-free version of an array, using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons, in which only the first occurrence of each element
       * is kept. The order of result values is determined by the order they occur
       * in the array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniq([2, 1, 2]);
       * // => [2, 1]
       */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
       * This method is like `_.uniq` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * uniqueness is computed. The order of result values is determined by the
       * order they occur in the array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
       * This method is like `_.uniq` except that it accepts `comparator` which
       * is invoked to compare elements of `array`. The order of result values is
       * determined by the order they occur in the array.The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.uniqWith(objects, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
       */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined$1;return array&&array.length?baseUniq(array,undefined$1,comparator):[];}/**
       * This method is like `_.zip` except that it accepts an array of grouped
       * elements and creates an array regrouping the elements to their pre-zip
       * configuration.
       *
       * @static
       * @memberOf _
       * @since 1.2.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       *
       * _.unzip(zipped);
       * // => [['a', 'b'], [1, 2], [true, false]]
       */function unzip(array){if(!(array&&array.length)){return [];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
       * This method is like `_.unzip` except that it accepts `iteratee` to specify
       * how regrouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  regrouped values.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
       * // => [[1, 10, 100], [2, 20, 200]]
       *
       * _.unzipWith(zipped, _.add);
       * // => [3, 30, 300]
       */function unzipWith(array,iteratee){if(!(array&&array.length)){return [];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined$1,group);});}/**
       * Creates an array excluding all given values using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.pull`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...*} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.xor
       * @example
       *
       * _.without([2, 1, 2, 3], 1, 2);
       * // => [3]
       */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
       * Creates an array of unique values that is the
       * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
       * of the given arrays. The order of result values is determined by the order
       * they occur in the arrays.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.without
       * @example
       *
       * _.xor([2, 1], [2, 3]);
       * // => [1, 3]
       */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
       * This method is like `_.xor` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which by which they're compared. The order of result values is determined
       * by the order they occur in the arrays. The iteratee is invoked with one
       * argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2, 3.4]
       *
       * // The `_.property` iteratee shorthand.
       * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
       * This method is like `_.xor` except that it accepts `comparator` which is
       * invoked to compare elements of `arrays`. The order of result values is
       * determined by the order they occur in the arrays. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.xorWith(objects, others, _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined$1,comparator);});/**
       * Creates an array of grouped elements, the first of which contains the
       * first elements of the given arrays, the second of which contains the
       * second elements of the given arrays, and so on.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       */var zip=baseRest(unzip);/**
       * This method is like `_.fromPairs` except that it accepts two arrays,
       * one of property identifiers and one of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 0.4.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObject(['a', 'b'], [1, 2]);
       * // => { 'a': 1, 'b': 2 }
       */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
       * This method is like `_.zipObject` except that it supports property paths.
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
       * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
       */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
       * This method is like `_.zip` except that it accepts `iteratee` to specify
       * how grouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  grouped values.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
       *   return a + b + c;
       * });
       * // => [111, 222]
       */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined$1;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined$1;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
       * Creates a `lodash` wrapper instance that wraps `value` with explicit method
       * chain sequences enabled. The result of such sequences must be unwrapped
       * with `_#value`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Seq
       * @param {*} value The value to wrap.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36 },
       *   { 'user': 'fred',    'age': 40 },
       *   { 'user': 'pebbles', 'age': 1 }
       * ];
       *
       * var youngest = _
       *   .chain(users)
       *   .sortBy('age')
       *   .map(function(o) {
       *     return o.user + ' is ' + o.age;
       *   })
       *   .head()
       *   .value();
       * // => 'pebbles is 1'
       */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
       * This method invokes `interceptor` and returns `value`. The interceptor
       * is invoked with one argument; (value). The purpose of this method is to
       * "tap into" a method chain sequence in order to modify intermediate results.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns `value`.
       * @example
       *
       * _([1, 2, 3])
       *  .tap(function(array) {
       *    // Mutate input array.
       *    array.pop();
       *  })
       *  .reverse()
       *  .value();
       * // => [2, 1]
       */function tap(value,interceptor){interceptor(value);return value;}/**
       * This method is like `_.tap` except that it returns the result of `interceptor`.
       * The purpose of this method is to "pass thru" values replacing intermediate
       * results in a method chain sequence.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns the result of `interceptor`.
       * @example
       *
       * _('  abc  ')
       *  .chain()
       *  .trim()
       *  .thru(function(value) {
       *    return [value];
       *  })
       *  .value();
       * // => ['abc']
       */function thru(value,interceptor){return interceptor(value);}/**
       * This method is the wrapper version of `_.at`.
       *
       * @name at
       * @memberOf _
       * @since 1.0.0
       * @category Seq
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _(object).at(['a[0].b.c', 'a[1]']).value();
       * // => [3, 4]
       */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined$1);}return array;});});/**
       * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
       *
       * @name chain
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * // A sequence without explicit chaining.
       * _(users).head();
       * // => { 'user': 'barney', 'age': 36 }
       *
       * // A sequence with explicit chaining.
       * _(users)
       *   .chain()
       *   .head()
       *   .pick('user')
       *   .value();
       * // => { 'user': 'barney' }
       */function wrapperChain(){return chain(this);}/**
       * Executes the chain sequence and returns the wrapped result.
       *
       * @name commit
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2];
       * var wrapped = _(array).push(3);
       *
       * console.log(array);
       * // => [1, 2]
       *
       * wrapped = wrapped.commit();
       * console.log(array);
       * // => [1, 2, 3]
       *
       * wrapped.last();
       * // => 3
       *
       * console.log(array);
       * // => [1, 2, 3]
       */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
       * Gets the next value on a wrapped object following the
       * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
       *
       * @name next
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the next iterator value.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 1 }
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 2 }
       *
       * wrapped.next();
       * // => { 'done': true, 'value': undefined }
       */function wrapperNext(){if(this.__values__===undefined$1){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined$1:this.__values__[this.__index__++];return {'done':done,'value':value};}/**
       * Enables the wrapper to be iterable.
       *
       * @name Symbol.iterator
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the wrapper object.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped[Symbol.iterator]() === wrapped;
       * // => true
       *
       * Array.from(wrapped);
       * // => [1, 2]
       */function wrapperToIterator(){return this;}/**
       * Creates a clone of the chain sequence planting `value` as the wrapped value.
       *
       * @name plant
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @param {*} value The value to plant.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2]).map(square);
       * var other = wrapped.plant([3, 4]);
       *
       * other.value();
       * // => [9, 16]
       *
       * wrapped.value();
       * // => [1, 4]
       */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined$1;if(result){previous.__wrapped__=clone;}else {result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
       * This method is the wrapper version of `_.reverse`.
       *
       * **Note:** This method mutates the wrapped array.
       *
       * @name reverse
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _(array).reverse().value()
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined$1});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
       * Executes the chain sequence to resolve the unwrapped value.
       *
       * @name value
       * @memberOf _
       * @since 0.1.0
       * @alias toJSON, valueOf
       * @category Seq
       * @returns {*} Returns the resolved unwrapped value.
       * @example
       *
       * _([1, 2, 3]).value();
       * // => [1, 2, 3]
       */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the number of times the key was returned by `iteratee`. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.countBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': 1, '6': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.countBy(['one', 'two', 'three'], 'length');
       * // => { '3': 2, '5': 1 }
       */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else {baseAssignValue(result,key,1);}});/**
       * Checks if `predicate` returns truthy for **all** elements of `collection`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * **Note:** This method returns `true` for
       * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
       * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
       * elements of empty collections.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * _.every([true, 1, null, 'yes'], Boolean);
       * // => false
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.every(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.every(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.every(users, 'active');
       * // => false
       */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
       * Iterates over elements of `collection`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * **Note:** Unlike `_.remove`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.reject
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * _.filter(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, { 'age': 36, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.filter(users, 'active');
       * // => objects for ['barney']
       *
       * // Combining several predicates using `_.overEvery` or `_.overSome`.
       * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
       * // => objects for ['fred', 'barney']
       */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
       * Iterates over elements of `collection`, returning the first element
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': true },
       *   { 'user': 'fred',    'age': 40, 'active': false },
       *   { 'user': 'pebbles', 'age': 1,  'active': true }
       * ];
       *
       * _.find(users, function(o) { return o.age < 40; });
       * // => object for 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.find(users, { 'age': 1, 'active': true });
       * // => object for 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.find(users, ['active', false]);
       * // => object for 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.find(users, 'active');
       * // => object for 'barney'
       */var find=createFind(findIndex);/**
       * This method is like `_.find` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=collection.length-1] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * _.findLast([1, 2, 3, 4], function(n) {
       *   return n % 2 == 1;
       * });
       * // => 3
       */var findLast=createFind(findLastIndex);/**
       * Creates a flattened array of values by running each element in `collection`
       * thru `iteratee` and flattening the mapped results. The iteratee is invoked
       * with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [n, n];
       * }
       *
       * _.flatMap([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDeep([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDepth([1, 2], duplicate, 2);
       * // => [[1, 1], [2, 2]]
       */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * **Note:** As with other "Collections" methods, objects with a "length"
       * property are iterated like arrays. To avoid this behavior use `_.forIn`
       * or `_.forOwn` for object iteration.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias each
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEachRight
       * @example
       *
       * _.forEach([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `1` then `2`.
       *
       * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
       * This method is like `_.forEach` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @alias eachRight
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEach
       * @example
       *
       * _.forEachRight([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `2` then `1`.
       */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The order of grouped values
       * is determined by the order they occur in `collection`. The corresponding
       * value of each key is an array of elements responsible for generating the
       * key. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.groupBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': [4.2], '6': [6.1, 6.3] }
       *
       * // The `_.property` iteratee shorthand.
       * _.groupBy(['one', 'two', 'three'], 'length');
       * // => { '3': ['one', 'two'], '5': ['three'] }
       */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else {baseAssignValue(result,key,[value]);}});/**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * is used for equality comparisons. If `fromIndex` is negative, it's used as
       * the offset from the end of `collection`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes([1, 2, 3], 1, 2);
       * // => false
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
       * Invokes the method at `path` of each element in `collection`, returning
       * an array of the results of each invoked method. Any additional arguments
       * are provided to each invoked method. If `path` is a function, it's invoked
       * for, and `this` bound to, each element in `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array|Function|string} path The path of the method to invoke or
       *  the function invoked per iteration.
       * @param {...*} [args] The arguments to invoke each method with.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
       * // => [[1, 5, 7], [1, 2, 3]]
       *
       * _.invokeMap([123, 456], String.prototype.split, '');
       * // => [['1', '2', '3'], ['4', '5', '6']]
       */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the last element responsible for generating the key. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * var array = [
       *   { 'dir': 'left', 'code': 97 },
       *   { 'dir': 'right', 'code': 100 }
       * ];
       *
       * _.keyBy(array, function(o) {
       *   return String.fromCharCode(o.code);
       * });
       * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
       *
       * _.keyBy(array, 'dir');
       * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
       */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
       * Creates an array of values by running each element in `collection` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
       *
       * The guarded methods are:
       * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
       * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
       * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
       * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * _.map([4, 8], square);
       * // => [16, 64]
       *
       * _.map({ 'a': 4, 'b': 8 }, square);
       * // => [16, 64] (iteration order is not guaranteed)
       *
       * var users = [
       *   { 'user': 'barney' },
       *   { 'user': 'fred' }
       * ];
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, 'user');
       * // => ['barney', 'fred']
       */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
       * This method is like `_.sortBy` except that it allows specifying the sort
       * orders of the iteratees to sort by. If `orders` is unspecified, all values
       * are sorted in ascending order. Otherwise, specify an order of "desc" for
       * descending or "asc" for ascending sort order of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @param {string[]} [orders] The sort orders of `iteratees`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 34 },
       *   { 'user': 'fred',   'age': 40 },
       *   { 'user': 'barney', 'age': 36 }
       * ];
       *
       * // Sort by `user` in ascending order and by `age` in descending order.
       * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
       */function orderBy(collection,iteratees,orders,guard){if(collection==null){return [];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined$1:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
       * Creates an array of elements split into two groups, the first of which
       * contains elements `predicate` returns truthy for, the second of which
       * contains elements `predicate` returns falsey for. The predicate is
       * invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of grouped elements.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': false },
       *   { 'user': 'fred',    'age': 40, 'active': true },
       *   { 'user': 'pebbles', 'age': 1,  'active': false }
       * ];
       *
       * _.partition(users, function(o) { return o.active; });
       * // => objects for [['fred'], ['barney', 'pebbles']]
       *
       * // The `_.matches` iteratee shorthand.
       * _.partition(users, { 'age': 1, 'active': false });
       * // => objects for [['pebbles'], ['barney', 'fred']]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.partition(users, ['active', false]);
       * // => objects for [['barney', 'pebbles'], ['fred']]
       *
       * // The `_.property` iteratee shorthand.
       * _.partition(users, 'active');
       * // => objects for [['fred'], ['barney', 'pebbles']]
       */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return [[],[]];});/**
       * Reduces `collection` to a value which is the accumulated result of running
       * each element in `collection` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `collection` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.reduce`, `_.reduceRight`, and `_.transform`.
       *
       * The guarded methods are:
       * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
       * and `sortBy`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduceRight
       * @example
       *
       * _.reduce([1, 2], function(sum, n) {
       *   return sum + n;
       * }, 0);
       * // => 3
       *
       * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       *   return result;
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
       */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
       * This method is like `_.reduce` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduce
       * @example
       *
       * var array = [[0, 1], [2, 3], [4, 5]];
       *
       * _.reduceRight(array, function(flattened, other) {
       *   return flattened.concat(other);
       * }, []);
       * // => [4, 5, 2, 3, 0, 1]
       */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
       * The opposite of `_.filter`; this method returns the elements of `collection`
       * that `predicate` does **not** return truthy for.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.filter
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': true }
       * ];
       *
       * _.reject(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.reject(users, { 'age': 40, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.reject(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.reject(users, 'active');
       * // => objects for ['barney']
       */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
       * Gets a random element from `collection`.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       * @example
       *
       * _.sample([1, 2, 3, 4]);
       * // => 2
       */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
       * Gets `n` random elements at unique keys from `collection` up to the
       * size of `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @param {number} [n=1] The number of elements to sample.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the random elements.
       * @example
       *
       * _.sampleSize([1, 2, 3], 2);
       * // => [3, 1]
       *
       * _.sampleSize([1, 2, 3], 4);
       * // => [2, 3, 1]
       */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
       * Creates an array of shuffled values, using a version of the
       * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       * @example
       *
       * _.shuffle([1, 2, 3, 4]);
       * // => [4, 1, 3, 2]
       */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
       * Gets the size of `collection` by returning its length for array-like
       * values or the number of own enumerable string keyed properties for objects.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * _.size([1, 2, 3]);
       * // => 3
       *
       * _.size({ 'a': 1, 'b': 2 });
       * // => 2
       *
       * _.size('pebbles');
       * // => 7
       */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
       * Checks if `predicate` returns truthy for **any** element of `collection`.
       * Iteration is stopped once `predicate` returns truthy. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       * @example
       *
       * _.some([null, 0, 'yes', false], Boolean);
       * // => true
       *
       * var users = [
       *   { 'user': 'barney', 'active': true },
       *   { 'user': 'fred',   'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.some(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.some(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.some(users, 'active');
       * // => true
       */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
       * Creates an array of elements, sorted in ascending order by the results of
       * running each element in a collection thru each iteratee. This method
       * performs a stable sort, that is, it preserves the original sort order of
       * equal elements. The iteratees are invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 30 },
       *   { 'user': 'barney', 'age': 34 }
       * ];
       *
       * _.sortBy(users, [function(o) { return o.user; }]);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
       *
       * _.sortBy(users, ['user', 'age']);
       * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
       */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return [];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
       * Gets the timestamp of the number of milliseconds that have elapsed since
       * the Unix epoch (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Date
       * @returns {number} Returns the timestamp.
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => Logs the number of milliseconds it took for the deferred invocation.
       */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
       * The opposite of `_.before`; this method creates a function that invokes
       * `func` once it's called `n` or more times.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {number} n The number of calls before `func` is invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var saves = ['profile', 'settings'];
       *
       * var done = _.after(saves.length, function() {
       *   console.log('done saving!');
       * });
       *
       * _.forEach(saves, function(type) {
       *   asyncSave({ 'type': type, 'complete': done });
       * });
       * // => Logs 'done saving!' after the two async saves have completed.
       */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
       * Creates a function that invokes `func`, with up to `n` arguments,
       * ignoring any additional arguments.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @param {number} [n=func.length] The arity cap.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.ary(parseInt, 1));
       * // => [6, 8, 10]
       */function ary(func,n,guard){n=guard?undefined$1:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,n);}/**
       * Creates a function that invokes `func`, with the `this` binding and arguments
       * of the created function, while it's called less than `n` times. Subsequent
       * calls to the created function return the result of the last `func` invocation.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {number} n The number of calls at which `func` is no longer invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * jQuery(element).on('click', _.before(5, addContactToList));
       * // => Allows adding up to 4 contacts to the list.
       */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined$1;}return result;};}/**
       * Creates a function that invokes `func` with the `this` binding of `thisArg`
       * and `partials` prepended to the arguments it receives.
       *
       * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for partially applied arguments.
       *
       * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
       * property of bound functions.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to bind.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * function greet(greeting, punctuation) {
       *   return greeting + ' ' + this.user + punctuation;
       * }
       *
       * var object = { 'user': 'fred' };
       *
       * var bound = _.bind(greet, object, 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bind(greet, object, _, '!');
       * bound('hi');
       * // => 'hi fred!'
       */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
       * Creates a function that invokes the method at `object[key]` with `partials`
       * prepended to the arguments it receives.
       *
       * This method differs from `_.bind` by allowing bound functions to reference
       * methods that may be redefined or don't yet exist. See
       * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
       * for more details.
       *
       * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Function
       * @param {Object} object The object to invoke the method on.
       * @param {string} key The key of the method.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * var object = {
       *   'user': 'fred',
       *   'greet': function(greeting, punctuation) {
       *     return greeting + ' ' + this.user + punctuation;
       *   }
       * };
       *
       * var bound = _.bindKey(object, 'greet', 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * object.greet = function(greeting, punctuation) {
       *   return greeting + 'ya ' + this.user + punctuation;
       * };
       *
       * bound('!');
       * // => 'hiya fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bindKey(object, 'greet', _, '!');
       * bound('hi');
       * // => 'hiya fred!'
       */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
       * Creates a function that accepts arguments of `func` and either invokes
       * `func` returning its result, if at least `arity` number of arguments have
       * been provided, or returns a function that accepts the remaining `func`
       * arguments, and so on. The arity of `func` may be specified if `func.length`
       * is not sufficient.
       *
       * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curry(abc);
       *
       * curried(1)(2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(1)(_, 3)(2);
       * // => [1, 2, 3]
       */function curry(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curry.placeholder;return result;}/**
       * This method is like `_.curry` except that arguments are applied to `func`
       * in the manner of `_.partialRight` instead of `_.partial`.
       *
       * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curryRight(abc);
       *
       * curried(3)(2)(1);
       * // => [1, 2, 3]
       *
       * curried(2, 3)(1);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(3)(1, _)(2);
       * // => [1, 2, 3]
       */function curryRight(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curryRight.placeholder;return result;}/**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked. The debounced function comes with a `cancel` method to cancel
       * delayed `func` invocations and a `flush` method to immediately invoke them.
       * Provide `options` to indicate whether `func` should be invoked on the
       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
       * with the last arguments provided to the debounced function. Subsequent
       * calls to the debounced function return the result of the last `func`
       * invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', debounced);
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel);
       */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined$1;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
  lastInvokeTime=time;// Start the timer for the trailing edge.
  timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
  return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
  // trailing edge, the system time has gone backwards and we're treating
  // it as the trailing edge, or we've hit the `maxWait` limit.
  return lastCallTime===undefined$1||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
  timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined$1;// Only invoke if we have `lastArgs` which means `func` has been
  // debounced at least once.
  if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined$1;return result;}function cancel(){if(timerId!==undefined$1){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined$1;}function flush(){return timerId===undefined$1?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined$1){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
  clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined$1){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
       * Defers invoking the `func` until the current call stack has cleared. Any
       * additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to defer.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.defer(function(text) {
       *   console.log(text);
       * }, 'deferred');
       * // => Logs 'deferred' after one millisecond.
       */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
       * Invokes `func` after `wait` milliseconds. Any additional arguments are
       * provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.delay(function(text) {
       *   console.log(text);
       * }, 1000, 'later');
       * // => Logs 'later' after one second.
       */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
       * Creates a function that invokes `func` with arguments reversed.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to flip arguments for.
       * @returns {Function} Returns the new flipped function.
       * @example
       *
       * var flipped = _.flip(function() {
       *   return _.toArray(arguments);
       * });
       *
       * flipped('a', 'b', 'c', 'd');
       * // => ['d', 'c', 'b', 'a']
       */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
       * Creates a function that memoizes the result of `func`. If `resolver` is
       * provided, it determines the cache key for storing the result based on the
       * arguments provided to the memoized function. By default, the first argument
       * provided to the memoized function is used as the map cache key. The `func`
       * is invoked with the `this` binding of the memoized function.
       *
       * **Note:** The cache is exposed as the `cache` property on the memoized
       * function. Its creation may be customized by replacing the `_.memoize.Cache`
       * constructor with one whose instances implement the
       * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
       * method interface of `clear`, `delete`, `get`, `has`, and `set`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to have its output memoized.
       * @param {Function} [resolver] The function to resolve the cache key.
       * @returns {Function} Returns the new memoized function.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       * var other = { 'c': 3, 'd': 4 };
       *
       * var values = _.memoize(_.values);
       * values(object);
       * // => [1, 2]
       *
       * values(other);
       * // => [3, 4]
       *
       * object.a = 2;
       * values(object);
       * // => [1, 2]
       *
       * // Modify the result cache.
       * values.cache.set(object, ['a', 'b']);
       * values(object);
       * // => ['a', 'b']
       *
       * // Replace `_.memoize.Cache`.
       * _.memoize.Cache = WeakMap;
       */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
  memoize.Cache=MapCache;/**
       * Creates a function that negates the result of the predicate `func`. The
       * `func` predicate is invoked with the `this` binding and arguments of the
       * created function.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} predicate The predicate to negate.
       * @returns {Function} Returns the new negated function.
       * @example
       *
       * function isEven(n) {
       *   return n % 2 == 0;
       * }
       *
       * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
       * // => [1, 3, 5]
       */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return !predicate.call(this);case 1:return !predicate.call(this,args[0]);case 2:return !predicate.call(this,args[0],args[1]);case 3:return !predicate.call(this,args[0],args[1],args[2]);}return !predicate.apply(this,args);};}/**
       * Creates a function that is restricted to invoking `func` once. Repeat calls
       * to the function return the value of the first invocation. The `func` is
       * invoked with the `this` binding and arguments of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var initialize = _.once(createApplication);
       * initialize();
       * initialize();
       * // => `createApplication` is invoked once
       */function once(func){return before(2,func);}/**
       * Creates a function that invokes `func` with its arguments transformed.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Function
       * @param {Function} func The function to wrap.
       * @param {...(Function|Function[])} [transforms=[_.identity]]
       *  The argument transforms.
       * @returns {Function} Returns the new function.
       * @example
       *
       * function doubled(n) {
       *   return n * 2;
       * }
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var func = _.overArgs(function(x, y) {
       *   return [x, y];
       * }, [square, doubled]);
       *
       * func(9, 3);
       * // => [81, 6]
       *
       * func(10, 5);
       * // => [100, 10]
       */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
       * Creates a function that invokes `func` with `partials` prepended to the
       * arguments it receives. This method is like `_.bind` except it does **not**
       * alter the `this` binding.
       *
       * The `_.partial.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 0.2.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var sayHelloTo = _.partial(greet, 'hello');
       * sayHelloTo('fred');
       * // => 'hello fred'
       *
       * // Partially applied with placeholders.
       * var greetFred = _.partial(greet, _, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined$1,partials,holders);});/**
       * This method is like `_.partial` except that partially applied arguments
       * are appended to the arguments it receives.
       *
       * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var greetFred = _.partialRight(greet, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       *
       * // Partially applied with placeholders.
       * var sayHelloTo = _.partialRight(greet, 'hello', _);
       * sayHelloTo('fred');
       * // => 'hello fred'
       */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined$1,partials,holders);});/**
       * Creates a function that invokes `func` with arguments arranged according
       * to the specified `indexes` where the argument value at the first index is
       * provided as the first argument, the argument value at the second index is
       * provided as the second argument, and so on.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to rearrange arguments for.
       * @param {...(number|number[])} indexes The arranged argument indexes.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var rearged = _.rearg(function(a, b, c) {
       *   return [a, b, c];
       * }, [2, 0, 1]);
       *
       * rearged('b', 'c', 'a')
       * // => ['a', 'b', 'c']
       */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined$1,undefined$1,undefined$1,indexes);});/**
       * Creates a function that invokes `func` with the `this` binding of the
       * created function and arguments from `start` and beyond provided as
       * an array.
       *
       * **Note:** This method is based on the
       * [rest parameter](https://mdn.io/rest_parameters).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.rest(function(what, names) {
       *   return what + ' ' + _.initial(names).join(', ') +
       *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
       * });
       *
       * say('hello', 'fred', 'barney', 'pebbles');
       * // => 'hello fred, barney, & pebbles'
       */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined$1?start:toInteger(start);return baseRest(func,start);}/**
       * Creates a function that invokes `func` with the `this` binding of the
       * create function and an array of arguments much like
       * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
       *
       * **Note:** This method is based on the
       * [spread operator](https://mdn.io/spread_operator).
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Function
       * @param {Function} func The function to spread arguments over.
       * @param {number} [start=0] The start position of the spread.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.spread(function(who, what) {
       *   return who + ' says ' + what;
       * });
       *
       * say(['fred', 'hello']);
       * // => 'fred says hello'
       *
       * var numbers = Promise.all([
       *   Promise.resolve(40),
       *   Promise.resolve(36)
       * ]);
       *
       * numbers.then(_.spread(function(x, y) {
       *   return x + y;
       * }));
       * // => a Promise of 76
       */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
       * Creates a throttled function that only invokes `func` at most once per
       * every `wait` milliseconds. The throttled function comes with a `cancel`
       * method to cancel delayed `func` invocations and a `flush` method to
       * immediately invoke them. Provide `options` to indicate whether `func`
       * should be invoked on the leading and/or trailing edge of the `wait`
       * timeout. The `func` is invoked with the last arguments provided to the
       * throttled function. Subsequent calls to the throttled function return the
       * result of the last `func` invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the throttled function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.throttle` and `_.debounce`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to throttle.
       * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=true]
       *  Specify invoking on the leading edge of the timeout.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new throttled function.
       * @example
       *
       * // Avoid excessively updating the position while scrolling.
       * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
       *
       * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
       * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
       * jQuery(element).on('click', throttled);
       *
       * // Cancel the trailing throttled invocation.
       * jQuery(window).on('popstate', throttled.cancel);
       */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
       * Creates a function that accepts up to one argument, ignoring any
       * additional arguments.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.unary(parseInt));
       * // => [6, 8, 10]
       */function unary(func){return ary(func,1);}/**
       * Creates a function that provides `value` to `wrapper` as its first
       * argument. Any additional arguments provided to the function are appended
       * to those provided to the `wrapper`. The wrapper is invoked with the `this`
       * binding of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {*} value The value to wrap.
       * @param {Function} [wrapper=identity] The wrapper function.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var p = _.wrap(_.escape, function(func, text) {
       *   return '<p>' + func(text) + '</p>';
       * });
       *
       * p('fred, barney, & pebbles');
       * // => '<p>fred, barney, &amp; pebbles</p>'
       */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
       * Casts `value` as an array if it's not one.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Lang
       * @param {*} value The value to inspect.
       * @returns {Array} Returns the cast array.
       * @example
       *
       * _.castArray(1);
       * // => [1]
       *
       * _.castArray({ 'a': 1 });
       * // => [{ 'a': 1 }]
       *
       * _.castArray('abc');
       * // => ['abc']
       *
       * _.castArray(null);
       * // => [null]
       *
       * _.castArray(undefined);
       * // => [undefined]
       *
       * _.castArray();
       * // => []
       *
       * var array = [1, 2, 3];
       * console.log(_.castArray(array) === array);
       * // => true
       */function castArray(){if(!arguments.length){return [];}var value=arguments[0];return isArray(value)?value:[value];}/**
       * Creates a shallow clone of `value`.
       *
       * **Note:** This method is loosely based on the
       * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
       * and supports cloning arrays, array buffers, booleans, date objects, maps,
       * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
       * arrays. The own enumerable properties of `arguments` objects are cloned
       * as plain objects. An empty object is returned for uncloneable values such
       * as error objects, functions, DOM nodes, and WeakMaps.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to clone.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeep
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var shallow = _.clone(objects);
       * console.log(shallow[0] === objects[0]);
       * // => true
       */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
       * This method is like `_.clone` except that it accepts `customizer` which
       * is invoked to produce the cloned value. If `customizer` returns `undefined`,
       * cloning is handled by the method instead. The `customizer` is invoked with
       * up to four arguments; (value [, index|key, object, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeepWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(false);
       *   }
       * }
       *
       * var el = _.cloneWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 0
       */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
       * This method is like `_.clone` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @returns {*} Returns the deep cloned value.
       * @see _.clone
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var deep = _.cloneDeep(objects);
       * console.log(deep[0] === objects[0]);
       * // => false
       */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
       * This method is like `_.cloneWith` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the deep cloned value.
       * @see _.cloneWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(true);
       *   }
       * }
       *
       * var el = _.cloneDeepWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 20
       */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
       * Checks if `object` conforms to `source` by invoking the predicate
       * properties of `source` with the corresponding property values of `object`.
       *
       * **Note:** This method is equivalent to `_.conforms` when `source` is
       * partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
       * // => true
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
       * // => false
       */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */function eq(value,other){return value===other||value!==value&&other!==other;}/**
       * Checks if `value` is greater than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       * @see _.lt
       * @example
       *
       * _.gt(3, 1);
       * // => true
       *
       * _.gt(3, 3);
       * // => false
       *
       * _.gt(1, 3);
       * // => false
       */var gt=createRelationalOperation(baseGt);/**
       * Checks if `value` is greater than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than or equal to
       *  `other`, else `false`.
       * @see _.lte
       * @example
       *
       * _.gte(3, 1);
       * // => true
       *
       * _.gte(3, 3);
       * // => true
       *
       * _.gte(1, 3);
       * // => false
       */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */var isArray=Array.isArray;/**
       * Checks if `value` is classified as an `ArrayBuffer` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       * @example
       *
       * _.isArrayBuffer(new ArrayBuffer(2));
       * // => true
       *
       * _.isArrayBuffer(new Array(2));
       * // => false
       */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
       * This method is like `_.isArrayLike` except that it also checks if `value`
       * is an object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array-like object,
       *  else `false`.
       * @example
       *
       * _.isArrayLikeObject([1, 2, 3]);
       * // => true
       *
       * _.isArrayLikeObject(document.body.children);
       * // => true
       *
       * _.isArrayLikeObject('abc');
       * // => false
       *
       * _.isArrayLikeObject(_.noop);
       * // => false
       */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
       * Checks if `value` is classified as a boolean primitive or object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
       * @example
       *
       * _.isBoolean(false);
       * // => true
       *
       * _.isBoolean(null);
       * // => false
       */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
       * Checks if `value` is a buffer.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
       * @example
       *
       * _.isBuffer(new Buffer(2));
       * // => true
       *
       * _.isBuffer(new Uint8Array(2));
       * // => false
       */var isBuffer=nativeIsBuffer||stubFalse;/**
       * Checks if `value` is classified as a `Date` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       * @example
       *
       * _.isDate(new Date);
       * // => true
       *
       * _.isDate('Mon April 23 2012');
       * // => false
       */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
       * Checks if `value` is likely a DOM element.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
       * @example
       *
       * _.isElement(document.body);
       * // => true
       *
       * _.isElement('<body>');
       * // => false
       */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
       * Checks if `value` is an empty object, collection, map, or set.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Array-like values such as `arguments` objects, arrays, buffers, strings, or
       * jQuery-like collections are considered empty if they have a `length` of `0`.
       * Similarly, maps and sets are considered empty if they have a `size` of `0`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * _.isEmpty(null);
       * // => true
       *
       * _.isEmpty(true);
       * // => true
       *
       * _.isEmpty(1);
       * // => true
       *
       * _.isEmpty([1, 2, 3]);
       * // => false
       *
       * _.isEmpty({ 'a': 1 });
       * // => false
       */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return !value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return !value.size;}if(isPrototype(value)){return !baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
       * Performs a deep comparison between two values to determine if they are
       * equivalent.
       *
       * **Note:** This method supports comparing arrays, array buffers, booleans,
       * date objects, error objects, maps, numbers, `Object` objects, regexes,
       * sets, strings, symbols, and typed arrays. `Object` objects are compared
       * by their own, not inherited, enumerable properties. Functions and DOM
       * nodes are compared by strict equality, i.e. `===`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.isEqual(object, other);
       * // => true
       *
       * object === other;
       * // => false
       */function isEqual(value,other){return baseIsEqual(value,other);}/**
       * This method is like `_.isEqual` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with up to
       * six arguments: (objValue, othValue [, index|key, object, other, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, othValue) {
       *   if (isGreeting(objValue) && isGreeting(othValue)) {
       *     return true;
       *   }
       * }
       *
       * var array = ['hello', 'goodbye'];
       * var other = ['hi', 'goodbye'];
       *
       * _.isEqualWith(array, other, customizer);
       * // => true
       */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;var result=customizer?customizer(value,other):undefined$1;return result===undefined$1?baseIsEqual(value,other,undefined$1,customizer):!!result;}/**
       * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
       * `SyntaxError`, `TypeError`, or `URIError` object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
       * @example
       *
       * _.isError(new Error);
       * // => true
       *
       * _.isError(Error);
       * // => false
       */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
       * Checks if `value` is a finite primitive number.
       *
       * **Note:** This method is based on
       * [`Number.isFinite`](https://mdn.io/Number/isFinite).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
       * @example
       *
       * _.isFinite(3);
       * // => true
       *
       * _.isFinite(Number.MIN_VALUE);
       * // => true
       *
       * _.isFinite(Infinity);
       * // => false
       *
       * _.isFinite('3');
       * // => false
       */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
       * Checks if `value` is an integer.
       *
       * **Note:** This method is based on
       * [`Number.isInteger`](https://mdn.io/Number/isInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
       * @example
       *
       * _.isInteger(3);
       * // => true
       *
       * _.isInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isInteger(Infinity);
       * // => false
       *
       * _.isInteger('3');
       * // => false
       */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}/**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */function isObjectLike(value){return value!=null&&_typeof(value)=='object';}/**
       * Checks if `value` is classified as a `Map` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       * @example
       *
       * _.isMap(new Map);
       * // => true
       *
       * _.isMap(new WeakMap);
       * // => false
       */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
       * Performs a partial deep comparison between `object` and `source` to
       * determine if `object` contains equivalent property values.
       *
       * **Note:** This method is equivalent to `_.matches` when `source` is
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.isMatch(object, { 'b': 2 });
       * // => true
       *
       * _.isMatch(object, { 'b': 1 });
       * // => false
       */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
       * This method is like `_.isMatch` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with five
       * arguments: (objValue, srcValue, index|key, object, source).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, srcValue) {
       *   if (isGreeting(objValue) && isGreeting(srcValue)) {
       *     return true;
       *   }
       * }
       *
       * var object = { 'greeting': 'hello' };
       * var source = { 'greeting': 'hi' };
       *
       * _.isMatchWith(object, source, customizer);
       * // => true
       */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
       * Checks if `value` is `NaN`.
       *
       * **Note:** This method is based on
       * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
       * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
       * `undefined` and other non-number values.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       * @example
       *
       * _.isNaN(NaN);
       * // => true
       *
       * _.isNaN(new Number(NaN));
       * // => true
       *
       * isNaN(undefined);
       * // => true
       *
       * _.isNaN(undefined);
       * // => false
       */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some
  // ActiveX objects in IE.
  return isNumber(value)&&value!=+value;}/**
       * Checks if `value` is a pristine native function.
       *
       * **Note:** This method can't reliably detect native functions in the presence
       * of the core-js package because core-js circumvents this kind of detection.
       * Despite multiple requests, the core-js maintainer has made it clear: any
       * attempt to fix the detection will be obstructed. As a result, we're left
       * with little choice but to throw an error. Unfortunately, this also affects
       * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
       * which rely on core-js.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       * @example
       *
       * _.isNative(Array.prototype.push);
       * // => true
       *
       * _.isNative(_);
       * // => false
       */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
       * Checks if `value` is `null`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
       * @example
       *
       * _.isNull(null);
       * // => true
       *
       * _.isNull(void 0);
       * // => false
       */function isNull(value){return value===null;}/**
       * Checks if `value` is `null` or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
       * @example
       *
       * _.isNil(null);
       * // => true
       *
       * _.isNil(void 0);
       * // => true
       *
       * _.isNil(NaN);
       * // => false
       */function isNil(value){return value==null;}/**
       * Checks if `value` is classified as a `Number` primitive or object.
       *
       * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
       * classified as numbers, use the `_.isFinite` method.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a number, else `false`.
       * @example
       *
       * _.isNumber(3);
       * // => true
       *
       * _.isNumber(Number.MIN_VALUE);
       * // => true
       *
       * _.isNumber(Infinity);
       * // => true
       *
       * _.isNumber('3');
       * // => false
       */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
       * Checks if `value` is classified as a `RegExp` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       * @example
       *
       * _.isRegExp(/abc/);
       * // => true
       *
       * _.isRegExp('/abc/');
       * // => false
       */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
       * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
       * double precision number which isn't the result of a rounded unsafe integer.
       *
       * **Note:** This method is based on
       * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
       * @example
       *
       * _.isSafeInteger(3);
       * // => true
       *
       * _.isSafeInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isSafeInteger(Infinity);
       * // => false
       *
       * _.isSafeInteger('3');
       * // => false
       */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
       * Checks if `value` is classified as a `Set` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       * @example
       *
       * _.isSet(new Set);
       * // => true
       *
       * _.isSet(new WeakSet);
       * // => false
       */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
       * Checks if `value` is classified as a `String` primitive or object.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a string, else `false`.
       * @example
       *
       * _.isString('abc');
       * // => true
       *
       * _.isString(1);
       * // => false
       */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */function isSymbol(value){return _typeof(value)=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
       * Checks if `value` is `undefined`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * _.isUndefined(void 0);
       * // => true
       *
       * _.isUndefined(null);
       * // => false
       */function isUndefined(value){return value===undefined$1;}/**
       * Checks if `value` is classified as a `WeakMap` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
       * @example
       *
       * _.isWeakMap(new WeakMap);
       * // => true
       *
       * _.isWeakMap(new Map);
       * // => false
       */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
       * Checks if `value` is classified as a `WeakSet` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
       * @example
       *
       * _.isWeakSet(new WeakSet);
       * // => true
       *
       * _.isWeakSet(new Set);
       * // => false
       */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
       * Checks if `value` is less than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       * @see _.gt
       * @example
       *
       * _.lt(1, 3);
       * // => true
       *
       * _.lt(3, 3);
       * // => false
       *
       * _.lt(3, 1);
       * // => false
       */var lt=createRelationalOperation(baseLt);/**
       * Checks if `value` is less than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than or equal to
       *  `other`, else `false`.
       * @see _.gte
       * @example
       *
       * _.lte(1, 3);
       * // => true
       *
       * _.lte(3, 3);
       * // => true
       *
       * _.lte(3, 1);
       * // => false
       */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
       * Converts `value` to an array.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Array} Returns the converted array.
       * @example
       *
       * _.toArray({ 'a': 1, 'b': 2 });
       * // => [1, 2]
       *
       * _.toArray('abc');
       * // => ['a', 'b', 'c']
       *
       * _.toArray(1);
       * // => []
       *
       * _.toArray(null);
       * // => []
       */function toArray(value){if(!value){return [];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
       * Converts `value` to a finite number.
       *
       * @static
       * @memberOf _
       * @since 4.12.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted number.
       * @example
       *
       * _.toFinite(3.2);
       * // => 3.2
       *
       * _.toFinite(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toFinite(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toFinite('3.2');
       * // => 3.2
       */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
       * Converts `value` to an integer.
       *
       * **Note:** This method is loosely based on
       * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toInteger(3.2);
       * // => 3
       *
       * _.toInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toInteger(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toInteger('3.2');
       * // => 3
       */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
       * Converts `value` to an integer suitable for use as the length of an
       * array-like object.
       *
       * **Note:** This method is based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toLength(3.2);
       * // => 3
       *
       * _.toLength(Number.MIN_VALUE);
       * // => 0
       *
       * _.toLength(Infinity);
       * // => 4294967295
       *
       * _.toLength('3.2');
       * // => 3
       */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
       * Converts `value` to a plain object flattening inherited enumerable string
       * keyed properties of `value` to own properties of the plain object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Object} Returns the converted plain object.
       * @example
       *
       * function Foo() {
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.assign({ 'a': 1 }, new Foo);
       * // => { 'a': 1, 'b': 2 }
       *
       * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
       * // => { 'a': 1, 'b': 2, 'c': 3 }
       */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
       * Converts `value` to a safe integer. A safe integer can be compared and
       * represented correctly.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toSafeInteger(3.2);
       * // => 3
       *
       * _.toSafeInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toSafeInteger(Infinity);
       * // => 9007199254740991
       *
       * _.toSafeInteger('3.2');
       * // => 3
       */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
       * Assigns own enumerable string keyed properties of source objects to the
       * destination object. Source objects are applied from left to right.
       * Subsequent sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object` and is loosely based on
       * [`Object.assign`](https://mdn.io/Object/assign).
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assignIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assign({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'c': 3 }
       */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
       * This method is like `_.assign` except that it iterates over own and
       * inherited source properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extend
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assign
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assignIn({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
       */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
       * This method is like `_.assignIn` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extendWith
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignInWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
       * This method is like `_.assign` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignInWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
       * Creates an array of values corresponding to `paths` of `object`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Array} Returns the picked values.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _.at(object, ['a[0].b.c', 'a[1]']);
       * // => [3, 4]
       */var at=flatRest(baseAt);/**
       * Creates an object that inherits from the `prototype` object. If a
       * `properties` object is given, its own enumerable string keyed properties
       * are assigned to the created object.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Object
       * @param {Object} prototype The object to inherit from.
       * @param {Object} [properties] The properties to assign to the object.
       * @returns {Object} Returns the new object.
       * @example
       *
       * function Shape() {
       *   this.x = 0;
       *   this.y = 0;
       * }
       *
       * function Circle() {
       *   Shape.call(this);
       * }
       *
       * Circle.prototype = _.create(Shape.prototype, {
       *   'constructor': Circle
       * });
       *
       * var circle = new Circle;
       * circle instanceof Circle;
       * // => true
       *
       * circle instanceof Shape;
       * // => true
       */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
       * Assigns own and inherited enumerable string keyed properties of source
       * objects to the destination object for all destination properties that
       * resolve to `undefined`. Source objects are applied from left to right.
       * Once a property is set, additional values of the same property are ignored.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaultsDeep
       * @example
       *
       * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined$1||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
       * This method is like `_.defaults` except that it recursively assigns
       * default properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaults
       * @example
       *
       * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
       * // => { 'a': { 'b': 2, 'c': 3 } }
       */var defaultsDeep=baseRest(function(args){args.push(undefined$1,customDefaultsMerge);return apply(mergeWith,undefined$1,args);});/**
       * This method is like `_.find` except that it returns the key of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findKey(users, function(o) { return o.age < 40; });
       * // => 'barney' (iteration order is not guaranteed)
       *
       * // The `_.matches` iteratee shorthand.
       * _.findKey(users, { 'age': 1, 'active': true });
       * // => 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findKey(users, 'active');
       * // => 'barney'
       */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
       * This method is like `_.findKey` except that it iterates over elements of
       * a collection in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findLastKey(users, function(o) { return o.age < 40; });
       * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastKey(users, { 'age': 36, 'active': true });
       * // => 'barney'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastKey(users, 'active');
       * // => 'pebbles'
       */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
       * Iterates over own and inherited enumerable string keyed properties of an
       * object and invokes `iteratee` for each property. The iteratee is invoked
       * with three arguments: (value, key, object). Iteratee functions may exit
       * iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forInRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forIn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
       */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
       * This method is like `_.forIn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forInRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
       */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
       * Iterates over own enumerable string keyed properties of an object and
       * invokes `iteratee` for each property. The iteratee is invoked with three
       * arguments: (value, key, object). Iteratee functions may exit iteration
       * early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwnRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
       * This method is like `_.forOwn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwnRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
       */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
       * Creates an array of function property names from own enumerable properties
       * of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functionsIn
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functions(new Foo);
       * // => ['a', 'b']
       */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
       * Creates an array of function property names from own and inherited
       * enumerable properties of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functions
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functionsIn(new Foo);
       * // => ['a', 'b', 'c']
       */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.get(object, 'a[0].b.c');
       * // => 3
       *
       * _.get(object, ['a', '0', 'b', 'c']);
       * // => 3
       *
       * _.get(object, 'a.b.c', 'default');
       * // => 'default'
       */function get(object,path,defaultValue){var result=object==null?undefined$1:baseGet(object,path);return result===undefined$1?defaultValue:result;}/**
       * Checks if `path` is a direct property of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = { 'a': { 'b': 2 } };
       * var other = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.has(object, 'a');
       * // => true
       *
       * _.has(object, 'a.b');
       * // => true
       *
       * _.has(object, ['a', 'b']);
       * // => true
       *
       * _.has(other, 'a');
       * // => false
       */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
       * Checks if `path` is a direct or inherited property of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.hasIn(object, 'a');
       * // => true
       *
       * _.hasIn(object, 'a.b');
       * // => true
       *
       * _.hasIn(object, ['a', 'b']);
       * // => true
       *
       * _.hasIn(object, 'b');
       * // => false
       */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
       * Creates an object composed of the inverted keys and values of `object`.
       * If `object` contains duplicate values, subsequent values overwrite
       * property assignments of previous values.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Object
       * @param {Object} object The object to invert.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invert(object);
       * // => { '1': 'c', '2': 'b' }
       */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
       * This method is like `_.invert` except that the inverted object is generated
       * from the results of running each element of `object` thru `iteratee`. The
       * corresponding inverted value of each inverted key is an array of keys
       * responsible for generating the inverted value. The iteratee is invoked
       * with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Object
       * @param {Object} object The object to invert.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invertBy(object);
       * // => { '1': ['a', 'c'], '2': ['b'] }
       *
       * _.invertBy(object, function(value) {
       *   return 'group' + value;
       * });
       * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
       */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else {result[value]=[key];}},getIteratee);/**
       * Invokes the method at `path` of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
       *
       * _.invoke(object, 'a[0].b.c.slice', 1, 3);
       * // => [2, 3]
       */var invoke=baseRest(baseInvoke);/**
       * Creates an array of the own enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects. See the
       * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * for more details.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keys(new Foo);
       * // => ['a', 'b'] (iteration order is not guaranteed)
       *
       * _.keys('hi');
       * // => ['0', '1']
       */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
       * The opposite of `_.mapValues`; this method creates an object with the
       * same values as `object` and keys generated by running each own enumerable
       * string keyed property of `object` thru `iteratee`. The iteratee is invoked
       * with three arguments: (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapValues
       * @example
       *
       * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
       *   return key + value;
       * });
       * // => { 'a1': 1, 'b2': 2 }
       */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
       * Creates an object with the same keys as `object` and values generated
       * by running each own enumerable string keyed property of `object` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapKeys
       * @example
       *
       * var users = {
       *   'fred':    { 'user': 'fred',    'age': 40 },
       *   'pebbles': { 'user': 'pebbles', 'age': 1 }
       * };
       *
       * _.mapValues(users, function(o) { return o.age; });
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       *
       * // The `_.property` iteratee shorthand.
       * _.mapValues(users, 'age');
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
       * This method is like `_.assign` except that it recursively merges own and
       * inherited enumerable string keyed properties of source objects into the
       * destination object. Source properties that resolve to `undefined` are
       * skipped if a destination value exists. Array and plain object properties
       * are merged recursively. Other objects and value types are overridden by
       * assignment. Source objects are applied from left to right. Subsequent
       * sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {
       *   'a': [{ 'b': 2 }, { 'd': 4 }]
       * };
       *
       * var other = {
       *   'a': [{ 'c': 3 }, { 'e': 5 }]
       * };
       *
       * _.merge(object, other);
       * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
       */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
       * This method is like `_.merge` except that it accepts `customizer` which
       * is invoked to produce the merged values of the destination and source
       * properties. If `customizer` returns `undefined`, merging is handled by the
       * method instead. The `customizer` is invoked with six arguments:
       * (objValue, srcValue, key, object, source, stack).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} customizer The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   if (_.isArray(objValue)) {
       *     return objValue.concat(srcValue);
       *   }
       * }
       *
       * var object = { 'a': [1], 'b': [2] };
       * var other = { 'a': [3], 'b': [4] };
       *
       * _.mergeWith(object, other, customizer);
       * // => { 'a': [1, 3], 'b': [2, 4] }
       */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
       * The opposite of `_.pick`; this method creates an object composed of the
       * own and inherited enumerable property paths of `object` that are not omitted.
       *
       * **Note:** This method is considerably slower than `_.pick`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to omit.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omit(object, ['a', 'c']);
       * // => { 'b': '2' }
       */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
       * The opposite of `_.pickBy`; this method creates an object composed of
       * the own and inherited enumerable string keyed properties of `object` that
       * `predicate` doesn't return truthy for. The predicate is invoked with two
       * arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omitBy(object, _.isNumber);
       * // => { 'b': '2' }
       */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
       * Creates an object composed of the picked `object` properties.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pick(object, ['a', 'c']);
       * // => { 'a': 1, 'c': 3 }
       */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
       * Creates an object composed of the `object` properties `predicate` returns
       * truthy for. The predicate is invoked with two arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pickBy(object, _.isNumber);
       * // => { 'a': 1, 'c': 3 }
       */function pickBy(object,predicate){if(object==null){return {};}var props=arrayMap(getAllKeysIn(object),function(prop){return [prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
       * This method is like `_.get` except that if the resolved value is a
       * function it's invoked with the `this` binding of its parent object and
       * its result is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to resolve.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
       *
       * _.result(object, 'a[0].b.c1');
       * // => 3
       *
       * _.result(object, 'a[0].b.c2');
       * // => 4
       *
       * _.result(object, 'a[0].b.c3', 'default');
       * // => 'default'
       *
       * _.result(object, 'a[0].b.c3', _.constant('default'));
       * // => 'default'
       */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
  if(!length){length=1;object=undefined$1;}while(++index<length){var value=object==null?undefined$1:object[toKey(path[index])];if(value===undefined$1){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
       * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
       * it's created. Arrays are created for missing index properties while objects
       * are created for all other missing properties. Use `_.setWith` to customize
       * `path` creation.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.set(object, 'a[0].b.c', 4);
       * console.log(object.a[0].b.c);
       * // => 4
       *
       * _.set(object, ['x', '0', 'y', 'z'], 5);
       * console.log(object.x[0].y.z);
       * // => 5
       */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
       * This method is like `_.set` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.setWith(object, '[0][1]', 'a', Object);
       * // => { '0': { '1': 'a' } }
       */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseSet(object,path,value,customizer);}/**
       * Creates an array of own enumerable string keyed-value pairs for `object`
       * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
       * entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entries
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairs(new Foo);
       * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
       */var toPairs=createToPairs(keys);/**
       * Creates an array of own and inherited enumerable string keyed-value pairs
       * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
       * or set, its entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entriesIn
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairsIn(new Foo);
       * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
       */var toPairsIn=createToPairs(keysIn);/**
       * An alternative to `_.reduce`; this method transforms `object` to a new
       * `accumulator` object which is the result of running each of its own
       * enumerable string keyed properties thru `iteratee`, with each invocation
       * potentially mutating the `accumulator` object. If `accumulator` is not
       * provided, a new object with the same `[[Prototype]]` will be used. The
       * iteratee is invoked with four arguments: (accumulator, value, key, object).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The custom accumulator value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * _.transform([2, 3, 4], function(result, n) {
       *   result.push(n *= n);
       *   return n % 2 == 0;
       * }, []);
       * // => [4, 9]
       *
       * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] }
       */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else {accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
       * Removes the property at `path` of `object`.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 7 } }] };
       * _.unset(object, 'a[0].b.c');
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       *
       * _.unset(object, ['a', '0', 'b', 'c']);
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
       * This method is like `_.set` except that accepts `updater` to produce the
       * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
       * is invoked with one argument: (value).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.update(object, 'a[0].b.c', function(n) { return n * n; });
       * console.log(object.a[0].b.c);
       * // => 9
       *
       * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
       * console.log(object.x[0].y.z);
       * // => 0
       */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
       * This method is like `_.update` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.updateWith(object, '[0][1]', _.constant('a'), Object);
       * // => { '0': { '1': 'a' } }
       */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
       * Creates an array of the own enumerable string keyed property values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.values(new Foo);
       * // => [1, 2] (iteration order is not guaranteed)
       *
       * _.values('hi');
       * // => ['h', 'i']
       */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
       * Creates an array of the own and inherited enumerable string keyed property
       * values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.valuesIn(new Foo);
       * // => [1, 2, 3] (iteration order is not guaranteed)
       */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
       * Clamps `number` within the inclusive `lower` and `upper` bounds.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Number
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       * @example
       *
       * _.clamp(-10, -5, 5);
       * // => -5
       *
       * _.clamp(10, -5, 5);
       * // => 5
       */function clamp(number,lower,upper){if(upper===undefined$1){upper=lower;lower=undefined$1;}if(upper!==undefined$1){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined$1){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
       * Checks if `n` is between `start` and up to, but not including, `end`. If
       * `end` is not specified, it's set to `start` with `start` then set to `0`.
       * If `start` is greater than `end` the params are swapped to support
       * negative ranges.
       *
       * @static
       * @memberOf _
       * @since 3.3.0
       * @category Number
       * @param {number} number The number to check.
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       * @see _.range, _.rangeRight
       * @example
       *
       * _.inRange(3, 2, 4);
       * // => true
       *
       * _.inRange(4, 8);
       * // => true
       *
       * _.inRange(4, 2);
       * // => false
       *
       * _.inRange(2, 2);
       * // => false
       *
       * _.inRange(1.2, 2);
       * // => true
       *
       * _.inRange(5.2, 4);
       * // => false
       *
       * _.inRange(-3, -2, -6);
       * // => true
       */function inRange(number,start,end){start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
       * Produces a random number between the inclusive `lower` and `upper` bounds.
       * If only one argument is provided a number between `0` and the given number
       * is returned. If `floating` is `true`, or either `lower` or `upper` are
       * floats, a floating-point number is returned instead of an integer.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Number
       * @param {number} [lower=0] The lower bound.
       * @param {number} [upper=1] The upper bound.
       * @param {boolean} [floating] Specify returning a floating-point number.
       * @returns {number} Returns the random number.
       * @example
       *
       * _.random(0, 5);
       * // => an integer between 0 and 5
       *
       * _.random(5);
       * // => also an integer between 0 and 5
       *
       * _.random(5, true);
       * // => a floating-point number between 0 and 5
       *
       * _.random(1.2, 5.2);
       * // => a floating-point number between 1.2 and 5.2
       */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined$1;}if(floating===undefined$1){if(typeof upper=='boolean'){floating=upper;upper=undefined$1;}else if(typeof lower=='boolean'){floating=lower;lower=undefined$1;}}if(lower===undefined$1&&upper===undefined$1){lower=0;upper=1;}else {lower=toFinite(lower);if(upper===undefined$1){upper=lower;lower=0;}else {upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
       * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the camel cased string.
       * @example
       *
       * _.camelCase('Foo Bar');
       * // => 'fooBar'
       *
       * _.camelCase('--foo-bar--');
       * // => 'fooBar'
       *
       * _.camelCase('__FOO_BAR__');
       * // => 'fooBar'
       */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * _.capitalize('FRED');
       * // => 'Fred'
       */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
       * Deburrs `string` by converting
       * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
       * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
       * letters to basic Latin letters and removing
       * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to deburr.
       * @returns {string} Returns the deburred string.
       * @example
       *
       * _.deburr('déjà vu');
       * // => 'deja vu'
       */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
       * Checks if `string` ends with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=string.length] The position to search up to.
       * @returns {boolean} Returns `true` if `string` ends with `target`,
       *  else `false`.
       * @example
       *
       * _.endsWith('abc', 'c');
       * // => true
       *
       * _.endsWith('abc', 'b');
       * // => false
       *
       * _.endsWith('abc', 'b', 2);
       * // => true
       */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined$1?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
       * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
       * corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional
       * characters use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't need escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value. See
       * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * When working with HTML you should always
       * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
       * XSS vectors.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
       * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
       * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escapeRegExp('[lodash](https://lodash.com/)');
       * // => '\[lodash\]\(https://lodash\.com/\)'
       */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
       * Converts `string` to
       * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the kebab cased string.
       * @example
       *
       * _.kebabCase('Foo Bar');
       * // => 'foo-bar'
       *
       * _.kebabCase('fooBar');
       * // => 'foo-bar'
       *
       * _.kebabCase('__FOO_BAR__');
       * // => 'foo-bar'
       */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
       * Converts `string`, as space separated words, to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.lowerCase('--Foo-Bar--');
       * // => 'foo bar'
       *
       * _.lowerCase('fooBar');
       * // => 'foo bar'
       *
       * _.lowerCase('__FOO_BAR__');
       * // => 'foo bar'
       */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
       * Converts the first character of `string` to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.lowerFirst('Fred');
       * // => 'fred'
       *
       * _.lowerFirst('FRED');
       * // => 'fRED'
       */var lowerFirst=createCaseFirst('toLowerCase');/**
       * Pads `string` on the left and right sides if it's shorter than `length`.
       * Padding characters are truncated if they can't be evenly divided by `length`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.pad('abc', 8);
       * // => '  abc   '
       *
       * _.pad('abc', 8, '_-');
       * // => '_-abc_-_'
       *
       * _.pad('abc', 3);
       * // => 'abc'
       */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
       * Pads `string` on the right side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padEnd('abc', 6);
       * // => 'abc   '
       *
       * _.padEnd('abc', 6, '_-');
       * // => 'abc_-_'
       *
       * _.padEnd('abc', 3);
       * // => 'abc'
       */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
       * Pads `string` on the left side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padStart('abc', 6);
       * // => '   abc'
       *
       * _.padStart('abc', 6, '_-');
       * // => '_-_abc'
       *
       * _.padStart('abc', 3);
       * // => 'abc'
       */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
       * Converts `string` to an integer of the specified radix. If `radix` is
       * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
       * hexadecimal, in which case a `radix` of `16` is used.
       *
       * **Note:** This method aligns with the
       * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category String
       * @param {string} string The string to convert.
       * @param {number} [radix=10] The radix to interpret `value` by.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.parseInt('08');
       * // => 8
       *
       * _.map(['6', '08', '10'], _.parseInt);
       * // => [6, 8, 10]
       */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
       * Repeats the given string `n` times.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to repeat.
       * @param {number} [n=1] The number of times to repeat the string.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the repeated string.
       * @example
       *
       * _.repeat('*', 3);
       * // => '***'
       *
       * _.repeat('abc', 2);
       * // => 'abcabc'
       *
       * _.repeat('abc', 0);
       * // => ''
       */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}return baseRepeat(toString(string),n);}/**
       * Replaces matches for `pattern` in `string` with `replacement`.
       *
       * **Note:** This method is based on
       * [`String#replace`](https://mdn.io/String/replace).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to modify.
       * @param {RegExp|string} pattern The pattern to replace.
       * @param {Function|string} replacement The match replacement.
       * @returns {string} Returns the modified string.
       * @example
       *
       * _.replace('Hi Fred', 'Fred', 'Barney');
       * // => 'Hi Barney'
       */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
       * Converts `string` to
       * [snake case](https://en.wikipedia.org/wiki/Snake_case).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the snake cased string.
       * @example
       *
       * _.snakeCase('Foo Bar');
       * // => 'foo_bar'
       *
       * _.snakeCase('fooBar');
       * // => 'foo_bar'
       *
       * _.snakeCase('--FOO-BAR--');
       * // => 'foo_bar'
       */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
       * Splits `string` by `separator`.
       *
       * **Note:** This method is based on
       * [`String#split`](https://mdn.io/String/split).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to split.
       * @param {RegExp|string} separator The separator pattern to split by.
       * @param {number} [limit] The length to truncate results to.
       * @returns {Array} Returns the string segments.
       * @example
       *
       * _.split('a-b-c', '-', 2);
       * // => ['a', 'b']
       */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined$1;}limit=limit===undefined$1?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return [];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
       * Converts `string` to
       * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
       *
       * @static
       * @memberOf _
       * @since 3.1.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the start cased string.
       * @example
       *
       * _.startCase('--foo-bar--');
       * // => 'Foo Bar'
       *
       * _.startCase('fooBar');
       * // => 'Foo Bar'
       *
       * _.startCase('__FOO_BAR__');
       * // => 'FOO BAR'
       */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
       * Checks if `string` starts with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=0] The position to search from.
       * @returns {boolean} Returns `true` if `string` starts with `target`,
       *  else `false`.
       * @example
       *
       * _.startsWith('abc', 'a');
       * // => true
       *
       * _.startsWith('abc', 'b');
       * // => false
       *
       * _.startsWith('abc', 'b', 1);
       * // => true
       */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
       * Creates a compiled template function that can interpolate data properties
       * in "interpolate" delimiters, HTML-escape interpolated data properties in
       * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
       * properties may be accessed as free variables in the template. If a setting
       * object is given, it takes precedence over `_.templateSettings` values.
       *
       * **Note:** In the development build `_.template` utilizes
       * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
       * for easier debugging.
       *
       * For more information on precompiling templates see
       * [lodash's custom builds documentation](https://lodash.com/custom-builds).
       *
       * For more information on Chrome extension sandboxes see
       * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The template string.
       * @param {Object} [options={}] The options object.
       * @param {RegExp} [options.escape=_.templateSettings.escape]
       *  The HTML "escape" delimiter.
       * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
       *  The "evaluate" delimiter.
       * @param {Object} [options.imports=_.templateSettings.imports]
       *  An object to import into the template as free variables.
       * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
       *  The "interpolate" delimiter.
       * @param {string} [options.sourceURL='lodash.templateSources[n]']
       *  The sourceURL of the compiled template.
       * @param {string} [options.variable='obj']
       *  The data object variable name.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the compiled template function.
       * @example
       *
       * // Use the "interpolate" delimiter to create a compiled template.
       * var compiled = _.template('hello <%= user %>!');
       * compiled({ 'user': 'fred' });
       * // => 'hello fred!'
       *
       * // Use the HTML "escape" delimiter to escape data property values.
       * var compiled = _.template('<b><%- value %></b>');
       * compiled({ 'value': '<script>' });
       * // => '<b>&lt;script&gt;</b>'
       *
       * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
       * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the internal `print` function in "evaluate" delimiters.
       * var compiled = _.template('<% print("hello " + user); %>!');
       * compiled({ 'user': 'barney' });
       * // => 'hello barney!'
       *
       * // Use the ES template literal delimiter as an "interpolate" delimiter.
       * // Disable support by replacing the "interpolate" delimiter.
       * var compiled = _.template('hello ${ user }!');
       * compiled({ 'user': 'pebbles' });
       * // => 'hello pebbles!'
       *
       * // Use backslashes to treat delimiters as plain text.
       * var compiled = _.template('<%= "\\<%- value %\\>" %>');
       * compiled({ 'value': 'ignored' });
       * // => '<%- value %>'
       *
       * // Use the `imports` option to import `jQuery` as `jq`.
       * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
       * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the `sourceURL` option to specify a custom sourceURL for the template.
       * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
       * compiled(data);
       * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
       *
       * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
       * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
       * compiled.source;
       * // => function(data) {
       * //   var __t, __p = '';
       * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
       * //   return __p;
       * // }
       *
       * // Use custom template delimiters.
       * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
       * var compiled = _.template('hello {{ user }}!');
       * compiled({ 'user': 'mustache' });
       * // => 'hello mustache!'
       *
       * // Use the `source` property to inline compiled templates for meaningful
       * // line numbers in error messages and stack traces.
       * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
       *   var JST = {\
       *     "main": ' + _.template(mainText).source + '\
       *   };\
       * ');
       */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined$1;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
  var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.
  var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
  source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
  if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
  // order to produce the correct `offset` value.
  return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
  source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
  source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined$1,importsValues);});// Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source=source;if(isError(result)){throw result;}return result;}/**
       * Converts `string`, as a whole, to lower case just like
       * [String#toLowerCase](https://mdn.io/toLowerCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.toLower('--Foo-Bar--');
       * // => '--foo-bar--'
       *
       * _.toLower('fooBar');
       * // => 'foobar'
       *
       * _.toLower('__FOO_BAR__');
       * // => '__foo_bar__'
       */function toLower(value){return toString(value).toLowerCase();}/**
       * Converts `string`, as a whole, to upper case just like
       * [String#toUpperCase](https://mdn.io/toUpperCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.toUpper('--foo-bar--');
       * // => '--FOO-BAR--'
       *
       * _.toUpper('fooBar');
       * // => 'FOOBAR'
       *
       * _.toUpper('__foo_bar__');
       * // => '__FOO_BAR__'
       */function toUpper(value){return toString(value).toUpperCase();}/**
       * Removes leading and trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trim('  abc  ');
       * // => 'abc'
       *
       * _.trim('-_-abc-_-', '_-');
       * // => 'abc'
       *
       * _.map(['  foo  ', '  bar  '], _.trim);
       * // => ['foo', 'bar']
       */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimEnd('  abc  ');
       * // => '  abc'
       *
       * _.trimEnd('-_-abc-_-', '_-');
       * // => '-_-abc'
       */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
       * Removes leading whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimStart('  abc  ');
       * // => 'abc  '
       *
       * _.trimStart('-_-abc-_-', '_-');
       * // => 'abc-_-'
       */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
       * Truncates `string` if it's longer than the given maximum string length.
       * The last characters of the truncated string are replaced with the omission
       * string which defaults to "...".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to truncate.
       * @param {Object} [options={}] The options object.
       * @param {number} [options.length=30] The maximum string length.
       * @param {string} [options.omission='...'] The string to indicate text is omitted.
       * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
       * @returns {string} Returns the truncated string.
       * @example
       *
       * _.truncate('hi-diddly-ho there, neighborino');
       * // => 'hi-diddly-ho there, neighbo...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': ' '
       * });
       * // => 'hi-diddly-ho there,...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': /,? +/
       * });
       * // => 'hi-diddly-ho there...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'omission': ' [...]'
       * });
       * // => 'hi-diddly-ho there, neig [...]'
       */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined$1){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined$1?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
       * The inverse of `_.escape`; this method converts the HTML entities
       * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
       * their corresponding characters.
       *
       * **Note:** No other HTML entities are unescaped. To unescape additional
       * HTML entities use a third-party library like [_he_](https://mths.be/he).
       *
       * @static
       * @memberOf _
       * @since 0.6.0
       * @category String
       * @param {string} [string=''] The string to unescape.
       * @returns {string} Returns the unescaped string.
       * @example
       *
       * _.unescape('fred, barney, &amp; pebbles');
       * // => 'fred, barney, & pebbles'
       */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
       * Converts `string`, as space separated words, to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.upperCase('--foo-bar');
       * // => 'FOO BAR'
       *
       * _.upperCase('fooBar');
       * // => 'FOO BAR'
       *
       * _.upperCase('__foo_bar__');
       * // => 'FOO BAR'
       */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
       * Converts the first character of `string` to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.upperFirst('fred');
       * // => 'Fred'
       *
       * _.upperFirst('FRED');
       * // => 'FRED'
       */var upperFirst=createCaseFirst('toUpperCase');/**
       * Splits `string` into an array of its words.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {RegExp|string} [pattern] The pattern to match words.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the words of `string`.
       * @example
       *
       * _.words('fred, barney, & pebbles');
       * // => ['fred', 'barney', 'pebbles']
       *
       * _.words('fred, barney, & pebbles', /[^, ]+/g);
       * // => ['fred', 'barney', '&', 'pebbles']
       */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined$1:pattern;if(pattern===undefined$1){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
       * Attempts to invoke `func`, returning either the result or the caught error
       * object. Any additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Function} func The function to attempt.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {*} Returns the `func` result or error object.
       * @example
       *
       * // Avoid throwing errors for invalid selectors.
       * var elements = _.attempt(function(selector) {
       *   return document.querySelectorAll(selector);
       * }, '>_>');
       *
       * if (_.isError(elements)) {
       *   elements = [];
       * }
       */var attempt=baseRest(function(func,args){try{return apply(func,undefined$1,args);}catch(e){return isError(e)?e:new Error(e);}});/**
       * Binds methods of an object to the object itself, overwriting the existing
       * method.
       *
       * **Note:** This method doesn't set the "length" property of bound functions.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Object} object The object to bind and assign the bound methods to.
       * @param {...(string|string[])} methodNames The object method names to bind.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var view = {
       *   'label': 'docs',
       *   'click': function() {
       *     console.log('clicked ' + this.label);
       *   }
       * };
       *
       * _.bindAll(view, ['click']);
       * jQuery(element).on('click', view.click);
       * // => Logs 'clicked docs' when clicked.
       */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
       * Creates a function that iterates over `pairs` and invokes the corresponding
       * function of the first predicate to return truthy. The predicate-function
       * pairs are invoked with the `this` binding and arguments of the created
       * function.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Array} pairs The predicate-function pairs.
       * @returns {Function} Returns the new composite function.
       * @example
       *
       * var func = _.cond([
       *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
       *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
       *   [_.stubTrue,                      _.constant('no match')]
       * ]);
       *
       * func({ 'a': 1, 'b': 2 });
       * // => 'matches A'
       *
       * func({ 'a': 0, 'b': 1 });
       * // => 'matches B'
       *
       * func({ 'a': '1', 'b': '2' });
       * // => 'no match'
       */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return [toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
       * Creates a function that invokes the predicate properties of `source` with
       * the corresponding property values of a given object, returning `true` if
       * all predicates return truthy, else `false`.
       *
       * **Note:** The created function is equivalent to `_.conformsTo` with
       * `source` partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 2, 'b': 1 },
       *   { 'a': 1, 'b': 2 }
       * ];
       *
       * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
       * // => [{ 'a': 1, 'b': 2 }]
       */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */function constant(value){return function(){return value;};}/**
       * Checks `value` to determine whether a default value should be returned in
       * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
       * or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Util
       * @param {*} value The value to check.
       * @param {*} defaultValue The default value.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * _.defaultTo(1, 10);
       * // => 1
       *
       * _.defaultTo(undefined, 10);
       * // => 10
       */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
       * Creates a function that returns the result of invoking the given functions
       * with the `this` binding of the created function, where each successive
       * invocation is supplied the return value of the previous.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flowRight
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flow([_.add, square]);
       * addSquare(1, 2);
       * // => 9
       */var flow=createFlow();/**
       * This method is like `_.flow` except that it creates a function that
       * invokes the given functions from right to left.
       *
       * @static
       * @since 3.0.0
       * @memberOf _
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flow
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flowRight([square, _.add]);
       * addSquare(1, 2);
       * // => 9
       */var flowRight=createFlow(true);/**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */function identity(value){return value;}/**
       * Creates a function that invokes `func` with the arguments of the created
       * function. If `func` is a property name, the created function returns the
       * property value for a given element. If `func` is an array or object, the
       * created function returns `true` for elements that contain the equivalent
       * source properties, otherwise it returns `false`.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Util
       * @param {*} [func=_.identity] The value to convert to a callback.
       * @returns {Function} Returns the callback.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
       * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, _.iteratee(['user', 'fred']));
       * // => [{ 'user': 'fred', 'age': 40 }]
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, _.iteratee('user'));
       * // => ['barney', 'fred']
       *
       * // Create custom iteratee shorthands.
       * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
       *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
       *     return func.test(string);
       *   };
       * });
       *
       * _.filter(['abc', 'def'], /ef/);
       * // => ['def']
       */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
       * Creates a function that performs a partial deep comparison between a given
       * object and `source`, returning `true` if the given object has equivalent
       * property values, else `false`.
       *
       * **Note:** The created function is equivalent to `_.isMatch` with `source`
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
       * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
       * Creates a function that performs a partial deep comparison between the
       * value at `path` of a given object to `srcValue`, returning `true` if the
       * object value is equivalent, else `false`.
       *
       * **Note:** Partial comparisons will match empty array and empty object
       * `srcValue` values against any array or object value, respectively. See
       * `_.isEqual` for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.find(objects, _.matchesProperty('a', 4));
       * // => { 'a': 4, 'b': 5, 'c': 6 }
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
       * Creates a function that invokes the method at `path` of a given object.
       * Any additional arguments are provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': _.constant(2) } },
       *   { 'a': { 'b': _.constant(1) } }
       * ];
       *
       * _.map(objects, _.method('a.b'));
       * // => [2, 1]
       *
       * _.map(objects, _.method(['a', 'b']));
       * // => [2, 1]
       */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
       * The opposite of `_.method`; this method creates a function that invokes
       * the method at a given path of `object`. Any additional arguments are
       * provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Object} object The object to query.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var array = _.times(3, _.constant),
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.methodOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
       * // => [2, 0]
       */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
       * Adds all own enumerable string keyed function properties of a source
       * object to the destination object. If `object` is a function, then methods
       * are added to its prototype as well.
       *
       * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
       * avoid conflicts caused by modifying the original.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Function|Object} [object=lodash] The destination object.
       * @param {Object} source The object of functions to add.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
       * @returns {Function|Object} Returns `object`.
       * @example
       *
       * function vowels(string) {
       *   return _.filter(string, function(v) {
       *     return /[aeiou]/i.test(v);
       *   });
       * }
       *
       * _.mixin({ 'vowels': vowels });
       * _.vowels('fred');
       * // => ['e']
       *
       * _('fred').vowels().value();
       * // => ['e']
       *
       * _.mixin({ 'vowels': vowels }, { 'chain': false });
       * _('fred').vowels();
       * // => ['e']
       */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
       * Reverts the `_` variable to its previous value and returns a reference to
       * the `lodash` function.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @returns {Function} Returns the `lodash` function.
       * @example
       *
       * var lodash = _.noConflict();
       */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
       * This method returns `undefined`.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Util
       * @example
       *
       * _.times(2, _.noop);
       * // => [undefined, undefined]
       */function noop(){// No operation performed.
  }/**
       * Creates a function that gets the argument at index `n`. If `n` is negative,
       * the nth argument from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [n=0] The index of the argument to return.
       * @returns {Function} Returns the new pass-thru function.
       * @example
       *
       * var func = _.nthArg(1);
       * func('a', 'b', 'c', 'd');
       * // => 'b'
       *
       * var func = _.nthArg(-2);
       * func('a', 'b', 'c', 'd');
       * // => 'c'
       */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
       * Creates a function that invokes `iteratees` with the arguments it receives
       * and returns their results.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to invoke.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.over([Math.max, Math.min]);
       *
       * func(1, 2, 3, 4);
       * // => [4, 1]
       */var over=createOver(arrayMap);/**
       * Creates a function that checks if **all** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overEvery([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => false
       *
       * func(NaN);
       * // => false
       */var overEvery=createOver(arrayEvery);/**
       * Creates a function that checks if **any** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overSome([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => true
       *
       * func(NaN);
       * // => false
       *
       * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
       * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
       */var overSome=createOver(arraySome);/**
       * Creates a function that returns the value at `path` of a given object.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': 2 } },
       *   { 'a': { 'b': 1 } }
       * ];
       *
       * _.map(objects, _.property('a.b'));
       * // => [2, 1]
       *
       * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
       * // => [1, 2]
       */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
       * The opposite of `_.property`; this method creates a function that returns
       * the value at a given path of `object`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var array = [0, 1, 2],
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
       * // => [2, 0]
       */function propertyOf(object){return function(path){return object==null?undefined$1:baseGet(object,path);};}/**
       * Creates an array of numbers (positive and/or negative) progressing from
       * `start` up to, but not including, `end`. A step of `-1` is used if a negative
       * `start` is specified without an `end` or `step`. If `end` is not specified,
       * it's set to `start` with `start` then set to `0`.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.rangeRight
       * @example
       *
       * _.range(4);
       * // => [0, 1, 2, 3]
       *
       * _.range(-4);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 5);
       * // => [1, 2, 3, 4]
       *
       * _.range(0, 20, 5);
       * // => [0, 5, 10, 15]
       *
       * _.range(0, -4, -1);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.range(0);
       * // => []
       */var range=createRange();/**
       * This method is like `_.range` except that it populates values in
       * descending order.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.range
       * @example
       *
       * _.rangeRight(4);
       * // => [3, 2, 1, 0]
       *
       * _.rangeRight(-4);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 5);
       * // => [4, 3, 2, 1]
       *
       * _.rangeRight(0, 20, 5);
       * // => [15, 10, 5, 0]
       *
       * _.rangeRight(0, -4, -1);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.rangeRight(0);
       * // => []
       */var rangeRight=createRange(true);/**
       * This method returns a new empty array.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Array} Returns the new empty array.
       * @example
       *
       * var arrays = _.times(2, _.stubArray);
       *
       * console.log(arrays);
       * // => [[], []]
       *
       * console.log(arrays[0] === arrays[1]);
       * // => false
       */function stubArray(){return [];}/**
       * This method returns `false`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `false`.
       * @example
       *
       * _.times(2, _.stubFalse);
       * // => [false, false]
       */function stubFalse(){return false;}/**
       * This method returns a new empty object.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Object} Returns the new empty object.
       * @example
       *
       * var objects = _.times(2, _.stubObject);
       *
       * console.log(objects);
       * // => [{}, {}]
       *
       * console.log(objects[0] === objects[1]);
       * // => false
       */function stubObject(){return {};}/**
       * This method returns an empty string.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {string} Returns the empty string.
       * @example
       *
       * _.times(2, _.stubString);
       * // => ['', '']
       */function stubString(){return '';}/**
       * This method returns `true`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `true`.
       * @example
       *
       * _.times(2, _.stubTrue);
       * // => [true, true]
       */function stubTrue(){return true;}/**
       * Invokes the iteratee `n` times, returning an array of the results of
       * each invocation. The iteratee is invoked with one argument; (index).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.times(3, String);
       * // => ['0', '1', '2']
       *
       *  _.times(4, _.constant(0));
       * // => [0, 0, 0, 0]
       */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return [];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
       * Converts `value` to a property path array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {*} value The value to convert.
       * @returns {Array} Returns the new property path array.
       * @example
       *
       * _.toPath('a.b.c');
       * // => ['a', 'b', 'c']
       *
       * _.toPath('a[0].b.c');
       * // => ['a', '0', 'b', 'c']
       */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
       * Generates a unique ID. If `prefix` is given, the ID is appended to it.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {string} [prefix=''] The value to prefix the ID with.
       * @returns {string} Returns the unique ID.
       * @example
       *
       * _.uniqueId('contact_');
       * // => 'contact_104'
       *
       * _.uniqueId();
       * // => '105'
       */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
       * Adds two numbers.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {number} augend The first number in an addition.
       * @param {number} addend The second number in an addition.
       * @returns {number} Returns the total.
       * @example
       *
       * _.add(6, 4);
       * // => 10
       */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
       * Computes `number` rounded up to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round up.
       * @param {number} [precision=0] The precision to round up to.
       * @returns {number} Returns the rounded up number.
       * @example
       *
       * _.ceil(4.006);
       * // => 5
       *
       * _.ceil(6.004, 2);
       * // => 6.01
       *
       * _.ceil(6040, -2);
       * // => 6100
       */var ceil=createRound('ceil');/**
       * Divide two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} dividend The first number in a division.
       * @param {number} divisor The second number in a division.
       * @returns {number} Returns the quotient.
       * @example
       *
       * _.divide(6, 4);
       * // => 1.5
       */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
       * Computes `number` rounded down to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round down.
       * @param {number} [precision=0] The precision to round down to.
       * @returns {number} Returns the rounded down number.
       * @example
       *
       * _.floor(4.006);
       * // => 4
       *
       * _.floor(0.046, 2);
       * // => 0.04
       *
       * _.floor(4060, -2);
       * // => 4000
       */var floor=createRound('floor');/**
       * Computes the maximum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * _.max([4, 2, 8, 6]);
       * // => 8
       *
       * _.max([]);
       * // => undefined
       */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined$1;}/**
       * This method is like `_.max` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.maxBy(objects, function(o) { return o.n; });
       * // => { 'n': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.maxBy(objects, 'n');
       * // => { 'n': 2 }
       */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined$1;}/**
       * Computes the mean of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the mean.
       * @example
       *
       * _.mean([4, 2, 8, 6]);
       * // => 5
       */function mean(array){return baseMean(array,identity);}/**
       * This method is like `_.mean` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be averaged.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the mean.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.meanBy(objects, function(o) { return o.n; });
       * // => 5
       *
       * // The `_.property` iteratee shorthand.
       * _.meanBy(objects, 'n');
       * // => 5
       */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
       * Computes the minimum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * _.min([4, 2, 8, 6]);
       * // => 2
       *
       * _.min([]);
       * // => undefined
       */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined$1;}/**
       * This method is like `_.min` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.minBy(objects, function(o) { return o.n; });
       * // => { 'n': 1 }
       *
       * // The `_.property` iteratee shorthand.
       * _.minBy(objects, 'n');
       * // => { 'n': 1 }
       */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined$1;}/**
       * Multiply two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} multiplier The first number in a multiplication.
       * @param {number} multiplicand The second number in a multiplication.
       * @returns {number} Returns the product.
       * @example
       *
       * _.multiply(6, 4);
       * // => 24
       */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
       * Computes `number` rounded to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round.
       * @param {number} [precision=0] The precision to round to.
       * @returns {number} Returns the rounded number.
       * @example
       *
       * _.round(4.006);
       * // => 4
       *
       * _.round(4.006, 2);
       * // => 4.01
       *
       * _.round(4060, -2);
       * // => 4100
       */var round=createRound('round');/**
       * Subtract two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {number} minuend The first number in a subtraction.
       * @param {number} subtrahend The second number in a subtraction.
       * @returns {number} Returns the difference.
       * @example
       *
       * _.subtract(6, 4);
       * // => 2
       */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
       * Computes the sum of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the sum.
       * @example
       *
       * _.sum([4, 2, 8, 6]);
       * // => 20
       */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
       * This method is like `_.sum` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be summed.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the sum.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.sumBy(objects, function(o) { return o.n; });
       * // => 20
       *
       * // The `_.property` iteratee shorthand.
       * _.sumBy(objects, 'n');
       * // => 20
       */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
  lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
  lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
  mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
  lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
  lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
       * The semantic version number.
       *
       * @static
       * @memberOf _
       * @type {string}
       */lodash.VERSION=VERSION;// Assign default placeholders.
  arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
  arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined$1?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else {result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
  arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
  arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
  arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined$1){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
  baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
  isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
  arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
  baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined$1,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined$1}];// Add methods to `LazyWrapper`.
  LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
  lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
  lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
  var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
  if(freeModule){// Export for Node.js.
  (freeModule.exports=_)._=_;// Export for CommonJS support.
  freeExports._=_;}else {// Export to the global object.
  root._=_;}}).call(commonjsGlobal);});

  /* eslint-disable no-template-curly-in-string */

  /* eslint-disable no-param-reassign */
  function attributeToString(attribute) {
    if (typeof attribute !== 'string') {
      attribute += '';

      if (attribute === 'undefined') {
        attribute = '';
      }
    }

    return attribute.trim();
  }
  function toggleClass(elem, className) {
    elem.classList.toggle(className);
  }
  function removeClass(elem) {
    var _elem$classList;

    for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      classNames[_key - 1] = arguments[_key];
    }

    (_elem$classList = elem.classList).remove.apply(_elem$classList, classNames);

    return elem;
  }
  function dispatchCustomEvent$1(elem, eventName, properties) {
    elem.dispatchEvent(new CustomEvent(eventName, properties));
  }
  function formatMoney(cents, format) {
    if (typeof cents === 'string') {
      cents = cents.replace('.', '');
    }

    var value = '';
    var placeholderRegex = /\{\{\s*(\w+)\s*\}\}/;
    var formatString = format || '${{amount}}';

    function formatWithDelimiters(number) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      var thousands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';
      var decimal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';

      if (Number.isNaN(number) || number == null) {
        return 0;
      }

      number = (number / 100.0).toFixed(precision);
      var parts = number.split('.');
      var dollarsAmount = parts[0].replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1".concat(thousands));
      var centsAmount = parts[1] ? decimal + parts[1] : '';
      return dollarsAmount + centsAmount;
    }

    switch (formatString.match(placeholderRegex)[1]) {
      case 'amount':
        value = formatWithDelimiters(cents, 2);
        break;

      case 'amount_no_decimals':
        value = formatWithDelimiters(cents, 0);
        break;

      case 'amount_with_comma_separator':
        value = formatWithDelimiters(cents, 2, '.', ',');
        break;

      case 'amount_no_decimals_with_comma_separator':
        value = formatWithDelimiters(cents, 0, '.', ',');
        break;

      default:
        value = formatWithDelimiters(cents, 2);
    }

    return formatString.replace(placeholderRegex, value);
  }

  var instance = axios$1.create({
    headers: {
      'X-Requested-With': 'XMLHttpRequest'
    }
  });

  var ajaxTemplateFunc = function ajaxTemplateFunc(url) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'get';
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var encoded = encodeURI(url);
    var request;

    if (method === 'get') {
      if (lodash.isEmpty(data)) {
        request = instance.get(encoded);
      } else {
        request = instance.get(encoded, data);
      }
    } else if (lodash.isEmpty(data) && !(data instanceof FormData)) {
      request = instance.post(encoded);
    } else {
      request = instance.post(encoded, data);
    }

    return request.then(function (response) {
      return response.data;
    })["catch"](function (error) {
      return error.response.data;
    });
  }; // todo: urlencode


  var getCart = function getCart() {
    return ajaxTemplateFunc('/cart.js');
  };
  var getProduct = function getProduct(handle) {
    return ajaxTemplateFunc("/products/".concat(handle, ".js"));
  };
  var clearCart = function clearCart() {
    return ajaxTemplateFunc('/cart/clear.js', 'post');
  };
  var updateCartFromForm = function updateCartFromForm(form) {
    return ajaxTemplateFunc('/cart/update.js', 'post', new FormData(form));
  };
  var changeItemByKeyOrId = function changeItemByKeyOrId(id, quantity) {
    return ajaxTemplateFunc('/cart/change.js', 'post', {
      quantity: quantity,
      id: id
    });
  };
  var removeItemByKeyOrId = function removeItemByKeyOrId(id) {
    return ajaxTemplateFunc('/cart/change.js', 'post', {
      quantity: 0,
      id: id
    });
  };
  var changeItemByLine = function changeItemByLine(line, quantity, properties) {
    return ajaxTemplateFunc('/cart/change.js', 'post', {
      quantity: quantity,
      line: line,
      properties: properties
    });
  };
  var removeItemByLine = function removeItemByLine(line) {
    return ajaxTemplateFunc('/cart/change.js', 'post', {
      quantity: 0,
      line: line
    });
  };
  var addItem = function addItem(id, quantity) {
    var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return ajaxTemplateFunc('/cart/add.js', 'post', {
      id: id,
      quantity: quantity,
      properties: properties
    });
  };
  var addItemFromForm = function addItemFromForm(form) {
    return ajaxTemplateFunc('/cart/add.js', 'post', new FormData(form));
  };
  var updateCartAttributes = function updateCartAttributes(attributes) {
    var data = '';

    if (Array.isArray(attributes)) {
      attributes.forEach(function (attribute) {
        var key = attributeToString(attribute.key);

        if (key !== '') {
          data += "attributes[".concat(key, "]=").concat(attributeToString(attribute.value), "&");
        }
      });
    } else if (_typeof(attributes) === 'object' && attributes !== null) {
      Object.keys(attributes).forEach(function (key) {
        var value = attributes[key];
        data += "attributes[".concat(attributeToString(key), "]=").concat(attributeToString(value), "&");
      });
    }

    return ajaxTemplateFunc('/cart/update.js', 'post', data);
  };
  var updateCartNote = function updateCartNote(note) {
    return ajaxTemplateFunc('/cart/update.js', 'post', "note=".concat(attributeToString(note)));
  };
  var getRecommendedProducts = function getRecommendedProducts(productId) {
    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    return ajaxTemplateFunc("/recommendations/products.json?product_id=".concat(productId, "&limit=").concat(limit && parseInt(limit, 10) > 0 && parseInt(limit, 10) <= 10 ? parseInt(limit, 10) : 10));
  };
  var getPredictiveSearchResults = function getPredictiveSearchResults(q) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['product', 'page', 'article', 'collection'];
    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    var unavailableProducts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'last';
    var fields = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['title', 'product_type', 'variants.title', 'vendor'];
    var paramsString = '';
    paramsString += "q=".concat(q);
    paramsString += "&resources[type]=".concat(type.join(','));
    paramsString += "&resources[limit]=".concat(limit);
    paramsString += "&resources[options][unavailable_products]=".concat(unavailableProducts);
    paramsString += "&resources[options][fields]=".concat(fields.join(','));
    return ajaxTemplateFunc("/search/suggest.json?".concat(paramsString));
  };
  var apis = {
    getCart: getCart,
    getProduct: getProduct,
    clearCart: clearCart,
    updateCartFromForm: updateCartFromForm,
    changeItemByKeyOrId: changeItemByKeyOrId,
    removeItemByKeyOrId: removeItemByKeyOrId,
    changeItemByLine: changeItemByLine,
    removeItemByLine: removeItemByLine,
    addItem: addItem,
    addItemFromForm: addItemFromForm,
    updateCartAttributes: updateCartAttributes,
    updateCartNote: updateCartNote,
    getRecommendedProducts: getRecommendedProducts,
    getPredictiveSearchResults: getPredictiveSearchResults
  };

  var glider = createCommonjsModule(function (module, exports) {
    /* @preserve
        _____ __ _     __                _
       / ___// /(_)___/ /___  ____      (_)___
      / (_ // // // _  // -_)/ __/_    / /(_-<
      \___//_//_/ \_,_/ \__//_/  (_)__/ //___/
                                  |___/
    
      Version: 1.7.3
      Author: Nick Piscitelli (pickykneee)
      Website: https://nickpiscitelli.com
      Documentation: http://nickpiscitelli.github.io/Glider.js
      License: MIT License
      Release Date: October 25th, 2018
    
    */

    /* global define */
    (function (factory) {
        module.exports = factory() ;
    })(function () {

      /* globals window:true */


      var _window = typeof window !== 'undefined' ? window : this;

      var Glider = _window.Glider = function (element, settings) {
        var _ = this;

        if (element._glider) return element._glider;
        _.ele = element;

        _.ele.classList.add('glider'); // expose glider object to its DOM element


        _.ele._glider = _; // merge user setting with defaults

        _.opt = Object.assign({}, {
          slidesToScroll: 1,
          slidesToShow: 1,
          resizeLock: true,
          duration: 0.5,
          // easeInQuad
          easing: function easing(x, t, b, c, d) {
            return c * (t /= d) * t + b;
          }
        }, settings); // set defaults

        _.animate_id = _.page = _.slide = 0;
        _.arrows = {}; // preserve original options to
        // extend breakpoint settings

        _._opt = _.opt;

        if (_.opt.skipTrack) {
          // first and only child is the track
          _.track = _.ele.children[0];
        } else {
          // create track and wrap slides
          _.track = document.createElement('div');

          _.ele.appendChild(_.track);

          while (_.ele.children.length !== 1) {
            _.track.appendChild(_.ele.children[0]);
          }
        }

        _.track.classList.add('glider-track'); // start glider


        _.init(); // set events


        _.resize = _.init.bind(_, true);

        _.event(_.ele, 'add', {
          scroll: _.updateControls.bind(_)
        });

        _.event(_window, 'add', {
          resize: _.resize
        });
      };

      var gliderPrototype = Glider.prototype;

      gliderPrototype.init = function (refresh, paging) {
        var _ = this;

        var width = 0;
        var height = 0;
        _.slides = _.track.children;
        [].forEach.call(_.slides, function (_) {
          _.classList.add('glider-slide');
        });
        _.containerWidth = _.ele.clientWidth;

        var breakpointChanged = _.settingsBreakpoint();

        if (!paging) paging = breakpointChanged;

        if (_.opt.slidesToShow === 'auto' || typeof _.opt._autoSlide !== 'undefined') {
          var slideCount = _.containerWidth / _.opt.itemWidth;
          _.opt._autoSlide = _.opt.slidesToShow = _.opt.exactWidth ? slideCount : Math.floor(slideCount);
        }

        if (_.opt.slidesToScroll === 'auto') {
          _.opt.slidesToScroll = Math.floor(_.opt.slidesToShow);
        }

        _.itemWidth = _.opt.exactWidth ? _.opt.itemWidth : _.containerWidth / _.opt.slidesToShow; // set slide dimensions

        [].forEach.call(_.slides, function (__) {
          __.style.height = 'auto';
          __.style.width = _.itemWidth + 'px';
          width += _.itemWidth;
          height = Math.max(__.offsetHeight, height);
        });
        _.track.style.width = width + 'px';
        _.trackWidth = width;
        _.isDrag = false;
        _.preventClick = false;
        _.opt.resizeLock && _.scrollTo(_.slide * _.itemWidth, 0);

        if (breakpointChanged || paging) {
          _.bindArrows();

          _.buildDots();

          _.bindDrag();
        }

        _.updateControls();

        _.emit(refresh ? 'refresh' : 'loaded');
      };

      gliderPrototype.bindDrag = function () {
        var _ = this;

        _.mouse = _.mouse || _.handleMouse.bind(_);

        var mouseup = function mouseup() {
          _.mouseDown = undefined;

          _.ele.classList.remove('drag');

          if (_.isDrag) {
            _.preventClick = true;
          }

          _.isDrag = false;
        };

        var events = {
          mouseup: mouseup,
          mouseleave: mouseup,
          mousedown: function mousedown(e) {
            e.preventDefault();
            e.stopPropagation();
            _.mouseDown = e.clientX;

            _.ele.classList.add('drag');
          },
          mousemove: _.mouse,
          click: function click(e) {
            if (_.preventClick) {
              e.preventDefault();
              e.stopPropagation();
            }

            _.preventClick = false;
          }
        };

        _.ele.classList.toggle('draggable', _.opt.draggable === true);

        _.event(_.ele, 'remove', events);

        if (_.opt.draggable) _.event(_.ele, 'add', events);
      };

      gliderPrototype.buildDots = function () {
        var _ = this;

        if (!_.opt.dots) {
          if (_.dots) _.dots.innerHTML = '';
          return;
        }

        if (typeof _.opt.dots === 'string') {
          _.dots = document.querySelector(_.opt.dots);
        } else _.dots = _.opt.dots;

        if (!_.dots) return;
        _.dots.innerHTML = '';

        _.dots.classList.add('glider-dots');

        for (var i = 0; i < Math.ceil(_.slides.length / _.opt.slidesToShow); ++i) {
          var dot = document.createElement('button');
          dot.dataset.index = i;
          dot.setAttribute('aria-label', 'Page ' + (i + 1));
          dot.className = 'glider-dot ' + (i ? '' : 'active');

          _.event(dot, 'add', {
            click: _.scrollItem.bind(_, i, true)
          });

          _.dots.appendChild(dot);
        }
      };

      gliderPrototype.bindArrows = function () {
        var _ = this;

        if (!_.opt.arrows) {
          Object.keys(_.arrows).forEach(function (direction) {
            var element = _.arrows[direction];

            _.event(element, 'remove', {
              click: element._func
            });
          });
          return;
        }

        ['prev', 'next'].forEach(function (direction) {
          var arrow = _.opt.arrows[direction];

          if (arrow) {
            if (typeof arrow === 'string') arrow = document.querySelector(arrow);
            arrow._func = arrow._func || _.scrollItem.bind(_, direction);

            _.event(arrow, 'remove', {
              click: arrow._func
            });

            _.event(arrow, 'add', {
              click: arrow._func
            });

            _.arrows[direction] = arrow;
          }
        });
      };

      gliderPrototype.updateControls = function (event) {
        var _ = this;

        if (event && !_.opt.scrollPropagate) {
          event.stopPropagation();
        }

        var disableArrows = _.containerWidth >= _.trackWidth;

        if (!_.opt.rewind) {
          if (_.arrows.prev) {
            _.arrows.prev.classList.toggle('disabled', _.ele.scrollLeft <= 0 || disableArrows);
          }

          if (_.arrows.next) {
            _.arrows.next.classList.toggle('disabled', Math.ceil(_.ele.scrollLeft + _.containerWidth) >= Math.floor(_.trackWidth) || disableArrows);
          }
        }

        _.slide = Math.round(_.ele.scrollLeft / _.itemWidth);
        _.page = Math.round(_.ele.scrollLeft / _.containerWidth);
        var middle = _.slide + Math.floor(Math.floor(_.opt.slidesToShow) / 2);
        var extraMiddle = Math.floor(_.opt.slidesToShow) % 2 ? 0 : middle + 1;

        if (Math.floor(_.opt.slidesToShow) === 1) {
          extraMiddle = 0;
        } // the last page may be less than one half of a normal page width so
        // the page is rounded down. when at the end, force the page to turn


        if (_.ele.scrollLeft + _.containerWidth >= Math.floor(_.trackWidth)) {
          _.page = _.dots ? _.dots.children.length - 1 : 0;
        }

        [].forEach.call(_.slides, function (slide, index) {
          var slideClasses = slide.classList;
          var wasVisible = slideClasses.contains('visible');
          var start = _.ele.scrollLeft;
          var end = _.ele.scrollLeft + _.containerWidth;
          var itemStart = _.itemWidth * index;
          var itemEnd = itemStart + _.itemWidth;
          [].forEach.call(slideClasses, function (className) {
            /^left|right/.test(className) && slideClasses.remove(className);
          });
          slideClasses.toggle('active', _.slide === index);

          if (middle === index || extraMiddle && extraMiddle === index) {
            slideClasses.add('center');
          } else {
            slideClasses.remove('center');
            slideClasses.add([index < middle ? 'left' : 'right', Math.abs(index - (index < middle ? middle : extraMiddle || middle))].join('-'));
          }

          var isVisible = Math.ceil(itemStart) >= start && Math.floor(itemEnd) <= end;
          slideClasses.toggle('visible', isVisible);

          if (isVisible !== wasVisible) {
            _.emit('slide-' + (isVisible ? 'visible' : 'hidden'), {
              slide: index
            });
          }
        });

        if (_.dots) {
          [].forEach.call(_.dots.children, function (dot, index) {
            dot.classList.toggle('active', _.page === index);
          });
        }

        if (event && _.opt.scrollLock) {
          clearTimeout(_.scrollLock);
          _.scrollLock = setTimeout(function () {
            clearTimeout(_.scrollLock); // dont attempt to scroll less than a pixel fraction - causes looping

            if (Math.abs(_.ele.scrollLeft / _.itemWidth - _.slide) > 0.02) {
              if (!_.mouseDown) {
                _.scrollItem(_.round(_.ele.scrollLeft / _.itemWidth));
              }
            }
          }, _.opt.scrollLockDelay || 250);
        }
      };

      gliderPrototype.scrollItem = function (slide, dot, e) {
        if (e) e.preventDefault();

        var _ = this;

        var originalSlide = slide;
        ++_.animate_id;

        if (dot === true) {
          slide = slide * _.containerWidth;
          slide = Math.round(slide / _.itemWidth) * _.itemWidth;
        } else {
          if (typeof slide === 'string') {
            var backwards = slide === 'prev'; // use precise location if fractional slides are on

            if (_.opt.slidesToScroll % 1 || _.opt.slidesToShow % 1) {
              slide = _.round(_.ele.scrollLeft / _.itemWidth);
            } else {
              slide = _.slide;
            }

            if (backwards) slide -= _.opt.slidesToScroll;else slide += _.opt.slidesToScroll;

            if (_.opt.rewind) {
              var scrollLeft = _.ele.scrollLeft;
              slide = backwards && !scrollLeft ? _.slides.length : !backwards && scrollLeft + _.containerWidth >= Math.floor(_.trackWidth) ? 0 : slide;
            }
          }

          slide = Math.max(Math.min(slide, _.slides.length), 0);
          _.slide = slide;
          slide = _.itemWidth * slide;
        }

        _.scrollTo(slide, _.opt.duration * Math.abs(_.ele.scrollLeft - slide), function () {
          _.updateControls();

          _.emit('animated', {
            value: originalSlide,
            type: typeof originalSlide === 'string' ? 'arrow' : dot ? 'dot' : 'slide'
          });
        });

        return false;
      };

      gliderPrototype.settingsBreakpoint = function () {
        var _ = this;

        var resp = _._opt.responsive;

        if (resp) {
          // Sort the breakpoints in mobile first order
          resp.sort(function (a, b) {
            return b.breakpoint - a.breakpoint;
          });

          for (var i = 0; i < resp.length; ++i) {
            var size = resp[i];

            if (_window.innerWidth >= size.breakpoint) {
              if (_.breakpoint !== size.breakpoint) {
                _.opt = Object.assign({}, _._opt, size.settings);
                _.breakpoint = size.breakpoint;
                return true;
              }

              return false;
            }
          }
        } // set back to defaults in case they were overriden


        var breakpointChanged = _.breakpoint !== 0;
        _.opt = Object.assign({}, _._opt);
        _.breakpoint = 0;
        return breakpointChanged;
      };

      gliderPrototype.scrollTo = function (scrollTarget, scrollDuration, callback) {
        var _ = this;

        var start = new Date().getTime();
        var animateIndex = _.animate_id;

        var animate = function animate() {
          var now = new Date().getTime() - start;
          _.ele.scrollLeft = _.ele.scrollLeft + (scrollTarget - _.ele.scrollLeft) * _.opt.easing(0, now, 0, 1, scrollDuration);

          if (now < scrollDuration && animateIndex === _.animate_id) {
            _window.requestAnimationFrame(animate);
          } else {
            _.ele.scrollLeft = scrollTarget;
            callback && callback.call(_);
          }
        };

        _window.requestAnimationFrame(animate);
      };

      gliderPrototype.removeItem = function (index) {
        var _ = this;

        if (_.slides.length) {
          _.track.removeChild(_.slides[index]);

          _.refresh(true);

          _.emit('remove');
        }
      };

      gliderPrototype.addItem = function (ele) {
        var _ = this;

        _.track.appendChild(ele);

        _.refresh(true);

        _.emit('add');
      };

      gliderPrototype.handleMouse = function (e) {
        var _ = this;

        if (_.mouseDown) {
          _.isDrag = true;
          _.ele.scrollLeft += (_.mouseDown - e.clientX) * (_.opt.dragVelocity || 3.3);
          _.mouseDown = e.clientX;
        }
      }; // used to round to the nearest 0.XX fraction


      gliderPrototype.round = function (_double) {
        var _ = this;

        var step = _.opt.slidesToScroll % 1 || 1;
        var inv = 1.0 / step;
        return Math.round(_double * inv) / inv;
      };

      gliderPrototype.refresh = function (paging) {
        var _ = this;

        _.init(true, paging);
      };

      gliderPrototype.setOption = function (opt, global) {
        var _ = this;

        if (_.breakpoint && !global) {
          _._opt.responsive.forEach(function (v) {
            if (v.breakpoint === _.breakpoint) {
              v.settings = Object.assign({}, v.settings, opt);
            }
          });
        } else {
          _._opt = Object.assign({}, _._opt, opt);
        }

        _.breakpoint = 0;

        _.settingsBreakpoint();
      };

      gliderPrototype.destroy = function () {
        var _ = this;

        var replace = _.ele.cloneNode(true);

        var clear = function clear(ele) {
          ele.removeAttribute('style');
          [].forEach.call(ele.classList, function (className) {
            /^glider/.test(className) && ele.classList.remove(className);
          });
        }; // remove track


        replace.children[0].outerHTML = replace.children[0].innerHTML;
        clear(replace);
        [].forEach.call(replace.getElementsByTagName('*'), clear);

        _.ele.parentNode.replaceChild(replace, _.ele);

        _.event(_window, 'remove', {
          resize: _.resize
        });

        _.emit('destroy');
      };

      gliderPrototype.emit = function (name, arg) {
        var _ = this;

        var e = new _window.CustomEvent('glider-' + name, {
          bubbles: !_.opt.eventPropagate,
          detail: arg
        });

        _.ele.dispatchEvent(e);
      };

      gliderPrototype.event = function (ele, type, args) {
        var eventHandler = ele[type + 'EventListener'].bind(ele);
        Object.keys(args).forEach(function (k) {
          eventHandler(k, args[k]);
        });
      };

      return Glider;
    });
  });

  window.addEventListener('load', function setupTestimonialSlider() {
    if (document.querySelector('.glider')) {
      // eslint-disable-next-line no-new
      new glider(document.querySelector('.glider'), {
        // Mobile-first defaults
        slidesToShow: 1,
        slidesToScroll: 1,
        scrollLock: true,
        dots: '#resp-dots',
        draggable: true,
        arrows: {
          prev: '.glider-prev',
          next: '.glider-next'
        },
        responsive: [{
          // screens greater than >= 775px
          breakpoint: 0,
          settings: {
            // Set to `auto` and provide item width to adjust to viewport
            slidesToShow: 1,
            slidesToScroll: 1,
            itemWidth: 300,
            duration: 1
          }
        }, {
          // screens greater than >= 1024px
          breakpoint: 540,
          settings: {
            slidesToShow: 'auto',
            slidesToScroll: 'auto',
            itemWidth: 300,
            duration: 1
          }
        }]
      });
    }
  });

  document.addEventListener('click', function (event) {
    var target = event.target;

    if (target.closest('.dropdown-menu')) {
      event.stopPropagation();
    } // class="navbar-toggler" data-trigger="#navbar_main"


    if (target.closest('.navbar-toggler[data-trigger]')) {
      event.preventDefault();
      event.stopPropagation();
      var offcanvasId = target.closest('.navbar-toggler[data-trigger]').getAttribute('data-trigger');
      var offcanvas = document.querySelector(offcanvasId);

      if (offcanvas) {
        toggleClass(offcanvas, 'show');
      }

      toggleClass(document.body, 'offcanvas-active');
      var screenOverlay = document.querySelector('.screen-overlay');

      if (screenOverlay) {
        toggleClass(screenOverlay, 'show');
      }
    }

    if (target.closest('.btn-close, .screen-overlay')) {
      var _screenOverlay = document.querySelector('.screen-overlay');

      if (_screenOverlay) {
        removeClass(_screenOverlay, 'show');
      }

      var mobileOffcanvas = document.querySelector('.mobile-offcanvas');

      if (mobileOffcanvas) {
        removeClass(mobileOffcanvas, 'show');
      }

      removeClass(document.body, 'offcanvas-active');
    }
  });

  var macy = createCommonjsModule(function (module, exports) {
    !function (t, n) {
       module.exports = n() ;
    }(commonjsGlobal, function () {

      function t(t, n) {
        var e = void 0;
        return function () {
          e && clearTimeout(e), e = setTimeout(t, n);
        };
      }

      function n(t, n) {
        for (var e = t.length, r = e, o = []; e--;) {
          o.push(n(t[r - e - 1]));
        }

        return o;
      }

      function e(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (window.Promise) return A(t, n, e);
        t.recalculate(!0, !0);
      }

      function r(t) {
        for (var n = t.options, e = t.responsiveOptions, r = t.keys, o = t.docWidth, i = void 0, s = 0; s < r.length; s++) {
          var a = parseInt(r[s], 10);
          o >= a && (i = n.breakAt[a], O(i, e));
        }

        return e;
      }

      function o(t) {
        for (var n = t.options, e = t.responsiveOptions, r = t.keys, o = t.docWidth, i = void 0, s = r.length - 1; s >= 0; s--) {
          var a = parseInt(r[s], 10);
          o <= a && (i = n.breakAt[a], O(i, e));
        }

        return e;
      }

      function i(t) {
        var n = t.useContainerForBreakpoints ? t.container.clientWidth : window.innerWidth,
            e = {
          columns: t.columns
        };
        b(t.margin) ? e.margin = {
          x: t.margin.x,
          y: t.margin.y
        } : e.margin = {
          x: t.margin,
          y: t.margin
        };
        var i = Object.keys(t.breakAt);
        return t.mobileFirst ? r({
          options: t,
          responsiveOptions: e,
          keys: i,
          docWidth: n
        }) : o({
          options: t,
          responsiveOptions: e,
          keys: i,
          docWidth: n
        });
      }

      function s(t) {
        return i(t).columns;
      }

      function a(t) {
        return i(t).margin;
      }

      function c(t) {
        var n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            e = s(t),
            r = a(t).x,
            o = 100 / e;
        if (!n) return o;
        if (1 === e) return "100%";
        var i = "px";

        if ("string" == typeof r) {
          var c = parseFloat(r);
          i = r.replace(c, ""), r = c;
        }

        return r = (e - 1) * r / e, "%" === i ? o - r + "%" : "calc(" + o + "% - " + r + i + ")";
      }

      function u(t, n) {
        var e = s(t.options),
            r = 0,
            o = void 0,
            i = void 0;
        if (1 === ++n) return 0;
        i = a(t.options).x;
        var u = "px";

        if ("string" == typeof i) {
          var l = parseFloat(i, 10);
          u = i.replace(l, ""), i = l;
        }

        return o = (i - (e - 1) * i / e) * (n - 1), r += c(t.options, !1) * (n - 1), "%" === u ? r + o + "%" : "calc(" + r + "% + " + o + u + ")";
      }

      function l(t) {
        var n = 0,
            e = t.container,
            r = t.rows;
        v(r, function (t) {
          n = t > n ? t : n;
        }), e.style.height = n + "px";
      }

      function p(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
            r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            o = s(t.options),
            i = a(t.options).y;
        M(t, o, e), v(n, function (n) {
          var e = 0,
              o = parseInt(n.offsetHeight, 10);
          isNaN(o) || (t.rows.forEach(function (n, r) {
            n < t.rows[e] && (e = r);
          }), n.style.position = "absolute", n.style.top = t.rows[e] + "px", n.style.left = "" + t.cols[e], t.rows[e] += isNaN(o) ? 0 : o + i, r && (n.dataset.macyComplete = 1));
        }), r && (t.tmpRows = null), l(t);
      }

      function f(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
            r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            o = s(t.options),
            i = a(t.options).y;
        M(t, o, e), v(n, function (n) {
          t.lastcol === o && (t.lastcol = 0);
          var e = C(n, "height");
          e = parseInt(n.offsetHeight, 10), isNaN(e) || (n.style.position = "absolute", n.style.top = t.rows[t.lastcol] + "px", n.style.left = "" + t.cols[t.lastcol], t.rows[t.lastcol] += isNaN(e) ? 0 : e + i, t.lastcol += 1, r && (n.dataset.macyComplete = 1));
        }), r && (t.tmpRows = null), l(t);
      }

      var h = function t(n, e) {
        if (!(this instanceof t)) return new t(n, e);
        if (n && n.nodeName) return n;
        if (n = n.replace(/^\s*/, "").replace(/\s*$/, ""), e) return this.byCss(n, e);

        for (var r in this.selectors) {
          if (e = r.split("/"), new RegExp(e[1], e[2]).test(n)) return this.selectors[r](n);
        }

        return this.byCss(n);
      };

      h.prototype.byCss = function (t, n) {
        return (n || document).querySelectorAll(t);
      }, h.prototype.selectors = {}, h.prototype.selectors[/^\.[\w\-]+$/] = function (t) {
        return document.getElementsByClassName(t.substring(1));
      }, h.prototype.selectors[/^\w+$/] = function (t) {
        return document.getElementsByTagName(t);
      }, h.prototype.selectors[/^\#[\w\-]+$/] = function (t) {
        return document.getElementById(t.substring(1));
      };

      var v = function v(t, n) {
        for (var e = t.length, r = e; e--;) {
          n(t[r - e - 1]);
        }
      },
          m = function m() {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        this.running = !1, this.events = [], this.add(t);
      };

      m.prototype.run = function () {
        if (!this.running && this.events.length > 0) {
          var t = this.events.shift();
          this.running = !0, t(), this.running = !1, this.run();
        }
      }, m.prototype.add = function () {
        var t = this,
            n = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return !!n && (Array.isArray(n) ? v(n, function (n) {
          return t.add(n);
        }) : (this.events.push(n), void this.run()));
      }, m.prototype.clear = function () {
        this.events = [];
      };

      var d = function d(t) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return this.instance = t, this.data = n, this;
      },
          y = function y() {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        this.events = {}, this.instance = t;
      };

      y.prototype.on = function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
            n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return !(!t || !n) && (Array.isArray(this.events[t]) || (this.events[t] = []), this.events[t].push(n));
      }, y.prototype.emit = function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!t || !Array.isArray(this.events[t])) return !1;
        var e = new d(this.instance, n);
        v(this.events[t], function (t) {
          return t(e);
        });
      };

      var g = function g(t) {
        return !("naturalHeight" in t && t.naturalHeight + t.naturalWidth === 0) || t.width + t.height !== 0;
      },
          E = function E(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return new Promise(function (t, e) {
          if (n.complete) return g(n) ? t(n) : e(n);
          n.addEventListener("load", function () {
            return g(n) ? t(n) : e(n);
          }), n.addEventListener("error", function () {
            return e(n);
          });
        }).then(function (n) {
          e && t.emit(t.constants.EVENT_IMAGE_LOAD, {
            img: n
          });
        })["catch"](function (n) {
          return t.emit(t.constants.EVENT_IMAGE_ERROR, {
            img: n
          });
        });
      },
          w = function w(t, e) {
        var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return n(e, function (n) {
          return E(t, n, r);
        });
      },
          A = function A(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return Promise.all(w(t, n, e)).then(function () {
          t.emit(t.constants.EVENT_IMAGE_COMPLETE);
        });
      },
          I = function I(n) {
        return t(function () {
          n.emit(n.constants.EVENT_RESIZE), n.queue.add(function () {
            return n.recalculate(!0, !0);
          });
        }, 100);
      },
          N = function N(t) {
        if (t.container = h(t.options.container), t.container instanceof h || !t.container) return !!t.options.debug && console.error("Error: Container not found");
        t.container.length && (t.container = t.container[0]), t.options.container = t.container, t.container.style.position = "relative";
      },
          T = function T(t) {
        t.queue = new m(), t.events = new y(t), t.rows = [], t.resizer = I(t);
      },
          L = function L(t) {
        var n = h("img", t.container);
        window.addEventListener("resize", t.resizer), t.on(t.constants.EVENT_IMAGE_LOAD, function () {
          return t.recalculate(!1, !1);
        }), t.on(t.constants.EVENT_IMAGE_COMPLETE, function () {
          return t.recalculate(!0, !0);
        }), t.options.useOwnImageLoader || e(t, n, !t.options.waitForImages), t.emit(t.constants.EVENT_INITIALIZED);
      },
          _ = function _(t) {
        N(t), T(t), L(t);
      },
          b = function b(t) {
        return t === Object(t) && "[object Array]" !== Object.prototype.toString.call(t);
      },
          O = function O(t, n) {
        b(t) || (n.columns = t), b(t) && t.columns && (n.columns = t.columns), b(t) && t.margin && !b(t.margin) && (n.margin = {
          x: t.margin,
          y: t.margin
        }), b(t) && t.margin && b(t.margin) && t.margin.x && (n.margin.x = t.margin.x), b(t) && t.margin && b(t.margin) && t.margin.y && (n.margin.y = t.margin.y);
      },
          C = function C(t, n) {
        return window.getComputedStyle(t, null).getPropertyValue(n);
      },
          M = function M(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];

        if (t.lastcol || (t.lastcol = 0), t.rows.length < 1 && (e = !0), e) {
          t.rows = [], t.cols = [], t.lastcol = 0;

          for (var r = n - 1; r >= 0; r--) {
            t.rows[r] = 0, t.cols[r] = u(t, r);
          }
        } else if (t.tmpRows) {
          t.rows = [];

          for (var r = n - 1; r >= 0; r--) {
            t.rows[r] = t.tmpRows[r];
          }
        } else {
          t.tmpRows = [];

          for (var r = n - 1; r >= 0; r--) {
            t.tmpRows[r] = t.rows[r];
          }
        }
      },
          V = function V(t) {
        var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            e = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            r = n ? t.container.children : h(':scope > *:not([data-macy-complete="1"])', t.container);
        r = Array.from(r).filter(function (t) {
          return null !== t.offsetParent;
        });
        var o = c(t.options);
        return v(r, function (t) {
          n && (t.dataset.macyComplete = 0), t.style.width = o;
        }), t.options.trueOrder ? (f(t, r, n, e), t.emit(t.constants.EVENT_RECALCULATED)) : (p(t, r, n, e), t.emit(t.constants.EVENT_RECALCULATED));
      },
          R = function R() {
        return !!window.Promise;
      },
          x = Object.assign || function (t) {
        for (var n = 1; n < arguments.length; n++) {
          var e = arguments[n];

          for (var r in e) {
            Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
          }
        }

        return t;
      };

      Array.from || (Array.from = function (t) {
        for (var n = 0, e = []; n < t.length;) {
          e.push(t[n++]);
        }

        return e;
      });
      var k = {
        columns: 4,
        margin: 2,
        trueOrder: !1,
        waitForImages: !1,
        useImageLoader: !0,
        breakAt: {},
        useOwnImageLoader: !1,
        onInit: !1,
        cancelLegacy: !1,
        useContainerForBreakpoints: !1
      };
      !function () {
        try {
          document.createElement("a").querySelector(":scope *");
        } catch (t) {
          !function () {
            function t(t) {
              return function (e) {
                if (e && n.test(e)) {
                  var r = this.getAttribute("id");
                  r || (this.id = "q" + Math.floor(9e6 * Math.random()) + 1e6), arguments[0] = e.replace(n, "#" + this.id);
                  var o = t.apply(this, arguments);
                  return null === r ? this.removeAttribute("id") : r || (this.id = r), o;
                }

                return t.apply(this, arguments);
              };
            }

            var n = /:scope\b/gi,
                e = t(Element.prototype.querySelector);

            Element.prototype.querySelector = function (t) {
              return e.apply(this, arguments);
            };

            var r = t(Element.prototype.querySelectorAll);

            Element.prototype.querySelectorAll = function (t) {
              return r.apply(this, arguments);
            };
          }();
        }
      }();

      var q = function t() {
        var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k;
        if (!(this instanceof t)) return new t(n);
        this.options = {}, x(this.options, k, n), this.options.cancelLegacy && !R() || _(this);
      };

      return q.init = function (t) {
        return console.warn("Depreciated: Macy.init will be removed in v3.0.0 opt to use Macy directly like so Macy({ /*options here*/ }) "), new q(t);
      }, q.prototype.recalculateOnImageLoad = function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return e(this, h("img", this.container), !t);
      }, q.prototype.runOnImageLoad = function (t) {
        var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            r = h("img", this.container);
        return this.on(this.constants.EVENT_IMAGE_COMPLETE, t), n && this.on(this.constants.EVENT_IMAGE_LOAD, t), e(this, r, n);
      }, q.prototype.recalculate = function () {
        var t = this,
            n = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
            e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        return e && this.queue.clear(), this.queue.add(function () {
          return V(t, n, e);
        });
      }, q.prototype.remove = function () {
        window.removeEventListener("resize", this.resizer), v(this.container.children, function (t) {
          t.removeAttribute("data-macy-complete"), t.removeAttribute("style");
        }), this.container.removeAttribute("style");
      }, q.prototype.reInit = function () {
        this.recalculate(!0, !0), this.emit(this.constants.EVENT_INITIALIZED), window.addEventListener("resize", this.resizer), this.container.style.position = "relative";
      }, q.prototype.on = function (t, n) {
        this.events.on(t, n);
      }, q.prototype.emit = function (t, n) {
        this.events.emit(t, n);
      }, q.constants = {
        EVENT_INITIALIZED: "macy.initialized",
        EVENT_RECALCULATED: "macy.recalculated",
        EVENT_IMAGE_LOAD: "macy.image.load",
        EVENT_IMAGE_ERROR: "macy.image.error",
        EVENT_IMAGE_COMPLETE: "macy.images.complete",
        EVENT_RESIZE: "macy.resize"
      }, q.prototype.constants = q.constants, q;
    });
  });

  if (document.querySelector('.index-section--masonry .images-wrapper')) {
    macy({
      container: '.index-section--masonry .images-wrapper',
      columns: 3,
      breakAt: {
        520: 2,
        400: 1
      }
    });
  }

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var directives = new WeakMap();
  var isDirective = function isDirective(o) {
    return typeof o === 'function' && directives.has(o);
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * True if the custom elements polyfill is in use.
   */
  var isCEPolyfill = typeof window !== 'undefined' && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== undefined;
  /**
   * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
   * `container`.
   */

  var removeNodes = function removeNodes(container, start) {
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    while (start !== end) {
      var n = start.nextSibling;
      container.removeChild(start);
      start = n;
    }
  };

  /**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * A sentinel value that signals that a value was handled by a directive and
   * should not be written to the DOM.
   */
  var noChange = {};
  /**
   * A sentinel value that signals a NodePart to fully clear its content.
   */

  var nothing = {};

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * An expression marker with embedded unique key to avoid collision with
   * possible text in templates.
   */
  var marker = "{{lit-".concat(String(Math.random()).slice(2), "}}");
  /**
   * An expression marker used text-positions, multi-binding attributes, and
   * attributes with markup-like text values.
   */

  var nodeMarker = "<!--".concat(marker, "-->");
  var markerRegex = new RegExp("".concat(marker, "|").concat(nodeMarker));
  /**
   * Suffix appended to all bound attribute names.
   */

  var boundAttributeSuffix = '$lit$';
  /**
   * An updatable Template that tracks the location of dynamic parts.
   */

  var Template = function Template(result, element) {
    _classCallCheck(this, Template);

    this.parts = [];
    this.element = element;
    var nodesToRemove = [];
    var stack = []; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

    var walker = document.createTreeWalker(element.content, 133
    /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
    , null, false); // Keeps track of the last index associated with a part. We try to delete
    // unnecessary nodes, but we never want to associate two different parts
    // to the same index. They must have a constant node between.

    var lastPartIndex = 0;
    var index = -1;
    var partIndex = 0;
    var strings = result.strings,
        length = result.values.length;

    while (partIndex < length) {
      var node = walker.nextNode();

      if (node === null) {
        // We've exhausted the content inside a nested template element.
        // Because we still have parts (the outer for-loop), we know:
        // - There is a template in the stack
        // - The walker will find a nextNode outside the template
        walker.currentNode = stack.pop();
        continue;
      }

      index++;

      if (node.nodeType === 1
      /* Node.ELEMENT_NODE */
      ) {
          if (node.hasAttributes()) {
            var attributes = node.attributes;
            var _length = attributes.length; // Per
            // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
            // attributes are not guaranteed to be returned in document order.
            // In particular, Edge/IE can return them out of order, so we cannot
            // assume a correspondence between part index and attribute index.

            var count = 0;

            for (var i = 0; i < _length; i++) {
              if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                count++;
              }
            }

            while (count-- > 0) {
              // Get the template literal section leading up to the first
              // expression in this attribute
              var stringForPart = strings[partIndex]; // Find the attribute name

              var name = lastAttributeNameRegex.exec(stringForPart)[2]; // Find the corresponding attribute
              // All bound attributes have had a suffix added in
              // TemplateResult#getHTML to opt out of special attribute
              // handling. To look up the attribute value we also need to add
              // the suffix.

              var attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
              var attributeValue = node.getAttribute(attributeLookupName);
              node.removeAttribute(attributeLookupName);
              var statics = attributeValue.split(markerRegex);
              this.parts.push({
                type: 'attribute',
                index: index,
                name: name,
                strings: statics
              });
              partIndex += statics.length - 1;
            }
          }

          if (node.tagName === 'TEMPLATE') {
            stack.push(node);
            walker.currentNode = node.content;
          }
        } else if (node.nodeType === 3
      /* Node.TEXT_NODE */
      ) {
          var data = node.data;

          if (data.indexOf(marker) >= 0) {
            var parent = node.parentNode;

            var _strings = data.split(markerRegex);

            var lastIndex = _strings.length - 1; // Generate a new text node for each literal section
            // These nodes are also used as the markers for node parts

            for (var _i = 0; _i < lastIndex; _i++) {
              var insert = void 0;
              var s = _strings[_i];

              if (s === '') {
                insert = createMarker();
              } else {
                var match = lastAttributeNameRegex.exec(s);

                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                  s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                }

                insert = document.createTextNode(s);
              }

              parent.insertBefore(insert, node);
              this.parts.push({
                type: 'node',
                index: ++index
              });
            } // If there's no text, we must insert a comment to mark our place.
            // Else, we can trust it will stick around after cloning.


            if (_strings[lastIndex] === '') {
              parent.insertBefore(createMarker(), node);
              nodesToRemove.push(node);
            } else {
              node.data = _strings[lastIndex];
            } // We have a part for each match found


            partIndex += lastIndex;
          }
        } else if (node.nodeType === 8
      /* Node.COMMENT_NODE */
      ) {
          if (node.data === marker) {
            var _parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of
            // the following are true:
            //  * We don't have a previousSibling
            //  * The previousSibling is already the start of a previous part

            if (node.previousSibling === null || index === lastPartIndex) {
              index++;

              _parent.insertBefore(createMarker(), node);
            }

            lastPartIndex = index;
            this.parts.push({
              type: 'node',
              index: index
            }); // If we don't have a nextSibling, keep this node so we have an end.
            // Else, we can remove it to save future costs.

            if (node.nextSibling === null) {
              node.data = '';
            } else {
              nodesToRemove.push(node);
              index--;
            }

            partIndex++;
          } else {
            var _i2 = -1;

            while ((_i2 = node.data.indexOf(marker, _i2 + 1)) !== -1) {
              // Comment node has a binding marker inside, make an inactive part
              // The binding won't work, but subsequent bindings will
              // TODO (justinfagnani): consider whether it's even worth it to
              // make bindings in comments work
              this.parts.push({
                type: 'node',
                index: -1
              });
              partIndex++;
            }
          }
        }
    } // Remove text binding nodes after the walk to not disturb the TreeWalker


    for (var _i3 = 0, _nodesToRemove = nodesToRemove; _i3 < _nodesToRemove.length; _i3++) {
      var n = _nodesToRemove[_i3];
      n.parentNode.removeChild(n);
    }
  };

  var endsWith = function endsWith(str, suffix) {
    var index = str.length - suffix.length;
    return index >= 0 && str.slice(index) === suffix;
  };

  var isTemplatePartActive = function isTemplatePartActive(part) {
    return part.index !== -1;
  }; // Allows `document.createComment('')` to be renamed for a
  // small manual size-savings.

  var createMarker = function createMarker() {
    return document.createComment('');
  };
  /**
   * This regex extracts the attribute name preceding an attribute-position
   * expression. It does this by matching the syntax allowed for attributes
   * against the string literal directly preceding the expression, assuming that
   * the expression is in an attribute-value position.
   *
   * See attributes in the HTML spec:
   * https://www.w3.org/TR/html5/syntax.html#elements-attributes
   *
   * " \x09\x0a\x0c\x0d" are HTML space characters:
   * https://www.w3.org/TR/html5/infrastructure.html#space-characters
   *
   * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
   * space character except " ".
   *
   * So an attribute is:
   *  * The name: any character except a control character, space character, ('),
   *    ("), ">", "=", or "/"
   *  * Followed by zero or more space characters
   *  * Followed by "="
   *  * Followed by zero or more space characters
   *  * Followed by:
   *    * Any character except space, ('), ("), "<", ">", "=", (`), or
   *    * (") then any non-("), or
   *    * (') then any non-(')
   */

  var lastAttributeNameRegex = // eslint-disable-next-line no-control-regex
  /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

  /**
   * An instance of a `Template` that can be attached to the DOM and updated
   * with new values.
   */

  var TemplateInstance = /*#__PURE__*/function () {
    function TemplateInstance(template, processor, options) {
      _classCallCheck(this, TemplateInstance);

      this.__parts = [];
      this.template = template;
      this.processor = processor;
      this.options = options;
    }

    _createClass(TemplateInstance, [{
      key: "update",
      value: function update(values) {
        var i = 0;

        var _iterator = _createForOfIteratorHelper(this.__parts),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var part = _step.value;

            if (part !== undefined) {
              part.setValue(values[i]);
            }

            i++;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var _iterator2 = _createForOfIteratorHelper(this.__parts),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _part = _step2.value;

            if (_part !== undefined) {
              _part.commit();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "_clone",
      value: function _clone() {
        // There are a number of steps in the lifecycle of a template instance's
        // DOM fragment:
        //  1. Clone - create the instance fragment
        //  2. Adopt - adopt into the main document
        //  3. Process - find part markers and create parts
        //  4. Upgrade - upgrade custom elements
        //  5. Update - set node, attribute, property, etc., values
        //  6. Connect - connect to the document. Optional and outside of this
        //     method.
        //
        // We have a few constraints on the ordering of these steps:
        //  * We need to upgrade before updating, so that property values will pass
        //    through any property setters.
        //  * We would like to process before upgrading so that we're sure that the
        //    cloned fragment is inert and not disturbed by self-modifying DOM.
        //  * We want custom elements to upgrade even in disconnected fragments.
        //
        // Given these constraints, with full custom elements support we would
        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
        //
        // But Safari does not implement CustomElementRegistry#upgrade, so we
        // can not implement that order and still have upgrade-before-update and
        // upgrade disconnected fragments. So we instead sacrifice the
        // process-before-upgrade constraint, since in Custom Elements v1 elements
        // must not modify their light DOM in the constructor. We still have issues
        // when co-existing with CEv0 elements like Polymer 1, and with polyfills
        // that don't strictly adhere to the no-modification rule because shadow
        // DOM, which may be created in the constructor, is emulated by being placed
        // in the light DOM.
        //
        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
        // in one step.
        //
        // The Custom Elements v1 polyfill supports upgrade(), so the order when
        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
        // Connect.
        var fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
        var stack = [];
        var parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

        var walker = document.createTreeWalker(fragment, 133
        /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
        , null, false);
        var partIndex = 0;
        var nodeIndex = 0;
        var part;
        var node = walker.nextNode(); // Loop through all the nodes and parts of a template

        while (partIndex < parts.length) {
          part = parts[partIndex];

          if (!isTemplatePartActive(part)) {
            this.__parts.push(undefined);

            partIndex++;
            continue;
          } // Progress the tree walker until we find our next part's node.
          // Note that multiple parts may share the same node (attribute parts
          // on a single element), so this loop may not run at all.


          while (nodeIndex < part.index) {
            nodeIndex++;

            if (node.nodeName === 'TEMPLATE') {
              stack.push(node);
              walker.currentNode = node.content;
            }

            if ((node = walker.nextNode()) === null) {
              // We've exhausted the content inside a nested template element.
              // Because we still have parts (the outer for-loop), we know:
              // - There is a template in the stack
              // - The walker will find a nextNode outside the template
              walker.currentNode = stack.pop();
              node = walker.nextNode();
            }
          } // We've arrived at our part's node.


          if (part.type === 'node') {
            var _part2 = this.processor.handleTextExpression(this.options);

            _part2.insertAfterNode(node.previousSibling);

            this.__parts.push(_part2);
          } else {
            var _this$__parts;

            (_this$__parts = this.__parts).push.apply(_this$__parts, _toConsumableArray(this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options)));
          }

          partIndex++;
        }

        if (isCEPolyfill) {
          document.adoptNode(fragment);
          customElements.upgrade(fragment);
        }

        return fragment;
      }
    }]);

    return TemplateInstance;
  }();

  /**
   * Our TrustedTypePolicy for HTML which is declared using the html template
   * tag function.
   *
   * That HTML is a developer-authored constant, and is parsed with innerHTML
   * before any untrusted expressions have been mixed in. Therefor it is
   * considered safe by construction.
   */

  var policy = window.trustedTypes && trustedTypes.createPolicy('lit-html', {
    createHTML: function createHTML(s) {
      return s;
    }
  });
  var commentMarker = " ".concat(marker, " ");
  /**
   * The return type of `html`, which holds a Template and the values from
   * interpolated expressions.
   */

  var TemplateResult = /*#__PURE__*/function () {
    function TemplateResult(strings, values, type, processor) {
      _classCallCheck(this, TemplateResult);

      this.strings = strings;
      this.values = values;
      this.type = type;
      this.processor = processor;
    }
    /**
     * Returns a string of HTML used to create a `<template>` element.
     */


    _createClass(TemplateResult, [{
      key: "getHTML",
      value: function getHTML() {
        var l = this.strings.length - 1;
        var html = '';
        var isCommentBinding = false;

        for (var i = 0; i < l; i++) {
          var s = this.strings[i]; // For each binding we want to determine the kind of marker to insert
          // into the template source before it's parsed by the browser's HTML
          // parser. The marker type is based on whether the expression is in an
          // attribute, text, or comment position.
          //   * For node-position bindings we insert a comment with the marker
          //     sentinel as its text content, like <!--{{lit-guid}}-->.
          //   * For attribute bindings we insert just the marker sentinel for the
          //     first binding, so that we support unquoted attribute bindings.
          //     Subsequent bindings can use a comment marker because multi-binding
          //     attributes must be quoted.
          //   * For comment bindings we insert just the marker sentinel so we don't
          //     close the comment.
          //
          // The following code scans the template source, but is *not* an HTML
          // parser. We don't need to track the tree structure of the HTML, only
          // whether a binding is inside a comment, and if not, if it appears to be
          // the first binding in an attribute.

          var commentOpen = s.lastIndexOf('<!--'); // We're in comment position if we have a comment open with no following
          // comment close. Because <-- can appear in an attribute value there can
          // be false positives.

          isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1; // Check to see if we have an attribute-like sequence preceding the
          // expression. This can match "name=value" like structures in text,
          // comments, and attribute values, so there can be false-positives.

          var attributeMatch = lastAttributeNameRegex.exec(s);

          if (attributeMatch === null) {
            // We're only in this branch if we don't have a attribute-like
            // preceding sequence. For comments, this guards against unusual
            // attribute values like <div foo="<!--${'bar'}">. Cases like
            // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
            // below.
            html += s + (isCommentBinding ? commentMarker : nodeMarker);
          } else {
            // For attributes we use just a marker sentinel, and also append a
            // $lit$ suffix to the name to opt-out of attribute-specific parsing
            // that IE and Edge do for style and certain SVG attributes.
            html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
          }
        }

        html += this.strings[l];
        return html;
      }
    }, {
      key: "getTemplateElement",
      value: function getTemplateElement() {
        var template = document.createElement('template');
        var value = this.getHTML();

        if (policy !== undefined) {
          // this is secure because `this.strings` is a TemplateStringsArray.
          // TODO: validate this when
          // https://github.com/tc39/proposal-array-is-template-object is
          // implemented.
          value = policy.createHTML(value);
        }

        template.innerHTML = value;
        return template;
      }
    }]);

    return TemplateResult;
  }();

  var isPrimitive = function isPrimitive(value) {
    return value === null || !(_typeof(value) === 'object' || typeof value === 'function');
  };
  var isIterable = function isIterable(value) {
    return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    !!(value && value[Symbol.iterator]);
  };
  /**
   * Writes attribute values to the DOM for a group of AttributeParts bound to a
   * single attribute. The value is only set once even if there are multiple parts
   * for an attribute.
   */

  var AttributeCommitter = /*#__PURE__*/function () {
    function AttributeCommitter(element, name, strings) {
      _classCallCheck(this, AttributeCommitter);

      this.dirty = true;
      this.element = element;
      this.name = name;
      this.strings = strings;
      this.parts = [];

      for (var i = 0; i < strings.length - 1; i++) {
        this.parts[i] = this._createPart();
      }
    }
    /**
     * Creates a single part. Override this to create a differnt type of part.
     */


    _createClass(AttributeCommitter, [{
      key: "_createPart",
      value: function _createPart() {
        return new AttributePart(this);
      }
    }, {
      key: "_getValue",
      value: function _getValue() {
        var strings = this.strings;
        var l = strings.length - 1;
        var parts = this.parts; // If we're assigning an attribute via syntax like:
        //    attr="${foo}"  or  attr=${foo}
        // but not
        //    attr="${foo} ${bar}" or attr="${foo} baz"
        // then we don't want to coerce the attribute value into one long
        // string. Instead we want to just return the value itself directly,
        // so that sanitizeDOMValue can get the actual value rather than
        // String(value)
        // The exception is if v is an array, in which case we do want to smash
        // it together into a string without calling String() on the array.
        //
        // This also allows trusted values (when using TrustedTypes) being
        // assigned to DOM sinks without being stringified in the process.

        if (l === 1 && strings[0] === '' && strings[1] === '') {
          var v = parts[0].value;

          if (_typeof(v) === 'symbol') {
            return String(v);
          }

          if (typeof v === 'string' || !isIterable(v)) {
            return v;
          }
        }

        var text = '';

        for (var i = 0; i < l; i++) {
          text += strings[i];
          var part = parts[i];

          if (part !== undefined) {
            var _v = part.value;

            if (isPrimitive(_v) || !isIterable(_v)) {
              text += typeof _v === 'string' ? _v : String(_v);
            } else {
              var _iterator = _createForOfIteratorHelper(_v),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var t = _step.value;
                  text += typeof t === 'string' ? t : String(t);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
          }
        }

        text += strings[l];
        return text;
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.dirty) {
          this.dirty = false;
          this.element.setAttribute(this.name, this._getValue());
        }
      }
    }]);

    return AttributeCommitter;
  }();
  /**
   * A Part that controls all or part of an attribute value.
   */

  var AttributePart = /*#__PURE__*/function () {
    function AttributePart(committer) {
      _classCallCheck(this, AttributePart);

      this.value = undefined;
      this.committer = committer;
    }

    _createClass(AttributePart, [{
      key: "setValue",
      value: function setValue(value) {
        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
          this.value = value; // If the value is a not a directive, dirty the committer so that it'll
          // call setAttribute. If the value is a directive, it'll dirty the
          // committer if it calls setValue().

          if (!isDirective(value)) {
            this.committer.dirty = true;
          }
        }
      }
    }, {
      key: "commit",
      value: function commit() {
        while (isDirective(this.value)) {
          var directive = this.value;
          this.value = noChange;
          directive(this);
        }

        if (this.value === noChange) {
          return;
        }

        this.committer.commit();
      }
    }]);

    return AttributePart;
  }();
  /**
   * A Part that controls a location within a Node tree. Like a Range, NodePart
   * has start and end locations and can set and update the Nodes between those
   * locations.
   *
   * NodeParts support several value types: primitives, Nodes, TemplateResults,
   * as well as arrays and iterables of those types.
   */

  var NodePart = /*#__PURE__*/function () {
    function NodePart(options) {
      _classCallCheck(this, NodePart);

      this.value = undefined;
      this.__pendingValue = undefined;
      this.options = options;
    }
    /**
     * Appends this part into a container.
     *
     * This part must be empty, as its contents are not automatically moved.
     */


    _createClass(NodePart, [{
      key: "appendInto",
      value: function appendInto(container) {
        this.startNode = container.appendChild(createMarker());
        this.endNode = container.appendChild(createMarker());
      }
      /**
       * Inserts this part after the `ref` node (between `ref` and `ref`'s next
       * sibling). Both `ref` and its next sibling must be static, unchanging nodes
       * such as those that appear in a literal section of a template.
       *
       * This part must be empty, as its contents are not automatically moved.
       */

    }, {
      key: "insertAfterNode",
      value: function insertAfterNode(ref) {
        this.startNode = ref;
        this.endNode = ref.nextSibling;
      }
      /**
       * Appends this part into a parent part.
       *
       * This part must be empty, as its contents are not automatically moved.
       */

    }, {
      key: "appendIntoPart",
      value: function appendIntoPart(part) {
        part.__insert(this.startNode = createMarker());

        part.__insert(this.endNode = createMarker());
      }
      /**
       * Inserts this part after the `ref` part.
       *
       * This part must be empty, as its contents are not automatically moved.
       */

    }, {
      key: "insertAfterPart",
      value: function insertAfterPart(ref) {
        ref.__insert(this.startNode = createMarker());

        this.endNode = ref.endNode;
        ref.endNode = this.startNode;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.__pendingValue = value;
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.startNode.parentNode === null) {
          return;
        }

        while (isDirective(this.__pendingValue)) {
          var directive = this.__pendingValue;
          this.__pendingValue = noChange;
          directive(this);
        }

        var value = this.__pendingValue;

        if (value === noChange) {
          return;
        }

        if (isPrimitive(value)) {
          if (value !== this.value) {
            this.__commitText(value);
          }
        } else if (value instanceof TemplateResult) {
          this.__commitTemplateResult(value);
        } else if (value instanceof Node) {
          this.__commitNode(value);
        } else if (isIterable(value)) {
          this.__commitIterable(value);
        } else if (value === nothing) {
          this.value = nothing;
          this.clear();
        } else {
          // Fallback, will render the string representation
          this.__commitText(value);
        }
      }
    }, {
      key: "__insert",
      value: function __insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
      }
    }, {
      key: "__commitNode",
      value: function __commitNode(value) {
        if (this.value === value) {
          return;
        }

        this.clear();

        this.__insert(value);

        this.value = value;
      }
    }, {
      key: "__commitText",
      value: function __commitText(value) {
        var node = this.startNode.nextSibling;
        value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case
        // it can't be implicitly converted - i.e. it's a symbol.

        var valueAsString = typeof value === 'string' ? value : String(value);

        if (node === this.endNode.previousSibling && node.nodeType === 3
        /* Node.TEXT_NODE */
        ) {
            // If we only have a single text node between the markers, we can just
            // set its value, rather than replacing it.
            // TODO(justinfagnani): Can we just check if this.value is primitive?
            node.data = valueAsString;
          } else {
          this.__commitNode(document.createTextNode(valueAsString));
        }

        this.value = value;
      }
    }, {
      key: "__commitTemplateResult",
      value: function __commitTemplateResult(value) {
        var template = this.options.templateFactory(value);

        if (this.value instanceof TemplateInstance && this.value.template === template) {
          this.value.update(value.values);
        } else {
          // Make sure we propagate the template processor from the TemplateResult
          // so that we use its syntax extension, etc. The template factory comes
          // from the render function options so that it can control template
          // caching and preprocessing.
          var instance = new TemplateInstance(template, value.processor, this.options);

          var fragment = instance._clone();

          instance.update(value.values);

          this.__commitNode(fragment);

          this.value = instance;
        }
      }
    }, {
      key: "__commitIterable",
      value: function __commitIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _value is an array, then the previous render was of an
        // iterable and _value will contain the NodeParts from the previous
        // render. If _value is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this.value)) {
          this.value = [];
          this.clear();
        } // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render


        var itemParts = this.value;
        var partIndex = 0;
        var itemPart;

        var _iterator2 = _createForOfIteratorHelper(value),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            // Try to reuse an existing part
            itemPart = itemParts[partIndex]; // If no existing part, create a new one

            if (itemPart === undefined) {
              itemPart = new NodePart(this.options);
              itemParts.push(itemPart);

              if (partIndex === 0) {
                itemPart.appendIntoPart(this);
              } else {
                itemPart.insertAfterPart(itemParts[partIndex - 1]);
              }
            }

            itemPart.setValue(item);
            itemPart.commit();
            partIndex++;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        if (partIndex < itemParts.length) {
          // Truncate the parts array so _value reflects the current state
          itemParts.length = partIndex;
          this.clear(itemPart && itemPart.endNode);
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;
        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
      }
    }]);

    return NodePart;
  }();
  /**
   * Implements a boolean attribute, roughly as defined in the HTML
   * specification.
   *
   * If the value is truthy, then the attribute is present with a value of
   * ''. If the value is falsey, the attribute is removed.
   */

  var BooleanAttributePart = /*#__PURE__*/function () {
    function BooleanAttributePart(element, name, strings) {
      _classCallCheck(this, BooleanAttributePart);

      this.value = undefined;
      this.__pendingValue = undefined;

      if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
        throw new Error('Boolean attributes can only contain a single expression');
      }

      this.element = element;
      this.name = name;
      this.strings = strings;
    }

    _createClass(BooleanAttributePart, [{
      key: "setValue",
      value: function setValue(value) {
        this.__pendingValue = value;
      }
    }, {
      key: "commit",
      value: function commit() {
        while (isDirective(this.__pendingValue)) {
          var directive = this.__pendingValue;
          this.__pendingValue = noChange;
          directive(this);
        }

        if (this.__pendingValue === noChange) {
          return;
        }

        var value = !!this.__pendingValue;

        if (this.value !== value) {
          if (value) {
            this.element.setAttribute(this.name, '');
          } else {
            this.element.removeAttribute(this.name);
          }

          this.value = value;
        }

        this.__pendingValue = noChange;
      }
    }]);

    return BooleanAttributePart;
  }();
  /**
   * Sets attribute values for PropertyParts, so that the value is only set once
   * even if there are multiple parts for a property.
   *
   * If an expression controls the whole property value, then the value is simply
   * assigned to the property under control. If there are string literals or
   * multiple expressions, then the strings are expressions are interpolated into
   * a string first.
   */

  var PropertyCommitter = /*#__PURE__*/function (_AttributeCommitter) {
    _inherits(PropertyCommitter, _AttributeCommitter);

    var _super = _createSuper(PropertyCommitter);

    function PropertyCommitter(element, name, strings) {
      var _this;

      _classCallCheck(this, PropertyCommitter);

      _this = _super.call(this, element, name, strings);
      _this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';
      return _this;
    }

    _createClass(PropertyCommitter, [{
      key: "_createPart",
      value: function _createPart() {
        return new PropertyPart(this);
      }
    }, {
      key: "_getValue",
      value: function _getValue() {
        if (this.single) {
          return this.parts[0].value;
        }

        return _get(_getPrototypeOf(PropertyCommitter.prototype), "_getValue", this).call(this);
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.dirty) {
          this.dirty = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          this.element[this.name] = this._getValue();
        }
      }
    }]);

    return PropertyCommitter;
  }(AttributeCommitter);
  var PropertyPart = /*#__PURE__*/function (_AttributePart) {
    _inherits(PropertyPart, _AttributePart);

    var _super2 = _createSuper(PropertyPart);

    function PropertyPart() {
      _classCallCheck(this, PropertyPart);

      return _super2.apply(this, arguments);
    }

    return PropertyPart;
  }(AttributePart); // Detect event listener options support. If the `capture` property is read
  // from the options object, then options are supported. If not, then the third
  // argument to add/removeEventListener is interpreted as the boolean capture
  // value so we should only pass the `capture` property.

  var eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
  // blocks right into the body of a module

  (function () {
    try {
      var options = {
        get capture() {
          eventOptionsSupported = true;
          return false;
        }

      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any

      window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any

      window.removeEventListener('test', options, options);
    } catch (_e) {// event options not supported
    }
  })();

  var EventPart = /*#__PURE__*/function () {
    function EventPart(element, eventName, eventContext) {
      var _this2 = this;

      _classCallCheck(this, EventPart);

      this.value = undefined;
      this.__pendingValue = undefined;
      this.element = element;
      this.eventName = eventName;
      this.eventContext = eventContext;

      this.__boundHandleEvent = function (e) {
        return _this2.handleEvent(e);
      };
    }

    _createClass(EventPart, [{
      key: "setValue",
      value: function setValue(value) {
        this.__pendingValue = value;
      }
    }, {
      key: "commit",
      value: function commit() {
        while (isDirective(this.__pendingValue)) {
          var directive = this.__pendingValue;
          this.__pendingValue = noChange;
          directive(this);
        }

        if (this.__pendingValue === noChange) {
          return;
        }

        var newListener = this.__pendingValue;
        var oldListener = this.value;
        var shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
        var shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);

        if (shouldRemoveListener) {
          this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }

        if (shouldAddListener) {
          this.__options = getOptions(newListener);
          this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }

        this.value = newListener;
        this.__pendingValue = noChange;
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        if (typeof this.value === 'function') {
          this.value.call(this.eventContext || this.element, event);
        } else {
          this.value.handleEvent(event);
        }
      }
    }]);

    return EventPart;
  }(); // We copy options because of the inconsistent behavior of browsers when reading
  // the third argument of add/removeEventListener. IE11 doesn't support options
  // at all. Chrome 41 only reads `capture` if the argument is an object.

  var getOptions = function getOptions(o) {
    return o && (eventOptionsSupported ? {
      capture: o.capture,
      passive: o.passive,
      once: o.once
    } : o.capture);
  };

  /**
   * Creates Parts when a template is instantiated.
   */

  var DefaultTemplateProcessor = /*#__PURE__*/function () {
    function DefaultTemplateProcessor() {
      _classCallCheck(this, DefaultTemplateProcessor);
    }

    _createClass(DefaultTemplateProcessor, [{
      key: "handleAttributeExpressions",

      /**
       * Create parts for an attribute-position binding, given the event, attribute
       * name, and string literals.
       *
       * @param element The element containing the binding
       * @param name  The attribute name
       * @param strings The string literals. There are always at least two strings,
       *   event for fully-controlled bindings with a single expression.
       */
      value: function handleAttributeExpressions(element, name, strings, options) {
        var prefix = name[0];

        if (prefix === '.') {
          var _committer = new PropertyCommitter(element, name.slice(1), strings);

          return _committer.parts;
        }

        if (prefix === '@') {
          return [new EventPart(element, name.slice(1), options.eventContext)];
        }

        if (prefix === '?') {
          return [new BooleanAttributePart(element, name.slice(1), strings)];
        }

        var committer = new AttributeCommitter(element, name, strings);
        return committer.parts;
      }
      /**
       * Create parts for a text-position binding.
       * @param templateFactory
       */

    }, {
      key: "handleTextExpression",
      value: function handleTextExpression(options) {
        return new NodePart(options);
      }
    }]);

    return DefaultTemplateProcessor;
  }();
  var defaultTemplateProcessor = new DefaultTemplateProcessor();

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * The default TemplateFactory which caches Templates keyed on
   * result.type and result.strings.
   */

  function templateFactory(result) {
    var templateCache = templateCaches.get(result.type);

    if (templateCache === undefined) {
      templateCache = {
        stringsArray: new WeakMap(),
        keyString: new Map()
      };
      templateCaches.set(result.type, templateCache);
    }

    var template = templateCache.stringsArray.get(result.strings);

    if (template !== undefined) {
      return template;
    } // If the TemplateStringsArray is new, generate a key from the strings
    // This key is shared between all templates with identical content


    var key = result.strings.join(marker); // Check if we already have a Template for this key

    template = templateCache.keyString.get(key);

    if (template === undefined) {
      // If we have not seen this key before, create a new Template
      template = new Template(result, result.getTemplateElement()); // Cache the Template for this key

      templateCache.keyString.set(key, template);
    } // Cache all future queries for this TemplateStringsArray


    templateCache.stringsArray.set(result.strings, template);
    return template;
  }
  var templateCaches = new Map();

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var parts = new WeakMap();
  /**
   * Renders a template result or other value to a container.
   *
   * To update a container with new values, reevaluate the template literal and
   * call `render` with the new result.
   *
   * @param result Any value renderable by NodePart - typically a TemplateResult
   *     created by evaluating a template tag like `html` or `svg`.
   * @param container A DOM parent to render to. The entire contents are either
   *     replaced, or efficiently updated if the same result type was previous
   *     rendered there.
   * @param options RenderOptions for the entire render tree rendered to this
   *     container. Render options must *not* change between renders to the same
   *     container, as those changes will not effect previously rendered DOM.
   */

  var render = function render(result, container, options) {
    var part = parts.get(container);

    if (part === undefined) {
      removeNodes(container, container.firstChild);
      parts.set(container, part = new NodePart(Object.assign({
        templateFactory: templateFactory
      }, options)));
      part.appendInto(container);
    }

    part.setValue(result);
    part.commit();
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  // This line will be used in regexes to search for lit-html usage.
  // TODO(justinfagnani): inject version number at build time

  if (typeof window !== 'undefined') {
    (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.3.0');
  }
  /**
   * Interprets a template literal as an HTML template that can efficiently
   * render to and update a container.
   */


  var html = function html(strings) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    return new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
  };

  var current;
  var currentId = 0;

  function setCurrent(state) {
    current = state;
  }

  function clear() {
    current = null;
    currentId = 0;
  }

  function notify() {
    return currentId++;
  }

  var phaseSymbol = Symbol('haunted.phase');
  var hookSymbol = Symbol('haunted.hook');
  var updateSymbol = Symbol('haunted.update');
  var commitSymbol = Symbol('haunted.commit');
  var effectsSymbol = Symbol('haunted.effects');
  var layoutEffectsSymbol = Symbol('haunted.layoutEffects');
  var contextEvent = 'haunted.context';

  var State = /*#__PURE__*/function () {
    function State(update, host) {
      _classCallCheck(this, State);

      this.update = update;
      this.host = host;
      this[hookSymbol] = new Map();
      this[effectsSymbol] = [];
      this[layoutEffectsSymbol] = [];
    }

    _createClass(State, [{
      key: "run",
      value: function run(cb) {
        setCurrent(this);
        var res = cb();
        clear();
        return res;
      }
    }, {
      key: "_runEffects",
      value: function _runEffects(phase) {
        var effects = this[phase];
        setCurrent(this);

        var _iterator = _createForOfIteratorHelper(effects),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var effect = _step.value;
            effect.call(this);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        clear();
      }
    }, {
      key: "runEffects",
      value: function runEffects() {
        this._runEffects(effectsSymbol);
      }
    }, {
      key: "runLayoutEffects",
      value: function runLayoutEffects() {
        this._runEffects(layoutEffectsSymbol);
      }
    }, {
      key: "teardown",
      value: function teardown() {
        var hooks = this[hookSymbol];
        hooks.forEach(function (hook) {
          if (typeof hook.teardown === 'function') {
            hook.teardown();
          }
        });
      }
    }]);

    return State;
  }();

  var defer = Promise.resolve().then.bind(Promise.resolve());

  function runner() {
    var tasks = [];
    var id;

    function runTasks() {
      id = null;
      var t = tasks;
      tasks = [];

      for (var i = 0, len = t.length; i < len; i++) {
        t[i]();
      }
    }

    return function (task) {
      tasks.push(task);

      if (id == null) {
        id = defer(runTasks);
      }
    };
  }

  var read = runner();
  var write = runner();

  var BaseScheduler = /*#__PURE__*/function () {
    function BaseScheduler(renderer, host) {
      _classCallCheck(this, BaseScheduler);

      this.renderer = renderer;
      this.host = host;
      this.state = new State(this.update.bind(this), host);
      this[phaseSymbol] = null;
      this._updateQueued = false;
    }

    _createClass(BaseScheduler, [{
      key: "update",
      value: function update() {
        var _this = this;

        if (this._updateQueued) return;
        read(function () {
          var result = _this.handlePhase(updateSymbol);

          write(function () {
            _this.handlePhase(commitSymbol, result);

            write(function () {
              _this.handlePhase(effectsSymbol);
            });
          });
          _this._updateQueued = false;
        });
        this._updateQueued = true;
      }
    }, {
      key: "handlePhase",
      value: function handlePhase(phase, arg) {
        this[phaseSymbol] = phase;

        switch (phase) {
          case commitSymbol:
            this.commit(arg);
            this.runEffects(layoutEffectsSymbol);
            return;

          case updateSymbol:
            return this.render();

          case effectsSymbol:
            return this.runEffects(effectsSymbol);
        }

        this[phaseSymbol] = null;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        return this.state.run(function () {
          return _this2.renderer.call(_this2.host, _this2.host);
        });
      }
    }, {
      key: "runEffects",
      value: function runEffects(phase) {
        this.state._runEffects(phase);
      }
    }, {
      key: "teardown",
      value: function teardown() {
        this.state.teardown();
      }
    }]);

    return BaseScheduler;
  }();

  var toCamelCase = function toCamelCase() {
    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return val.replace(/-+([a-z])?/g, function (_, _char) {
      return _char ? _char.toUpperCase() : '';
    });
  };

  function makeComponent(render) {
    var Scheduler = /*#__PURE__*/function (_BaseScheduler) {
      _inherits(Scheduler, _BaseScheduler);

      var _super = _createSuper(Scheduler);

      function Scheduler(renderer, frag, host) {
        var _this;

        _classCallCheck(this, Scheduler);

        _this = _super.call(this, renderer, host || frag);
        _this.frag = frag;
        return _this;
      }

      _createClass(Scheduler, [{
        key: "commit",
        value: function commit(result) {
          render(result, this.frag);
        }
      }]);

      return Scheduler;
    }(BaseScheduler);

    function component(renderer, baseElementOrOptions, options) {
      var BaseElement = (options || baseElementOrOptions || {}).baseElement || HTMLElement;

      var _ref = options || baseElementOrOptions || {},
          _ref$observedAttribut = _ref.observedAttributes,
          observedAttributes = _ref$observedAttribut === void 0 ? [] : _ref$observedAttribut,
          _ref$useShadowDOM = _ref.useShadowDOM,
          useShadowDOM = _ref$useShadowDOM === void 0 ? true : _ref$useShadowDOM,
          _ref$shadowRootInit = _ref.shadowRootInit,
          shadowRootInit = _ref$shadowRootInit === void 0 ? {} : _ref$shadowRootInit;

      var Element = /*#__PURE__*/function (_BaseElement) {
        _inherits(Element, _BaseElement);

        var _super2 = _createSuper(Element);

        function Element() {
          var _this2;

          _classCallCheck(this, Element);

          _this2 = _super2.call(this);

          if (useShadowDOM === false) {
            _this2._scheduler = new Scheduler(renderer, _assertThisInitialized(_this2));
          } else {
            _this2.attachShadow(_objectSpread2({
              mode: 'open'
            }, shadowRootInit));

            _this2._scheduler = new Scheduler(renderer, _this2.shadowRoot, _assertThisInitialized(_this2));
          }

          return _this2;
        }

        _createClass(Element, [{
          key: "connectedCallback",
          value: function connectedCallback() {
            this._scheduler.update();
          }
        }, {
          key: "disconnectedCallback",
          value: function disconnectedCallback() {
            this._scheduler.teardown();
          }
        }, {
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(name, oldValue, newValue) {
            if (oldValue === newValue) {
              return;
            }

            var val = newValue === '' ? true : newValue;
            Reflect.set(this, toCamelCase(name), val);
          }
        }], [{
          key: "observedAttributes",
          get: function get() {
            return renderer.observedAttributes || observedAttributes || [];
          }
        }]);

        return Element;
      }(BaseElement);

      function reflectiveProp(initialValue) {
        var value = initialValue;
        return Object.freeze({
          enumerable: true,
          configurable: true,
          get: function get() {
            return value;
          },
          set: function set(newValue) {
            value = newValue;

            this._scheduler.update();
          }
        });
      }

      var proto = new Proxy(BaseElement.prototype, {
        getPrototypeOf: function getPrototypeOf(target) {
          return target;
        },
        set: function set(target, key, value, receiver) {
          var desc;

          if (key in target) {
            desc = Object.getOwnPropertyDescriptor(target, key);

            if (desc && desc.set) {
              desc.set.call(receiver, value);
              return true;
            }

            Reflect.set(target, key, value);
          }

          if (_typeof(key) === 'symbol' || key[0] === '_') {
            desc = {
              enumerable: true,
              configurable: true,
              writable: true,
              value: value
            };
          } else {
            desc = reflectiveProp(value);
          }

          Object.defineProperty(receiver, key, desc);

          if (desc.set) {
            desc.set.call(receiver, value);
          }

          return true;
        }
      });
      Object.setPrototypeOf(Element.prototype, proto);
      return Element;
    }

    return component;
  }

  var Hook = function Hook(id, state) {
    _classCallCheck(this, Hook);

    this.id = id;
    this.state = state;
  };

  function use(Hook) {
    var _hook;

    var id = notify();
    var hooks = current[hookSymbol];
    var hook = hooks.get(id);

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (!hook) {
      hook = _construct(Hook, [id, current].concat(args));
      hooks.set(id, hook);
    }

    return (_hook = hook).update.apply(_hook, args);
  }

  function hook(Hook) {
    return use.bind(null, Hook);
  }

  function createEffect(setEffects) {
    return hook( /*#__PURE__*/function (_Hook) {
      _inherits(_class, _Hook);

      var _super = _createSuper(_class);

      function _class(id, state, ignored1, ignored2) {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this, id, state);
        setEffects(state, _assertThisInitialized(_this));
        return _this;
      }

      _createClass(_class, [{
        key: "update",
        value: function update(callback, values) {
          this.callback = callback;
          this.lastValues = this.values;
          this.values = values;
        }
      }, {
        key: "call",
        value: function call() {
          if (!this.values || this.hasChanged()) {
            this.run();
          }
        }
      }, {
        key: "run",
        value: function run() {
          this.teardown();
          this._teardown = this.callback.call(this.state);
        }
      }, {
        key: "teardown",
        value: function teardown() {
          if (typeof this._teardown === 'function') {
            this._teardown();
          }
        }
      }, {
        key: "hasChanged",
        value: function hasChanged() {
          var _this2 = this;

          return !this.lastValues || this.values.some(function (value, i) {
            return _this2.lastValues[i] !== value;
          });
        }
      }]);

      return _class;
    }(Hook));
  }

  function setEffects(state, cb) {
    state[effectsSymbol].push(cb);
  }

  var useEffect = createEffect(setEffects);

  var useContext = hook( /*#__PURE__*/function (_Hook) {
    _inherits(_class, _Hook);

    var _super = _createSuper(_class);

    function _class(id, state, _) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, id, state);
      _this._updater = _this._updater.bind(_assertThisInitialized(_this));
      _this._ranEffect = false;
      _this._unsubscribe = null;
      setEffects(state, _assertThisInitialized(_this));
      return _this;
    }

    _createClass(_class, [{
      key: "update",
      value: function update(Context) {
        if (this.state.virtual) {
          throw new Error('can\'t be used with virtual components');
        }

        if (this.Context !== Context) {
          this._subscribe(Context);

          this.Context = Context;
        }

        return this.value;
      }
    }, {
      key: "call",
      value: function call() {
        if (!this._ranEffect) {
          this._ranEffect = true;
          if (this._unsubscribe) this._unsubscribe();

          this._subscribe(this.Context);

          this.state.update();
        }
      }
    }, {
      key: "_updater",
      value: function _updater(value) {
        this.value = value;
        this.state.update();
      }
    }, {
      key: "_subscribe",
      value: function _subscribe(Context) {
        var detail = {
          Context: Context,
          callback: this._updater
        };
        this.state.host.dispatchEvent(new CustomEvent(contextEvent, {
          detail: detail,
          bubbles: true,
          cancelable: true,
          composed: true
        }));
        var unsubscribe = detail.unsubscribe,
            value = detail.value;
        this.value = unsubscribe ? value : Context.defaultValue;
        this._unsubscribe = unsubscribe;
      }
    }, {
      key: "teardown",
      value: function teardown() {
        if (this._unsubscribe) {
          this._unsubscribe();
        }
      }
    }]);

    return _class;
  }(Hook));

  function makeContext(component) {
    return function (defaultValue) {
      var Context = {
        Provider: /*#__PURE__*/function (_HTMLElement) {
          _inherits(Provider, _HTMLElement);

          var _super = _createSuper(Provider);

          function Provider() {
            var _this;

            _classCallCheck(this, Provider);

            _this = _super.call(this);
            _this.listeners = new Set();

            _this.addEventListener(contextEvent, _assertThisInitialized(_this));

            return _this;
          }

          _createClass(Provider, [{
            key: "disconnectedCallback",
            value: function disconnectedCallback() {
              this.removeEventListener(contextEvent, this);
            }
          }, {
            key: "handleEvent",
            value: function handleEvent(event) {
              var detail = event.detail;

              if (detail.Context === Context) {
                detail.value = this.value;
                detail.unsubscribe = this.unsubscribe.bind(this, detail.callback);
                this.listeners.add(detail.callback);
                event.stopPropagation();
              }
            }
          }, {
            key: "unsubscribe",
            value: function unsubscribe(callback) {
              this.listeners["delete"](callback);
            }
          }, {
            key: "value",
            set: function set(value) {
              this._value = value;

              var _iterator = _createForOfIteratorHelper(this.listeners),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var callback = _step.value;
                  callback(value);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            },
            get: function get() {
              return this._value;
            }
          }]);

          return Provider;
        }( /*#__PURE__*/_wrapNativeSuper(HTMLElement)),
        Consumer: component(function (_ref) {
          var render = _ref.render;
          var context = useContext(Context);
          return render(context);
        }),
        defaultValue: defaultValue
      };
      return Context;
    };
  }

  var useMemo = hook( /*#__PURE__*/function (_Hook) {
    _inherits(_class, _Hook);

    var _super = _createSuper(_class);

    function _class(id, state, fn, values) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, id, state);
      _this.value = fn();
      _this.values = values;
      return _this;
    }

    _createClass(_class, [{
      key: "update",
      value: function update(fn, values) {
        if (this.hasChanged(values)) {
          this.values = values;
          this.value = fn();
        }

        return this.value;
      }
    }, {
      key: "hasChanged",
      value: function hasChanged() {
        var _this2 = this;

        var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return values.some(function (value, i) {
          return _this2.values[i] !== value;
        });
      }
    }]);

    return _class;
  }(Hook));

  var useCallback = function useCallback(fn, inputs) {
    return useMemo(function () {
      return fn;
    }, inputs);
  };

  function setLayoutEffects(state, cb) {
    state[layoutEffectsSymbol].push(cb);
  }

  var useLayoutEffect = createEffect(setLayoutEffects);

  var useState = hook( /*#__PURE__*/function (_Hook) {
    _inherits(_class, _Hook);

    var _super = _createSuper(_class);

    function _class(id, state, initialValue) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, id, state);
      _this.updater = _this.updater.bind(_assertThisInitialized(_this));

      if (typeof initialValue === 'function') {
        initialValue = initialValue();
      }

      _this.makeArgs(initialValue);

      return _this;
    }

    _createClass(_class, [{
      key: "update",
      value: function update() {
        return this.args;
      }
    }, {
      key: "updater",
      value: function updater(value) {
        if (typeof value === 'function') {
          var updaterFn = value;

          var _this$args = _slicedToArray(this.args, 1),
              previousValue = _this$args[0];

          value = updaterFn(previousValue);
        }

        this.makeArgs(value);
        this.state.update();
      }
    }, {
      key: "makeArgs",
      value: function makeArgs(value) {
        this.args = Object.freeze([value, this.updater]);
      }
    }]);

    return _class;
  }(Hook));

  var useReducer = hook( /*#__PURE__*/function (_Hook) {
    _inherits(_class, _Hook);

    var _super = _createSuper(_class);

    function _class(id, state, _, initialState, init) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, id, state);
      _this.dispatch = _this.dispatch.bind(_assertThisInitialized(_this));
      _this.currentState = init !== undefined ? init(initialState) : initialState;
      return _this;
    }

    _createClass(_class, [{
      key: "update",
      value: function update(reducer) {
        this.reducer = reducer;
        return [this.currentState, this.dispatch];
      }
    }, {
      key: "dispatch",
      value: function dispatch(action) {
        this.currentState = this.reducer(this.currentState, action);
        this.state.update();
      }
    }]);

    return _class;
  }(Hook));

  var useRef = function useRef(initialValue) {
    return useMemo(function () {
      return {
        current: initialValue
      };
    }, []);
  };

  function haunted(_ref) {
    var render = _ref.render;
    var component = makeComponent(render);
    var createContext = makeContext(component);
    return {
      component: component,
      createContext: createContext
    };
  }

  var _haunted = haunted({
    render: render
  }),
      component = _haunted.component;

  function useDebouncedCallback(func, rawWait) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      leading: false,
      trailing: true
    };
    var lastCallTime = useRef(undefined);
    var lastInvokeTime = useRef(0);
    var timerId = useRef(undefined);
    var lastArgs = useRef([]);
    var lastThis = useRef(null);
    var result = useRef(null);
    var funcRef = useRef(func);
    var mounted = useRef(true);
    funcRef.current = func; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.

    var useRAF = !rawWait && rawWait !== 0 && typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function';

    if (typeof func !== 'function') {
      throw new TypeError('Expected a function');
    }

    var wait = Number(rawWait) || 0;
    var leading = !!options.leading;
    var trailing = 'trailing' in options ? !!options.trailing : true;
    var maxing = ('maxWait' in options);
    var maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : undefined;
    var invokeFunc = useCallback(function (time) {
      var args = lastArgs.current;
      var thisArg = lastThis.current;
      lastThis.current = undefined;
      lastArgs.current = undefined;
      lastInvokeTime.current = time;
      result.current = funcRef.current.apply(thisArg, args);
      return result.current;
    }, []);
    var startTimer = useCallback(function (pendingFunc, timeout) {
      if (useRAF) {
        window.cancelAnimationFrame(timerId.current);
        return window.requestAnimationFrame(pendingFunc);
      }

      return setTimeout(pendingFunc, timeout);
    }, [useRAF]);
    var cancelTimer = useCallback(function (id) {
      if (useRAF) {
        return window.cancelAnimationFrame(id);
      }

      clearTimeout(id);
      return true;
    }, [useRAF]);
    var remainingWait = useCallback(function (time) {
      var timeSinceLastCall = time - lastCallTime.current;
      var timeSinceLastInvoke = time - lastInvokeTime.current;
      var timeWaiting = wait - timeSinceLastCall;
      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }, [maxWait, maxing, wait]);
    var shouldInvoke = useCallback(function (time) {
      if (!mounted.current) return false;
      var timeSinceLastCall = time - lastCallTime.current;
      var timeSinceLastInvoke = time - lastInvokeTime.current; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime.current === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }, [maxWait, maxing, wait]);
    var trailingEdge = useCallback(function (time) {
      timerId.current = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs.current) {
        return invokeFunc(time);
      }

      lastThis.current = undefined;
      lastArgs.current = undefined;
      return result.current;
    }, [invokeFunc, trailing]);
    var timerExpired = useCallback(function () {
      var time = Date.now();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId.current = startTimer(timerExpired, remainingWait(time));
      return true;
    }, [remainingWait, shouldInvoke, startTimer, trailingEdge]);
    var leadingEdge = useCallback(function (time) {
      // Reset any `maxWait` timer.
      lastInvokeTime.current = time; // Start the timer for the trailing edge.

      timerId.current = startTimer(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result.current;
    }, [invokeFunc, startTimer, leading, timerExpired, wait]);
    var cancel = useCallback(function () {
      if (timerId.current !== undefined) {
        cancelTimer(timerId.current);
      }

      lastInvokeTime.current = 0;
      timerId.current = undefined;
      lastThis.current = undefined;
      lastCallTime.current = undefined;
      lastArgs.current = undefined;
    }, [cancelTimer]);
    var flush = useCallback(function () {
      return timerId.current === undefined ? result.current : trailingEdge(Date.now());
    }, [trailingEdge]);
    useEffect(function () {
      mounted.current = true;
      return function () {
        mounted.current = false;
      };
    }, []);
    var debounced = useCallback(function () {
      var time = Date.now();
      var isInvoking = shouldInvoke(time);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      lastArgs.current = args;
      lastThis.current = _this;
      lastCallTime.current = time;

      if (isInvoking) {
        if (timerId.current === undefined && mounted.current) {
          return leadingEdge(lastCallTime.current);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          timerId.current = startTimer(timerExpired, wait);
          return invokeFunc(lastCallTime.current);
        }
      }

      if (timerId.current === undefined) {
        timerId.current = startTimer(timerExpired, wait);
      }

      return result.current;
    }, [invokeFunc, leadingEdge, maxing, shouldInvoke, startTimer, timerExpired, wait]);
    var pending = useCallback(function () {
      return timerId.current !== undefined;
    }, []);
    var debouncedState = useMemo(function () {
      return {
        callback: debounced,
        cancel: cancel,
        flush: flush,
        pending: pending
      };
    }, [debounced, cancel, flush, pending]);
    return debouncedState;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteral(["\n    <h1>", "</h1>\n    <input type=\"text\" @keyup=", " value=", " />\n    <div>", "</div>\n  "]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  function predictiveSearch() {
    var _useState = useState(''),
        _useState2 = _slicedToArray(_useState, 2),
        q = _useState2[0],
        setQ = _useState2[1];

    var _useState3 = useState({}),
        _useState4 = _slicedToArray(_useState3, 2),
        results = _useState4[0],
        setResults = _useState4[1];

    var _useState5 = useState(false),
        _useState6 = _slicedToArray(_useState5, 2),
        loading = _useState6[0],
        setLoading = _useState6[1];

    var debounced = useDebouncedCallback(function () {
      getPredictiveSearchResults(q).then(function setValue(response) {
        setLoading(false);

        if (response.message) {
          setResults({});
        } else {
          setResults(response.resources.results);
        }
      });
    }, 500);

    var handleKeyup = function handleKeyup(event) {
      setLoading(true);
      setQ(event.target.value);
      debounced.callback(event.target.value);
    };

    return html(_templateObject(), "".concat(loading ? 'loading...' : 'loaded'), handleKeyup, q, JSON.stringify(results));
  }

  customElements.define('predictive-search', component(predictiveSearch, {
    useShadowDOM: false
  }));

  function _templateObject8() {
    var data = _taggedTemplateLiteral([""]);

    _templateObject8 = function _templateObject8() {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    var data = _taggedTemplateLiteral(["Added"]);

    _templateObject7 = function _templateObject7() {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    var data = _taggedTemplateLiteral(["<span class=\"spinner-border\"></span>"]);

    _templateObject6 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    var data = _taggedTemplateLiteral(["Add To Cart"]);

    _templateObject5 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    var data = _taggedTemplateLiteral(["Not Available"]);

    _templateObject4 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    var data = _taggedTemplateLiteral(["<option\n                  value=\"", "\"\n                  ?selected=", "\n                >\n                  ", "\n                </option>"]);

    _templateObject3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    var data = _taggedTemplateLiteral(["<div\n          class=\"selector-wrapper form-group ", "\"\n          ?hidden=", "\n        >\n          <label class=\"", "\" for=\"", "\"\n            >", ":</label\n          >\n          <select\n            id=\"", "\"\n            data-option=\"option", "\"\n            @change=", "\n            class=\"form-control ", "\"\n          >\n            ", "\n          </select>\n        </div>"]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$1() {
    var data = _taggedTemplateLiteral(["<input\n      name=\"id\"\n      value=\"", "\"\n      type=\"hidden\"\n    />\n    ", "\n    <input\n      class=\"form-control quantity_input ", "\"\n      name=\"quantity\"\n      type=\"number\"\n      value=\"1\"\n      step=\"1\"\n    />\n    <button\n      ?disabled=", "\n      @click=", "\n      type=\"submit\"\n      name=\"add\"\n      class=\"form-control AddToCart btn ", "\"\n    >\n      <span class=\"AddToCartText\"\n        >", "</span\n      >\n    </button>\n    <div class=\"error-description\" ?hidden=", ">\n      ", "\n    </div>"]);

    _templateObject$1 = function _templateObject() {
      return data;
    };

    return data;
  }

  function atcDropdownInputs(_ref) {
    var _this = this;

    var dataProduct = _ref.dataProduct,
        dataSelectedOrFirstAvailableVariant = _ref.dataSelectedOrFirstAvailableVariant,
        dataOptionsWithValues = _ref.dataOptionsWithValues,
        _ref$selectorWrapperC = _ref.selectorWrapperCustomClasses,
        selectorWrapperCustomClasses = _ref$selectorWrapperC === void 0 ? '' : _ref$selectorWrapperC,
        _ref$selectorLabelCus = _ref.selectorLabelCustomClasses,
        selectorLabelCustomClasses = _ref$selectorLabelCus === void 0 ? '' : _ref$selectorLabelCus,
        _ref$selectorCustomCl = _ref.selectorCustomClasses,
        selectorCustomClasses = _ref$selectorCustomCl === void 0 ? '' : _ref$selectorCustomCl,
        _ref$quantityInputCus = _ref.quantityInputCustomClasses,
        quantityInputCustomClasses = _ref$quantityInputCus === void 0 ? '' : _ref$quantityInputCus,
        _ref$atcButtonCustomC = _ref.atcButtonCustomClasses,
        atcButtonCustomClasses = _ref$atcButtonCustomC === void 0 ? '' : _ref$atcButtonCustomC;
    var product = JSON.parse(dataProduct);
    var optionsWithValues = JSON.parse(dataOptionsWithValues);

    var _useState = useState(product.variants.find(function (variant) {
      return variant.id === parseInt(dataSelectedOrFirstAvailableVariant, 10);
    })),
        _useState2 = _slicedToArray(_useState, 2),
        currentVariant = _useState2[0],
        setCurrentVariant = _useState2[1];

    var _useState3 = useState('suspended'),
        _useState4 = _slicedToArray(_useState3, 2),
        status = _useState4[0],
        setStatus = _useState4[1]; // there should be four kinds of status, suspended, loading, success, error


    var _useState5 = useState(''),
        _useState6 = _slicedToArray(_useState5, 2),
        errorDescription = _useState6[0],
        setErrorDescription = _useState6[1];

    var handleOptionChange = function handleOptionChange() {
      var form = _this.closest('form');

      var option1 = _this.querySelector('select[data-option="option1"]') && _this.querySelector('select[data-option="option1"]').value;

      var option2 = _this.querySelector('select[data-option="option2"]') && _this.querySelector('select[data-option="option2"]').value;

      var option3 = _this.querySelector('select[data-option="option3"]') && _this.querySelector('select[data-option="option3"]').value;

      var cVariant = product.variants.find(function (variant) {
        return variant.option1 === option1 && variant.option2 === option2 && variant.option3 === option3;
      });
      setCurrentVariant(cVariant);
      dispatchCustomEvent$1(form, 'variantchanged', {
        bubbles: true,
        composed: true,
        detail: {
          currentVariant: cVariant,
          formatMoney: formatMoney
        }
      });
    };

    var handleATCButtonClick = function handleATCButtonClick(e) {
      if (_this.closest('form').id) {
        e.preventDefault();

        var form = _this.closest('form');

        setStatus('loading');
        addItemFromForm(form).then(function (addedItem) {
          if (addedItem.id) {
            setStatus('success');
            getCart().then(function (cart) {
              dispatchCustomEvent$1(form, 'cartupdated', {
                bubbles: true,
                composed: true,
                detail: {
                  cart: cart
                }
              });
            });
            setTimeout(function () {
              setStatus('suspended');
            }, 1000);
          }

          if (addedItem.description) {
            setStatus('error');
            setErrorDescription(addedItem.description);
            setTimeout(function () {
              setErrorDescription('');
              setStatus('suspended');
            }, 1000);
          }
        });
      }
    };

    return html(_templateObject$1(), currentVariant && currentVariant.id, optionsWithValues.map(function (option) {
      return html(_templateObject2(), selectorWrapperCustomClasses, option.name === 'Title' && option.values[0] === 'Default Title', selectorLabelCustomClasses, option.name, option.name, option.name, option.position, handleOptionChange, selectorCustomClasses, option.values.map(function (value) {
        return html(_templateObject3(), value, currentVariant && currentVariant["option".concat(option.position)] === value, value);
      }));
    }), quantityInputCustomClasses, !currentVariant || !currentVariant.available, handleATCButtonClick, atcButtonCustomClasses, currentVariant && !currentVariant.available ? html(_templateObject4()) : status === 'suspended' ? html(_templateObject5()) : status === 'loading' ? html(_templateObject6()) : status === 'success' ? html(_templateObject7()) : html(_templateObject8()), errorDescription === '', errorDescription);
  }

  customElements.define('atc-dropdown-inputs', component(atcDropdownInputs, {
    useShadowDOM: false,
    observedAttributes: ['data-product', 'data-selected-or-first-available-variant', 'data-options-with-values', 'selector-wrapper-custom-classes', 'selector-label-custom-classes', 'selector-custom-classes', 'quantity-input-custom-classes', 'atc-button-custom-classes']
  }));

  window.datomar = {
    BSN: index,
    apis: apis
  };

})));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ib290c3RyYXAubmF0aXZlL2Rpc3QvYm9vdHN0cmFwLW5hdGl2ZS5lc20uanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanMiLCJzcmMvc2NyaXB0cy9oZWxwZXIuanMiLCJzcmMvc2NyaXB0cy9hamF4YXBpcy5qcyIsIm5vZGVfbW9kdWxlcy9nbGlkZXItanMvZ2xpZGVyLmpzIiwic3JjL3NjcmlwdHMvc2VjdGlvbnMvdGVzdGltb25pYWxzLmpzIiwic3JjL3NjcmlwdHMvc2VjdGlvbnMvaGVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL21hY3kvZGlzdC9tYWN5LmpzIiwic3JjL3NjcmlwdHMvc2VjdGlvbnMvbWFzb25yeS1nYWxsZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9kaXJlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvcGFydC5qcyIsIm5vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL3RlbXBsYXRlLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi90ZW1wbGF0ZS1yZXN1bHQuanMiLCJub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL3BhcnRzLmpzIiwibm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcyIsIm5vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUtZmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpdC1odG1sLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL2ludGVyZmFjZS5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi9zeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi9jb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvaG9vay5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi9jcmVhdGUtZWZmZWN0LmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3VzZS1lZmZlY3QuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvdXNlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvY3JlYXRlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvdXNlLW1lbW8uanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvdXNlLWNhbGxiYWNrLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3VzZS1sYXlvdXQtZWZmZWN0LmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3VzZS1zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi91c2UtcmVkdWNlci5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi91c2UtcmVmLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL2NvcmUuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvbGl0LWhhdW50ZWQuanMiLCJzcmMvc2NyaXB0cy9jb21wb25lbnRzL2N1c3RvbS1ob29rcy5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvcHJlZGljdGl2ZS1zZWFyY2guanMiLCJzcmMvc2NyaXB0cy9jb21wb25lbnRzL2F0Yy1kcm9wZG93bi1pbnB1dHMuanMiLCJzcmMvc2NyaXB0cy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIHYzLjAuMTAgKGh0dHBzOi8vdGhlZG5wLmdpdGh1Yi5pby9ib290c3RyYXAubmF0aXZlLylcbiAgKiBDb3B5cmlnaHQgMjAxNS0yMDIwIMKpIGRucF90aGVtZVxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3RoZWRucC9ib290c3RyYXAubmF0aXZlL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gICovXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG5cbnZhciBzdXBwb3J0VHJhbnNpdGlvbiA9ICd3ZWJraXRUcmFuc2l0aW9uJyBpbiBkb2N1bWVudC5oZWFkLnN0eWxlIHx8ICd0cmFuc2l0aW9uJyBpbiBkb2N1bWVudC5oZWFkLnN0eWxlO1xuXG52YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uJyA6ICd0cmFuc2l0aW9uRHVyYXRpb24nO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50VHJhbnNpdGlvbkR1cmF0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGR1cmF0aW9uID0gc3VwcG9ydFRyYW5zaXRpb24gPyBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbdHJhbnNpdGlvbkR1cmF0aW9uXSkgOiAwO1xuICBkdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGR1cmF0aW9uKSA/IGR1cmF0aW9uICogMTAwMCA6IDA7XG4gIHJldHVybiBkdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gZW11bGF0ZVRyYW5zaXRpb25FbmQoZWxlbWVudCxoYW5kbGVyKXtcbiAgdmFyIGNhbGxlZCA9IDAsIGR1cmF0aW9uID0gZ2V0RWxlbWVudFRyYW5zaXRpb25EdXJhdGlvbihlbGVtZW50KTtcbiAgZHVyYXRpb24gPyBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHRyYW5zaXRpb25FbmRFdmVudCwgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZFdyYXBwZXIoZSl7XG4gICAgICAgICAgICAgICFjYWxsZWQgJiYgaGFuZGxlcihlKSwgY2FsbGVkID0gMTtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0cmFuc2l0aW9uRW5kRXZlbnQsIHRyYW5zaXRpb25FbmRXcmFwcGVyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgIDogc2V0VGltZW91dChmdW5jdGlvbigpIHsgIWNhbGxlZCAmJiBoYW5kbGVyKCksIGNhbGxlZCA9IDE7IH0sIDE3KTtcbn1cblxuZnVuY3Rpb24gcXVlcnlFbGVtZW50KHNlbGVjdG9yLCBwYXJlbnQpIHtcbiAgdmFyIGxvb2tVcCA9IHBhcmVudCAmJiBwYXJlbnQgaW5zdGFuY2VvZiBFbGVtZW50ID8gcGFyZW50IDogZG9jdW1lbnQ7XG4gIHJldHVybiBzZWxlY3RvciBpbnN0YW5jZW9mIEVsZW1lbnQgPyBzZWxlY3RvciA6IGxvb2tVcC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBjb21wb25lbnROYW1lLCByZWxhdGVkKSB7XG4gIHZhciBPcmlnaW5hbEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCBldmVudE5hbWUgKyAnLmJzLicgKyBjb21wb25lbnROYW1lLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pO1xuICBPcmlnaW5hbEN1c3RvbUV2ZW50LnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkO1xuICByZXR1cm4gT3JpZ2luYWxDdXN0b21FdmVudDtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDdXN0b21FdmVudChjdXN0b21FdmVudCl7XG4gIHRoaXMgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcbn1cblxuZnVuY3Rpb24gQWxlcnQoZWxlbWVudCkge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgYWxlcnQsXG4gICAgY2xvc2VDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdjbG9zZScsJ2FsZXJ0JyksXG4gICAgY2xvc2VkQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnY2xvc2VkJywnYWxlcnQnKTtcbiAgZnVuY3Rpb24gdHJpZ2dlckhhbmRsZXIoKSB7XG4gICAgYWxlcnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykgPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChhbGVydCx0cmFuc2l0aW9uRW5kSGFuZGxlcikgOiB0cmFuc2l0aW9uRW5kSGFuZGxlcigpO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUV2ZW50cyhhY3Rpb24pe1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBlbGVtZW50W2FjdGlvbl0oJ2NsaWNrJyxjbGlja0hhbmRsZXIsZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgYWxlcnQgPSBlICYmIGUudGFyZ2V0LmNsb3Nlc3QoXCIuYWxlcnRcIik7XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudCgnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJyxhbGVydCk7XG4gICAgZWxlbWVudCAmJiBhbGVydCAmJiAoZWxlbWVudCA9PT0gZS50YXJnZXQgfHwgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpICYmIHNlbGYuY2xvc2UoKTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kSGFuZGxlcigpIHtcbiAgICB0b2dnbGVFdmVudHMoKTtcbiAgICBhbGVydC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFsZXJ0KTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWxlcnQsY2xvc2VkQ3VzdG9tRXZlbnQpO1xuICB9XG4gIHNlbGYuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCBhbGVydCAmJiBlbGVtZW50ICYmIGFsZXJ0LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICkge1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGFsZXJ0LGNsb3NlQ3VzdG9tRXZlbnQpO1xuICAgICAgaWYgKCBjbG9zZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgICAgc2VsZi5kaXNwb3NlKCk7XG4gICAgICBhbGVydC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICB0cmlnZ2VySGFuZGxlcigpO1xuICAgIH1cbiAgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgIGRlbGV0ZSBlbGVtZW50LkFsZXJ0O1xuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBhbGVydCA9IGVsZW1lbnQuY2xvc2VzdCgnLmFsZXJ0Jyk7XG4gIGVsZW1lbnQuQWxlcnQgJiYgZWxlbWVudC5BbGVydC5kaXNwb3NlKCk7XG4gIGlmICggIWVsZW1lbnQuQWxlcnQgKSB7XG4gICAgdG9nZ2xlRXZlbnRzKDEpO1xuICB9XG4gIHNlbGYuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIGVsZW1lbnQuQWxlcnQgPSBzZWxmO1xufVxuXG5mdW5jdGlvbiBCdXR0b24oZWxlbWVudCkge1xuICB2YXIgc2VsZiA9IHRoaXMsIGxhYmVscyxcbiAgICAgIGNoYW5nZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2NoYW5nZScsICdidXR0b24nKTtcbiAgZnVuY3Rpb24gdG9nZ2xlKGUpIHtcbiAgICB2YXIgaW5wdXQsXG4gICAgICAgIGxhYmVsID0gZS50YXJnZXQudGFnTmFtZSA9PT0gJ0xBQkVMJyA/IGUudGFyZ2V0XG4gICAgICAgICAgICAgIDogZS50YXJnZXQuY2xvc2VzdCgnTEFCRUwnKSA/IGUudGFyZ2V0LmNsb3Nlc3QoJ0xBQkVMJykgOiBudWxsO1xuICAgIGlucHV0ID0gbGFiZWwgJiYgbGFiZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0lOUFVUJylbMF07XG4gICAgaWYgKCAhaW5wdXQgKSB7IHJldHVybjsgfVxuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChpbnB1dCwgY2hhbmdlQ3VzdG9tRXZlbnQpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBjaGFuZ2VDdXN0b21FdmVudCk7XG4gICAgaWYgKCBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnICkge1xuICAgICAgaWYgKCBjaGFuZ2VDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICAgIGlmICggIWlucHV0LmNoZWNrZWQgKSB7XG4gICAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdjaGVja2VkJywnY2hlY2tlZCcpO1xuICAgICAgICBpbnB1dC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudC50b2dnbGVkKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICggaW5wdXQudHlwZSA9PT0gJ3JhZGlvJyAmJiAhZWxlbWVudC50b2dnbGVkICkge1xuICAgICAgaWYgKCBjaGFuZ2VDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICAgIGlmICggIWlucHV0LmNoZWNrZWQgfHwgKGUuc2NyZWVuWCA9PT0gMCAmJiBlLnNjcmVlblkgPT0gMCkgKSB7XG4gICAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmb2N1cycpO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCdjaGVja2VkJyk7XG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICBlbGVtZW50LnRvZ2dsZWQgPSB0cnVlO1xuICAgICAgICBBcnJheS5mcm9tKGxhYmVscykubWFwKGZ1bmN0aW9uIChvdGhlckxhYmVsKXtcbiAgICAgICAgICB2YXIgb3RoZXJJbnB1dCA9IG90aGVyTGFiZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0lOUFVUJylbMF07XG4gICAgICAgICAgaWYgKCBvdGhlckxhYmVsICE9PSBsYWJlbCAmJiBvdGhlckxhYmVsLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgKSAge1xuICAgICAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKG90aGVySW5wdXQsIGNoYW5nZUN1c3RvbUV2ZW50KTtcbiAgICAgICAgICAgIG90aGVyTGFiZWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICBvdGhlcklucHV0LnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgICAgICAgb3RoZXJJbnB1dC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VGltZW91dCggZnVuY3Rpb24gKCkgeyBlbGVtZW50LnRvZ2dsZWQgPSBmYWxzZTsgfSwgNTAgKTtcbiAgfVxuICBmdW5jdGlvbiBrZXlIYW5kbGVyKGUpIHtcbiAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAga2V5ID09PSAzMiAmJiBlLnRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiB0b2dnbGUoZSk7XG4gIH1cbiAgZnVuY3Rpb24gcHJldmVudFNjcm9sbChlKSB7XG4gICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgIGtleSA9PT0gMzIgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZvY3VzVG9nZ2xlKGUpIHtcbiAgICBpZiAoZS50YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJyApIHtcbiAgICAgIHZhciBhY3Rpb24gPSBlLnR5cGUgPT09ICdmb2N1c2luJyA/ICdhZGQnIDogJ3JlbW92ZSc7XG4gICAgICBlLnRhcmdldC5jbG9zZXN0KCcuYnRuJykuY2xhc3NMaXN0W2FjdGlvbl0oJ2ZvY3VzJyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUV2ZW50cyhhY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgZWxlbWVudFthY3Rpb25dKCdjbGljaycsdG9nZ2xlLGZhbHNlICk7XG4gICAgZWxlbWVudFthY3Rpb25dKCdrZXl1cCcsa2V5SGFuZGxlcixmYWxzZSksIGVsZW1lbnRbYWN0aW9uXSgna2V5ZG93bicscHJldmVudFNjcm9sbCxmYWxzZSk7XG4gICAgZWxlbWVudFthY3Rpb25dKCdmb2N1c2luJyxmb2N1c1RvZ2dsZSxmYWxzZSksIGVsZW1lbnRbYWN0aW9uXSgnZm9jdXNvdXQnLGZvY3VzVG9nZ2xlLGZhbHNlKTtcbiAgfVxuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgZGVsZXRlIGVsZW1lbnQuQnV0dG9uO1xuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBlbGVtZW50LkJ1dHRvbiAmJiBlbGVtZW50LkJ1dHRvbi5kaXNwb3NlKCk7XG4gIGxhYmVscyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYnRuJyk7XG4gIGlmICghbGFiZWxzLmxlbmd0aCkgeyByZXR1cm47IH1cbiAgaWYgKCAhZWxlbWVudC5CdXR0b24gKSB7XG4gICAgdG9nZ2xlRXZlbnRzKDEpO1xuICB9XG4gIGVsZW1lbnQudG9nZ2xlZCA9IGZhbHNlO1xuICBlbGVtZW50LkJ1dHRvbiA9IHNlbGY7XG4gIEFycmF5LmZyb20obGFiZWxzKS5tYXAoZnVuY3Rpb24gKGJ0bil7XG4gICAgIWJ0bi5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpXG4gICAgICAmJiBxdWVyeUVsZW1lbnQoJ2lucHV0OmNoZWNrZWQnLGJ0bilcbiAgICAgICYmIGJ0bi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICBidG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKVxuICAgICAgJiYgIXF1ZXJ5RWxlbWVudCgnaW5wdXQ6Y2hlY2tlZCcsYnRuKVxuICAgICAgJiYgYnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICB9KTtcbn1cblxudmFyIG1vdXNlSG92ZXJFdmVudHMgPSAoJ29ubW91c2VsZWF2ZScgaW4gZG9jdW1lbnQpID8gWyAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ10gOiBbICdtb3VzZW92ZXInLCAnbW91c2VvdXQnIF07XG5cbnZhciBzdXBwb3J0UGFzc2l2ZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiB3cmFwKCl7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgd3JhcCwgb3B0cyk7XG4gICAgfSwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiByZXN1bHQ7XG59KSgpO1xuXG52YXIgcGFzc2l2ZUhhbmRsZXIgPSBzdXBwb3J0UGFzc2l2ZSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudEluU2Nyb2xsUmFuZ2UoZWxlbWVudCkge1xuICB2YXIgYmNyID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHZpZXdwb3J0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJldHVybiBiY3IudG9wIDw9IHZpZXdwb3J0SGVpZ2h0ICYmIGJjci5ib3R0b20gPj0gMDtcbn1cblxuZnVuY3Rpb24gQ2Fyb3VzZWwgKGVsZW1lbnQsb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgIHZhcnMsIG9wcyxcbiAgICBzbGlkZUN1c3RvbUV2ZW50LCBzbGlkQ3VzdG9tRXZlbnQsXG4gICAgc2xpZGVzLCBsZWZ0QXJyb3csIHJpZ2h0QXJyb3csIGluZGljYXRvciwgaW5kaWNhdG9ycztcbiAgZnVuY3Rpb24gcGF1c2VIYW5kbGVyKCkge1xuICAgIGlmICggb3BzLmludGVydmFsICE9PWZhbHNlICYmICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGF1c2VkJykgKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3BhdXNlZCcpO1xuICAgICAgIXZhcnMuaXNTbGlkaW5nICYmICggY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKSwgdmFycy50aW1lciA9IG51bGwgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lSGFuZGxlcigpIHtcbiAgICBpZiAoIG9wcy5pbnRlcnZhbCAhPT0gZmFsc2UgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhdXNlZCcpICkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdwYXVzZWQnKTtcbiAgICAgICF2YXJzLmlzU2xpZGluZyAmJiAoIGNsZWFySW50ZXJ2YWwodmFycy50aW1lciksIHZhcnMudGltZXIgPSBudWxsICk7XG4gICAgICAhdmFycy5pc1NsaWRpbmcgJiYgc2VsZi5jeWNsZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbmRpY2F0b3JIYW5kbGVyKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHZhcnMuaXNTbGlkaW5nKSB7IHJldHVybjsgfVxuICAgIHZhciBldmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICAgIGlmICggZXZlbnRUYXJnZXQgJiYgIWV2ZW50VGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgJiYgZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsaWRlLXRvJykgKSB7XG4gICAgICB2YXJzLmluZGV4ID0gcGFyc2VJbnQoIGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGlkZS10bycpKTtcbiAgICB9IGVsc2UgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBzZWxmLnNsaWRlVG8oIHZhcnMuaW5kZXggKTtcbiAgfVxuICBmdW5jdGlvbiBjb250cm9sc0hhbmRsZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGV2ZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICBpZiAoIGV2ZW50VGFyZ2V0ID09PSByaWdodEFycm93ICkge1xuICAgICAgdmFycy5pbmRleCsrO1xuICAgIH0gZWxzZSBpZiAoIGV2ZW50VGFyZ2V0ID09PSBsZWZ0QXJyb3cgKSB7XG4gICAgICB2YXJzLmluZGV4LS07XG4gICAgfVxuICAgIHNlbGYuc2xpZGVUbyggdmFycy5pbmRleCApO1xuICB9XG4gIGZ1bmN0aW9uIGtleUhhbmRsZXIocmVmKSB7XG4gICAgdmFyIHdoaWNoID0gcmVmLndoaWNoO1xuICAgIGlmICh2YXJzLmlzU2xpZGluZykgeyByZXR1cm47IH1cbiAgICBzd2l0Y2ggKHdoaWNoKSB7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICB2YXJzLmluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNzpcbiAgICAgICAgdmFycy5pbmRleC0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5zbGlkZVRvKCB2YXJzLmluZGV4ICk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFjdGlvbikge1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBpZiAoIG9wcy5wYXVzZSAmJiBvcHMuaW50ZXJ2YWwgKSB7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oIG1vdXNlSG92ZXJFdmVudHNbMF0sIHBhdXNlSGFuZGxlciwgZmFsc2UgKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSggbW91c2VIb3ZlckV2ZW50c1sxXSwgcmVzdW1lSGFuZGxlciwgZmFsc2UgKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSggJ3RvdWNoc3RhcnQnLCBwYXVzZUhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oICd0b3VjaGVuZCcsIHJlc3VtZUhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgfVxuICAgIG9wcy50b3VjaCAmJiBzbGlkZXMubGVuZ3RoID4gMSAmJiBlbGVtZW50W2FjdGlvbl0oICd0b3VjaHN0YXJ0JywgdG91Y2hEb3duSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICByaWdodEFycm93ICYmIHJpZ2h0QXJyb3dbYWN0aW9uXSggJ2NsaWNrJywgY29udHJvbHNIYW5kbGVyLGZhbHNlICk7XG4gICAgbGVmdEFycm93ICYmIGxlZnRBcnJvd1thY3Rpb25dKCAnY2xpY2snLCBjb250cm9sc0hhbmRsZXIsZmFsc2UgKTtcbiAgICBpbmRpY2F0b3IgJiYgaW5kaWNhdG9yW2FjdGlvbl0oICdjbGljaycsIGluZGljYXRvckhhbmRsZXIsZmFsc2UgKTtcbiAgICBvcHMua2V5Ym9hcmQgJiYgd2luZG93W2FjdGlvbl0oICdrZXlkb3duJywga2V5SGFuZGxlcixmYWxzZSApO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZVRvdWNoRXZlbnRzKGFjdGlvbikge1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBlbGVtZW50W2FjdGlvbl0oICd0b3VjaG1vdmUnLCB0b3VjaE1vdmVIYW5kbGVyLCBwYXNzaXZlSGFuZGxlciApO1xuICAgIGVsZW1lbnRbYWN0aW9uXSggJ3RvdWNoZW5kJywgdG91Y2hFbmRIYW5kbGVyLCBwYXNzaXZlSGFuZGxlciApO1xuICB9XG4gIGZ1bmN0aW9uIHRvdWNoRG93bkhhbmRsZXIoZSkge1xuICAgIGlmICggdmFycy5pc1RvdWNoICkgeyByZXR1cm47IH1cbiAgICB2YXJzLnRvdWNoUG9zaXRpb24uc3RhcnRYID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcbiAgICBpZiAoIGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpICkge1xuICAgICAgdmFycy5pc1RvdWNoID0gdHJ1ZTtcbiAgICAgIHRvZ2dsZVRvdWNoRXZlbnRzKDEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b3VjaE1vdmVIYW5kbGVyKGUpIHtcbiAgICBpZiAoICF2YXJzLmlzVG91Y2ggKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuOyB9XG4gICAgdmFycy50b3VjaFBvc2l0aW9uLmN1cnJlbnRYID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcbiAgICBpZiAoIGUudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAxICkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b3VjaEVuZEhhbmRsZXIgKGUpIHtcbiAgICBpZiAoICF2YXJzLmlzVG91Y2ggfHwgdmFycy5pc1NsaWRpbmcgKSB7IHJldHVybiB9XG4gICAgdmFycy50b3VjaFBvc2l0aW9uLmVuZFggPSB2YXJzLnRvdWNoUG9zaXRpb24uY3VycmVudFggfHwgZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcbiAgICBpZiAoIHZhcnMuaXNUb3VjaCApIHtcbiAgICAgIGlmICggKCFlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSB8fCAhZWxlbWVudC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpIClcbiAgICAgICAgICAmJiBNYXRoLmFicyh2YXJzLnRvdWNoUG9zaXRpb24uc3RhcnRYIC0gdmFycy50b3VjaFBvc2l0aW9uLmVuZFgpIDwgNzUgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggdmFycy50b3VjaFBvc2l0aW9uLmN1cnJlbnRYIDwgdmFycy50b3VjaFBvc2l0aW9uLnN0YXJ0WCApIHtcbiAgICAgICAgICB2YXJzLmluZGV4Kys7XG4gICAgICAgIH0gZWxzZSBpZiAoIHZhcnMudG91Y2hQb3NpdGlvbi5jdXJyZW50WCA+IHZhcnMudG91Y2hQb3NpdGlvbi5zdGFydFggKSB7XG4gICAgICAgICAgdmFycy5pbmRleC0tO1xuICAgICAgICB9XG4gICAgICAgIHZhcnMuaXNUb3VjaCA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNsaWRlVG8odmFycy5pbmRleCk7XG4gICAgICB9XG4gICAgICB0b2dnbGVUb3VjaEV2ZW50cygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBY3RpdmVQYWdlKHBhZ2VJbmRleCkge1xuICAgIEFycmF5LmZyb20oaW5kaWNhdG9ycykubWFwKGZ1bmN0aW9uICh4KXt4LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO30pO1xuICAgIGluZGljYXRvcnNbcGFnZUluZGV4XSAmJiBpbmRpY2F0b3JzW3BhZ2VJbmRleF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZEhhbmRsZXIoZSl7XG4gICAgaWYgKHZhcnMudG91Y2hQb3NpdGlvbil7XG4gICAgICB2YXIgbmV4dCA9IHZhcnMuaW5kZXgsXG4gICAgICAgICAgdGltZW91dCA9IGUgJiYgZS50YXJnZXQgIT09IHNsaWRlc1tuZXh0XSA/IGUuZWxhcHNlZFRpbWUqMTAwMCsxMDAgOiAyMCxcbiAgICAgICAgICBhY3RpdmVJdGVtID0gc2VsZi5nZXRBY3RpdmVJbmRleCgpLFxuICAgICAgICAgIG9yaWVudGF0aW9uID0gdmFycy5kaXJlY3Rpb24gPT09ICdsZWZ0JyA/ICduZXh0JyA6ICdwcmV2JztcbiAgICAgIHZhcnMuaXNTbGlkaW5nICYmIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodmFycy50b3VjaFBvc2l0aW9uKXtcbiAgICAgICAgICB2YXJzLmlzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNsaWRlc1tuZXh0XS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICBzbGlkZXNbYWN0aXZlSXRlbV0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgc2xpZGVzW25leHRdLmNsYXNzTGlzdC5yZW1vdmUoKFwiY2Fyb3VzZWwtaXRlbS1cIiArIG9yaWVudGF0aW9uKSk7XG4gICAgICAgICAgc2xpZGVzW25leHRdLmNsYXNzTGlzdC5yZW1vdmUoKFwiY2Fyb3VzZWwtaXRlbS1cIiArICh2YXJzLmRpcmVjdGlvbikpKTtcbiAgICAgICAgICBzbGlkZXNbYWN0aXZlSXRlbV0uY2xhc3NMaXN0LnJlbW92ZSgoXCJjYXJvdXNlbC1pdGVtLVwiICsgKHZhcnMuZGlyZWN0aW9uKSkpO1xuICAgICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkQ3VzdG9tRXZlbnQpO1xuICAgICAgICAgIGlmICggIWRvY3VtZW50LmhpZGRlbiAmJiBvcHMuaW50ZXJ2YWwgJiYgIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYXVzZWQnKSApIHtcbiAgICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBzZWxmLmN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh2YXJzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHZhcnMudGltZXIpO1xuICAgICAgdmFycy50aW1lciA9IG51bGw7XG4gICAgfVxuICAgIHZhcnMudGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWR4ID0gdmFycy5pbmRleCB8fCBzZWxmLmdldEFjdGl2ZUluZGV4KCk7XG4gICAgICBpc0VsZW1lbnRJblNjcm9sbFJhbmdlKGVsZW1lbnQpICYmIChpZHgrKywgc2VsZi5zbGlkZVRvKCBpZHggKSApO1xuICAgIH0sIG9wcy5pbnRlcnZhbCk7XG4gIH07XG4gIHNlbGYuc2xpZGVUbyA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgaWYgKHZhcnMuaXNTbGlkaW5nKSB7IHJldHVybjsgfVxuICAgIHZhciBhY3RpdmVJdGVtID0gc2VsZi5nZXRBY3RpdmVJbmRleCgpLCBvcmllbnRhdGlvbjtcbiAgICBpZiAoIGFjdGl2ZUl0ZW0gPT09IG5leHQgKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICAoIChhY3RpdmVJdGVtIDwgbmV4dCApIHx8IChhY3RpdmVJdGVtID09PSAwICYmIG5leHQgPT09IHNsaWRlcy5sZW5ndGggLTEgKSApIHtcbiAgICAgIHZhcnMuZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAgKCAoYWN0aXZlSXRlbSA+IG5leHQpIHx8IChhY3RpdmVJdGVtID09PSBzbGlkZXMubGVuZ3RoIC0gMSAmJiBuZXh0ID09PSAwICkgKSB7XG4gICAgICB2YXJzLmRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIGlmICggbmV4dCA8IDAgKSB7IG5leHQgPSBzbGlkZXMubGVuZ3RoIC0gMTsgfVxuICAgIGVsc2UgaWYgKCBuZXh0ID49IHNsaWRlcy5sZW5ndGggKXsgbmV4dCA9IDA7IH1cbiAgICBvcmllbnRhdGlvbiA9IHZhcnMuZGlyZWN0aW9uID09PSAnbGVmdCcgPyAnbmV4dCcgOiAncHJldic7XG4gICAgc2xpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzbGlkZScsICdjYXJvdXNlbCcsIHNsaWRlc1tuZXh0XSk7XG4gICAgc2xpZEN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3NsaWQnLCAnY2Fyb3VzZWwnLCBzbGlkZXNbbmV4dF0pO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkZUN1c3RvbUV2ZW50KTtcbiAgICBpZiAoc2xpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgIHZhcnMuaW5kZXggPSBuZXh0O1xuICAgIHZhcnMuaXNTbGlkaW5nID0gdHJ1ZTtcbiAgICBjbGVhckludGVydmFsKHZhcnMudGltZXIpO1xuICAgIHZhcnMudGltZXIgPSBudWxsO1xuICAgIHNldEFjdGl2ZVBhZ2UoIG5leHQgKTtcbiAgICBpZiAoIGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24oc2xpZGVzW25leHRdKSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2xpZGUnKSApIHtcbiAgICAgIHNsaWRlc1tuZXh0XS5jbGFzc0xpc3QuYWRkKChcImNhcm91c2VsLWl0ZW0tXCIgKyBvcmllbnRhdGlvbikpO1xuICAgICAgc2xpZGVzW25leHRdLm9mZnNldFdpZHRoO1xuICAgICAgc2xpZGVzW25leHRdLmNsYXNzTGlzdC5hZGQoKFwiY2Fyb3VzZWwtaXRlbS1cIiArICh2YXJzLmRpcmVjdGlvbikpKTtcbiAgICAgIHNsaWRlc1thY3RpdmVJdGVtXS5jbGFzc0xpc3QuYWRkKChcImNhcm91c2VsLWl0ZW0tXCIgKyAodmFycy5kaXJlY3Rpb24pKSk7XG4gICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChzbGlkZXNbbmV4dF0sIHRyYW5zaXRpb25FbmRIYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGVzW25leHRdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgc2xpZGVzW25leHRdLm9mZnNldFdpZHRoO1xuICAgICAgc2xpZGVzW2FjdGl2ZUl0ZW1dLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhcnMuaXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICggb3BzLmludGVydmFsICYmIGVsZW1lbnQgJiYgIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYXVzZWQnKSApIHtcbiAgICAgICAgICBzZWxmLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNsaWRDdXN0b21FdmVudCk7XG4gICAgICB9LCAxMDAgKTtcbiAgICB9XG4gIH07XG4gIHNlbGYuZ2V0QWN0aXZlSW5kZXggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBBcnJheS5mcm9tKHNsaWRlcykuaW5kZXhPZihlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Nhcm91c2VsLWl0ZW0gYWN0aXZlJylbMF0pIHx8IDA7IH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXRlbUNsYXNzZXMgPSBbJ2xlZnQnLCdyaWdodCcsJ3ByZXYnLCduZXh0J107XG4gICAgQXJyYXkuZnJvbShzbGlkZXMpLm1hcChmdW5jdGlvbiAoc2xpZGUsaWR4KSB7XG4gICAgICBzbGlkZS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICYmIHNldEFjdGl2ZVBhZ2UoIGlkeCApO1xuICAgICAgaXRlbUNsYXNzZXMubWFwKGZ1bmN0aW9uIChjbHMpIHsgcmV0dXJuIHNsaWRlLmNsYXNzTGlzdC5yZW1vdmUoKFwiY2Fyb3VzZWwtaXRlbS1cIiArIGNscykpOyB9KTtcbiAgICB9KTtcbiAgICBjbGVhckludGVydmFsKHZhcnMudGltZXIpO1xuICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgIHZhcnMgPSB7fTtcbiAgICBvcHMgPSB7fTtcbiAgICBkZWxldGUgZWxlbWVudC5DYXJvdXNlbDtcbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudCggZWxlbWVudCApO1xuICBlbGVtZW50LkNhcm91c2VsICYmIGVsZW1lbnQuQ2Fyb3VzZWwuZGlzcG9zZSgpO1xuICBzbGlkZXMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Nhcm91c2VsLWl0ZW0nKTtcbiAgbGVmdEFycm93ID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1jb250cm9sLXByZXYnKVswXTtcbiAgcmlnaHRBcnJvdyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2Fyb3VzZWwtY29udHJvbC1uZXh0JylbMF07XG4gIGluZGljYXRvciA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2Fyb3VzZWwtaW5kaWNhdG9ycycpWzBdO1xuICBpbmRpY2F0b3JzID0gaW5kaWNhdG9yICYmIGluZGljYXRvci5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJMSVwiICkgfHwgW107XG4gIGlmIChzbGlkZXMubGVuZ3RoIDwgMikgeyByZXR1cm4gfVxuICB2YXJcbiAgICBpbnRlcnZhbEF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWludGVydmFsJyksXG4gICAgaW50ZXJ2YWxEYXRhID0gaW50ZXJ2YWxBdHRyaWJ1dGUgPT09ICdmYWxzZScgPyAwIDogcGFyc2VJbnQoaW50ZXJ2YWxBdHRyaWJ1dGUpLFxuICAgIHRvdWNoRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRvdWNoJykgPT09ICdmYWxzZScgPyAwIDogMSxcbiAgICBwYXVzZURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1wYXVzZScpID09PSAnaG92ZXInIHx8IGZhbHNlLFxuICAgIGtleWJvYXJkRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWtleWJvYXJkJykgPT09ICd0cnVlJyB8fCBmYWxzZSxcbiAgICBpbnRlcnZhbE9wdGlvbiA9IG9wdGlvbnMuaW50ZXJ2YWwsXG4gICAgdG91Y2hPcHRpb24gPSBvcHRpb25zLnRvdWNoO1xuICBvcHMgPSB7fTtcbiAgb3BzLmtleWJvYXJkID0gb3B0aW9ucy5rZXlib2FyZCA9PT0gdHJ1ZSB8fCBrZXlib2FyZERhdGE7XG4gIG9wcy5wYXVzZSA9IChvcHRpb25zLnBhdXNlID09PSAnaG92ZXInIHx8IHBhdXNlRGF0YSkgPyAnaG92ZXInIDogZmFsc2U7XG4gIG9wcy50b3VjaCA9IHRvdWNoT3B0aW9uIHx8IHRvdWNoRGF0YTtcbiAgb3BzLmludGVydmFsID0gdHlwZW9mIGludGVydmFsT3B0aW9uID09PSAnbnVtYmVyJyA/IGludGVydmFsT3B0aW9uXG4gICAgICAgICAgICAgIDogaW50ZXJ2YWxPcHRpb24gPT09IGZhbHNlIHx8IGludGVydmFsRGF0YSA9PT0gMCB8fCBpbnRlcnZhbERhdGEgPT09IGZhbHNlID8gMFxuICAgICAgICAgICAgICA6IGlzTmFOKGludGVydmFsRGF0YSkgPyA1MDAwXG4gICAgICAgICAgICAgIDogaW50ZXJ2YWxEYXRhO1xuICBpZiAoc2VsZi5nZXRBY3RpdmVJbmRleCgpPDApIHtcbiAgICBzbGlkZXMubGVuZ3RoICYmIHNsaWRlc1swXS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICBpbmRpY2F0b3JzLmxlbmd0aCAmJiBzZXRBY3RpdmVQYWdlKDApO1xuICB9XG4gIHZhcnMgPSB7fTtcbiAgdmFycy5kaXJlY3Rpb24gPSAnbGVmdCc7XG4gIHZhcnMuaW5kZXggPSAwO1xuICB2YXJzLnRpbWVyID0gbnVsbDtcbiAgdmFycy5pc1NsaWRpbmcgPSBmYWxzZTtcbiAgdmFycy5pc1RvdWNoID0gZmFsc2U7XG4gIHZhcnMudG91Y2hQb3NpdGlvbiA9IHtcbiAgICBzdGFydFggOiAwLFxuICAgIGN1cnJlbnRYIDogMCxcbiAgICBlbmRYIDogMFxuICB9O1xuICB0b2dnbGVFdmVudHMoMSk7XG4gIGlmICggb3BzLmludGVydmFsICl7IHNlbGYuY3ljbGUoKTsgfVxuICBlbGVtZW50LkNhcm91c2VsID0gc2VsZjtcbn1cblxuZnVuY3Rpb24gQ29sbGFwc2UoZWxlbWVudCxvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhY2NvcmRpb24gPSBudWxsLFxuICAgICAgY29sbGFwc2UgPSBudWxsLFxuICAgICAgYWN0aXZlQ29sbGFwc2UsXG4gICAgICBhY3RpdmVFbGVtZW50LFxuICAgICAgc2hvd0N1c3RvbUV2ZW50LFxuICAgICAgc2hvd25DdXN0b21FdmVudCxcbiAgICAgIGhpZGVDdXN0b21FdmVudCxcbiAgICAgIGhpZGRlbkN1c3RvbUV2ZW50O1xuICBmdW5jdGlvbiBvcGVuQWN0aW9uKGNvbGxhcHNlRWxlbWVudCwgdG9nZ2xlKSB7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGNvbGxhcHNlRWxlbWVudCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICBpZiAoIHNob3dDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICBjb2xsYXBzZUVsZW1lbnQuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzaW5nJyk7XG4gICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbGxhcHNlJyk7XG4gICAgY29sbGFwc2VFbGVtZW50LnN0eWxlLmhlaWdodCA9IChjb2xsYXBzZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0KSArIFwicHhcIjtcbiAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChjb2xsYXBzZUVsZW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgY29sbGFwc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsJ3RydWUnKTtcbiAgICAgIHRvZ2dsZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCd0cnVlJyk7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2luZycpO1xuICAgICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlJyk7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgICAgY29sbGFwc2VFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGNvbGxhcHNlRWxlbWVudCwgc2hvd25DdXN0b21FdmVudCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xvc2VBY3Rpb24oY29sbGFwc2VFbGVtZW50LCB0b2dnbGUpIHtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgIGlmICggaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgIGNvbGxhcHNlRWxlbWVudC5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgY29sbGFwc2VFbGVtZW50LnN0eWxlLmhlaWdodCA9IChjb2xsYXBzZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0KSArIFwicHhcIjtcbiAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2UnKTtcbiAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzaW5nJyk7XG4gICAgY29sbGFwc2VFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIGNvbGxhcHNlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMHB4JztcbiAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChjb2xsYXBzZUVsZW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgY29sbGFwc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsJ2ZhbHNlJyk7XG4gICAgICB0b2dnbGUuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywnZmFsc2UnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzaW5nJyk7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2UnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuICBzZWxmLnRvZ2dsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUgJiYgZS50YXJnZXQudGFnTmFtZSA9PT0gJ0EnIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0EnKSB7ZS5wcmV2ZW50RGVmYXVsdCgpO31cbiAgICBpZiAoZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkgfHwgZS50YXJnZXQgPT09IGVsZW1lbnQpIHtcbiAgICAgIGlmICghY29sbGFwc2UuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHsgc2VsZi5zaG93KCk7IH1cbiAgICAgIGVsc2UgeyBzZWxmLmhpZGUoKTsgfVxuICAgIH1cbiAgfTtcbiAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICggY29sbGFwc2UuaXNBbmltYXRpbmcgKSB7IHJldHVybjsgfVxuICAgIGNsb3NlQWN0aW9uKGNvbGxhcHNlLGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2VkJyk7XG4gIH07XG4gIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIGFjY29yZGlvbiApIHtcbiAgICAgIGFjdGl2ZUNvbGxhcHNlID0gYWNjb3JkaW9uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJjb2xsYXBzZSBzaG93XCIpWzBdO1xuICAgICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUNvbGxhcHNlICYmIChxdWVyeUVsZW1lbnQoKFwiW2RhdGEtdGFyZ2V0PVxcXCIjXCIgKyAoYWN0aXZlQ29sbGFwc2UuaWQpICsgXCJcXFwiXVwiKSxhY2NvcmRpb24pXG4gICAgICAgICAgICAgICAgICAgIHx8IHF1ZXJ5RWxlbWVudCgoXCJbaHJlZj1cXFwiI1wiICsgKGFjdGl2ZUNvbGxhcHNlLmlkKSArIFwiXFxcIl1cIiksYWNjb3JkaW9uKSApO1xuICAgIH1cbiAgICBpZiAoICFjb2xsYXBzZS5pc0FuaW1hdGluZyApIHtcbiAgICAgIGlmICggYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVDb2xsYXBzZSAhPT0gY29sbGFwc2UgKSB7XG4gICAgICAgIGNsb3NlQWN0aW9uKGFjdGl2ZUNvbGxhcHNlLGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlZCcpO1xuICAgICAgfVxuICAgICAgb3BlbkFjdGlvbihjb2xsYXBzZSxlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2VkJyk7XG4gICAgfVxuICB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsc2VsZi50b2dnbGUsZmFsc2UpO1xuICAgIGRlbGV0ZSBlbGVtZW50LkNvbGxhcHNlO1xuICB9O1xuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5Db2xsYXBzZSAmJiBlbGVtZW50LkNvbGxhcHNlLmRpc3Bvc2UoKTtcbiAgICB2YXIgYWNjb3JkaW9uRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcmVudCcpO1xuICAgIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ2NvbGxhcHNlJyk7XG4gICAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93bicsICdjb2xsYXBzZScpO1xuICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ2NvbGxhcHNlJyk7XG4gICAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ2NvbGxhcHNlJyk7XG4gICAgY29sbGFwc2UgPSBxdWVyeUVsZW1lbnQob3B0aW9ucy50YXJnZXQgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7XG4gICAgY29sbGFwc2UuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICBhY2NvcmRpb24gPSBlbGVtZW50LmNsb3Nlc3Qob3B0aW9ucy5wYXJlbnQgfHwgYWNjb3JkaW9uRGF0YSk7XG4gICAgaWYgKCAhZWxlbWVudC5Db2xsYXBzZSApIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLHNlbGYudG9nZ2xlLGZhbHNlKTtcbiAgICB9XG4gICAgZWxlbWVudC5Db2xsYXBzZSA9IHNlbGY7XG59XG5cbmZ1bmN0aW9uIHNldEZvY3VzIChlbGVtZW50KXtcbiAgZWxlbWVudC5mb2N1cyA/IGVsZW1lbnQuZm9jdXMoKSA6IGVsZW1lbnQuc2V0QWN0aXZlKCk7XG59XG5cbmZ1bmN0aW9uIERyb3Bkb3duKGVsZW1lbnQsb3B0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHNob3dDdXN0b21FdmVudCxcbiAgICAgIHNob3duQ3VzdG9tRXZlbnQsXG4gICAgICBoaWRlQ3VzdG9tRXZlbnQsXG4gICAgICBoaWRkZW5DdXN0b21FdmVudCxcbiAgICAgIHJlbGF0ZWRUYXJnZXQgPSBudWxsLFxuICAgICAgcGFyZW50LCBtZW51LCBtZW51SXRlbXMgPSBbXSxcbiAgICAgIHBlcnNpc3Q7XG4gIGZ1bmN0aW9uIHByZXZlbnRFbXB0eUFuY2hvcihhbmNob3IpIHtcbiAgICAoYW5jaG9yLmhyZWYgJiYgYW5jaG9yLmhyZWYuc2xpY2UoLTEpID09PSAnIycgfHwgYW5jaG9yLnBhcmVudE5vZGUgJiYgYW5jaG9yLnBhcmVudE5vZGUuaHJlZlxuICAgICAgJiYgYW5jaG9yLnBhcmVudE5vZGUuaHJlZi5zbGljZSgtMSkgPT09ICcjJykgJiYgdGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZURpc21pc3MoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGVsZW1lbnQub3BlbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBkb2N1bWVudFthY3Rpb25dKCdjbGljaycsZGlzbWlzc0hhbmRsZXIsZmFsc2UpO1xuICAgIGRvY3VtZW50W2FjdGlvbl0oJ2tleWRvd24nLHByZXZlbnRTY3JvbGwsZmFsc2UpO1xuICAgIGRvY3VtZW50W2FjdGlvbl0oJ2tleXVwJyxrZXlIYW5kbGVyLGZhbHNlKTtcbiAgICBkb2N1bWVudFthY3Rpb25dKCdmb2N1cycsZGlzbWlzc0hhbmRsZXIsZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc21pc3NIYW5kbGVyKGUpIHtcbiAgICB2YXIgZXZlbnRUYXJnZXQgPSBlLnRhcmdldCxcbiAgICAgICAgICBoYXNEYXRhID0gZXZlbnRUYXJnZXQgJiYgKGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10b2dnbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBldmVudFRhcmdldC5wYXJlbnROb2RlICYmIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScpKTtcbiAgICBpZiAoIGUudHlwZSA9PT0gJ2ZvY3VzJyAmJiAoZXZlbnRUYXJnZXQgPT09IGVsZW1lbnQgfHwgZXZlbnRUYXJnZXQgPT09IG1lbnUgfHwgbWVudS5jb250YWlucyhldmVudFRhcmdldCkgKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCAoZXZlbnRUYXJnZXQgPT09IG1lbnUgfHwgbWVudS5jb250YWlucyhldmVudFRhcmdldCkpICYmIChwZXJzaXN0IHx8IGhhc0RhdGEpICkgeyByZXR1cm47IH1cbiAgICBlbHNlIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQgPSBldmVudFRhcmdldCA9PT0gZWxlbWVudCB8fCBlbGVtZW50LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSA/IGVsZW1lbnQgOiBudWxsO1xuICAgICAgc2VsZi5oaWRlKCk7XG4gICAgfVxuICAgIHByZXZlbnRFbXB0eUFuY2hvci5jYWxsKGUsZXZlbnRUYXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgcmVsYXRlZFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgc2VsZi5zaG93KCk7XG4gICAgcHJldmVudEVtcHR5QW5jaG9yLmNhbGwoZSxlLnRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJldmVudFNjcm9sbChlKSB7XG4gICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgIGlmKCBrZXkgPT09IDM4IHx8IGtleSA9PT0gNDAgKSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICB9XG4gIGZ1bmN0aW9uIGtleUhhbmRsZXIoZSkge1xuICAgIHZhciBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZSxcbiAgICAgICAgYWN0aXZlSXRlbSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsXG4gICAgICAgIGlzU2FtZUVsZW1lbnQgPSBhY3RpdmVJdGVtID09PSBlbGVtZW50LFxuICAgICAgICBpc0luc2lkZU1lbnUgPSBtZW51LmNvbnRhaW5zKGFjdGl2ZUl0ZW0pLFxuICAgICAgICBpc01lbnVJdGVtID0gYWN0aXZlSXRlbS5wYXJlbnROb2RlID09PSBtZW51IHx8IGFjdGl2ZUl0ZW0ucGFyZW50Tm9kZS5wYXJlbnROb2RlID09PSBtZW51LFxuICAgICAgICBpZHggPSBtZW51SXRlbXMuaW5kZXhPZihhY3RpdmVJdGVtKTtcbiAgICBpZiAoIGlzTWVudUl0ZW0gKSB7XG4gICAgICBpZHggPSBpc1NhbWVFbGVtZW50ID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGtleSA9PT0gMzggPyAoaWR4PjE/aWR4LTE6MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBrZXkgPT09IDQwID8gKGlkeDxtZW51SXRlbXMubGVuZ3RoLTE/aWR4KzE6aWR4KSA6IGlkeDtcbiAgICAgIG1lbnVJdGVtc1tpZHhdICYmIHNldEZvY3VzKG1lbnVJdGVtc1tpZHhdKTtcbiAgICB9XG4gICAgaWYgKCAobWVudUl0ZW1zLmxlbmd0aCAmJiBpc01lbnVJdGVtXG4gICAgICAgICAgfHwgIW1lbnVJdGVtcy5sZW5ndGggJiYgKGlzSW5zaWRlTWVudSB8fCBpc1NhbWVFbGVtZW50KVxuICAgICAgICAgIHx8ICFpc0luc2lkZU1lbnUgKVxuICAgICAgICAgICYmIGVsZW1lbnQub3BlbiAmJiBrZXkgPT09IDI3XG4gICAgKSB7XG4gICAgICBzZWxmLnRvZ2dsZSgpO1xuICAgICAgcmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICdkcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIHNob3dDdXN0b21FdmVudCk7XG4gICAgaWYgKCBzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgbWVudS5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgcGFyZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsdHJ1ZSk7XG4gICAgZWxlbWVudC5vcGVuID0gdHJ1ZTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja0hhbmRsZXIsZmFsc2UpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2V0Rm9jdXMoIG1lbnUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0lOUFVUJylbMF0gfHwgZWxlbWVudCApO1xuICAgICAgdG9nZ2xlRGlzbWlzcygpO1xuICAgICAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCAnc2hvd24nLCAnZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIHNob3duQ3VzdG9tRXZlbnQpO1xuICAgIH0sMSk7XG4gIH07XG4gIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZScsICdkcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIGhpZGVDdXN0b21FdmVudCk7XG4gICAgaWYgKCBoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgbWVudS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgcGFyZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsZmFsc2UpO1xuICAgIGVsZW1lbnQub3BlbiA9IGZhbHNlO1xuICAgIHRvZ2dsZURpc21pc3MoKTtcbiAgICBzZXRGb2N1cyhlbGVtZW50KTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuRHJvcGRvd24gJiYgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tIYW5kbGVyLGZhbHNlKTtcbiAgICB9LDEpO1xuICAgIGhpZGRlbkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGRlbicsICdkcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgfTtcbiAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSAmJiBlbGVtZW50Lm9wZW4pIHsgc2VsZi5oaWRlKCk7IH1cbiAgICBlbHNlIHsgc2VsZi5zaG93KCk7IH1cbiAgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgZWxlbWVudC5vcGVuKSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tIYW5kbGVyLGZhbHNlKTtcbiAgICBkZWxldGUgZWxlbWVudC5Ecm9wZG93bjtcbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgZWxlbWVudC5Ecm9wZG93biAmJiBlbGVtZW50LkRyb3Bkb3duLmRpc3Bvc2UoKTtcbiAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICBtZW51ID0gcXVlcnlFbGVtZW50KCcuZHJvcGRvd24tbWVudScsIHBhcmVudCk7XG4gIEFycmF5LmZyb20obWVudS5jaGlsZHJlbikubWFwKGZ1bmN0aW9uIChjaGlsZCl7XG4gICAgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoICYmIChjaGlsZC5jaGlsZHJlblswXS50YWdOYW1lID09PSAnQScgJiYgbWVudUl0ZW1zLnB1c2goY2hpbGQuY2hpbGRyZW5bMF0pKTtcbiAgICBjaGlsZC50YWdOYW1lID09PSAnQScgJiYgbWVudUl0ZW1zLnB1c2goY2hpbGQpO1xuICB9KTtcbiAgaWYgKCAhZWxlbWVudC5Ecm9wZG93biApIHtcbiAgICAhKCd0YWJpbmRleCcgaW4gbWVudSkgJiYgbWVudS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja0hhbmRsZXIsZmFsc2UpO1xuICB9XG4gIHBlcnNpc3QgPSBvcHRpb24gPT09IHRydWUgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGVyc2lzdCcpID09PSAndHJ1ZScgfHwgZmFsc2U7XG4gIGVsZW1lbnQub3BlbiA9IGZhbHNlO1xuICBlbGVtZW50LkRyb3Bkb3duID0gc2VsZjtcbn1cblxuZnVuY3Rpb24gTW9kYWwoZWxlbWVudCxvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VsZiA9IHRoaXMsIG1vZGFsLFxuICAgIHNob3dDdXN0b21FdmVudCxcbiAgICBzaG93bkN1c3RvbUV2ZW50LFxuICAgIGhpZGVDdXN0b21FdmVudCxcbiAgICBoaWRkZW5DdXN0b21FdmVudCxcbiAgICByZWxhdGVkVGFyZ2V0ID0gbnVsbCxcbiAgICBzY3JvbGxCYXJXaWR0aCxcbiAgICBvdmVybGF5LFxuICAgIG92ZXJsYXlEZWxheSxcbiAgICBmaXhlZEl0ZW1zLFxuICAgIG9wcyA9IHt9O1xuICBmdW5jdGlvbiBzZXRTY3JvbGxiYXIoKSB7XG4gICAgdmFyIG9wZW5Nb2RhbCA9IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbC1vcGVuJyksXG4gICAgICAgIGJvZHlQYWQgPSBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLnBhZGRpbmdSaWdodCksXG4gICAgICAgIGJvZHlPdmVyZmxvdyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQgIT09IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBtb2RhbE92ZXJmbG93ID0gbW9kYWwuY2xpZW50SGVpZ2h0ICE9PSBtb2RhbC5zY3JvbGxIZWlnaHQ7XG4gICAgc2Nyb2xsQmFyV2lkdGggPSBtZWFzdXJlU2Nyb2xsYmFyKCk7XG4gICAgbW9kYWwuc3R5bGUucGFkZGluZ1JpZ2h0ID0gIW1vZGFsT3ZlcmZsb3cgJiYgc2Nyb2xsQmFyV2lkdGggPyAoc2Nyb2xsQmFyV2lkdGggKyBcInB4XCIpIDogJyc7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBtb2RhbE92ZXJmbG93IHx8IGJvZHlPdmVyZmxvdyA/ICgoYm9keVBhZCArIChvcGVuTW9kYWwgPyAwOnNjcm9sbEJhcldpZHRoKSkgKyBcInB4XCIpIDogJyc7XG4gICAgZml4ZWRJdGVtcy5sZW5ndGggJiYgZml4ZWRJdGVtcy5tYXAoZnVuY3Rpb24gKGZpeGVkKXtcbiAgICAgIHZhciBpdGVtUGFkID0gZ2V0Q29tcHV0ZWRTdHlsZShmaXhlZCkucGFkZGluZ1JpZ2h0O1xuICAgICAgZml4ZWQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gbW9kYWxPdmVyZmxvdyB8fCBib2R5T3ZlcmZsb3cgPyAoKHBhcnNlSW50KGl0ZW1QYWQpICsgKG9wZW5Nb2RhbD8wOnNjcm9sbEJhcldpZHRoKSkgKyBcInB4XCIpIDogKChwYXJzZUludChpdGVtUGFkKSkgKyBcInB4XCIpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0U2Nyb2xsYmFyKCkge1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgbW9kYWwuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgZml4ZWRJdGVtcy5sZW5ndGggJiYgZml4ZWRJdGVtcy5tYXAoZnVuY3Rpb24gKGZpeGVkKXtcbiAgICAgIGZpeGVkLnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVTY3JvbGxiYXIoKSB7XG4gICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCB3aWR0aFZhbHVlO1xuICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICB3aWR0aFZhbHVlID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICByZXR1cm4gd2lkdGhWYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVPdmVybGF5KCkge1xuICAgIHZhciBuZXdPdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgb3ZlcmxheSA9IHF1ZXJ5RWxlbWVudCgnLm1vZGFsLWJhY2tkcm9wJyk7XG4gICAgaWYgKCBvdmVybGF5ID09PSBudWxsICkge1xuICAgICAgbmV3T3ZlcmxheS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ21vZGFsLWJhY2tkcm9wJyArIChvcHMuYW5pbWF0aW9uID8gJyBmYWRlJyA6ICcnKSk7XG4gICAgICBvdmVybGF5ID0gbmV3T3ZlcmxheTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XG4gICAgfVxuICAgIHJldHVybiBvdmVybGF5O1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU92ZXJsYXkgKCkge1xuICAgIG92ZXJsYXkgPSBxdWVyeUVsZW1lbnQoJy5tb2RhbC1iYWNrZHJvcCcpO1xuICAgIGlmICggb3ZlcmxheSAmJiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbW9kYWwgc2hvdycpWzBdICkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5KTsgb3ZlcmxheSA9IG51bGw7XG4gICAgfVxuICAgIG92ZXJsYXkgPT09IG51bGwgJiYgKGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnbW9kYWwtb3BlbicpLCByZXNldFNjcm9sbGJhcigpKTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWN0aW9uKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIHdpbmRvd1thY3Rpb25dKCAncmVzaXplJywgc2VsZi51cGRhdGUsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICBtb2RhbFthY3Rpb25dKCAnY2xpY2snLGRpc21pc3NIYW5kbGVyLGZhbHNlKTtcbiAgICBkb2N1bWVudFthY3Rpb25dKCAna2V5ZG93bicsa2V5SGFuZGxlcixmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gYmVmb3JlU2hvdygpIHtcbiAgICBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBzZXRTY3JvbGxiYXIoKTtcbiAgICAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbW9kYWwgc2hvdycpWzBdICYmIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnbW9kYWwtb3BlbicpO1xuICAgIG1vZGFsLmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xuICAgIG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnZmFkZScpID8gZW11bGF0ZVRyYW5zaXRpb25FbmQobW9kYWwsIHRyaWdnZXJTaG93KSA6IHRyaWdnZXJTaG93KCk7XG4gIH1cbiAgZnVuY3Rpb24gdHJpZ2dlclNob3coKSB7XG4gICAgc2V0Rm9jdXMobW9kYWwpO1xuICAgIG1vZGFsLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgdG9nZ2xlRXZlbnRzKDEpO1xuICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAnbW9kYWwnLCByZWxhdGVkVGFyZ2V0KTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIHNob3duQ3VzdG9tRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHRyaWdnZXJIaWRlKGZvcmNlKSB7XG4gICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIGVsZW1lbnQgJiYgKHNldEZvY3VzKGVsZW1lbnQpKTtcbiAgICBvdmVybGF5ID0gcXVlcnlFbGVtZW50KCcubW9kYWwtYmFja2Ryb3AnKTtcbiAgICBpZiAoZm9yY2UgIT09IDEgJiYgb3ZlcmxheSAmJiBvdmVybGF5LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmICFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtb2RhbCBzaG93JylbMF0pIHtcbiAgICAgIG92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQob3ZlcmxheSxyZW1vdmVPdmVybGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlT3ZlcmxheSgpO1xuICAgIH1cbiAgICB0b2dnbGVFdmVudHMoKTtcbiAgICBtb2RhbC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIGhpZGRlbkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGRlbicsICdtb2RhbCcpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgaWYgKCBtb2RhbC5pc0FuaW1hdGluZyApIHsgcmV0dXJuOyB9XG4gICAgdmFyIGNsaWNrVGFyZ2V0ID0gZS50YXJnZXQsXG4gICAgICAgIG1vZGFsSUQgPSBcIiNcIiArIChtb2RhbC5nZXRBdHRyaWJ1dGUoJ2lkJykpLFxuICAgICAgICB0YXJnZXRBdHRyVmFsdWUgPSBjbGlja1RhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykgfHwgY2xpY2tUYXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJyksXG4gICAgICAgIGVsZW1BdHRyVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIGlmICggIW1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpXG4gICAgICAgICYmIChjbGlja1RhcmdldCA9PT0gZWxlbWVudCAmJiB0YXJnZXRBdHRyVmFsdWUgPT09IG1vZGFsSURcbiAgICAgICAgfHwgZWxlbWVudC5jb250YWlucyhjbGlja1RhcmdldCkgJiYgZWxlbUF0dHJWYWx1ZSA9PT0gbW9kYWxJRCkgKSB7XG4gICAgICBtb2RhbC5tb2RhbFRyaWdnZXIgPSBlbGVtZW50O1xuICAgICAgcmVsYXRlZFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICBzZWxmLnNob3coKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24ga2V5SGFuZGxlcihyZWYpIHtcbiAgICB2YXIgd2hpY2ggPSByZWYud2hpY2g7XG4gICAgaWYgKCFtb2RhbC5pc0FuaW1hdGluZyAmJiBvcHMua2V5Ym9hcmQgJiYgd2hpY2ggPT0gMjcgJiYgbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgKSB7XG4gICAgICBzZWxmLmhpZGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGlzbWlzc0hhbmRsZXIoZSkge1xuICAgIGlmICggbW9kYWwuaXNBbmltYXRpbmcgKSB7IHJldHVybjsgfVxuICAgIHZhciBjbGlja1RhcmdldCA9IGUudGFyZ2V0LFxuICAgICAgICBoYXNEYXRhID0gY2xpY2tUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc21pc3MnKSA9PT0gJ21vZGFsJyxcbiAgICAgICAgcGFyZW50V2l0aERhdGEgPSBjbGlja1RhcmdldC5jbG9zZXN0KCdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nKTtcbiAgICBpZiAoIG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmICggcGFyZW50V2l0aERhdGEgfHwgaGFzRGF0YVxuICAgICAgICB8fCBjbGlja1RhcmdldCA9PT0gbW9kYWwgJiYgb3BzLmJhY2tkcm9wICE9PSAnc3RhdGljJyApICkge1xuICAgICAgc2VsZi5oaWRlKCk7IHJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBzZWxmLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICkge3NlbGYuaGlkZSgpO30gZWxzZSB7c2VsZi5zaG93KCk7fVxuICB9O1xuICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmICEhbW9kYWwuaXNBbmltYXRpbmcgKSB7cmV0dXJufVxuICAgIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ21vZGFsJywgcmVsYXRlZFRhcmdldCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKG1vZGFsLCBzaG93Q3VzdG9tRXZlbnQpO1xuICAgIGlmICggc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgIG1vZGFsLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudE9wZW4gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtb2RhbCBzaG93JylbMF07XG4gICAgaWYgKGN1cnJlbnRPcGVuICYmIGN1cnJlbnRPcGVuICE9PSBtb2RhbCkge1xuICAgICAgY3VycmVudE9wZW4ubW9kYWxUcmlnZ2VyICYmIGN1cnJlbnRPcGVuLm1vZGFsVHJpZ2dlci5Nb2RhbC5oaWRlKCk7XG4gICAgICBjdXJyZW50T3Blbi5Nb2RhbCAmJiBjdXJyZW50T3Blbi5Nb2RhbC5oaWRlKCk7XG4gICAgfVxuICAgIGlmICggb3BzLmJhY2tkcm9wICkge1xuICAgICAgb3ZlcmxheSA9IGNyZWF0ZU92ZXJsYXkoKTtcbiAgICB9XG4gICAgaWYgKCBvdmVybGF5ICYmICFjdXJyZW50T3BlbiAmJiAhb3ZlcmxheS5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSApIHtcbiAgICAgIG92ZXJsYXkub2Zmc2V0V2lkdGg7XG4gICAgICBvdmVybGF5RGVsYXkgPSBnZXRFbGVtZW50VHJhbnNpdGlvbkR1cmF0aW9uKG92ZXJsYXkpO1xuICAgICAgb3ZlcmxheS5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgfVxuICAgICFjdXJyZW50T3BlbiA/IHNldFRpbWVvdXQoIGJlZm9yZVNob3csIG92ZXJsYXkgJiYgb3ZlcmxheURlbGF5ID8gb3ZlcmxheURlbGF5OjAgKSA6IGJlZm9yZVNob3coKTtcbiAgfTtcbiAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgaWYgKCAhbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgKSB7cmV0dXJufVxuICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCAnaGlkZScsICdtb2RhbCcpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICBpZiAoIGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICBtb2RhbC5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgbW9kYWwuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgIG1vZGFsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICBtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSAmJiBmb3JjZSAhPT0gMSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKG1vZGFsLCB0cmlnZ2VySGlkZSkgOiB0cmlnZ2VySGlkZSgpO1xuICB9O1xuICBzZWxmLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHF1ZXJ5RWxlbWVudCgnLm1vZGFsLWNvbnRlbnQnLG1vZGFsKS5pbm5lckhUTUwgPSBjb250ZW50O1xuICB9O1xuICBzZWxmLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgIHNldFNjcm9sbGJhcigpO1xuICAgIH1cbiAgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuaGlkZSgxKTtcbiAgICBpZiAoZWxlbWVudCkge2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSGFuZGxlcixmYWxzZSk7IGRlbGV0ZSBlbGVtZW50Lk1vZGFsOyB9XG4gICAgZWxzZSB7ZGVsZXRlIG1vZGFsLk1vZGFsO31cbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIGNoZWNrTW9kYWwgPSBxdWVyeUVsZW1lbnQoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJykgKTtcbiAgbW9kYWwgPSBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbW9kYWwnKSA/IGVsZW1lbnQgOiBjaGVja01vZGFsO1xuICBmaXhlZEl0ZW1zID0gQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmaXhlZC10b3AnKSlcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChBcnJheS5mcm9tKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ZpeGVkLWJvdHRvbScpKSk7XG4gIGlmICggZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ21vZGFsJykgKSB7IGVsZW1lbnQgPSBudWxsOyB9XG4gIGVsZW1lbnQgJiYgZWxlbWVudC5Nb2RhbCAmJiBlbGVtZW50Lk1vZGFsLmRpc3Bvc2UoKTtcbiAgbW9kYWwgJiYgbW9kYWwuTW9kYWwgJiYgbW9kYWwuTW9kYWwuZGlzcG9zZSgpO1xuICBvcHMua2V5Ym9hcmQgPSBvcHRpb25zLmtleWJvYXJkID09PSBmYWxzZSB8fCBtb2RhbC5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5Ym9hcmQnKSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdHJ1ZTtcbiAgb3BzLmJhY2tkcm9wID0gb3B0aW9ucy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycgfHwgbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWJhY2tkcm9wJykgPT09ICdzdGF0aWMnID8gJ3N0YXRpYycgOiB0cnVlO1xuICBvcHMuYmFja2Ryb3AgPSBvcHRpb25zLmJhY2tkcm9wID09PSBmYWxzZSB8fCBtb2RhbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmFja2Ryb3AnKSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogb3BzLmJhY2tkcm9wO1xuICBvcHMuYW5pbWF0aW9uID0gbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykgPyB0cnVlIDogZmFsc2U7XG4gIG9wcy5jb250ZW50ID0gb3B0aW9ucy5jb250ZW50O1xuICBtb2RhbC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICBpZiAoIGVsZW1lbnQgJiYgIWVsZW1lbnQuTW9kYWwgKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tIYW5kbGVyLGZhbHNlKTtcbiAgfVxuICBpZiAoIG9wcy5jb250ZW50ICkge1xuICAgIHNlbGYuc2V0Q29udGVudCggb3BzLmNvbnRlbnQudHJpbSgpICk7XG4gIH1cbiAgaWYgKGVsZW1lbnQpIHtcbiAgICBtb2RhbC5tb2RhbFRyaWdnZXIgPSBlbGVtZW50O1xuICAgIGVsZW1lbnQuTW9kYWwgPSBzZWxmO1xuICB9IGVsc2Uge1xuICAgIG1vZGFsLk1vZGFsID0gc2VsZjtcbiAgfVxufVxuXG52YXIgbW91c2VDbGlja0V2ZW50cyA9IHsgZG93bjogJ21vdXNlZG93bicsIHVwOiAnbW91c2V1cCcgfTtcblxuZnVuY3Rpb24gZ2V0U2Nyb2xsKCkge1xuICByZXR1cm4ge1xuICAgIHkgOiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCxcbiAgICB4IDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0XG4gIH1cbn1cblxuZnVuY3Rpb24gc3R5bGVUaXAobGluayxlbGVtZW50LHBvc2l0aW9uLHBhcmVudCkge1xuICB2YXIgdGlwUG9zaXRpb25zID0gL1xcYih0b3B8Ym90dG9tfGxlZnR8cmlnaHQpKy8sXG4gICAgICBlbGVtZW50RGltZW5zaW9ucyA9IHsgdyA6IGVsZW1lbnQub2Zmc2V0V2lkdGgsIGg6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IH0sXG4gICAgICB3aW5kb3dXaWR0aCA9IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCksXG4gICAgICB3aW5kb3dIZWlnaHQgPSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCksXG4gICAgICByZWN0ID0gbGluay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHNjcm9sbCA9IHBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSA/IGdldFNjcm9sbCgpIDogeyB4OiBwYXJlbnQub2Zmc2V0TGVmdCArIHBhcmVudC5zY3JvbGxMZWZ0LCB5OiBwYXJlbnQub2Zmc2V0VG9wICsgcGFyZW50LnNjcm9sbFRvcCB9LFxuICAgICAgbGlua0RpbWVuc2lvbnMgPSB7IHc6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIGg6IHJlY3QuYm90dG9tIC0gcmVjdC50b3AgfSxcbiAgICAgIGlzUG9wb3ZlciA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwb3BvdmVyJyksXG4gICAgICBhcnJvdyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYXJyb3cnKVswXSxcbiAgICAgIGhhbGZUb3BFeGNlZWQgPSByZWN0LnRvcCArIGxpbmtEaW1lbnNpb25zLmgvMiAtIGVsZW1lbnREaW1lbnNpb25zLmgvMiA8IDAsXG4gICAgICBoYWxmTGVmdEV4Y2VlZCA9IHJlY3QubGVmdCArIGxpbmtEaW1lbnNpb25zLncvMiAtIGVsZW1lbnREaW1lbnNpb25zLncvMiA8IDAsXG4gICAgICBoYWxmUmlnaHRFeGNlZWQgPSByZWN0LmxlZnQgKyBlbGVtZW50RGltZW5zaW9ucy53LzIgKyBsaW5rRGltZW5zaW9ucy53LzIgPj0gd2luZG93V2lkdGgsXG4gICAgICBoYWxmQm90dG9tRXhjZWVkID0gcmVjdC50b3AgKyBlbGVtZW50RGltZW5zaW9ucy5oLzIgKyBsaW5rRGltZW5zaW9ucy5oLzIgPj0gd2luZG93SGVpZ2h0LFxuICAgICAgdG9wRXhjZWVkID0gcmVjdC50b3AgLSBlbGVtZW50RGltZW5zaW9ucy5oIDwgMCxcbiAgICAgIGxlZnRFeGNlZWQgPSByZWN0LmxlZnQgLSBlbGVtZW50RGltZW5zaW9ucy53IDwgMCxcbiAgICAgIGJvdHRvbUV4Y2VlZCA9IHJlY3QudG9wICsgZWxlbWVudERpbWVuc2lvbnMuaCArIGxpbmtEaW1lbnNpb25zLmggPj0gd2luZG93SGVpZ2h0LFxuICAgICAgcmlnaHRFeGNlZWQgPSByZWN0LmxlZnQgKyBlbGVtZW50RGltZW5zaW9ucy53ICsgbGlua0RpbWVuc2lvbnMudyA+PSB3aW5kb3dXaWR0aDtcbiAgcG9zaXRpb24gPSAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykgJiYgbGVmdEV4Y2VlZCAmJiByaWdodEV4Y2VlZCA/ICd0b3AnIDogcG9zaXRpb247XG4gIHBvc2l0aW9uID0gcG9zaXRpb24gPT09ICd0b3AnICYmIHRvcEV4Y2VlZCA/ICdib3R0b20nIDogcG9zaXRpb247XG4gIHBvc2l0aW9uID0gcG9zaXRpb24gPT09ICdib3R0b20nICYmIGJvdHRvbUV4Y2VlZCA/ICd0b3AnIDogcG9zaXRpb247XG4gIHBvc2l0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyAmJiBsZWZ0RXhjZWVkID8gJ3JpZ2h0JyA6IHBvc2l0aW9uO1xuICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSAncmlnaHQnICYmIHJpZ2h0RXhjZWVkID8gJ2xlZnQnIDogcG9zaXRpb247XG4gIHZhciB0b3BQb3NpdGlvbixcbiAgICBsZWZ0UG9zaXRpb24sXG4gICAgYXJyb3dUb3AsXG4gICAgYXJyb3dMZWZ0LFxuICAgIGFycm93V2lkdGgsXG4gICAgYXJyb3dIZWlnaHQ7XG4gIGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiAoZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKHRpcFBvc2l0aW9ucyxwb3NpdGlvbikpO1xuICBhcnJvd1dpZHRoID0gYXJyb3cub2Zmc2V0V2lkdGg7IGFycm93SGVpZ2h0ID0gYXJyb3cub2Zmc2V0SGVpZ2h0O1xuICBpZiAoIHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcgKSB7XG4gICAgaWYgKCBwb3NpdGlvbiA9PT0gJ2xlZnQnICkge1xuICAgICAgbGVmdFBvc2l0aW9uID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnggLSBlbGVtZW50RGltZW5zaW9ucy53IC0gKCBpc1BvcG92ZXIgPyBhcnJvd1dpZHRoIDogMCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0UG9zaXRpb24gPSByZWN0LmxlZnQgKyBzY3JvbGwueCArIGxpbmtEaW1lbnNpb25zLnc7XG4gICAgfVxuICAgIGlmIChoYWxmVG9wRXhjZWVkKSB7XG4gICAgICB0b3BQb3NpdGlvbiA9IHJlY3QudG9wICsgc2Nyb2xsLnk7XG4gICAgICBhcnJvd1RvcCA9IGxpbmtEaW1lbnNpb25zLmgvMiAtIGFycm93V2lkdGg7XG4gICAgfSBlbHNlIGlmIChoYWxmQm90dG9tRXhjZWVkKSB7XG4gICAgICB0b3BQb3NpdGlvbiA9IHJlY3QudG9wICsgc2Nyb2xsLnkgLSBlbGVtZW50RGltZW5zaW9ucy5oICsgbGlua0RpbWVuc2lvbnMuaDtcbiAgICAgIGFycm93VG9wID0gZWxlbWVudERpbWVuc2lvbnMuaCAtIGxpbmtEaW1lbnNpb25zLmgvMiAtIGFycm93V2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcFBvc2l0aW9uID0gcmVjdC50b3AgKyBzY3JvbGwueSAtIGVsZW1lbnREaW1lbnNpb25zLmgvMiArIGxpbmtEaW1lbnNpb25zLmgvMjtcbiAgICAgIGFycm93VG9wID0gZWxlbWVudERpbWVuc2lvbnMuaC8yIC0gKGlzUG9wb3ZlciA/IGFycm93SGVpZ2h0KjAuOSA6IGFycm93SGVpZ2h0LzIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICggcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyApIHtcbiAgICBpZiAoIHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgdG9wUG9zaXRpb24gPSAgcmVjdC50b3AgKyBzY3JvbGwueSAtIGVsZW1lbnREaW1lbnNpb25zLmggLSAoIGlzUG9wb3ZlciA/IGFycm93SGVpZ2h0IDogMCApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3BQb3NpdGlvbiA9IHJlY3QudG9wICsgc2Nyb2xsLnkgKyBsaW5rRGltZW5zaW9ucy5oO1xuICAgIH1cbiAgICBpZiAoaGFsZkxlZnRFeGNlZWQpIHtcbiAgICAgIGxlZnRQb3NpdGlvbiA9IDA7XG4gICAgICBhcnJvd0xlZnQgPSByZWN0LmxlZnQgKyBsaW5rRGltZW5zaW9ucy53LzIgLSBhcnJvd1dpZHRoO1xuICAgIH0gZWxzZSBpZiAoaGFsZlJpZ2h0RXhjZWVkKSB7XG4gICAgICBsZWZ0UG9zaXRpb24gPSB3aW5kb3dXaWR0aCAtIGVsZW1lbnREaW1lbnNpb25zLncqMS4wMTtcbiAgICAgIGFycm93TGVmdCA9IGVsZW1lbnREaW1lbnNpb25zLncgLSAoIHdpbmRvd1dpZHRoIC0gcmVjdC5sZWZ0ICkgKyBsaW5rRGltZW5zaW9ucy53LzIgLSBhcnJvd1dpZHRoLzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnRQb3NpdGlvbiA9IHJlY3QubGVmdCArIHNjcm9sbC54IC0gZWxlbWVudERpbWVuc2lvbnMudy8yICsgbGlua0RpbWVuc2lvbnMudy8yO1xuICAgICAgYXJyb3dMZWZ0ID0gZWxlbWVudERpbWVuc2lvbnMudy8yIC0gKCBpc1BvcG92ZXIgPyBhcnJvd1dpZHRoIDogYXJyb3dXaWR0aC8yICk7XG4gICAgfVxuICB9XG4gIGVsZW1lbnQuc3R5bGUudG9wID0gdG9wUG9zaXRpb24gKyAncHgnO1xuICBlbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0UG9zaXRpb24gKyAncHgnO1xuICBhcnJvd1RvcCAmJiAoYXJyb3cuc3R5bGUudG9wID0gYXJyb3dUb3AgKyAncHgnKTtcbiAgYXJyb3dMZWZ0ICYmIChhcnJvdy5zdHlsZS5sZWZ0ID0gYXJyb3dMZWZ0ICsgJ3B4Jyk7XG59XG5cbmZ1bmN0aW9uIFBvcG92ZXIoZWxlbWVudCxvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb3BvdmVyID0gbnVsbCxcbiAgICAgIHRpbWVyID0gMCxcbiAgICAgIGlzSXBob25lID0gLyhpUGhvbmV8aVBvZHxpUGFkKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgIHRpdGxlU3RyaW5nLFxuICAgICAgY29udGVudFN0cmluZyxcbiAgICAgIG9wcyA9IHt9O1xuICB2YXIgdHJpZ2dlckRhdGEsXG4gICAgICBhbmltYXRpb25EYXRhLFxuICAgICAgcGxhY2VtZW50RGF0YSxcbiAgICAgIGRpc21pc3NpYmxlRGF0YSxcbiAgICAgIGRlbGF5RGF0YSxcbiAgICAgIGNvbnRhaW5lckRhdGEsXG4gICAgICBjbG9zZUJ0bixcbiAgICAgIHNob3dDdXN0b21FdmVudCxcbiAgICAgIHNob3duQ3VzdG9tRXZlbnQsXG4gICAgICBoaWRlQ3VzdG9tRXZlbnQsXG4gICAgICBoaWRkZW5DdXN0b21FdmVudCxcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQsXG4gICAgICBjb250YWluZXJEYXRhRWxlbWVudCxcbiAgICAgIG1vZGFsLFxuICAgICAgbmF2YmFyRml4ZWRUb3AsXG4gICAgICBuYXZiYXJGaXhlZEJvdHRvbSxcbiAgICAgIHBsYWNlbWVudENsYXNzO1xuICBmdW5jdGlvbiBkaXNtaXNzaWJsZUhhbmRsZXIoZSkge1xuICAgIGlmIChwb3BvdmVyICE9PSBudWxsICYmIGUudGFyZ2V0ID09PSBxdWVyeUVsZW1lbnQoJy5jbG9zZScscG9wb3ZlcikpIHtcbiAgICAgIHNlbGYuaGlkZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRDb250ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgMCA6IG9wdGlvbnMudGl0bGUgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnKSB8fCBudWxsLFxuICAgICAgMSA6IG9wdGlvbnMuY29udGVudCB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb250ZW50JykgfHwgbnVsbFxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVQb3BvdmVyKCkge1xuICAgIG9wcy5jb250YWluZXIucmVtb3ZlQ2hpbGQocG9wb3Zlcik7XG4gICAgdGltZXIgPSBudWxsOyBwb3BvdmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVQb3BvdmVyKCkge1xuICAgIHRpdGxlU3RyaW5nID0gZ2V0Q29udGVudHMoKVswXSB8fCBudWxsO1xuICAgIGNvbnRlbnRTdHJpbmcgPSBnZXRDb250ZW50cygpWzFdO1xuICAgIGNvbnRlbnRTdHJpbmcgPSAhIWNvbnRlbnRTdHJpbmcgPyBjb250ZW50U3RyaW5nLnRyaW0oKSA6IG51bGw7XG4gICAgcG9wb3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBwb3BvdmVyQXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwb3BvdmVyQXJyb3cuY2xhc3NMaXN0LmFkZCgnYXJyb3cnKTtcbiAgICBwb3BvdmVyLmFwcGVuZENoaWxkKHBvcG92ZXJBcnJvdyk7XG4gICAgaWYgKCBjb250ZW50U3RyaW5nICE9PSBudWxsICYmIG9wcy50ZW1wbGF0ZSA9PT0gbnVsbCApIHtcbiAgICAgIHBvcG92ZXIuc2V0QXR0cmlidXRlKCdyb2xlJywndG9vbHRpcCcpO1xuICAgICAgaWYgKHRpdGxlU3RyaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwb3BvdmVyVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xuICAgICAgICBwb3BvdmVyVGl0bGUuY2xhc3NMaXN0LmFkZCgncG9wb3Zlci1oZWFkZXInKTtcbiAgICAgICAgcG9wb3ZlclRpdGxlLmlubmVySFRNTCA9IG9wcy5kaXNtaXNzaWJsZSA/IHRpdGxlU3RyaW5nICsgY2xvc2VCdG4gOiB0aXRsZVN0cmluZztcbiAgICAgICAgcG9wb3Zlci5hcHBlbmRDaGlsZChwb3BvdmVyVGl0bGUpO1xuICAgICAgfVxuICAgICAgdmFyIHBvcG92ZXJCb2R5TWFya3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwb3BvdmVyQm9keU1hcmt1cC5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLWJvZHknKTtcbiAgICAgIHBvcG92ZXJCb2R5TWFya3VwLmlubmVySFRNTCA9IG9wcy5kaXNtaXNzaWJsZSAmJiB0aXRsZVN0cmluZyA9PT0gbnVsbCA/IGNvbnRlbnRTdHJpbmcgKyBjbG9zZUJ0biA6IGNvbnRlbnRTdHJpbmc7XG4gICAgICBwb3BvdmVyLmFwcGVuZENoaWxkKHBvcG92ZXJCb2R5TWFya3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvcG92ZXJUZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcG9wb3ZlclRlbXBsYXRlLmlubmVySFRNTCA9IG9wcy50ZW1wbGF0ZS50cmltKCk7XG4gICAgICBwb3BvdmVyLmNsYXNzTmFtZSA9IHBvcG92ZXJUZW1wbGF0ZS5maXJzdENoaWxkLmNsYXNzTmFtZTtcbiAgICAgIHBvcG92ZXIuaW5uZXJIVE1MID0gcG9wb3ZlclRlbXBsYXRlLmZpcnN0Q2hpbGQuaW5uZXJIVE1MO1xuICAgICAgdmFyIHBvcG92ZXJIZWFkZXIgPSBxdWVyeUVsZW1lbnQoJy5wb3BvdmVyLWhlYWRlcicscG9wb3ZlciksXG4gICAgICAgICAgcG9wb3ZlckJvZHkgPSBxdWVyeUVsZW1lbnQoJy5wb3BvdmVyLWJvZHknLHBvcG92ZXIpO1xuICAgICAgdGl0bGVTdHJpbmcgJiYgcG9wb3ZlckhlYWRlciAmJiAocG9wb3ZlckhlYWRlci5pbm5lckhUTUwgPSB0aXRsZVN0cmluZy50cmltKCkpO1xuICAgICAgY29udGVudFN0cmluZyAmJiBwb3BvdmVyQm9keSAmJiAocG9wb3ZlckJvZHkuaW5uZXJIVE1MID0gY29udGVudFN0cmluZy50cmltKCkpO1xuICAgIH1cbiAgICBvcHMuY29udGFpbmVyLmFwcGVuZENoaWxkKHBvcG92ZXIpO1xuICAgIHBvcG92ZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgIXBvcG92ZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCAncG9wb3ZlcicpICYmIHBvcG92ZXIuY2xhc3NMaXN0LmFkZCgncG9wb3ZlcicpO1xuICAgICFwb3BvdmVyLmNsYXNzTGlzdC5jb250YWlucyggb3BzLmFuaW1hdGlvbikgJiYgcG9wb3Zlci5jbGFzc0xpc3QuYWRkKG9wcy5hbmltYXRpb24pO1xuICAgICFwb3BvdmVyLmNsYXNzTGlzdC5jb250YWlucyggcGxhY2VtZW50Q2xhc3MpICYmIHBvcG92ZXIuY2xhc3NMaXN0LmFkZChwbGFjZW1lbnRDbGFzcyk7XG4gIH1cbiAgZnVuY3Rpb24gc2hvd1BvcG92ZXIoKSB7XG4gICAgIXBvcG92ZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgKCBwb3BvdmVyLmNsYXNzTGlzdC5hZGQoJ3Nob3cnKSApO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcG92ZXIoKSB7XG4gICAgc3R5bGVUaXAoZWxlbWVudCwgcG9wb3Zlciwgb3BzLnBsYWNlbWVudCwgb3BzLmNvbnRhaW5lcik7XG4gIH1cbiAgZnVuY3Rpb24gZm9yY2VGb2N1cyAoKSB7XG4gICAgaWYgKHBvcG92ZXIgPT09IG51bGwpIHsgZWxlbWVudC5mb2N1cygpOyB9XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFjdGlvbikge1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBpZiAob3BzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSggbW91c2VDbGlja0V2ZW50cy5kb3duLCBzZWxmLnNob3cgKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSggbW91c2VIb3ZlckV2ZW50c1swXSwgc2VsZi5zaG93ICk7XG4gICAgICBpZiAoIW9wcy5kaXNtaXNzaWJsZSkgeyBlbGVtZW50W2FjdGlvbl0oIG1vdXNlSG92ZXJFdmVudHNbMV0sIHNlbGYuaGlkZSApOyB9XG4gICAgfSBlbHNlIGlmICgnY2xpY2snID09IG9wcy50cmlnZ2VyKSB7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oIG9wcy50cmlnZ2VyLCBzZWxmLnRvZ2dsZSApO1xuICAgIH0gZWxzZSBpZiAoJ2ZvY3VzJyA9PSBvcHMudHJpZ2dlcikge1xuICAgICAgaXNJcGhvbmUgJiYgZWxlbWVudFthY3Rpb25dKCAnY2xpY2snLCBmb3JjZUZvY3VzLCBmYWxzZSApO1xuICAgICAgZWxlbWVudFthY3Rpb25dKCBvcHMudHJpZ2dlciwgc2VsZi50b2dnbGUgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG91Y2hIYW5kbGVyKGUpe1xuICAgIGlmICggcG9wb3ZlciAmJiBwb3BvdmVyLmNvbnRhaW5zKGUudGFyZ2V0KSB8fCBlLnRhcmdldCA9PT0gZWxlbWVudCB8fCBlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSkgOyBlbHNlIHtcbiAgICAgIHNlbGYuaGlkZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaXNtaXNzSGFuZGxlclRvZ2dsZShhY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgaWYgKG9wcy5kaXNtaXNzaWJsZSkge1xuICAgICAgZG9jdW1lbnRbYWN0aW9uXSgnY2xpY2snLCBkaXNtaXNzaWJsZUhhbmRsZXIsIGZhbHNlICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICdmb2N1cycgPT0gb3BzLnRyaWdnZXIgJiYgZWxlbWVudFthY3Rpb25dKCAnYmx1cicsIHNlbGYuaGlkZSApO1xuICAgICAgJ2hvdmVyJyA9PSBvcHMudHJpZ2dlciAmJiBkb2N1bWVudFthY3Rpb25dKCAndG91Y2hzdGFydCcsIHRvdWNoSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICB9XG4gICAgd2luZG93W2FjdGlvbl0oJ3Jlc2l6ZScsIHNlbGYuaGlkZSwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgfVxuICBmdW5jdGlvbiBzaG93VHJpZ2dlcigpIHtcbiAgICBkaXNtaXNzSGFuZGxlclRvZ2dsZSgxKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd25DdXN0b21FdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gaGlkZVRyaWdnZXIoKSB7XG4gICAgZGlzbWlzc0hhbmRsZXJUb2dnbGUoKTtcbiAgICByZW1vdmVQb3BvdmVyKCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgfVxuICBzZWxmLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocG9wb3ZlciA9PT0gbnVsbCkgeyBzZWxmLnNob3coKTsgfVxuICAgIGVsc2UgeyBzZWxmLmhpZGUoKTsgfVxuICB9O1xuICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwb3BvdmVyID09PSBudWxsKSB7XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzaG93Q3VzdG9tRXZlbnQpO1xuICAgICAgICBpZiAoIHNob3dDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICAgICAgY3JlYXRlUG9wb3ZlcigpO1xuICAgICAgICB1cGRhdGVQb3BvdmVyKCk7XG4gICAgICAgIHNob3dQb3BvdmVyKCk7XG4gICAgICAgICEhb3BzLmFuaW1hdGlvbiA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHBvcG92ZXIsIHNob3dUcmlnZ2VyKSA6IHNob3dUcmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfSwgMjAgKTtcbiAgfTtcbiAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocG9wb3ZlciAmJiBwb3BvdmVyICE9PSBudWxsICYmIHBvcG92ZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGVDdXN0b21FdmVudCk7XG4gICAgICAgIGlmICggaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgICAgICBwb3BvdmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgICAgISFvcHMuYW5pbWF0aW9uID8gZW11bGF0ZVRyYW5zaXRpb25FbmQocG9wb3ZlciwgaGlkZVRyaWdnZXIpIDogaGlkZVRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9LCBvcHMuZGVsYXkgKTtcbiAgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuaGlkZSgpO1xuICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgIGRlbGV0ZSBlbGVtZW50LlBvcG92ZXI7XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIGVsZW1lbnQuUG9wb3ZlciAmJiBlbGVtZW50LlBvcG92ZXIuZGlzcG9zZSgpO1xuICB0cmlnZ2VyRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRyaWdnZXInKTtcbiAgYW5pbWF0aW9uRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicpO1xuICBwbGFjZW1lbnREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2VtZW50Jyk7XG4gIGRpc21pc3NpYmxlRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc21pc3NpYmxlJyk7XG4gIGRlbGF5RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRlbGF5Jyk7XG4gIGNvbnRhaW5lckRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb250YWluZXInKTtcbiAgY2xvc2VCdG4gPSAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiPsOXPC9idXR0b24+JztcbiAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAncG9wb3ZlcicpO1xuICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3duJywgJ3BvcG92ZXInKTtcbiAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAncG9wb3ZlcicpO1xuICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAncG9wb3ZlcicpO1xuICBjb250YWluZXJFbGVtZW50ID0gcXVlcnlFbGVtZW50KG9wdGlvbnMuY29udGFpbmVyKTtcbiAgY29udGFpbmVyRGF0YUVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoY29udGFpbmVyRGF0YSk7XG4gIG1vZGFsID0gZWxlbWVudC5jbG9zZXN0KCcubW9kYWwnKTtcbiAgbmF2YmFyRml4ZWRUb3AgPSBlbGVtZW50LmNsb3Nlc3QoJy5maXhlZC10b3AnKTtcbiAgbmF2YmFyRml4ZWRCb3R0b20gPSBlbGVtZW50LmNsb3Nlc3QoJy5maXhlZC1ib3R0b20nKTtcbiAgb3BzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSA/IG9wdGlvbnMudGVtcGxhdGUgOiBudWxsO1xuICBvcHMudHJpZ2dlciA9IG9wdGlvbnMudHJpZ2dlciA/IG9wdGlvbnMudHJpZ2dlciA6IHRyaWdnZXJEYXRhIHx8ICdob3Zlcic7XG4gIG9wcy5hbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gJ2ZhZGUnID8gb3B0aW9ucy5hbmltYXRpb24gOiBhbmltYXRpb25EYXRhIHx8ICdmYWRlJztcbiAgb3BzLnBsYWNlbWVudCA9IG9wdGlvbnMucGxhY2VtZW50ID8gb3B0aW9ucy5wbGFjZW1lbnQgOiBwbGFjZW1lbnREYXRhIHx8ICd0b3AnO1xuICBvcHMuZGVsYXkgPSBwYXJzZUludChvcHRpb25zLmRlbGF5IHx8IGRlbGF5RGF0YSkgfHwgMjAwO1xuICBvcHMuZGlzbWlzc2libGUgPSBvcHRpb25zLmRpc21pc3NpYmxlIHx8IGRpc21pc3NpYmxlRGF0YSA9PT0gJ3RydWUnID8gdHJ1ZSA6IGZhbHNlO1xuICBvcHMuY29udGFpbmVyID0gY29udGFpbmVyRWxlbWVudCA/IGNvbnRhaW5lckVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb250YWluZXJEYXRhRWxlbWVudCA/IGNvbnRhaW5lckRhdGFFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbmF2YmFyRml4ZWRUb3AgPyBuYXZiYXJGaXhlZFRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5hdmJhckZpeGVkQm90dG9tID8gbmF2YmFyRml4ZWRCb3R0b21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RhbCA/IG1vZGFsIDogZG9jdW1lbnQuYm9keTtcbiAgcGxhY2VtZW50Q2xhc3MgPSBcImJzLXBvcG92ZXItXCIgKyAob3BzLnBsYWNlbWVudCk7XG4gIHZhciBwb3BvdmVyQ29udGVudHMgPSBnZXRDb250ZW50cygpO1xuICB0aXRsZVN0cmluZyA9IHBvcG92ZXJDb250ZW50c1swXTtcbiAgY29udGVudFN0cmluZyA9IHBvcG92ZXJDb250ZW50c1sxXTtcbiAgaWYgKCAhY29udGVudFN0cmluZyAmJiAhb3BzLnRlbXBsYXRlICkgeyByZXR1cm47IH1cbiAgaWYgKCAhZWxlbWVudC5Qb3BvdmVyICkge1xuICAgIHRvZ2dsZUV2ZW50cygxKTtcbiAgfVxuICBlbGVtZW50LlBvcG92ZXIgPSBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxTcHkoZWxlbWVudCxvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgdmFycyxcbiAgICB0YXJnZXREYXRhLFxuICAgIG9mZnNldERhdGEsXG4gICAgc3B5VGFyZ2V0LFxuICAgIHNjcm9sbFRhcmdldCxcbiAgICBvcHMgPSB7fTtcbiAgZnVuY3Rpb24gdXBkYXRlVGFyZ2V0cygpe1xuICAgIHZhciBsaW5rcyA9IHNweVRhcmdldC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnQScpO1xuICAgIGlmICh2YXJzLmxlbmd0aCAhPT0gbGlua3MubGVuZ3RoKSB7XG4gICAgICB2YXJzLml0ZW1zID0gW107XG4gICAgICB2YXJzLnRhcmdldHMgPSBbXTtcbiAgICAgIEFycmF5LmZyb20obGlua3MpLm1hcChmdW5jdGlvbiAobGluayl7XG4gICAgICAgIHZhciBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSxcbiAgICAgICAgICB0YXJnZXRJdGVtID0gaHJlZiAmJiBocmVmLmNoYXJBdCgwKSA9PT0gJyMnICYmIGhyZWYuc2xpY2UoLTEpICE9PSAnIycgJiYgcXVlcnlFbGVtZW50KGhyZWYpO1xuICAgICAgICBpZiAoIHRhcmdldEl0ZW0gKSB7XG4gICAgICAgICAgdmFycy5pdGVtcy5wdXNoKGxpbmspO1xuICAgICAgICAgIHZhcnMudGFyZ2V0cy5wdXNoKHRhcmdldEl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhcnMubGVuZ3RoID0gbGlua3MubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVJdGVtKGluZGV4KSB7XG4gICAgdmFyIGl0ZW0gPSB2YXJzLml0ZW1zW2luZGV4XSxcbiAgICAgIHRhcmdldEl0ZW0gPSB2YXJzLnRhcmdldHNbaW5kZXhdLFxuICAgICAgZHJvcG1lbnUgPSBpdGVtLmNsYXNzTGlzdC5jb250YWlucygnZHJvcGRvd24taXRlbScpICYmIGl0ZW0uY2xvc2VzdCgnLmRyb3Bkb3duLW1lbnUnKSxcbiAgICAgIGRyb3BMaW5rID0gZHJvcG1lbnUgJiYgZHJvcG1lbnUucHJldmlvdXNFbGVtZW50U2libGluZyxcbiAgICAgIG5leHRTaWJsaW5nID0gaXRlbS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICBhY3RpdmVTaWJsaW5nID0gbmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYWN0aXZlJykubGVuZ3RoLFxuICAgICAgdGFyZ2V0UmVjdCA9IHZhcnMuaXNXaW5kb3cgJiYgdGFyZ2V0SXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGlzQWN0aXZlID0gaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpIHx8IGZhbHNlLFxuICAgICAgdG9wRWRnZSA9ICh2YXJzLmlzV2luZG93ID8gdGFyZ2V0UmVjdC50b3AgKyB2YXJzLnNjcm9sbE9mZnNldCA6IHRhcmdldEl0ZW0ub2Zmc2V0VG9wKSAtIG9wcy5vZmZzZXQsXG4gICAgICBib3R0b21FZGdlID0gdmFycy5pc1dpbmRvdyA/IHRhcmdldFJlY3QuYm90dG9tICsgdmFycy5zY3JvbGxPZmZzZXQgLSBvcHMub2Zmc2V0XG4gICAgICAgICAgICAgICAgIDogdmFycy50YXJnZXRzW2luZGV4KzFdID8gdmFycy50YXJnZXRzW2luZGV4KzFdLm9mZnNldFRvcCAtIG9wcy5vZmZzZXRcbiAgICAgICAgICAgICAgICAgOiBlbGVtZW50LnNjcm9sbEhlaWdodCxcbiAgICAgIGluc2lkZSA9IGFjdGl2ZVNpYmxpbmcgfHwgdmFycy5zY3JvbGxPZmZzZXQgPj0gdG9wRWRnZSAmJiBib3R0b21FZGdlID4gdmFycy5zY3JvbGxPZmZzZXQ7XG4gICAgIGlmICggIWlzQWN0aXZlICYmIGluc2lkZSApIHtcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICBpZiAoZHJvcExpbmsgJiYgIWRyb3BMaW5rLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgKSB7XG4gICAgICAgIGRyb3BMaW5rLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGJvb3RzdHJhcEN1c3RvbUV2ZW50KCAnYWN0aXZhdGUnLCAnc2Nyb2xsc3B5JywgdmFycy5pdGVtc1tpbmRleF0pKTtcbiAgICB9IGVsc2UgaWYgKCBpc0FjdGl2ZSAmJiAhaW5zaWRlICkge1xuICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIGlmIChkcm9wTGluayAmJiBkcm9wTGluay5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICYmICFpdGVtLnBhcmVudE5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYWN0aXZlJykubGVuZ3RoICkge1xuICAgICAgICBkcm9wTGluay5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCBpc0FjdGl2ZSAmJiBpbnNpZGUgfHwgIWluc2lkZSAmJiAhaXNBY3RpdmUgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUl0ZW1zKCkge1xuICAgIHVwZGF0ZVRhcmdldHMoKTtcbiAgICB2YXJzLnNjcm9sbE9mZnNldCA9IHZhcnMuaXNXaW5kb3cgPyBnZXRTY3JvbGwoKS55IDogZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgdmFycy5pdGVtcy5tYXAoZnVuY3Rpb24gKGwsaWR4KXsgcmV0dXJuIHVwZGF0ZUl0ZW0oaWR4KTsgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFjdGlvbikge1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBzY3JvbGxUYXJnZXRbYWN0aW9uXSgnc2Nyb2xsJywgc2VsZi5yZWZyZXNoLCBwYXNzaXZlSGFuZGxlciApO1xuICAgIHdpbmRvd1thY3Rpb25dKCAncmVzaXplJywgc2VsZi5yZWZyZXNoLCBwYXNzaXZlSGFuZGxlciApO1xuICB9XG4gIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVJdGVtcygpO1xuICB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgZGVsZXRlIGVsZW1lbnQuU2Nyb2xsU3B5O1xuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBlbGVtZW50LlNjcm9sbFNweSAmJiBlbGVtZW50LlNjcm9sbFNweS5kaXNwb3NlKCk7XG4gIHRhcmdldERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKTtcbiAgb2Zmc2V0RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9mZnNldCcpO1xuICBzcHlUYXJnZXQgPSBxdWVyeUVsZW1lbnQob3B0aW9ucy50YXJnZXQgfHwgdGFyZ2V0RGF0YSk7XG4gIHNjcm9sbFRhcmdldCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQgPyBlbGVtZW50IDogd2luZG93O1xuICBpZiAoIXNweVRhcmdldCkgeyByZXR1cm4gfVxuICBvcHMudGFyZ2V0ID0gc3B5VGFyZ2V0O1xuICBvcHMub2Zmc2V0ID0gcGFyc2VJbnQob3B0aW9ucy5vZmZzZXQgfHwgb2Zmc2V0RGF0YSkgfHwgMTA7XG4gIHZhcnMgPSB7fTtcbiAgdmFycy5sZW5ndGggPSAwO1xuICB2YXJzLml0ZW1zID0gW107XG4gIHZhcnMudGFyZ2V0cyA9IFtdO1xuICB2YXJzLmlzV2luZG93ID0gc2Nyb2xsVGFyZ2V0ID09PSB3aW5kb3c7XG4gIGlmICggIWVsZW1lbnQuU2Nyb2xsU3B5ICkge1xuICAgIHRvZ2dsZUV2ZW50cygxKTtcbiAgfVxuICBzZWxmLnJlZnJlc2goKTtcbiAgZWxlbWVudC5TY3JvbGxTcHkgPSBzZWxmO1xufVxuXG5mdW5jdGlvbiBUYWIoZWxlbWVudCxvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgaGVpZ2h0RGF0YSxcbiAgICB0YWJzLCBkcm9wZG93bixcbiAgICBzaG93Q3VzdG9tRXZlbnQsXG4gICAgc2hvd25DdXN0b21FdmVudCxcbiAgICBoaWRlQ3VzdG9tRXZlbnQsXG4gICAgaGlkZGVuQ3VzdG9tRXZlbnQsXG4gICAgbmV4dCxcbiAgICB0YWJzQ29udGVudENvbnRhaW5lciA9IGZhbHNlLFxuICAgIGFjdGl2ZVRhYixcbiAgICBhY3RpdmVDb250ZW50LFxuICAgIG5leHRDb250ZW50LFxuICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICBlcXVhbENvbnRlbnRzLFxuICAgIG5leHRIZWlnaHQsXG4gICAgYW5pbWF0ZUhlaWdodDtcbiAgZnVuY3Rpb24gdHJpZ2dlckVuZCgpIHtcbiAgICB0YWJzQ29udGVudENvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICB0YWJzQ29udGVudENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzaW5nJyk7XG4gICAgdGFicy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHRyaWdnZXJTaG93KCkge1xuICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgaWYgKCBlcXVhbENvbnRlbnRzICkge1xuICAgICAgICB0cmlnZ2VyRW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YWJzQ29udGVudENvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBuZXh0SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRhYnNDb250ZW50Q29udGFpbmVyLCB0cmlnZ2VyRW5kKTtcbiAgICAgICAgfSw1MCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYnMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93bicsICd0YWInLCBhY3RpdmVUYWIpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChuZXh0LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiB0cmlnZ2VySGlkZSgpIHtcbiAgICBpZiAodGFic0NvbnRlbnRDb250YWluZXIpIHtcbiAgICAgIGFjdGl2ZUNvbnRlbnQuc3R5bGUuZmxvYXQgPSAnbGVmdCc7XG4gICAgICBuZXh0Q29udGVudC5zdHlsZS5mbG9hdCA9ICdsZWZ0JztcbiAgICAgIGNvbnRhaW5lckhlaWdodCA9IGFjdGl2ZUNvbnRlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICd0YWInLCBhY3RpdmVUYWIpO1xuICAgIGhpZGRlbkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGRlbicsICd0YWInLCBuZXh0KTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobmV4dCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICBpZiAoIHNob3dDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICBuZXh0Q29udGVudC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICBhY3RpdmVDb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgbmV4dEhlaWdodCA9IG5leHRDb250ZW50LnNjcm9sbEhlaWdodDtcbiAgICAgIGVxdWFsQ29udGVudHMgPSBuZXh0SGVpZ2h0ID09PSBjb250YWluZXJIZWlnaHQ7XG4gICAgICB0YWJzQ29udGVudENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzaW5nJyk7XG4gICAgICB0YWJzQ29udGVudENvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBjb250YWluZXJIZWlnaHQgKyBcInB4XCI7XG4gICAgICB0YWJzQ29udGVudENvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICBhY3RpdmVDb250ZW50LnN0eWxlLmZsb2F0ID0gJyc7XG4gICAgICBuZXh0Q29udGVudC5zdHlsZS5mbG9hdCA9ICcnO1xuICAgIH1cbiAgICBpZiAoIG5leHRDb250ZW50LmNsYXNzTGlzdC5jb250YWlucygnZmFkZScpICkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRDb250ZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQobmV4dENvbnRlbnQsdHJpZ2dlclNob3cpO1xuICAgICAgfSwyMCk7XG4gICAgfSBlbHNlIHsgdHJpZ2dlclNob3coKTsgfVxuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChhY3RpdmVUYWIsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRBY3RpdmVUYWIoKSB7XG4gICAgdmFyIGFjdGl2ZVRhYnMgPSB0YWJzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FjdGl2ZScpLCBhY3RpdmVUYWI7XG4gICAgaWYgKCBhY3RpdmVUYWJzLmxlbmd0aCA9PT0gMSAmJiAhYWN0aXZlVGFic1swXS5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZHJvcGRvd24nKSApIHtcbiAgICAgIGFjdGl2ZVRhYiA9IGFjdGl2ZVRhYnNbMF07XG4gICAgfSBlbHNlIGlmICggYWN0aXZlVGFicy5sZW5ndGggPiAxICkge1xuICAgICAgYWN0aXZlVGFiID0gYWN0aXZlVGFic1thY3RpdmVUYWJzLmxlbmd0aC0xXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZVRhYjtcbiAgfVxuICBmdW5jdGlvbiBnZXRBY3RpdmVDb250ZW50KCkgeyByZXR1cm4gcXVlcnlFbGVtZW50KGdldEFjdGl2ZVRhYigpLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB9XG4gIGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG5leHQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgIXRhYnMuaXNBbmltYXRpbmcgJiYgc2VsZi5zaG93KCk7XG4gIH1cbiAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIG5leHQgPSBuZXh0IHx8IGVsZW1lbnQ7XG4gICAgaWYgKCFuZXh0LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgIG5leHRDb250ZW50ID0gcXVlcnlFbGVtZW50KG5leHQuZ2V0QXR0cmlidXRlKCdocmVmJykpO1xuICAgICAgYWN0aXZlVGFiID0gZ2V0QWN0aXZlVGFiKCk7XG4gICAgICBhY3RpdmVDb250ZW50ID0gZ2V0QWN0aXZlQ29udGVudCgpO1xuICAgICAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoICdoaWRlJywgJ3RhYicsIG5leHQpO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGFjdGl2ZVRhYiwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgIGlmIChoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgIHRhYnMuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgYWN0aXZlVGFiLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgYWN0aXZlVGFiLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsJ2ZhbHNlJyk7XG4gICAgICBuZXh0LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgbmV4dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCd0cnVlJyk7XG4gICAgICBpZiAoIGRyb3Bkb3duICkge1xuICAgICAgICBpZiAoICFlbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bi1tZW51JykgKSB7XG4gICAgICAgICAgaWYgKGRyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHsgZHJvcGRvd24uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWRyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHsgZHJvcGRvd24uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZUNvbnRlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykpIHtcbiAgICAgICAgYWN0aXZlQ29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGFjdGl2ZUNvbnRlbnQsIHRyaWdnZXJIaWRlKTtcbiAgICAgIH0gZWxzZSB7IHRyaWdnZXJIaWRlKCk7IH1cbiAgICB9XG4gIH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja0hhbmRsZXIsZmFsc2UpO1xuICAgIGRlbGV0ZSBlbGVtZW50LlRhYjtcbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgZWxlbWVudC5UYWIgJiYgZWxlbWVudC5UYWIuZGlzcG9zZSgpO1xuICBoZWlnaHREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGVpZ2h0Jyk7XG4gIHRhYnMgPSBlbGVtZW50LmNsb3Nlc3QoJy5uYXYnKTtcbiAgZHJvcGRvd24gPSB0YWJzICYmIHF1ZXJ5RWxlbWVudCgnLmRyb3Bkb3duLXRvZ2dsZScsdGFicyk7XG4gIGFuaW1hdGVIZWlnaHQgPSAhc3VwcG9ydFRyYW5zaXRpb24gfHwgKG9wdGlvbnMuaGVpZ2h0ID09PSBmYWxzZSB8fCBoZWlnaHREYXRhID09PSAnZmFsc2UnKSA/IGZhbHNlIDogdHJ1ZTtcbiAgdGFicy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICBpZiAoICFlbGVtZW50LlRhYiApIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja0hhbmRsZXIsZmFsc2UpO1xuICB9XG4gIGlmIChhbmltYXRlSGVpZ2h0KSB7IHRhYnNDb250ZW50Q29udGFpbmVyID0gZ2V0QWN0aXZlQ29udGVudCgpLnBhcmVudE5vZGU7IH1cbiAgZWxlbWVudC5UYWIgPSBzZWxmO1xufVxuXG5mdW5jdGlvbiBUb2FzdChlbGVtZW50LG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHRvYXN0LCB0aW1lciA9IDAsXG4gICAgICBhbmltYXRpb25EYXRhLFxuICAgICAgYXV0b2hpZGVEYXRhLFxuICAgICAgZGVsYXlEYXRhLFxuICAgICAgc2hvd0N1c3RvbUV2ZW50LFxuICAgICAgaGlkZUN1c3RvbUV2ZW50LFxuICAgICAgc2hvd25DdXN0b21FdmVudCxcbiAgICAgIGhpZGRlbkN1c3RvbUV2ZW50LFxuICAgICAgb3BzID0ge307XG4gIGZ1bmN0aW9uIHNob3dDb21wbGV0ZSgpIHtcbiAgICB0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKCAnc2hvd2luZycgKTtcbiAgICB0b2FzdC5jbGFzc0xpc3QuYWRkKCAnc2hvdycgKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwodG9hc3Qsc2hvd25DdXN0b21FdmVudCk7XG4gICAgaWYgKG9wcy5hdXRvaGlkZSkgeyBzZWxmLmhpZGUoKTsgfVxuICB9XG4gIGZ1bmN0aW9uIGhpZGVDb21wbGV0ZSgpIHtcbiAgICB0b2FzdC5jbGFzc0xpc3QuYWRkKCAnaGlkZScgKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICB0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93JyApO1xuICAgIG9wcy5hbmltYXRpb24gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b2FzdCwgaGlkZUNvbXBsZXRlKSA6IGhpZGVDb21wbGV0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3Bvc2VDb21wbGV0ZSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLHNlbGYuaGlkZSxmYWxzZSk7XG4gICAgZGVsZXRlIGVsZW1lbnQuVG9hc3Q7XG4gIH1cbiAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0b2FzdCAmJiAhdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbCh0b2FzdCxzaG93Q3VzdG9tRXZlbnQpO1xuICAgICAgaWYgKHNob3dDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgICAgb3BzLmFuaW1hdGlvbiAmJiB0b2FzdC5jbGFzc0xpc3QuYWRkKCAnZmFkZScgKTtcbiAgICAgIHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnICk7XG4gICAgICB0b2FzdC5vZmZzZXRXaWR0aDtcbiAgICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoJ3Nob3dpbmcnICk7XG4gICAgICBvcHMuYW5pbWF0aW9uID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIHNob3dDb21wbGV0ZSkgOiBzaG93Q29tcGxldGUoKTtcbiAgICB9XG4gIH07XG4gIHNlbGYuaGlkZSA9IGZ1bmN0aW9uIChub1RpbWVyKSB7XG4gICAgaWYgKHRvYXN0ICYmIHRvYXN0LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgIGlmKGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgICAgbm9UaW1lciA/IGNsb3NlKCkgOiAodGltZXIgPSBzZXRUaW1lb3V0KCBjbG9zZSwgb3BzLmRlbGF5KSk7XG4gICAgfVxuICB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgb3BzLmFuaW1hdGlvbiA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRvYXN0LCBkaXNwb3NlQ29tcGxldGUpIDogZGlzcG9zZUNvbXBsZXRlKCk7XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIGVsZW1lbnQuVG9hc3QgJiYgZWxlbWVudC5Ub2FzdC5kaXNwb3NlKCk7XG4gIHRvYXN0ID0gZWxlbWVudC5jbG9zZXN0KCcudG9hc3QnKTtcbiAgYW5pbWF0aW9uRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicpO1xuICBhdXRvaGlkZURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1hdXRvaGlkZScpO1xuICBkZWxheURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kZWxheScpO1xuICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICd0b2FzdCcpO1xuICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZScsICd0b2FzdCcpO1xuICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3duJywgJ3RvYXN0Jyk7XG4gIGhpZGRlbkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGRlbicsICd0b2FzdCcpO1xuICBvcHMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gPT09IGZhbHNlIHx8IGFuaW1hdGlvbkRhdGEgPT09ICdmYWxzZScgPyAwIDogMTtcbiAgb3BzLmF1dG9oaWRlID0gb3B0aW9ucy5hdXRvaGlkZSA9PT0gZmFsc2UgfHwgYXV0b2hpZGVEYXRhID09PSAnZmFsc2UnID8gMCA6IDE7XG4gIG9wcy5kZWxheSA9IHBhcnNlSW50KG9wdGlvbnMuZGVsYXkgfHwgZGVsYXlEYXRhKSB8fCA1MDA7XG4gIGlmICggIWVsZW1lbnQuVG9hc3QgKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsc2VsZi5oaWRlLGZhbHNlKTtcbiAgfVxuICBlbGVtZW50LlRvYXN0ID0gc2VsZjtcbn1cblxuZnVuY3Rpb24gVG9vbHRpcChlbGVtZW50LG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHRvb2x0aXAgPSBudWxsLCB0aW1lciA9IDAsIHRpdGxlU3RyaW5nLFxuICAgICAgYW5pbWF0aW9uRGF0YSxcbiAgICAgIHBsYWNlbWVudERhdGEsXG4gICAgICBkZWxheURhdGEsXG4gICAgICBjb250YWluZXJEYXRhLFxuICAgICAgc2hvd0N1c3RvbUV2ZW50LFxuICAgICAgc2hvd25DdXN0b21FdmVudCxcbiAgICAgIGhpZGVDdXN0b21FdmVudCxcbiAgICAgIGhpZGRlbkN1c3RvbUV2ZW50LFxuICAgICAgY29udGFpbmVyRWxlbWVudCxcbiAgICAgIGNvbnRhaW5lckRhdGFFbGVtZW50LFxuICAgICAgbW9kYWwsXG4gICAgICBuYXZiYXJGaXhlZFRvcCxcbiAgICAgIG5hdmJhckZpeGVkQm90dG9tLFxuICAgICAgcGxhY2VtZW50Q2xhc3MsXG4gICAgICBvcHMgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpXG4gICAgICAgIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJylcbiAgICAgICAgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRvb2xUaXAoKSB7XG4gICAgb3BzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0b29sdGlwKTtcbiAgICB0b29sdGlwID0gbnVsbDsgdGltZXIgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVRvb2xUaXAoKSB7XG4gICAgdGl0bGVTdHJpbmcgPSBnZXRUaXRsZSgpO1xuICAgIGlmICggdGl0bGVTdHJpbmcgKSB7XG4gICAgICB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpZiAob3BzLnRlbXBsYXRlKSB7XG4gICAgICAgIHZhciB0b29sdGlwTWFya3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvb2x0aXBNYXJrdXAuaW5uZXJIVE1MID0gb3BzLnRlbXBsYXRlLnRyaW0oKTtcbiAgICAgICAgdG9vbHRpcC5jbGFzc05hbWUgPSB0b29sdGlwTWFya3VwLmZpcnN0Q2hpbGQuY2xhc3NOYW1lO1xuICAgICAgICB0b29sdGlwLmlubmVySFRNTCA9IHRvb2x0aXBNYXJrdXAuZmlyc3RDaGlsZC5pbm5lckhUTUw7XG4gICAgICAgIHF1ZXJ5RWxlbWVudCgnLnRvb2x0aXAtaW5uZXInLHRvb2x0aXApLmlubmVySFRNTCA9IHRpdGxlU3RyaW5nLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0b29sdGlwQXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9vbHRpcEFycm93LmNsYXNzTGlzdC5hZGQoJ2Fycm93Jyk7XG4gICAgICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQodG9vbHRpcEFycm93KTtcbiAgICAgICAgdmFyIHRvb2x0aXBJbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b29sdGlwSW5uZXIuY2xhc3NMaXN0LmFkZCgndG9vbHRpcC1pbm5lcicpO1xuICAgICAgICB0b29sdGlwLmFwcGVuZENoaWxkKHRvb2x0aXBJbm5lcik7XG4gICAgICAgIHRvb2x0aXBJbm5lci5pbm5lckhUTUwgPSB0aXRsZVN0cmluZztcbiAgICAgIH1cbiAgICAgIHRvb2x0aXAuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIHRvb2x0aXAuc3R5bGUudG9wID0gJzAnO1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCd0b29sdGlwJyk7XG4gICAgICAhdG9vbHRpcC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rvb2x0aXAnKSAmJiB0b29sdGlwLmNsYXNzTGlzdC5hZGQoJ3Rvb2x0aXAnKTtcbiAgICAgICF0b29sdGlwLmNsYXNzTGlzdC5jb250YWlucyhvcHMuYW5pbWF0aW9uKSAmJiB0b29sdGlwLmNsYXNzTGlzdC5hZGQob3BzLmFuaW1hdGlvbik7XG4gICAgICAhdG9vbHRpcC5jbGFzc0xpc3QuY29udGFpbnMocGxhY2VtZW50Q2xhc3MpICYmIHRvb2x0aXAuY2xhc3NMaXN0LmFkZChwbGFjZW1lbnRDbGFzcyk7XG4gICAgICBvcHMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVUb29sdGlwKCkge1xuICAgIHN0eWxlVGlwKGVsZW1lbnQsIHRvb2x0aXAsIG9wcy5wbGFjZW1lbnQsIG9wcy5jb250YWluZXIpO1xuICB9XG4gIGZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgICF0b29sdGlwLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmICggdG9vbHRpcC5jbGFzc0xpc3QuYWRkKCdzaG93JykgKTtcbiAgfVxuICBmdW5jdGlvbiB0b3VjaEhhbmRsZXIoZSl7XG4gICAgaWYgKCB0b29sdGlwICYmIHRvb2x0aXAuY29udGFpbnMoZS50YXJnZXQpIHx8IGUudGFyZ2V0ID09PSBlbGVtZW50IHx8IGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSA7IGVsc2Uge1xuICAgICAgc2VsZi5oaWRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUFjdGlvbihhY3Rpb24pe1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBkb2N1bWVudFthY3Rpb25dKCAndG91Y2hzdGFydCcsIHRvdWNoSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICB3aW5kb3dbYWN0aW9uXSggJ3Jlc2l6ZScsIHNlbGYuaGlkZSwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgfVxuICBmdW5jdGlvbiBzaG93QWN0aW9uKCkge1xuICAgIHRvZ2dsZUFjdGlvbigxKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd25DdXN0b21FdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gaGlkZUFjdGlvbigpIHtcbiAgICB0b2dnbGVBY3Rpb24oKTtcbiAgICByZW1vdmVUb29sVGlwKCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWN0aW9uKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGVsZW1lbnRbYWN0aW9uXShtb3VzZUNsaWNrRXZlbnRzLmRvd24sIHNlbGYuc2hvdyxmYWxzZSk7XG4gICAgZWxlbWVudFthY3Rpb25dKG1vdXNlSG92ZXJFdmVudHNbMF0sIHNlbGYuc2hvdyxmYWxzZSk7XG4gICAgZWxlbWVudFthY3Rpb25dKG1vdXNlSG92ZXJFdmVudHNbMV0sIHNlbGYuaGlkZSxmYWxzZSk7XG4gIH1cbiAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodG9vbHRpcCA9PT0gbnVsbCkge1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICAgICAgaWYgKHNob3dDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgICAgICBpZihjcmVhdGVUb29sVGlwKCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdXBkYXRlVG9vbHRpcCgpO1xuICAgICAgICAgIHNob3dUb29sdGlwKCk7XG4gICAgICAgICAgISFvcHMuYW5pbWF0aW9uID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9vbHRpcCwgc2hvd0FjdGlvbikgOiBzaG93QWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAyMCApO1xuICB9O1xuICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGVDdXN0b21FdmVudCk7XG4gICAgICAgIGlmIChoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICAgICEhb3BzLmFuaW1hdGlvbiA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRvb2x0aXAsIGhpZGVBY3Rpb24pIDogaGlkZUFjdGlvbigpO1xuICAgICAgfVxuICAgIH0sIG9wcy5kZWxheSk7XG4gIH07XG4gIHNlbGYudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdG9vbHRpcCkgeyBzZWxmLnNob3coKTsgfVxuICAgIGVsc2UgeyBzZWxmLmhpZGUoKTsgfVxuICB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgc2VsZi5oaWRlKCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKSk7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKTtcbiAgICBkZWxldGUgZWxlbWVudC5Ub29sdGlwO1xuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBlbGVtZW50LlRvb2x0aXAgJiYgZWxlbWVudC5Ub29sdGlwLmRpc3Bvc2UoKTtcbiAgYW5pbWF0aW9uRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicpO1xuICBwbGFjZW1lbnREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2VtZW50Jyk7XG4gIGRlbGF5RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRlbGF5Jyk7XG4gIGNvbnRhaW5lckRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb250YWluZXInKTtcbiAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAndG9vbHRpcCcpO1xuICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3duJywgJ3Rvb2x0aXAnKTtcbiAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAndG9vbHRpcCcpO1xuICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAndG9vbHRpcCcpO1xuICBjb250YWluZXJFbGVtZW50ID0gcXVlcnlFbGVtZW50KG9wdGlvbnMuY29udGFpbmVyKTtcbiAgY29udGFpbmVyRGF0YUVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoY29udGFpbmVyRGF0YSk7XG4gIG1vZGFsID0gZWxlbWVudC5jbG9zZXN0KCcubW9kYWwnKTtcbiAgbmF2YmFyRml4ZWRUb3AgPSBlbGVtZW50LmNsb3Nlc3QoJy5maXhlZC10b3AnKTtcbiAgbmF2YmFyRml4ZWRCb3R0b20gPSBlbGVtZW50LmNsb3Nlc3QoJy5maXhlZC1ib3R0b20nKTtcbiAgb3BzLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSAnZmFkZScgPyBvcHRpb25zLmFuaW1hdGlvbiA6IGFuaW1hdGlvbkRhdGEgfHwgJ2ZhZGUnO1xuICBvcHMucGxhY2VtZW50ID0gb3B0aW9ucy5wbGFjZW1lbnQgPyBvcHRpb25zLnBsYWNlbWVudCA6IHBsYWNlbWVudERhdGEgfHwgJ3RvcCc7XG4gIG9wcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgPyBvcHRpb25zLnRlbXBsYXRlIDogbnVsbDtcbiAgb3BzLmRlbGF5ID0gcGFyc2VJbnQob3B0aW9ucy5kZWxheSB8fCBkZWxheURhdGEpIHx8IDIwMDtcbiAgb3BzLmNvbnRhaW5lciA9IGNvbnRhaW5lckVsZW1lbnQgPyBjb250YWluZXJFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogY29udGFpbmVyRGF0YUVsZW1lbnQgPyBjb250YWluZXJEYXRhRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5hdmJhckZpeGVkVG9wID8gbmF2YmFyRml4ZWRUb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuYXZiYXJGaXhlZEJvdHRvbSA/IG5hdmJhckZpeGVkQm90dG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9kYWwgPyBtb2RhbCA6IGRvY3VtZW50LmJvZHk7XG4gIHBsYWNlbWVudENsYXNzID0gXCJicy10b29sdGlwLVwiICsgKG9wcy5wbGFjZW1lbnQpO1xuICB0aXRsZVN0cmluZyA9IGdldFRpdGxlKCk7XG4gIGlmICggIXRpdGxlU3RyaW5nICkgeyByZXR1cm47IH1cbiAgaWYgKCFlbGVtZW50LlRvb2x0aXApIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScsdGl0bGVTdHJpbmcpO1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xuICAgIHRvZ2dsZUV2ZW50cygxKTtcbiAgfVxuICBlbGVtZW50LlRvb2x0aXAgPSBzZWxmO1xufVxuXG52YXIgY29tcG9uZW50c0luaXQgPSB7fTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZURhdGFBUEkoIENvbnN0cnVjdG9yLCBjb2xsZWN0aW9uICl7XG4gIEFycmF5LmZyb20oY29sbGVjdGlvbikubWFwKGZ1bmN0aW9uICh4KXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih4KTsgfSk7XG59XG5mdW5jdGlvbiBpbml0Q2FsbGJhY2sobG9va1VwKXtcbiAgbG9va1VwID0gbG9va1VwIHx8IGRvY3VtZW50O1xuICBmb3IgKHZhciBjb21wb25lbnQgaW4gY29tcG9uZW50c0luaXQpIHtcbiAgICBpbml0aWFsaXplRGF0YUFQSSggY29tcG9uZW50c0luaXRbY29tcG9uZW50XVswXSwgbG9va1VwLnF1ZXJ5U2VsZWN0b3JBbGwgKGNvbXBvbmVudHNJbml0W2NvbXBvbmVudF1bMV0pICk7XG4gIH1cbn1cblxuY29tcG9uZW50c0luaXQuQWxlcnQgPSBbIEFsZXJ0LCAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ107XG5jb21wb25lbnRzSW5pdC5CdXR0b24gPSBbIEJ1dHRvbiwgJ1tkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIl0nIF07XG5jb21wb25lbnRzSW5pdC5DYXJvdXNlbCA9IFsgQ2Fyb3VzZWwsICdbZGF0YS1yaWRlPVwiY2Fyb3VzZWxcIl0nIF07XG5jb21wb25lbnRzSW5pdC5Db2xsYXBzZSA9IFsgQ29sbGFwc2UsICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXScgXTtcbmNvbXBvbmVudHNJbml0LkRyb3Bkb3duID0gWyBEcm9wZG93biwgJ1tkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJdJ107XG5jb21wb25lbnRzSW5pdC5Nb2RhbCA9IFsgTW9kYWwsICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScgXTtcbmNvbXBvbmVudHNJbml0LlBvcG92ZXIgPSBbIFBvcG92ZXIsICdbZGF0YS10b2dnbGU9XCJwb3BvdmVyXCJdLFtkYXRhLXRpcD1cInBvcG92ZXJcIl0nIF07XG5jb21wb25lbnRzSW5pdC5TY3JvbGxTcHkgPSBbIFNjcm9sbFNweSwgJ1tkYXRhLXNweT1cInNjcm9sbFwiXScgXTtcbmNvbXBvbmVudHNJbml0LlRhYiA9IFsgVGFiLCAnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJyBdO1xuY29tcG9uZW50c0luaXQuVG9hc3QgPSBbIFRvYXN0LCAnW2RhdGEtZGlzbWlzcz1cInRvYXN0XCJdJyBdO1xuY29tcG9uZW50c0luaXQuVG9vbHRpcCA9IFsgVG9vbHRpcCwgJ1tkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIl0sW2RhdGEtdGlwPVwidG9vbHRpcFwiXScgXTtcbmRvY3VtZW50LmJvZHkgPyBpbml0Q2FsbGJhY2soKSA6IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gaW5pdFdyYXBwZXIoKXtcblx0aW5pdENhbGxiYWNrKCk7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLGluaXRXcmFwcGVyLGZhbHNlKTtcbn0sIGZhbHNlICk7XG5cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnREYXRhQVBJKCBDb25zdHJ1Y3Rvck5hbWUsIGNvbGxlY3Rpb24gKXtcbiAgQXJyYXkuZnJvbShjb2xsZWN0aW9uKS5tYXAoZnVuY3Rpb24gKHgpeyByZXR1cm4geFtDb25zdHJ1Y3Rvck5hbWVdLmRpc3Bvc2UoKTsgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVEYXRhQVBJKGxvb2tVcCkge1xuICBsb29rVXAgPSBsb29rVXAgfHwgZG9jdW1lbnQ7XG4gIGZvciAodmFyIGNvbXBvbmVudCBpbiBjb21wb25lbnRzSW5pdCkge1xuICAgIHJlbW92ZUVsZW1lbnREYXRhQVBJKCBjb21wb25lbnQsIGxvb2tVcC5xdWVyeVNlbGVjdG9yQWxsIChjb21wb25lbnRzSW5pdFtjb21wb25lbnRdWzFdKSApO1xuICB9XG59XG5cbnZhciB2ZXJzaW9uID0gXCIzLjAuMTBcIjtcblxudmFyIGluZGV4ID0ge1xuICBBbGVydDogQWxlcnQsXG4gIEJ1dHRvbjogQnV0dG9uLFxuICBDYXJvdXNlbDogQ2Fyb3VzZWwsXG4gIENvbGxhcHNlOiBDb2xsYXBzZSxcbiAgRHJvcGRvd246IERyb3Bkb3duLFxuICBNb2RhbDogTW9kYWwsXG4gIFBvcG92ZXI6IFBvcG92ZXIsXG4gIFNjcm9sbFNweTogU2Nyb2xsU3B5LFxuICBUYWI6IFRhYixcbiAgVG9hc3Q6IFRvYXN0LFxuICBUb29sdGlwOiBUb29sdGlwLFxuICBpbml0Q2FsbGJhY2s6IGluaXRDYWxsYmFjayxcbiAgcmVtb3ZlRGF0YUFQSTogcmVtb3ZlRGF0YUFQSSxcbiAgY29tcG9uZW50c0luaXQ6IGNvbXBvbmVudHNJbml0LFxuICBWZXJzaW9uOiB2ZXJzaW9uXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgKHV0aWxzLmlzQmxvYihyZXF1ZXN0RGF0YSkgfHwgdXRpbHMuaXNGaWxlKHJlcXVlc3REYXRhKSkgJiZcbiAgICAgIHJlcXVlc3REYXRhLnR5cGVcbiAgICApIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcih0aW1lb3V0RXJyb3JNZXNzYWdlLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdkYXRhJ107XG4gIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5JywgJ3BhcmFtcyddO1xuICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgJ2Jhc2VVUkwnLCAndHJhbnNmb3JtUmVxdWVzdCcsICd0cmFuc2Zvcm1SZXNwb25zZScsICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAndGltZW91dCcsICd0aW1lb3V0TWVzc2FnZScsICd3aXRoQ3JlZGVudGlhbHMnLCAnYWRhcHRlcicsICdyZXNwb25zZVR5cGUnLCAneHNyZkNvb2tpZU5hbWUnLFxuICAgICd4c3JmSGVhZGVyTmFtZScsICdvblVwbG9hZFByb2dyZXNzJywgJ29uRG93bmxvYWRQcm9ncmVzcycsICdkZWNvbXByZXNzJyxcbiAgICAnbWF4Q29udGVudExlbmd0aCcsICdtYXhCb2R5TGVuZ3RoJywgJ21heFJlZGlyZWN0cycsICd0cmFuc3BvcnQnLCAnaHR0cEFnZW50JyxcbiAgICAnaHR0cHNBZ2VudCcsICdjYW5jZWxUb2tlbicsICdzb2NrZXRQYXRoJywgJ3Jlc3BvbnNlRW5jb2RpbmcnXG4gIF07XG4gIHZhciBkaXJlY3RNZXJnZUtleXMgPSBbJ3ZhbGlkYXRlU3RhdHVzJ107XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB1dGlscy5mb3JFYWNoKHZhbHVlRnJvbUNvbmZpZzJLZXlzLCBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgdXRpbHMuZm9yRWFjaChkZWZhdWx0VG9Db25maWcyS2V5cywgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goZGlyZWN0TWVyZ2VLZXlzLCBmdW5jdGlvbiBtZXJnZShwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAuY29uY2F0KG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzKVxuICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpXG4gICAgLmNvbmNhdChkaXJlY3RNZXJnZUtleXMpO1xuXG4gIHZhciBvdGhlcktleXMgPSBPYmplY3RcbiAgICAua2V5cyhjb25maWcxKVxuICAgIC5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpXG4gICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjIwJztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXG4gICAgICBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuICB2YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG4gIHZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMixcbiAgICAgIExBWllfV0hJTEVfRkxBRyA9IDM7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgICAgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG4gIHZhciB3cmFwRmxhZ3MgPSBbXG4gICAgWydhcnknLCBXUkFQX0FSWV9GTEFHXSxcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gICAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgICBbJ2N1cnJ5JywgV1JBUF9DVVJSWV9GTEFHXSxcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICAgIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgICBbJ3BhcnRpYWwnLCBXUkFQX1BBUlRJQUxfRkxBR10sXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gICAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nLFxuICAgICAgd2Vha1NldFRhZyA9ICdbb2JqZWN0IFdlYWtTZXRdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nLFxuICAgICAgcmVUcmltU3RhcnQgPSAvXlxccysvLFxuICAgICAgcmVUcmltRW5kID0gL1xccyskLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLFxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICAgIHJlU3BsaXREZXRhaWxzID0gLyw/ICYgLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2hcbiAgICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbiAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgICByc09yZExvd2VyID0gJ1xcXFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpKD89XFxcXGJ8W0EtWl9dKScsXG4gICAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgICByc09yZFVwcGVyLFxuICAgIHJzT3JkTG93ZXIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQnVmZmVyJywgJ0RhdGFWaWV3JywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWFwJywgJ01hdGgnLCAnT2JqZWN0JyxcbiAgICAnUHJvbWlzZScsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdTeW1ib2wnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnLFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAgICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAgICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAgICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAgICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAgICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAgICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG4gIHZhciBmcmVlUGFyc2VGbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuICB2YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICAgIGlmICh0eXBlcykge1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuICB2YXIgbm9kZUlzQXJyYXlCdWZmZXIgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0FycmF5QnVmZmVyLFxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgICAgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHAsXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAqIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNZWFuKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgKiBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGBwbGFjZWhvbGRlcmAgb2NjdXJyZW5jZXMgaW4gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGNvdW50LlxuICAgKi9cbiAgZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICArK3Jlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovXG4gIHZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgaXRlcmF0b3JgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgdmFyIGRhdGEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBpdHMgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9QYWlycyhzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmxhc3RJbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgKytyZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIENyZWF0ZSBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qcy5cbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIHZhciBydW5JbkNvbnRleHQgPSAoZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuXG4gICAgLyoqIEJ1aWx0LWluIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgICB2YXIgY29yZUpzRGF0YSA9IGNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICAgIHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbiAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IGNvbnRleHQuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbCxcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcbiAgICAgICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgICAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bUl0ZXJhdG9yID0gU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9KCkpO1xuXG4gICAgLyoqIE1vY2tlZCBidWlsdC1pbnMuICovXG4gICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgY3R4Tm93ID0gRGF0ZSAmJiBEYXRlLm5vdyAhPT0gcm9vdC5EYXRlLm5vdyAmJiBEYXRlLm5vdyxcbiAgICAgICAgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSm9pbiA9IGFycmF5UHJvdG8uam9pbixcbiAgICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlTm93ID0gRGF0ZS5ub3csXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb20sXG4gICAgICAgIG5hdGl2ZVJldmVyc2UgPSBhcnJheVByb3RvLnJldmVyc2U7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG4gICAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdEYXRhVmlldycpLFxuICAgICAgICBNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ01hcCcpLFxuICAgICAgICBQcm9taXNlID0gZ2V0TmF0aXZlKGNvbnRleHQsICdQcm9taXNlJyksXG4gICAgICAgIFNldCA9IGdldE5hdGl2ZShjb250ZXh0LCAnU2V0JyksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKSxcbiAgICAgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4gICAgLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG4gICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbiAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgICAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICAgICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcy4gTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLFxuICAgICAqIGFuZCBmdW5jdGlvbnMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZVxuICAgICAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAgICAgKiBhbmQgcmV0dXJuIHRoZSB1bndyYXBwZWQgdmFsdWUuIE90aGVyd2lzZSwgdGhlIHZhbHVlIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbiBzZXF1ZW5jZXMsIHdoaWNoIG11c3QgYmUgdW53cmFwcGVkIHdpdGggYF8jdmFsdWVgLCBtYXkgYmVcbiAgICAgKiBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC5cbiAgICAgKlxuICAgICAqIFRoZSBleGVjdXRpb24gb2YgY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGl0J3MgZGVmZXJyZWQgdW50aWxcbiAgICAgKiBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLlxuICAgICAqIFNob3J0Y3V0IGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdG8gbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgYXZvaWRzXG4gICAgICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gICAgICogaXRlcmF0ZWUgZXhlY3V0aW9ucy4gU2VjdGlvbnMgb2YgYSBjaGFpbiBzZXF1ZW5jZSBxdWFsaWZ5IGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpZiB0aGUgc2VjdGlvbiBpcyBhcHBsaWVkIHRvIGFuIGFycmF5IGFuZCBpdGVyYXRlZXMgYWNjZXB0IG9ubHlcbiAgICAgKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaXMgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAgICAgKiBgZmluZExhc3RgLCBgaGVhZGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHJlamVjdGAsIGByZXZlcnNlYCwgYHNsaWNlYCxcbiAgICAgKiBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBhbmQgYHRvQXJyYXlgXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgbWV0aG9kcyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXNzaWduSW5gLCBgYXNzaWduSW5XaXRoYCwgYGFzc2lnbldpdGhgLCBgYXRgLFxuICAgICAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAgICAgKiBgY29tbWl0YCwgYGNvbXBhY3RgLCBgY29uY2F0YCwgYGNvbmZvcm1zYCwgYGNvbnN0YW50YCwgYGNvdW50QnlgLCBgY3JlYXRlYCxcbiAgICAgKiBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICAgICAqIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZXh0ZW5kYCwgYGV4dGVuZFdpdGhgLCBgZmlsbGAsIGBmaWx0ZXJgLFxuICAgICAqIGBmbGF0TWFwYCwgYGZsYXRNYXBEZWVwYCwgYGZsYXRNYXBEZXB0aGAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCxcbiAgICAgKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gICAgICogYGZ1bmN0aW9uc0luYCwgYGdyb3VwQnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW50ZXJzZWN0aW9uQnlgLFxuICAgICAqIGBpbnRlcnNlY3Rpb25XaXRoYCwgYGludmVydGAsIGBpbnZlcnRCeWAsIGBpbnZva2VNYXBgLCBgaXRlcmF0ZWVgLCBga2V5QnlgLFxuICAgICAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICAgICAqIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1lcmdlV2l0aGAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLCBgbmVnYXRlYCxcbiAgICAgKiBgbnRoQXJnYCwgYG9taXRgLCBgb21pdEJ5YCwgYG9uY2VgLCBgb3JkZXJCeWAsIGBvdmVyYCwgYG92ZXJBcmdzYCxcbiAgICAgKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAgICAgKiBgcGlja0J5YCwgYHBsYW50YCwgYHByb3BlcnR5YCwgYHByb3BlcnR5T2ZgLCBgcHVsbGAsIGBwdWxsQWxsYCwgYHB1bGxBbGxCeWAsXG4gICAgICogYHB1bGxBbGxXaXRoYCwgYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVhcmdgLCBgcmVqZWN0YCxcbiAgICAgKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICAgICAqIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdG9BcnJheWAsXG4gICAgICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gICAgICogYHVuaW9uYCwgYHVuaW9uQnlgLCBgdW5pb25XaXRoYCwgYHVuaXFgLCBgdW5pcUJ5YCwgYHVuaXFXaXRoYCwgYHVuc2V0YCxcbiAgICAgKiBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdXBkYXRlYCwgYHVwZGF0ZVdpdGhgLCBgdmFsdWVzYCxcbiAgICAgKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gICAgICogYHppcE9iamVjdGAsIGB6aXBPYmplY3REZWVwYCwgYW5kIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbGFtcGAsIGBjbG9uZWAsXG4gICAgICogYGNsb25lRGVlcGAsIGBjbG9uZURlZXBXaXRoYCwgYGNsb25lV2l0aGAsIGBjb25mb3Jtc1RvYCwgYGRlYnVycmAsXG4gICAgICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAgICAgKiBgZXNjYXBlUmVnRXhwYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCwgYGZpbmRLZXlgLCBgZmluZExhc3RgLFxuICAgICAqIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpcnN0YCwgYGZsb29yYCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCxcbiAgICAgKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICAgICAqIGBoYXNJbmAsIGBoZWFkYCwgYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLCBgaW5SYW5nZWAsIGBpbnZva2VgLFxuICAgICAqIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQXJyYXlCdWZmZXJgLCBgaXNBcnJheUxpa2VgLCBgaXNBcnJheUxpa2VPYmplY3RgLFxuICAgICAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICAgICAqIGBpc0VxdWFsV2l0aGAsIGBpc0Vycm9yYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNJbnRlZ2VyYCwgYGlzTGVuZ3RoYCxcbiAgICAgKiBgaXNNYXBgLCBgaXNNYXRjaGAsIGBpc01hdGNoV2l0aGAsIGBpc05hTmAsIGBpc05hdGl2ZWAsIGBpc05pbGAsIGBpc051bGxgLFxuICAgICAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gICAgICogYGlzU2FmZUludGVnZXJgLCBgaXNTZXRgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgaXNUeXBlZEFycmF5YCxcbiAgICAgKiBgaXNXZWFrTWFwYCwgYGlzV2Vha1NldGAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCxcbiAgICAgKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gICAgICogYG1pbmAsIGBtaW5CeWAsIGBtdWx0aXBseWAsIGBub0NvbmZsaWN0YCwgYG5vb3BgLCBgbm93YCwgYG50aGAsIGBwYWRgLFxuICAgICAqIGBwYWRFbmRgLCBgcGFkU3RhcnRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLFxuICAgICAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZEluZGV4QnlgLCBgc29ydGVkTGFzdEluZGV4YCxcbiAgICAgKiBgc29ydGVkTGFzdEluZGV4QnlgLCBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3R1YkFycmF5YCwgYHN0dWJGYWxzZWAsXG4gICAgICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0aW1lc2AsIGB0b0Zpbml0ZWAsIGB0b0ludGVnZXJgLCBgdG9KU09OYCwgYHRvTGVuZ3RoYCxcbiAgICAgKiBgdG9Mb3dlcmAsIGB0b051bWJlcmAsIGB0b1NhZmVJbnRlZ2VyYCwgYHRvU3RyaW5nYCwgYHRvVXBwZXJgLCBgdHJpbWAsXG4gICAgICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gICAgICogYHVwcGVyRmlyc3RgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB3cmFwcGVkLnJlZHVjZShfLmFkZCk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhIHdyYXBwZWQgdmFsdWUuXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAgICAgKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbG9kYXNoO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19kaXJfXyA9IDE7XG4gICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gICAgICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsb25lXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlDbG9uZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19kaXJfXyA9IHRoaXMuX19kaXJfXztcbiAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gY29weUFycmF5KHRoaXMuX19pdGVyYXRlZXNfXyk7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCksXG4gICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShhcnJheSksXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFyckxlbmd0aCwgdGhpcy5fX3ZpZXdzX18pLFxuICAgICAgICAgIHN0YXJ0ID0gdmlldy5zdGFydCxcbiAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcbiAgICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiAoc3RhcnQgLSAxKSxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XG5cbiAgICAgIGlmICghaXNBcnIgfHwgKCFpc1JpZ2h0ICYmIGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xuICAgICAgICBpbmRleCArPSBkaXI7XG5cbiAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuICAgICAgICAgIHZhciBkYXRhID0gaXRlcmF0ZWVzW2l0ZXJJbmRleF0sXG4gICAgICAgICAgICAgIGl0ZXJhdGVlID0gZGF0YS5pdGVyYXRlZSxcbiAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gICAgICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbiAgICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuICAgIEhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG4gICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIGRhdGEucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICAtLXRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICArK3RoaXMuc2l6ZTtcbiAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBhZGRcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAYWxpYXMgcHVzaFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuICAgIFNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuICAgIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG4gICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICAgICApKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGUoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZVNpemVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICAgICAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAgICAgKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gICAgICogdmFsdWUgY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWwgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXAgPSBvYmplY3QgPT0gbnVsbDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQgOiBnZXQob2JqZWN0LCBwYXRoc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAgICAgKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gRGVlcCBjbG9uZVxuICAgICAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICAgICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgfVxuICAgICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxuICAgICAgICAgICAgcHJlZGljYXRlID0gc291cmNlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICgodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAgICAgKiB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICAgKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZW5kID0gc3RhcnQgPiBlbmQgPyAwIDogdG9MZW5ndGgoZW5kKTtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm50aGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbiArPSBuIDwgMCA/IGxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICAgIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShpdGVyYXRlZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYmFzZUdldCh2YWx1ZSwgaXRlcmF0ZWUubGVuZ3RoID09PSAxID8gaXRlcmF0ZWVbMF0gOiBpdGVyYXRlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpdGVyYXRlZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaWRlbnRpdHldO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEFsbEJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAgICogc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4T2YgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHNlZW4gPSBhcnJheTtcblxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gY29weUFycmF5KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2VlbiA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSkgPiAtMSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlcGVhdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlU2l6ZWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoYXJyYXksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gbG93IDogYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXG4gICAgICAgICAgICAgIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4QnlgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhCeWBcbiAgICAgKiB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGVcbiAgICAgKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICB2YXIgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSksXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IG90aElzRGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XG4gICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxuICAgICAqIGNvbnZlcnNpb25zIG9mIGJpbmFyeSwgaGV4YWRlY2ltYWwsIG9yIG9jdGFsIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICByZXR1cm4gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB1cGRhdGVyKGJhc2VHZXQob2JqZWN0LCBwYXRoKSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kcm9wV2hpbGVgIGFuZCBgXy50YWtlV2hpbGVgXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJlxuICAgICAgICBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuXG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlcmZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9LCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVVuaXEoYXJyYXlzWzBdKSA6IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcbiAgICAgICAgICAgIG90aEluZGV4ID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBiYXNlRGlmZmVyZW5jZShyZXN1bHRbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4ocmVzdWx0LCAxKSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYXNzaWduRnVuYyhyZXN1bHQsIHByb3BzW2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBgYmFzZVJlc3RgIGFsaWFzIHdoaWNoIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBpZGVudGl0eWAgYnkgbW9kdWxlXG4gICAgICogcmVwbGFjZW1lbnQgcGx1Z2lucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BjbGVhclRpbWVvdXRgXShodHRwczovL21kbi5pby9jbGVhclRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IGlkIFRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdCBvZiB0aGUgdGltZXIgdG8gY2xlYXIuXG4gICAgICovXG4gICAgdmFyIGNsZWFyVGltZW91dCA9IGN0eENsZWFyVGltZW91dCB8fCBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICAgICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAgICAgKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAgICAgKlxuICAgICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gICAgICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICAgICAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgICAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyByYW5nZUxlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gICAgICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgcmFuZ2VMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtvZmZzZXQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICAgICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yKEN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgICAgICAvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWZ1bmN0aW9uLW9iamVjdHMtY2FsbC10aGlzYXJndW1lbnQtYXJndW1lbnRzbGlzdFxuICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcml0eSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlcik7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgICAgICA/IFtdXG4gICAgICAgICAgOiByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXJncywgaG9sZGVycywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5IC0gbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmxvd2Agb3IgYF8uZmxvd1JpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmNzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHByZXJlcSA9IExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnU7XG5cbiAgICAgICAgaWYgKGZyb21SaWdodCkge1xuICAgICAgICAgIGZ1bmNzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIHZhciBmdW5jID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVyZXEgJiYgIXdyYXBwZXIgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBMb2Rhc2hXcmFwcGVyKFtdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gaW5kZXggOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmXG4gICAgICAgICAgICAgICAgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLCBkYXRhWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpXG4gICAgICAgICAgICAgID8gd3JhcHBlcltmdW5jTmFtZV0oKVxuICAgICAgICAgICAgICA6IHdyYXBwZXIudGhydShmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcbiAgICAgKiAgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIFdSQVBfQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyaWVkID0gYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLFxuICAgICAgICAgIGlzRmxpcCA9IGJpdG1hc2sgJiBXUkFQX0ZMSVBfRkxBRyxcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJpZWQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksXG4gICAgICAgICAgICAgIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzQ291bnQ7XG4gICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgbmV3SG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdGhpc0FyZyxcbiAgICAgICAgICAgIGFyZ3MsIG5ld0hvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSAtIGxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblxuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ1Bvcykge1xuICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwICYmIGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgIGZuID0gQ3RvciB8fCBjcmVhdGVDdG9yKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uaW52ZXJ0QnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdG9JdGVyYXRlZSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52ZXJ0ZXIoc2V0dGVyLCB0b0l0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCB0b0l0ZXJhdGVlKGl0ZXJhdGVlKSwge30pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHVzZWQgZm9yIGB1bmRlZmluZWRgIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hdGhPcGVyYXRpb24ob3BlcmF0b3IsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb1N0cmluZyhvdGhlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5vdmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG92ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT3ZlcihhcnJheUZ1bmMpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihpdGVyYXRlZXMpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gYXJyYXlGdW5jKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AgYmFzZWQgb24gYGxlbmd0aGAuIFRoZSBgY2hhcnNgIHN0cmluZ1xuICAgICAqIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgY2hhcnMgPSBjaGFycyA9PT0gdW5kZWZpbmVkID8gJyAnIDogYmFzZVRvU3RyaW5nKGNoYXJzKTtcblxuICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgaWYgKGNoYXJzTGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY2hhcnNMZW5ndGggPyBiYXNlUmVwZWF0KGNoYXJzLCBsZW5ndGgpIDogY2hhcnM7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChsZW5ndGggLyBzdHJpbmdTaXplKGNoYXJzKSkpO1xuICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpXG4gICAgICAgID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0KSwgMCwgbGVuZ3RoKS5qb2luKCcnKVxuICAgICAgICA6IHJlc3VsdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgICAgIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcblxuICAgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHJlbGF0aW9uYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVsYXRpb25hbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgIG90aGVyID0gdG9OdW1iZXIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gY29udGludWUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAgICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVjdXJyeShmdW5jLCBiaXRtYXNrLCB3cmFwRnVuYywgcGxhY2Vob2xkZXIsIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgICAgICBuZXdIb2xkZXJzID0gaXNDdXJyeSA/IGhvbGRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGhvbGRlcnMsXG4gICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBwYXJ0aWFscztcblxuICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICAgICAgaWYgKCEoYml0bWFzayAmIFdSQVBfQ1VSUllfQk9VTkRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3SG9sZGVycywgbmV3UGFydGlhbHNSaWdodCxcbiAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIHZhciByZXN1bHQgPSB3cmFwRnVuYy5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHJlc3VsdCwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ucm91bmRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XG4gICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAwIDogbmF0aXZlTWluKHRvSW50ZWdlcihwcmVjaXNpb24pLCAyOTIpO1xuICAgICAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cbiAgICAgICAgICAvLyBTZWUgW01ETl0oaHR0cHM6Ly9tZG4uaW8vcm91bmQjRXhhbXBsZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArICdlJykuc3BsaXQoJ2UnKSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcblxuICAgICAgICAgIHBhaXIgPSAodG9TdHJpbmcodmFsdWUpICsgJ2UnKS5zcGxpdCgnZScpO1xuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFpcnMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogIDI1NiAtIGBfLmFyeWBcbiAgICAgKiAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gICAgICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgICAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgICAgIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICAgICAgfVxuICAgICAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAgICAgKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gICAgICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgICAgIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IChmdW5jLm5hbWUgKyAnJyksXG4gICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywgcmVzdWx0KSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcbiAgICAgIHZhciBvYmplY3QgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwgJ3BsYWNlaG9sZGVyJykgPyBsb2Rhc2ggOiBmdW5jO1xuICAgICAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcIml0ZXJhdGVlXCIgZnVuY3Rpb24uIElmIGBfLml0ZXJhdGVlYCBpcyBjdXN0b21pemVkLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGJhc2VJdGVyYXRlZWAuXG4gICAgICogSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgdGhlIGNob3NlbiBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIHRoZSBjcmVhdGVkIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0ZWUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLml0ZXJhdGVlIHx8IGl0ZXJhdGVlO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpdGVyYXRlZSA/IGJhc2VJdGVyYXRlZSA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICAgIDogZGF0YS5tYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgICAgaWYgKGlzT3duKSB7XG4gICAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbiAgICAvLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG4gICAgaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgICAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAgICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgICAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gICAgICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1zIFRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZpZXcuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHN0YXJ0YCBhbmQgYGVuZGBcbiAgICAgKiAgcG9zaXRpb25zIG9mIHRoZSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHJhbnNmb3Jtc1tpbmRleF0sXG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZHJvcCc6ICAgICAgc3RhcnQgKz0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZHJvcFJpZ2h0JzogZW5kIC09IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2UnOiAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2VSaWdodCc6IHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0LCBlbmQgLSBzaXplKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7ICdzdGFydCc6IHN0YXJ0LCAnZW5kJzogZW5kIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3cmFwcGVyIGRldGFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2gocmVXcmFwRGV0YWlscyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChyZVNwbGl0RGV0YWlscykgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgICAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgZGV0YWlscyA9IGRldGFpbHMuam9pbihsZW5ndGggPiAyID8gJywgJyA6ICcgJyk7XG4gICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gICAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBvdGhlciAhPSAnZnVuY3Rpb24nIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBjYXBhYmxlIG9mIGJlaW5nIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIHZhciBpc01hc2thYmxlID0gY29yZUpzRGF0YSA/IGlzRnVuY3Rpb24gOiBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgdXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAgICAgKiBgXy5yZWFyZ2AgbW9kaWZ5IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZVxuICAgICAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICAgICAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gICAgICogYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykpICYmIChzb3VyY2VbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs2XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICAgICAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAgICAgKiBmdW5jdGlvbiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWVcbiAgICAgKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSBzaG9ydE91dChiYXNlU2V0RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgc2V0VGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL3NldFRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VGltZW91dCA9IGN0eFNldFRpbWVvdXQgfHwgZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgICAgcmV0dXJuIHJvb3Quc2V0VGltZW91dChmdW5jLCB3YWl0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAgICAgKiB3aXRoIHdyYXBwZXIgZGV0YWlscyBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgc291cmNlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgd3JhcHBlcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICAgICAgdmFyIHNvdXJjZSA9IChyZWZlcmVuY2UgKyAnJyk7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcod3JhcHBlciwgaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCB1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLCBiaXRtYXNrKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXcmFwRGV0YWlscyhkZXRhaWxzLCBiaXRtYXNrKSB7XG4gICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgICAgICBpZiAoKGJpdG1hc2sgJiBwYWlyWzFdKSAmJiAhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gICAgICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgYXJyYXlgIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY2h1bmtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCh0b0ludGVnZXIoc2l6ZSksIDApO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBjb25jYXRlbmF0aW5nIGBhcnJheWAgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvdGhlcik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoIC0gMSksXG4gICAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpID8gY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIGJhc2VGbGF0dGVuKGFyZ3MsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLndpdGhvdXQsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sIFt7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZUJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIG9yZGVyIGFuZFxuICAgICAqIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxXaXRoYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZVdpdGgob2JqZWN0cywgW3sgJ3gnOiAxLCAneSc6IDIgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZVdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xuICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4LCAxMF0sICcqJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzQsICcqJywgJyonLCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggPCAwXG4gICAgICAgICAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApXG4gICAgICAgICAgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIElORklOSVRZKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgWzIsIFszLCBbNF1dLCA1XV07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy50b1BhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBmaXJzdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmhlYWQoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMCwgLTEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBpZiAoaXRlcmF0ZWUgPT09IGxhc3QobWFwcGVkKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXNcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYWxsIGVsZW1lbnRzIGluIGBhcnJheWAgaW50byBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBqb2luZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmpvaW4oWydhJywgJ2InLCAnYyddLCAnficpO1xuICAgICAqIC8vID0+ICdhfmJ+YydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqb2luKGFycmF5LCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gJycgOiBuYXRpdmVKb2luLmNhbGwoYXJyYXksIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICAgID8gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleClcbiAgICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IGF0IGluZGV4IGBuYCBvZiBgYXJyYXlgLiBJZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSBudGhcbiAgICAgKiBlbGVtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcbiAgICAgKiAvLyA9PiAnYyc7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGdpdmVuIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcbiAgICAgKiB0byByZW1vdmUgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgJ2EnLCAnYycpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbEJ5KGFycmF5LCBbeyAneCc6IDEgfSwgeyAneCc6IDMgfV0sICd4Jyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZVdpdGhgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDMsICd5JzogNCB9LCB7ICd4JzogNSwgJ3knOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsV2l0aChhcnJheSwgW3sgJ3gnOiAzLCAneSc6IDQgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cbiAgICAgKiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocHVsbGVkKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXG4gICAgICovXG4gICAgdmFyIHB1bGxBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZUF0KGFycmF5LCBpbmRleGVzKTtcblxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCkgPyAraW5kZXggOiBpbmRleDtcbiAgICAgIH0pLnNvcnQoY29tcGFyZUFzY2VuZGluZykpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gICAgICogdG8gcHVsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgQXJyYXkjcmV2ZXJzZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3JldmVyc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5yZXZlcnNlKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2ZcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZExhc3RJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubGFzdEluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgaWYgKGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFCeWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXFCeShbMS4xLCAxLjIsIDIuMywgMi40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMSwgMi4zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRhaWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWlsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAxLCBsZW5ndGgpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb20gdGhlIGZpcnN0XG4gICAgICogYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uQnkoWzIuMV0sIFsxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbVxuICAgICAqIHRoZSBmaXJzdCBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICAgICAqIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgICAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pcUJ5KFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIHVuZGVmaW5lZCwgY29tcGFyYXRvcikgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlVGltZXMobGVuZ3RoLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XG4gICAgICogLy8gPT4gW1sxLCAxMCwgMTAwXSwgWzIsIDIwLCAyMDBdXVxuICAgICAqXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzMsIDMwLCAzMDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgZ2l2ZW4gdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gICAgICogW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICAgICAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkXG4gICAgICogYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmVcbiAgICAgKiBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvckJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjIsIDMuNF1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ueG9yQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHhvckJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy54b3JXaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHhvcldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAgICAgKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwT2JqZWN0YCBleGNlcHQgdGhhdCBpdCBzdXBwb3J0cyBwcm9wZXJ0eSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3REZWVwKFsnYS5iWzBdLmMnLCAnYS5iWzFdLmQnXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IFt7ICdjJzogMSB9LCB7ICdkJzogMiB9XSB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3REZWVwKHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGJhc2VTZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzExMSwgMjIyXVxuICAgICAqL1xuICAgIHZhciB6aXBXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGl0ZXJhdGVlID0gdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgPyAoYXJyYXlzLnBvcCgpLCBpdGVyYXRlZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXG4gICAgICogICAuY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cbiAgICAgKiBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UgaW4gb3JkZXIgdG8gbW9kaWZ5IGludGVybWVkaWF0ZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJwYXNzIHRocnVcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxuICAgICAqIHJlc3VsdHMgaW4gYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gbGVuZ3RoID8gcGF0aHNbMF0gOiAwLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gYmFzZUF0KG9iamVjdCwgcGF0aHMpOyB9O1xuXG4gICAgICBpZiAobGVuZ3RoID4gMSB8fCB0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCB8fFxuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAnYXJncyc6IFtpbnRlcmNlcHRvcl0sXG4gICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSwgdGhpcy5fX2NoYWluX18pLnRocnUoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAmJiAhYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2Ugd2l0aCBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycykuaGVhZCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKVxuICAgICAqICAgLmNoYWluKClcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgdmFsdWUgb24gYSB3cmFwcGVkIG9iamVjdCBmb2xsb3dpbmcgdGhlXG4gICAgICogW2l0ZXJhdG9yIHByb3RvY29sXShodHRwczovL21kbi5pby9pdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG5leHRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXh0IGl0ZXJhdG9yIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMSB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDIgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IHRydWUsICd2YWx1ZSc6IHVuZGVmaW5lZCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICBpZiAodGhpcy5fX3ZhbHVlc19fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdmFyIGRvbmUgPSB0aGlzLl9faW5kZXhfXyA+PSB0aGlzLl9fdmFsdWVzX18ubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZCA6IHRoaXMuX192YWx1ZXNfX1t0aGlzLl9faW5kZXhfXysrXTtcblxuICAgICAgcmV0dXJuIHsgJ2RvbmUnOiBkb25lLCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdyYXBwZXIgdG8gYmUgaXRlcmFibGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBTeW1ib2wuaXRlcmF0b3JcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKSA9PT0gd3JhcHBlZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHdyYXBwZWQpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjaGFpbiBzZXF1ZW5jZSBwbGFudGluZyBgdmFsdWVgIGFzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhbnRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwbGFudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKS5tYXAoc3F1YXJlKTtcbiAgICAgKiB2YXIgb3RoZXIgPSB3cmFwcGVkLnBsYW50KFszLCA0XSk7XG4gICAgICpcbiAgICAgKiBvdGhlci52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGNsb25lLl9faW5kZXhfXyA9IDA7XG4gICAgICAgIGNsb25lLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLnJldmVyc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8oYXJyYXkpLnJldmVyc2UoKS52YWx1ZSgpXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclJldmVyc2UoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgd3JhcHBlZCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgIHdyYXBwZWQuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAgICdhcmdzJzogW3JldmVyc2VdLFxuICAgICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlZCwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICArK3Jlc3VsdFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBbZW1wdHkgY29sbGVjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtcHR5X3NldCkgYmVjYXVzZVxuICAgICAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gICAgICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5yZWplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBDb21iaW5pbmcgc2V2ZXJhbCBwcmVkaWNhdGVzIHVzaW5nIGBfLm92ZXJFdmVyeWAgb3IgYF8ub3ZlclNvbWVgLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLm92ZXJTb21lKFt7ICdhZ2UnOiAzNiB9LCBbJ2FnZScsIDQwXV0pKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXG4gICAgICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtuLCBuXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVlcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBJTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cyB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVwdGgoWzEsIDJdLCBkdXBsaWNhdGUsIDIpO1xuICAgICAqIC8vID0+IFtbMSwgMV0sIFsyLCAyXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVwdGgoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoUmlnaHQoWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDJgIHRoZW4gYDFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIG9yZGVyIG9mIGdyb3VwZWQgdmFsdWVzXG4gICAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gICAgICoga2V5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuM10gfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYHBhdGhgIGlzIGEgZnVuY3Rpb24sIGl0J3MgaW52b2tlZFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBhcHBseShwYXRoLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gICAgICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gICAgICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAgICAgKiBhbmQgYHNvcnRCeWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbjtcbiAgICAgKiB9LCAwKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlamVjdCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBmcm9tIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYG5gIHJhbmRvbSBlbGVtZW50cyBhdCB1bmlxdWUga2V5cyBmcm9tIGBjb2xsZWN0aW9uYCB1cCB0byB0aGVcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAgICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDMwXV1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDhdXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gICAgICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICAgKiB9LCBfLm5vdygpKTtcbiAgICAgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHZhciBub3cgPSBjdHhOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdXAgdG8gYG5gIGFyZ3VtZW50cyxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgbiA9IGd1YXJkID8gdW5kZWZpbmVkIDogbjtcbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgLCB0aGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWAgd2l0aCBgcGFydGlhbHNgXG4gICAgICogcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC4gU2VlXG4gICAgICogW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZva2UgdGhlIG1ldGhvZCBvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhcmd1bWVudHMgb2YgYGZ1bmNgIGFuZCBlaXRoZXIgaW52b2tlc1xuICAgICAqIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYXQgbGVhc3QgYGFyaXR5YCBudW1iZXIgb2YgYXJndW1lbnRzIGhhdmVcbiAgICAgKiBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgYGZ1bmNgXG4gICAgICogYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZCBpZiBgZnVuYy5sZW5ndGhgXG4gICAgICogaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnlSaWdodChmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfUklHSFRfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAgICogaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgICAgIHJldHVybiBtYXhpbmdcbiAgICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICAgICAgOiB0aW1lV2FpdGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlZmVyID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IExvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgdG9OdW1iZXIod2FpdCkgfHwgMCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZsaXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbGlwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmxpcHBlZCA9IF8uZmxpcChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZsaXBwZWQoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiBbJ2QnLCAnYycsICdiJywgJ2EnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAgICpcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhbHVlcyhvdGhlcik7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICpcbiAgICAgKiBvYmplY3QuYSA9IDI7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgYXJndW1lbnQgdHJhbnNmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDksIDMpO1xuICAgICAqIC8vID0+IFs4MSwgNl1cbiAgICAgKlxuICAgICAqIGZ1bmMoMTAsIDUpO1xuICAgICAqIC8vID0+IFsxMDAsIDEwXVxuICAgICAqL1xuICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSAodHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pKVxuICAgICAgICA/IGFycmF5TWFwKHRyYW5zZm9ybXNbMF0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSlcbiAgICAgICAgOiBhcnJheU1hcChiYXNlRmxhdHRlbih0cmFuc2Zvcm1zLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIGZ1bmNzTGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgZnVuY3NMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XS5jYWxsKHRoaXMsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcbiAgICAgKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbFJpZ2h0KSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGBpbmRleGVzYCB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIFsyLCAwLCAxXSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9SRUFSR19GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleGVzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICAgICAqIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCBhcyBhbiBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtudWxsXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqIGNvbnNvbGUubG9nKF8uY2FzdEFycmF5KGFycmF5KSA9PT0gYXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXkoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICAgICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAgICAgKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICAgICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAgICAgKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWUuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdXAgdG8gZm91ciBhcmd1bWVudHM7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZVdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVXaXRoYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXBXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAyOyB9IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlR3QpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3RlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAgICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5QnVmZmVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5QnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICAgICAqXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAgICAgKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAgICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAgICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNFcXVhbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHVwIHRvXG4gICAgICogc2l4IGFyZ3VtZW50czogKG9ialZhbHVlLCBvdGhWYWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhvdGhWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0b1xuICAgICAqIGRldGVybWluZSBpZiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLm1hdGNoZXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzTWF0Y2hgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBmaXZlXG4gICAgICogYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBpbmRleHxrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhzcmNWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xuICAgICAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gICAgICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByaXN0aW5lIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBjYW4ndCByZWxpYWJseSBkZXRlY3QgbmF0aXZlIGZ1bmN0aW9ucyBpbiB0aGUgcHJlc2VuY2VcbiAgICAgKiBvZiB0aGUgY29yZS1qcyBwYWNrYWdlIGJlY2F1c2UgY29yZS1qcyBjaXJjdW12ZW50cyB0aGlzIGtpbmQgb2YgZGV0ZWN0aW9uLlxuICAgICAqIERlc3BpdGUgbXVsdGlwbGUgcmVxdWVzdHMsIHRoZSBjb3JlLWpzIG1haW50YWluZXIgaGFzIG1hZGUgaXQgY2xlYXI6IGFueVxuICAgICAqIGF0dGVtcHQgdG8gZml4IHRoZSBkZXRlY3Rpb24gd2lsbCBiZSBvYnN0cnVjdGVkLiBBcyBhIHJlc3VsdCwgd2UncmUgbGVmdFxuICAgICAqIHdpdGggbGl0dGxlIGNob2ljZSBidXQgdG8gdGhyb3cgYW4gZXJyb3IuIFVuZm9ydHVuYXRlbHksIHRoaXMgYWxzbyBhZmZlY3RzXG4gICAgICogcGFja2FnZXMsIGxpa2UgW2JhYmVsLXBvbHlmaWxsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9iYWJlbC1wb2x5ZmlsbCksXG4gICAgICogd2hpY2ggcmVseSBvbiBjb3JlLWpzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmIChpc01hc2thYmxlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09SRV9FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05pbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbChOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcbiAgICAgKiBkb3VibGUgcHJlY2lzaW9uIG51bWJlciB3aGljaCBpc24ndCB0aGUgcmVzdWx0IG9mIGEgcm91bmRlZCB1bnNhZmUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzU2FmZUludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNTYWZlSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSB3ZWFrTWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gd2Vha1NldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoMSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgnMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBLZXlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gICAgICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSk7XG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAgICAgKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAgICAgKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAgICAgKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gICAgICogXy51bnNldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udW5zZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IC01XG4gICAgICpcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgICAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgfVxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gICAgICogZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyPTBdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obG93ZXIsIHVwcGVyLCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSB1cHBlcjtcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIHVwcGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcbiAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAgICAgKiB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAgICAgKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICAgICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gICAgICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gICAgICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gICAgICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAgICAgLy8gdG8gbm9ybWFsaXplIGFsbCBraW5kcyBvZiB3aGl0ZXNwYWNlLCBzbyBlLmcuIG5ld2xpbmVzIChhbmQgdW5pY29kZSB2ZXJzaW9ucyBvZiBpdCkgY2FuJ3Qgc25lYWsgaW5cbiAgICAgIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgICAgICAgPyAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJylcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1FbmQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xuICAgICAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKSwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBIVE1MIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICovXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gbWV0aG9kTmFtZXMgVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdjbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3LCBbJ2NsaWNrJ10pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB2aWV3LmNsaWNrKTtcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIGBwYWlyc2AgYW5kIGludm9rZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cbiAgICAgKiBwYWlycyBhcmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb24gcGFpcnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXG4gICAgICogICBbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCAgICAgICAgICAgXy5jb25zdGFudCgnbWF0Y2hlcyBBJyldLFxuICAgICAqICAgW18uY29uZm9ybXMoeyAnYic6IF8uaXNOdW1iZXIgfSksIF8uY29uc3RhbnQoJ21hdGNoZXMgQicpXSxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEEnXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQidcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XG4gICAgICogLy8gPT4gJ25vIG1hdGNoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBpdHMgcGxhY2UuIFRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBgbnVsbGAsXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKDEsIDEwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbyh1bmRlZmluZWQsIDEwKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1JpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksIF8ubWF0Y2hlcyh7ICdhJzogNCB9KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZVxuICAgICAqIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdCB0byBgc3JjVmFsdWVgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZVxuICAgICAqIG9iamVjdCB2YWx1ZSBpcyBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3RcbiAgICAgKiBgc3JjVmFsdWVgIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlXG4gICAgICogYF8uaXNFcXVhbGAgZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChvYmplY3RzLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCAxKSwgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgICAqIGFyZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciBtaXhpbnMgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxuICAgICAgICAgICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSAhKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGhBcmcobikge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBiYXNlTnRoKGFyZ3MsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcbiAgICAgKiBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFs0LCAxXVxuICAgICAqL1xuICAgIHZhciBvdmVyID0gY3JlYXRlT3ZlcihhcnJheU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyRXZlcnkoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbnkqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIG1hdGNoZXNGdW5jID0gXy5vdmVyU29tZShbeyAnYSc6IDEgfSwgeyAnYSc6IDIgfV0pXG4gICAgICogdmFyIG1hdGNoZXNQcm9wZXJ0eUZ1bmMgPSBfLm92ZXJTb21lKFtbJ2EnLCAxXSwgWydhJywgMl1dKVxuICAgICAqL1xuICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gICAgICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgtNCk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmFuZ2VgIGV4Y2VwdCB0aGF0IGl0IHBvcHVsYXRlcyB2YWx1ZXMgaW5cbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XG4gICAgICogLy8gPT4gWzQsIDMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFsxNSwgMTAsIDUsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZVJpZ2h0ID0gY3JlYXRlUmFuZ2UodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gICAgICogLy8gPT4gW1tdLCBbXV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAgICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3t9LCB7fV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnJywgJyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAgICAgKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cbiAgICAgKlxuICAgICAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xuICAgICAqIC8vID0+IFswLCAwLCAwLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgaWYgKG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IE1BWF9BUlJBWV9MRU5HVEgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlKTtcbiAgICAgIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VUaW1lcyhsZW5ndGgsIGl0ZXJhdGVlKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgc2Vjb25kIG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcbiAgICAgKiAvLyA9PiAxLjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGlkZW50aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWVyIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcbiAgICAgKiAvLyA9PiAyNFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbGllciAqIG11bHRpcGxpY2FuZDtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51ZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgcmV0dXJuIG1pbnVlbmQgLSBzdWJ0cmFoZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcbiAgICBsb2Rhc2guYXNzaWduV2l0aCA9IGFzc2lnbldpdGg7XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FzdEFycmF5ID0gY2FzdEFycmF5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgIGxvZGFzaC5jb25kID0gY29uZDtcbiAgICBsb2Rhc2guY29uZm9ybXMgPSBjb25mb3JtcztcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VCeSA9IGRpZmZlcmVuY2VCeTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlZXAgPSBmbGF0TWFwRGVlcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25XaXRoID0gaW50ZXJzZWN0aW9uV2l0aDtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xuICAgIGxvZGFzaC5pbnZva2VNYXAgPSBpbnZva2VNYXA7XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcbiAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcbiAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XG4gICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcbiAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcbiAgICBsb2Rhc2guZW50cmllc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVxID0gZXE7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc0xlbmd0aCA9IGlzTGVuZ3RoO1xuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNNYXRjaFdpdGggPSBpc01hdGNoV2l0aDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOaWwgPSBpc05pbDtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcbiAgICBsb2Rhc2guam9pbiA9IGpvaW47XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tYXhCeSA9IG1heEJ5O1xuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcbiAgICBsb2Rhc2guc3R1YkZhbHNlID0gc3R1YkZhbHNlO1xuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XG4gICAgbG9kYXNoLnN0dWJUcnVlID0gc3R1YlRydWU7XG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgbG9kYXNoLm50aCA9IG50aDtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleE9mID0gc29ydGVkSW5kZXhPZjtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhPZiA9IHNvcnRlZExhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgbG9kYXNoLnRvSW50ZWdlciA9IHRvSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgbG9kYXNoLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGxvZGFzaC50b1VwcGVyID0gdG9VcHBlcjtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgIGxvZGFzaC50cmltU3RhcnQgPSB0cmltU3RhcnQ7XG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZCA/IDEgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKG4pLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gKHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleClcbiAgICAgICAgICA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKVxuICAgICAgICAgIDogdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Ll9fdGFrZUNvdW50X18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XG4gICAgICAgICAgICAnc2l6ZSc6IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSxcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbaXNUYWtlciA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgICByZXR1cm4gKGlzVGFrZXIgJiYgY2hhaW5BbGwpID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc1Vud3JhcHBlZCA9IHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwsXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vud3JhcHBlZCAmJiBvbmx5TGF6eSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsncG9wJywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIG1ldGhvZCBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUgKyAnJztcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywga2V5KSkge1xuICAgICAgICAgIHJlYWxOYW1lc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVhbE5hbWVzW2tleV0ucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIFdSQVBfQklORF9LRVlfRkxBRykubmFtZV0gPSBbe1xuICAgICAgJ25hbWUnOiAnd3JhcHBlcicsXG4gICAgICAnZnVuYyc6IHVuZGVmaW5lZFxuICAgIH1dO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cbiAgICAvLyBBZGQgY2hhaW4gc2VxdWVuY2UgbWV0aG9kcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb21taXQgPSB3cmFwcGVyQ29tbWl0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGxhenkgYWxpYXNlcy5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuXG4gICAgaWYgKHN5bUl0ZXJhdG9yKSB7XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9KTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG9kYXNoIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gTG9kYXNoIGlzXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIFVzZSBgXy5ub0NvbmZsaWN0YCB0byByZW1vdmUgTG9kYXNoIGZyb20gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGl0LlxuICBlbHNlIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzLlxuICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby10ZW1wbGF0ZS1jdXJseS1pbi1zdHJpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlVG9TdHJpbmcoYXR0cmlidXRlKSB7XG4gIGlmICh0eXBlb2YgYXR0cmlidXRlICE9PSAnc3RyaW5nJykge1xuICAgIGF0dHJpYnV0ZSArPSAnJztcbiAgICBpZiAoYXR0cmlidXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYXR0cmlidXRlID0gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBhdHRyaWJ1dGUudHJpbSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gIGVsZW0uY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbSwgLi4uY2xhc3NOYW1lcykge1xuICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gIHJldHVybiBlbGVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hDdXN0b21FdmVudChlbGVtLCBldmVudE5hbWUsIHByb3BlcnRpZXMpIHtcbiAgZWxlbS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHByb3BlcnRpZXMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE1vbmV5KGNlbnRzLCBmb3JtYXQpIHtcbiAgaWYgKHR5cGVvZiBjZW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICBjZW50cyA9IGNlbnRzLnJlcGxhY2UoJy4nLCAnJyk7XG4gIH1cbiAgbGV0IHZhbHVlID0gJyc7XG4gIGNvbnN0IHBsYWNlaG9sZGVyUmVnZXggPSAvXFx7XFx7XFxzKihcXHcrKVxccypcXH1cXH0vO1xuICBjb25zdCBmb3JtYXRTdHJpbmcgPSBmb3JtYXQgfHwgJyR7e2Ftb3VudH19JztcblxuICBmdW5jdGlvbiBmb3JtYXRXaXRoRGVsaW1pdGVycyhcbiAgICBudW1iZXIsXG4gICAgcHJlY2lzaW9uID0gMixcbiAgICB0aG91c2FuZHMgPSAnLCcsXG4gICAgZGVjaW1hbCA9ICcuJ1xuICApIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIG51bWJlciA9IChudW1iZXIgLyAxMDAuMCkudG9GaXhlZChwcmVjaXNpb24pO1xuXG4gICAgY29uc3QgcGFydHMgPSBudW1iZXIuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBkb2xsYXJzQW1vdW50ID0gcGFydHNbMF0ucmVwbGFjZShcbiAgICAgIC8oXFxkKSg/PShcXGRcXGRcXGQpKyg/IVxcZCkpL2csXG4gICAgICBgJDEke3Rob3VzYW5kc31gXG4gICAgKTtcbiAgICBjb25zdCBjZW50c0Ftb3VudCA9IHBhcnRzWzFdID8gZGVjaW1hbCArIHBhcnRzWzFdIDogJyc7XG5cbiAgICByZXR1cm4gZG9sbGFyc0Ftb3VudCArIGNlbnRzQW1vdW50O1xuICB9XG5cbiAgc3dpdGNoIChmb3JtYXRTdHJpbmcubWF0Y2gocGxhY2Vob2xkZXJSZWdleClbMV0pIHtcbiAgICBjYXNlICdhbW91bnQnOlxuICAgICAgdmFsdWUgPSBmb3JtYXRXaXRoRGVsaW1pdGVycyhjZW50cywgMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhbW91bnRfbm9fZGVjaW1hbHMnOlxuICAgICAgdmFsdWUgPSBmb3JtYXRXaXRoRGVsaW1pdGVycyhjZW50cywgMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhbW91bnRfd2l0aF9jb21tYV9zZXBhcmF0b3InOlxuICAgICAgdmFsdWUgPSBmb3JtYXRXaXRoRGVsaW1pdGVycyhjZW50cywgMiwgJy4nLCAnLCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYW1vdW50X25vX2RlY2ltYWxzX3dpdGhfY29tbWFfc2VwYXJhdG9yJzpcbiAgICAgIHZhbHVlID0gZm9ybWF0V2l0aERlbGltaXRlcnMoY2VudHMsIDAsICcuJywgJywnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YWx1ZSA9IGZvcm1hdFdpdGhEZWxpbWl0ZXJzKGNlbnRzLCAyKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRTdHJpbmcucmVwbGFjZShwbGFjZWhvbGRlclJlZ2V4LCB2YWx1ZSk7XG59XG4iLCJpbXBvcnQgQXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgaXNFbXB0eSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBhdHRyaWJ1dGVUb1N0cmluZyB9IGZyb20gJy4vaGVscGVyJztcblxuY29uc3QgaW5zdGFuY2UgPSBBeGlvcy5jcmVhdGUoe1xuICBoZWFkZXJzOiB7ICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyB9LFxufSk7XG5jb25zdCBhamF4VGVtcGxhdGVGdW5jID0gKHVybCwgbWV0aG9kID0gJ2dldCcsIGRhdGEgPSB7fSkgPT4ge1xuICBjb25zdCBlbmNvZGVkID0gZW5jb2RlVVJJKHVybCk7XG4gIGxldCByZXF1ZXN0O1xuXG4gIGlmIChtZXRob2QgPT09ICdnZXQnKSB7XG4gICAgaWYgKGlzRW1wdHkoZGF0YSkpIHtcbiAgICAgIHJlcXVlc3QgPSBpbnN0YW5jZS5nZXQoZW5jb2RlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QgPSBpbnN0YW5jZS5nZXQoZW5jb2RlZCwgZGF0YSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW1wdHkoZGF0YSkgJiYgIShkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpKSB7XG4gICAgcmVxdWVzdCA9IGluc3RhbmNlLnBvc3QoZW5jb2RlZCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IGluc3RhbmNlLnBvc3QoZW5jb2RlZCwgZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RcbiAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0pXG4gICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgcmV0dXJuIGVycm9yLnJlc3BvbnNlLmRhdGE7XG4gICAgfSk7XG59O1xuLy8gdG9kbzogdXJsZW5jb2RlXG5cbmV4cG9ydCBjb25zdCBnZXRDYXJ0ID0gKCkgPT4ge1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYygnL2NhcnQuanMnKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0UHJvZHVjdCA9IChoYW5kbGUpID0+IHtcbiAgcmV0dXJuIGFqYXhUZW1wbGF0ZUZ1bmMoYC9wcm9kdWN0cy8ke2hhbmRsZX0uanNgKTtcbn07XG5leHBvcnQgY29uc3QgY2xlYXJDYXJ0ID0gKCkgPT4ge1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYygnL2NhcnQvY2xlYXIuanMnLCAncG9zdCcpO1xufTtcbmV4cG9ydCBjb25zdCB1cGRhdGVDYXJ0RnJvbUZvcm0gPSAoZm9ybSkgPT4ge1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYygnL2NhcnQvdXBkYXRlLmpzJywgJ3Bvc3QnLCBuZXcgRm9ybURhdGEoZm9ybSkpO1xufTtcbmV4cG9ydCBjb25zdCBjaGFuZ2VJdGVtQnlLZXlPcklkID0gKGlkLCBxdWFudGl0eSkgPT4ge1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYygnL2NhcnQvY2hhbmdlLmpzJywgJ3Bvc3QnLCB7XG4gICAgcXVhbnRpdHksXG4gICAgaWQsXG4gIH0pO1xufTtcbmV4cG9ydCBjb25zdCByZW1vdmVJdGVtQnlLZXlPcklkID0gKGlkKSA9PiB7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKCcvY2FydC9jaGFuZ2UuanMnLCAncG9zdCcsIHsgcXVhbnRpdHk6IDAsIGlkIH0pO1xufTtcbmV4cG9ydCBjb25zdCBjaGFuZ2VJdGVtQnlMaW5lID0gKGxpbmUsIHF1YW50aXR5LCBwcm9wZXJ0aWVzKSA9PiB7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKCcvY2FydC9jaGFuZ2UuanMnLCAncG9zdCcsIHtcbiAgICBxdWFudGl0eSxcbiAgICBsaW5lLFxuICAgIHByb3BlcnRpZXMsXG4gIH0pO1xufTtcbmV4cG9ydCBjb25zdCByZW1vdmVJdGVtQnlMaW5lID0gKGxpbmUpID0+IHtcbiAgcmV0dXJuIGFqYXhUZW1wbGF0ZUZ1bmMoJy9jYXJ0L2NoYW5nZS5qcycsICdwb3N0JywgeyBxdWFudGl0eTogMCwgbGluZSB9KTtcbn07XG5leHBvcnQgY29uc3QgYWRkSXRlbSA9IChpZCwgcXVhbnRpdHksIHByb3BlcnRpZXMgPSB7fSkgPT4ge1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYygnL2NhcnQvYWRkLmpzJywgJ3Bvc3QnLCB7XG4gICAgaWQsXG4gICAgcXVhbnRpdHksXG4gICAgcHJvcGVydGllcyxcbiAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IGFkZEl0ZW1Gcm9tRm9ybSA9IChmb3JtKSA9PiB7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKCcvY2FydC9hZGQuanMnLCAncG9zdCcsIG5ldyBGb3JtRGF0YShmb3JtKSk7XG59O1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUNhcnRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykpIHtcbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYXR0cmlidXRlVG9TdHJpbmcoYXR0cmlidXRlLmtleSk7XG4gICAgICBpZiAoa2V5ICE9PSAnJykge1xuICAgICAgICBkYXRhICs9IGBhdHRyaWJ1dGVzWyR7a2V5fV09JHthdHRyaWJ1dGVUb1N0cmluZyhhdHRyaWJ1dGUudmFsdWUpfSZgO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzID09PSAnb2JqZWN0JyAmJiBhdHRyaWJ1dGVzICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIGRhdGEgKz0gYGF0dHJpYnV0ZXNbJHthdHRyaWJ1dGVUb1N0cmluZyhrZXkpfV09JHthdHRyaWJ1dGVUb1N0cmluZyhcbiAgICAgICAgdmFsdWVcbiAgICAgICl9JmA7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFqYXhUZW1wbGF0ZUZ1bmMoJy9jYXJ0L3VwZGF0ZS5qcycsICdwb3N0JywgZGF0YSk7XG59O1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUNhcnROb3RlID0gKG5vdGUpID0+IHtcbiAgcmV0dXJuIGFqYXhUZW1wbGF0ZUZ1bmMoXG4gICAgJy9jYXJ0L3VwZGF0ZS5qcycsXG4gICAgJ3Bvc3QnLFxuICAgIGBub3RlPSR7YXR0cmlidXRlVG9TdHJpbmcobm90ZSl9YFxuICApO1xufTtcbmV4cG9ydCBjb25zdCBnZXRSZWNvbW1lbmRlZFByb2R1Y3RzID0gKHByb2R1Y3RJZCwgbGltaXQgPSAxMCkgPT4ge1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYyhcbiAgICBgL3JlY29tbWVuZGF0aW9ucy9wcm9kdWN0cy5qc29uP3Byb2R1Y3RfaWQ9JHtwcm9kdWN0SWR9JmxpbWl0PSR7XG4gICAgICBsaW1pdCAmJiBwYXJzZUludChsaW1pdCwgMTApID4gMCAmJiBwYXJzZUludChsaW1pdCwgMTApIDw9IDEwXG4gICAgICAgID8gcGFyc2VJbnQobGltaXQsIDEwKVxuICAgICAgICA6IDEwXG4gICAgfWBcbiAgKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0UHJlZGljdGl2ZVNlYXJjaFJlc3VsdHMgPSAoXG4gIHEsXG4gIHR5cGUgPSBbJ3Byb2R1Y3QnLCAncGFnZScsICdhcnRpY2xlJywgJ2NvbGxlY3Rpb24nXSxcbiAgbGltaXQgPSAxMCxcbiAgdW5hdmFpbGFibGVQcm9kdWN0cyA9ICdsYXN0JyxcbiAgZmllbGRzID0gWyd0aXRsZScsICdwcm9kdWN0X3R5cGUnLCAndmFyaWFudHMudGl0bGUnLCAndmVuZG9yJ11cbikgPT4ge1xuICBsZXQgcGFyYW1zU3RyaW5nID0gJyc7XG4gIHBhcmFtc1N0cmluZyArPSBgcT0ke3F9YDtcbiAgcGFyYW1zU3RyaW5nICs9IGAmcmVzb3VyY2VzW3R5cGVdPSR7dHlwZS5qb2luKCcsJyl9YDtcbiAgcGFyYW1zU3RyaW5nICs9IGAmcmVzb3VyY2VzW2xpbWl0XT0ke2xpbWl0fWA7XG4gIHBhcmFtc1N0cmluZyArPSBgJnJlc291cmNlc1tvcHRpb25zXVt1bmF2YWlsYWJsZV9wcm9kdWN0c109JHt1bmF2YWlsYWJsZVByb2R1Y3RzfWA7XG4gIHBhcmFtc1N0cmluZyArPSBgJnJlc291cmNlc1tvcHRpb25zXVtmaWVsZHNdPSR7ZmllbGRzLmpvaW4oJywnKX1gO1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYyhgL3NlYXJjaC9zdWdnZXN0Lmpzb24/JHtwYXJhbXNTdHJpbmd9YCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldENhcnQsXG4gIGdldFByb2R1Y3QsXG4gIGNsZWFyQ2FydCxcbiAgdXBkYXRlQ2FydEZyb21Gb3JtLFxuICBjaGFuZ2VJdGVtQnlLZXlPcklkLFxuICByZW1vdmVJdGVtQnlLZXlPcklkLFxuICBjaGFuZ2VJdGVtQnlMaW5lLFxuICByZW1vdmVJdGVtQnlMaW5lLFxuICBhZGRJdGVtLFxuICBhZGRJdGVtRnJvbUZvcm0sXG4gIHVwZGF0ZUNhcnRBdHRyaWJ1dGVzLFxuICB1cGRhdGVDYXJ0Tm90ZSxcbiAgZ2V0UmVjb21tZW5kZWRQcm9kdWN0cyxcbiAgZ2V0UHJlZGljdGl2ZVNlYXJjaFJlc3VsdHMsXG59O1xuIiwiLyogQHByZXNlcnZlXG4gICAgX19fX18gX18gXyAgICAgX18gICAgICAgICAgICAgICAgX1xuICAgLyBfX18vLyAvKF8pX19fLyAvX19fICBfX19fICAgICAgKF8pX19fXG4gIC8gKF8gLy8gLy8gLy8gXyAgLy8gLV8pLyBfXy9fICAgIC8gLyhfLTxcbiAgXFxfX18vL18vL18vIFxcXyxfLyBcXF9fLy9fLyAgKF8pX18vIC8vX19fL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fXy9cblxuICBWZXJzaW9uOiAxLjcuM1xuICBBdXRob3I6IE5pY2sgUGlzY2l0ZWxsaSAocGlja3lrbmVlZSlcbiAgV2Vic2l0ZTogaHR0cHM6Ly9uaWNrcGlzY2l0ZWxsaS5jb21cbiAgRG9jdW1lbnRhdGlvbjogaHR0cDovL25pY2twaXNjaXRlbGxpLmdpdGh1Yi5pby9HbGlkZXIuanNcbiAgTGljZW5zZTogTUlUIExpY2Vuc2VcbiAgUmVsZWFzZSBEYXRlOiBPY3RvYmVyIDI1dGgsIDIwMThcblxuKi9cblxuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICA6IHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0J1xuICAgICAgPyAobW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkpXG4gICAgICA6IGZhY3RvcnkoKVxufSkoZnVuY3Rpb24gKCkge1xuICAoJ3VzZSBzdHJpY3QnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gIC8qIGdsb2JhbHMgd2luZG93OnRydWUgKi9cbiAgdmFyIF93aW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXNcblxuICB2YXIgR2xpZGVyID0gKF93aW5kb3cuR2xpZGVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNldHRpbmdzKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICBpZiAoZWxlbWVudC5fZ2xpZGVyKSByZXR1cm4gZWxlbWVudC5fZ2xpZGVyXG5cbiAgICBfLmVsZSA9IGVsZW1lbnRcbiAgICBfLmVsZS5jbGFzc0xpc3QuYWRkKCdnbGlkZXInKVxuXG4gICAgLy8gZXhwb3NlIGdsaWRlciBvYmplY3QgdG8gaXRzIERPTSBlbGVtZW50XG4gICAgXy5lbGUuX2dsaWRlciA9IF9cblxuICAgIC8vIG1lcmdlIHVzZXIgc2V0dGluZyB3aXRoIGRlZmF1bHRzXG4gICAgXy5vcHQgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICB7XG4gICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICAgICAgICBzbGlkZXNUb1Nob3c6IDEsXG4gICAgICAgIHJlc2l6ZUxvY2s6IHRydWUsXG4gICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgIC8vIGVhc2VJblF1YWRcbiAgICAgICAgZWFzaW5nOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICsgYlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0dGluZ3NcbiAgICApXG5cbiAgICAvLyBzZXQgZGVmYXVsdHNcbiAgICBfLmFuaW1hdGVfaWQgPSBfLnBhZ2UgPSBfLnNsaWRlID0gMFxuICAgIF8uYXJyb3dzID0ge31cblxuICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIG9wdGlvbnMgdG9cbiAgICAvLyBleHRlbmQgYnJlYWtwb2ludCBzZXR0aW5nc1xuICAgIF8uX29wdCA9IF8ub3B0XG5cbiAgICBpZiAoXy5vcHQuc2tpcFRyYWNrKSB7XG4gICAgICAvLyBmaXJzdCBhbmQgb25seSBjaGlsZCBpcyB0aGUgdHJhY2tcbiAgICAgIF8udHJhY2sgPSBfLmVsZS5jaGlsZHJlblswXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgdHJhY2sgYW5kIHdyYXAgc2xpZGVzXG4gICAgICBfLnRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIF8uZWxlLmFwcGVuZENoaWxkKF8udHJhY2spXG4gICAgICB3aGlsZSAoXy5lbGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIF8udHJhY2suYXBwZW5kQ2hpbGQoXy5lbGUuY2hpbGRyZW5bMF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgXy50cmFjay5jbGFzc0xpc3QuYWRkKCdnbGlkZXItdHJhY2snKVxuXG4gICAgLy8gc3RhcnQgZ2xpZGVyXG4gICAgXy5pbml0KClcblxuICAgIC8vIHNldCBldmVudHNcbiAgICBfLnJlc2l6ZSA9IF8uaW5pdC5iaW5kKF8sIHRydWUpXG4gICAgXy5ldmVudChfLmVsZSwgJ2FkZCcsIHtcbiAgICAgIHNjcm9sbDogXy51cGRhdGVDb250cm9scy5iaW5kKF8pXG4gICAgfSlcbiAgICBfLmV2ZW50KF93aW5kb3csICdhZGQnLCB7XG4gICAgICByZXNpemU6IF8ucmVzaXplXG4gICAgfSlcbiAgfSlcblxuICB2YXIgZ2xpZGVyUHJvdG90eXBlID0gR2xpZGVyLnByb3RvdHlwZVxuICBnbGlkZXJQcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChyZWZyZXNoLCBwYWdpbmcpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIHZhciB3aWR0aCA9IDBcblxuICAgIHZhciBoZWlnaHQgPSAwXG5cbiAgICBfLnNsaWRlcyA9IF8udHJhY2suY2hpbGRyZW47XG5cbiAgICBbXS5mb3JFYWNoLmNhbGwoXy5zbGlkZXMsIGZ1bmN0aW9uIChfKSB7XG4gICAgICBfLmNsYXNzTGlzdC5hZGQoJ2dsaWRlci1zbGlkZScpXG4gICAgfSlcblxuICAgIF8uY29udGFpbmVyV2lkdGggPSBfLmVsZS5jbGllbnRXaWR0aFxuXG4gICAgdmFyIGJyZWFrcG9pbnRDaGFuZ2VkID0gXy5zZXR0aW5nc0JyZWFrcG9pbnQoKVxuICAgIGlmICghcGFnaW5nKSBwYWdpbmcgPSBicmVha3BvaW50Q2hhbmdlZFxuXG4gICAgaWYgKFxuICAgICAgXy5vcHQuc2xpZGVzVG9TaG93ID09PSAnYXV0bycgfHxcbiAgICAgIHR5cGVvZiBfLm9wdC5fYXV0b1NsaWRlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgdmFyIHNsaWRlQ291bnQgPSBfLmNvbnRhaW5lcldpZHRoIC8gXy5vcHQuaXRlbVdpZHRoXG5cbiAgICAgIF8ub3B0Ll9hdXRvU2xpZGUgPSBfLm9wdC5zbGlkZXNUb1Nob3cgPSBfLm9wdC5leGFjdFdpZHRoXG4gICAgICAgID8gc2xpZGVDb3VudFxuICAgICAgICA6IE1hdGguZmxvb3Ioc2xpZGVDb3VudClcbiAgICB9XG4gICAgaWYgKF8ub3B0LnNsaWRlc1RvU2Nyb2xsID09PSAnYXV0bycpIHtcbiAgICAgIF8ub3B0LnNsaWRlc1RvU2Nyb2xsID0gTWF0aC5mbG9vcihfLm9wdC5zbGlkZXNUb1Nob3cpXG4gICAgfVxuXG4gICAgXy5pdGVtV2lkdGggPSBfLm9wdC5leGFjdFdpZHRoXG4gICAgICA/IF8ub3B0Lml0ZW1XaWR0aFxuICAgICAgOiBfLmNvbnRhaW5lcldpZHRoIC8gXy5vcHQuc2xpZGVzVG9TaG93O1xuXG4gICAgLy8gc2V0IHNsaWRlIGRpbWVuc2lvbnNcbiAgICBbXS5mb3JFYWNoLmNhbGwoXy5zbGlkZXMsIGZ1bmN0aW9uIChfXykge1xuICAgICAgX18uc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nXG4gICAgICBfXy5zdHlsZS53aWR0aCA9IF8uaXRlbVdpZHRoICsgJ3B4J1xuICAgICAgd2lkdGggKz0gXy5pdGVtV2lkdGhcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KF9fLm9mZnNldEhlaWdodCwgaGVpZ2h0KVxuICAgIH0pXG5cbiAgICBfLnRyYWNrLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnXG4gICAgXy50cmFja1dpZHRoID0gd2lkdGhcbiAgICBfLmlzRHJhZyA9IGZhbHNlXG4gICAgXy5wcmV2ZW50Q2xpY2sgPSBmYWxzZVxuXG4gICAgXy5vcHQucmVzaXplTG9jayAmJiBfLnNjcm9sbFRvKF8uc2xpZGUgKiBfLml0ZW1XaWR0aCwgMClcblxuICAgIGlmIChicmVha3BvaW50Q2hhbmdlZCB8fCBwYWdpbmcpIHtcbiAgICAgIF8uYmluZEFycm93cygpXG4gICAgICBfLmJ1aWxkRG90cygpXG4gICAgICBfLmJpbmREcmFnKClcbiAgICB9XG5cbiAgICBfLnVwZGF0ZUNvbnRyb2xzKClcblxuICAgIF8uZW1pdChyZWZyZXNoID8gJ3JlZnJlc2gnIDogJ2xvYWRlZCcpXG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUuYmluZERyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF8gPSB0aGlzXG4gICAgXy5tb3VzZSA9IF8ubW91c2UgfHwgXy5oYW5kbGVNb3VzZS5iaW5kKF8pXG5cbiAgICB2YXIgbW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF8ubW91c2VEb3duID0gdW5kZWZpbmVkXG4gICAgICBfLmVsZS5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnJylcbiAgICAgIGlmIChfLmlzRHJhZykge1xuICAgICAgICBfLnByZXZlbnRDbGljayA9IHRydWVcbiAgICAgIH1cbiAgICAgIF8uaXNEcmFnID0gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRzID0ge1xuICAgICAgbW91c2V1cDogbW91c2V1cCxcbiAgICAgIG1vdXNlbGVhdmU6IG1vdXNldXAsXG4gICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIF8ubW91c2VEb3duID0gZS5jbGllbnRYXG4gICAgICAgIF8uZWxlLmNsYXNzTGlzdC5hZGQoJ2RyYWcnKVxuICAgICAgfSxcbiAgICAgIG1vdXNlbW92ZTogXy5tb3VzZSxcbiAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoXy5wcmV2ZW50Q2xpY2spIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH1cbiAgICAgICAgXy5wcmV2ZW50Q2xpY2sgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIF8uZWxlLmNsYXNzTGlzdC50b2dnbGUoJ2RyYWdnYWJsZScsIF8ub3B0LmRyYWdnYWJsZSA9PT0gdHJ1ZSlcbiAgICBfLmV2ZW50KF8uZWxlLCAncmVtb3ZlJywgZXZlbnRzKVxuICAgIGlmIChfLm9wdC5kcmFnZ2FibGUpIF8uZXZlbnQoXy5lbGUsICdhZGQnLCBldmVudHMpXG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUuYnVpbGREb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgaWYgKCFfLm9wdC5kb3RzKSB7XG4gICAgICBpZiAoXy5kb3RzKSBfLmRvdHMuaW5uZXJIVE1MID0gJydcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgXy5vcHQuZG90cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIF8uZG90cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXy5vcHQuZG90cylcbiAgICB9IGVsc2UgXy5kb3RzID0gXy5vcHQuZG90c1xuICAgIGlmICghXy5kb3RzKSByZXR1cm5cblxuICAgIF8uZG90cy5pbm5lckhUTUwgPSAnJ1xuICAgIF8uZG90cy5jbGFzc0xpc3QuYWRkKCdnbGlkZXItZG90cycpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguY2VpbChfLnNsaWRlcy5sZW5ndGggLyBfLm9wdC5zbGlkZXNUb1Nob3cpOyArK2kpIHtcbiAgICAgIHZhciBkb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICAgICAgZG90LmRhdGFzZXQuaW5kZXggPSBpXG4gICAgICBkb3Quc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ1BhZ2UgJyArIChpICsgMSkpXG4gICAgICBkb3QuY2xhc3NOYW1lID0gJ2dsaWRlci1kb3QgJyArIChpID8gJycgOiAnYWN0aXZlJylcbiAgICAgIF8uZXZlbnQoZG90LCAnYWRkJywge1xuICAgICAgICBjbGljazogXy5zY3JvbGxJdGVtLmJpbmQoXywgaSwgdHJ1ZSlcbiAgICAgIH0pXG4gICAgICBfLmRvdHMuYXBwZW5kQ2hpbGQoZG90KVxuICAgIH1cbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5iaW5kQXJyb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfID0gdGhpc1xuICAgIGlmICghXy5vcHQuYXJyb3dzKSB7XG4gICAgICBPYmplY3Qua2V5cyhfLmFycm93cykuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gXy5hcnJvd3NbZGlyZWN0aW9uXVxuICAgICAgICBfLmV2ZW50KGVsZW1lbnQsICdyZW1vdmUnLCB7IGNsaWNrOiBlbGVtZW50Ll9mdW5jIH0pXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFsncHJldicsICduZXh0J10uZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgYXJyb3cgPSBfLm9wdC5hcnJvd3NbZGlyZWN0aW9uXVxuICAgICAgaWYgKGFycm93KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJyb3cgPT09ICdzdHJpbmcnKSBhcnJvdyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJyb3cpXG4gICAgICAgIGFycm93Ll9mdW5jID0gYXJyb3cuX2Z1bmMgfHwgXy5zY3JvbGxJdGVtLmJpbmQoXywgZGlyZWN0aW9uKVxuICAgICAgICBfLmV2ZW50KGFycm93LCAncmVtb3ZlJywge1xuICAgICAgICAgIGNsaWNrOiBhcnJvdy5fZnVuY1xuICAgICAgICB9KVxuICAgICAgICBfLmV2ZW50KGFycm93LCAnYWRkJywge1xuICAgICAgICAgIGNsaWNrOiBhcnJvdy5fZnVuY1xuICAgICAgICB9KVxuICAgICAgICBfLmFycm93c1tkaXJlY3Rpb25dID0gYXJyb3dcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLnVwZGF0ZUNvbnRyb2xzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICBpZiAoZXZlbnQgJiYgIV8ub3B0LnNjcm9sbFByb3BhZ2F0ZSkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICB9XG5cbiAgICB2YXIgZGlzYWJsZUFycm93cyA9IF8uY29udGFpbmVyV2lkdGggPj0gXy50cmFja1dpZHRoXG5cbiAgICBpZiAoIV8ub3B0LnJld2luZCkge1xuICAgICAgaWYgKF8uYXJyb3dzLnByZXYpIHtcbiAgICAgICAgXy5hcnJvd3MucHJldi5jbGFzc0xpc3QudG9nZ2xlKFxuICAgICAgICAgICdkaXNhYmxlZCcsXG4gICAgICAgICAgXy5lbGUuc2Nyb2xsTGVmdCA8PSAwIHx8IGRpc2FibGVBcnJvd3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKF8uYXJyb3dzLm5leHQpIHtcbiAgICAgICAgXy5hcnJvd3MubmV4dC5jbGFzc0xpc3QudG9nZ2xlKFxuICAgICAgICAgICdkaXNhYmxlZCcsXG4gICAgICAgICAgTWF0aC5jZWlsKF8uZWxlLnNjcm9sbExlZnQgKyBfLmNvbnRhaW5lcldpZHRoKSA+PVxuICAgICAgICAgICAgTWF0aC5mbG9vcihfLnRyYWNrV2lkdGgpIHx8IGRpc2FibGVBcnJvd3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIF8uc2xpZGUgPSBNYXRoLnJvdW5kKF8uZWxlLnNjcm9sbExlZnQgLyBfLml0ZW1XaWR0aClcbiAgICBfLnBhZ2UgPSBNYXRoLnJvdW5kKF8uZWxlLnNjcm9sbExlZnQgLyBfLmNvbnRhaW5lcldpZHRoKVxuXG4gICAgdmFyIG1pZGRsZSA9IF8uc2xpZGUgKyBNYXRoLmZsb29yKE1hdGguZmxvb3IoXy5vcHQuc2xpZGVzVG9TaG93KSAvIDIpXG5cbiAgICB2YXIgZXh0cmFNaWRkbGUgPSBNYXRoLmZsb29yKF8ub3B0LnNsaWRlc1RvU2hvdykgJSAyID8gMCA6IG1pZGRsZSArIDFcbiAgICBpZiAoTWF0aC5mbG9vcihfLm9wdC5zbGlkZXNUb1Nob3cpID09PSAxKSB7XG4gICAgICBleHRyYU1pZGRsZSA9IDBcbiAgICB9XG5cbiAgICAvLyB0aGUgbGFzdCBwYWdlIG1heSBiZSBsZXNzIHRoYW4gb25lIGhhbGYgb2YgYSBub3JtYWwgcGFnZSB3aWR0aCBzb1xuICAgIC8vIHRoZSBwYWdlIGlzIHJvdW5kZWQgZG93bi4gd2hlbiBhdCB0aGUgZW5kLCBmb3JjZSB0aGUgcGFnZSB0byB0dXJuXG4gICAgaWYgKF8uZWxlLnNjcm9sbExlZnQgKyBfLmNvbnRhaW5lcldpZHRoID49IE1hdGguZmxvb3IoXy50cmFja1dpZHRoKSkge1xuICAgICAgXy5wYWdlID0gXy5kb3RzID8gXy5kb3RzLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwXG4gICAgfVxuXG4gICAgW10uZm9yRWFjaC5jYWxsKF8uc2xpZGVzLCBmdW5jdGlvbiAoc2xpZGUsIGluZGV4KSB7XG4gICAgICB2YXIgc2xpZGVDbGFzc2VzID0gc2xpZGUuY2xhc3NMaXN0XG5cbiAgICAgIHZhciB3YXNWaXNpYmxlID0gc2xpZGVDbGFzc2VzLmNvbnRhaW5zKCd2aXNpYmxlJylcblxuICAgICAgdmFyIHN0YXJ0ID0gXy5lbGUuc2Nyb2xsTGVmdFxuXG4gICAgICB2YXIgZW5kID0gXy5lbGUuc2Nyb2xsTGVmdCArIF8uY29udGFpbmVyV2lkdGhcblxuICAgICAgdmFyIGl0ZW1TdGFydCA9IF8uaXRlbVdpZHRoICogaW5kZXhcblxuICAgICAgdmFyIGl0ZW1FbmQgPSBpdGVtU3RhcnQgKyBfLml0ZW1XaWR0aDtcblxuICAgICAgW10uZm9yRWFjaC5jYWxsKHNsaWRlQ2xhc3NlcywgZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAvXmxlZnR8cmlnaHQvLnRlc3QoY2xhc3NOYW1lKSAmJiBzbGlkZUNsYXNzZXMucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICAgIH0pXG4gICAgICBzbGlkZUNsYXNzZXMudG9nZ2xlKCdhY3RpdmUnLCBfLnNsaWRlID09PSBpbmRleClcbiAgICAgIGlmIChtaWRkbGUgPT09IGluZGV4IHx8IChleHRyYU1pZGRsZSAmJiBleHRyYU1pZGRsZSA9PT0gaW5kZXgpKSB7XG4gICAgICAgIHNsaWRlQ2xhc3Nlcy5hZGQoJ2NlbnRlcicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZUNsYXNzZXMucmVtb3ZlKCdjZW50ZXInKVxuICAgICAgICBzbGlkZUNsYXNzZXMuYWRkKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIGluZGV4IDwgbWlkZGxlID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgICAgICAgIE1hdGguYWJzKGluZGV4IC0gKGluZGV4IDwgbWlkZGxlID8gbWlkZGxlIDogZXh0cmFNaWRkbGUgfHwgbWlkZGxlKSlcbiAgICAgICAgICBdLmpvaW4oJy0nKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHZhciBpc1Zpc2libGUgPVxuICAgICAgICBNYXRoLmNlaWwoaXRlbVN0YXJ0KSA+PSBzdGFydCAmJiBNYXRoLmZsb29yKGl0ZW1FbmQpIDw9IGVuZFxuICAgICAgc2xpZGVDbGFzc2VzLnRvZ2dsZSgndmlzaWJsZScsIGlzVmlzaWJsZSlcbiAgICAgIGlmIChpc1Zpc2libGUgIT09IHdhc1Zpc2libGUpIHtcbiAgICAgICAgXy5lbWl0KCdzbGlkZS0nICsgKGlzVmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nKSwge1xuICAgICAgICAgIHNsaWRlOiBpbmRleFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKF8uZG90cykge1xuICAgICAgW10uZm9yRWFjaC5jYWxsKF8uZG90cy5jaGlsZHJlbiwgZnVuY3Rpb24gKGRvdCwgaW5kZXgpIHtcbiAgICAgICAgZG90LmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScsIF8ucGFnZSA9PT0gaW5kZXgpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChldmVudCAmJiBfLm9wdC5zY3JvbGxMb2NrKSB7XG4gICAgICBjbGVhclRpbWVvdXQoXy5zY3JvbGxMb2NrKVxuICAgICAgXy5zY3JvbGxMb2NrID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfLnNjcm9sbExvY2spXG4gICAgICAgIC8vIGRvbnQgYXR0ZW1wdCB0byBzY3JvbGwgbGVzcyB0aGFuIGEgcGl4ZWwgZnJhY3Rpb24gLSBjYXVzZXMgbG9vcGluZ1xuICAgICAgICBpZiAoTWF0aC5hYnMoXy5lbGUuc2Nyb2xsTGVmdCAvIF8uaXRlbVdpZHRoIC0gXy5zbGlkZSkgPiAwLjAyKSB7XG4gICAgICAgICAgaWYgKCFfLm1vdXNlRG93bikge1xuICAgICAgICAgICAgXy5zY3JvbGxJdGVtKF8ucm91bmQoXy5lbGUuc2Nyb2xsTGVmdCAvIF8uaXRlbVdpZHRoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF8ub3B0LnNjcm9sbExvY2tEZWxheSB8fCAyNTApXG4gICAgfVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLnNjcm9sbEl0ZW0gPSBmdW5jdGlvbiAoc2xpZGUsIGRvdCwgZSkge1xuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIHZhciBfID0gdGhpc1xuXG4gICAgdmFyIG9yaWdpbmFsU2xpZGUgPSBzbGlkZVxuICAgICsrXy5hbmltYXRlX2lkXG5cbiAgICBpZiAoZG90ID09PSB0cnVlKSB7XG4gICAgICBzbGlkZSA9IHNsaWRlICogXy5jb250YWluZXJXaWR0aFxuICAgICAgc2xpZGUgPSBNYXRoLnJvdW5kKHNsaWRlIC8gXy5pdGVtV2lkdGgpICogXy5pdGVtV2lkdGhcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBzbGlkZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGJhY2t3YXJkcyA9IHNsaWRlID09PSAncHJldidcblxuICAgICAgICAvLyB1c2UgcHJlY2lzZSBsb2NhdGlvbiBpZiBmcmFjdGlvbmFsIHNsaWRlcyBhcmUgb25cbiAgICAgICAgaWYgKF8ub3B0LnNsaWRlc1RvU2Nyb2xsICUgMSB8fCBfLm9wdC5zbGlkZXNUb1Nob3cgJSAxKSB7XG4gICAgICAgICAgc2xpZGUgPSBfLnJvdW5kKF8uZWxlLnNjcm9sbExlZnQgLyBfLml0ZW1XaWR0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbGlkZSA9IF8uc2xpZGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYWNrd2FyZHMpIHNsaWRlIC09IF8ub3B0LnNsaWRlc1RvU2Nyb2xsXG4gICAgICAgIGVsc2Ugc2xpZGUgKz0gXy5vcHQuc2xpZGVzVG9TY3JvbGxcblxuICAgICAgICBpZiAoXy5vcHQucmV3aW5kKSB7XG4gICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBfLmVsZS5zY3JvbGxMZWZ0XG4gICAgICAgICAgc2xpZGUgPVxuICAgICAgICAgICAgYmFja3dhcmRzICYmICFzY3JvbGxMZWZ0XG4gICAgICAgICAgICAgID8gXy5zbGlkZXMubGVuZ3RoXG4gICAgICAgICAgICAgIDogIWJhY2t3YXJkcyAmJlxuICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgKyBfLmNvbnRhaW5lcldpZHRoID49IE1hdGguZmxvb3IoXy50cmFja1dpZHRoKVxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogc2xpZGVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzbGlkZSA9IE1hdGgubWF4KE1hdGgubWluKHNsaWRlLCBfLnNsaWRlcy5sZW5ndGgpLCAwKVxuXG4gICAgICBfLnNsaWRlID0gc2xpZGVcbiAgICAgIHNsaWRlID0gXy5pdGVtV2lkdGggKiBzbGlkZVxuICAgIH1cblxuICAgIF8uc2Nyb2xsVG8oXG4gICAgICBzbGlkZSxcbiAgICAgIF8ub3B0LmR1cmF0aW9uICogTWF0aC5hYnMoXy5lbGUuc2Nyb2xsTGVmdCAtIHNsaWRlKSxcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXy51cGRhdGVDb250cm9scygpXG4gICAgICAgIF8uZW1pdCgnYW5pbWF0ZWQnLCB7XG4gICAgICAgICAgdmFsdWU6IG9yaWdpbmFsU2xpZGUsXG4gICAgICAgICAgdHlwZTpcbiAgICAgICAgICAgIHR5cGVvZiBvcmlnaW5hbFNsaWRlID09PSAnc3RyaW5nJyA/ICdhcnJvdycgOiBkb3QgPyAnZG90JyA6ICdzbGlkZSdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5zZXR0aW5nc0JyZWFrcG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICB2YXIgcmVzcCA9IF8uX29wdC5yZXNwb25zaXZlXG5cbiAgICBpZiAocmVzcCkge1xuICAgICAgLy8gU29ydCB0aGUgYnJlYWtwb2ludHMgaW4gbW9iaWxlIGZpcnN0IG9yZGVyXG4gICAgICByZXNwLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuYnJlYWtwb2ludCAtIGEuYnJlYWtwb2ludFxuICAgICAgfSlcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNwLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzaXplID0gcmVzcFtpXVxuICAgICAgICBpZiAoX3dpbmRvdy5pbm5lcldpZHRoID49IHNpemUuYnJlYWtwb2ludCkge1xuICAgICAgICAgIGlmIChfLmJyZWFrcG9pbnQgIT09IHNpemUuYnJlYWtwb2ludCkge1xuICAgICAgICAgICAgXy5vcHQgPSBPYmplY3QuYXNzaWduKHt9LCBfLl9vcHQsIHNpemUuc2V0dGluZ3MpXG4gICAgICAgICAgICBfLmJyZWFrcG9pbnQgPSBzaXplLmJyZWFrcG9pbnRcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBiYWNrIHRvIGRlZmF1bHRzIGluIGNhc2UgdGhleSB3ZXJlIG92ZXJyaWRlblxuICAgIHZhciBicmVha3BvaW50Q2hhbmdlZCA9IF8uYnJlYWtwb2ludCAhPT0gMFxuICAgIF8ub3B0ID0gT2JqZWN0LmFzc2lnbih7fSwgXy5fb3B0KVxuICAgIF8uYnJlYWtwb2ludCA9IDBcbiAgICByZXR1cm4gYnJlYWtwb2ludENoYW5nZWRcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uIChzY3JvbGxUYXJnZXQsIHNjcm9sbER1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICAgIHZhciBhbmltYXRlSW5kZXggPSBfLmFuaW1hdGVfaWRcblxuICAgIHZhciBhbmltYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRcbiAgICAgIF8uZWxlLnNjcm9sbExlZnQgPVxuICAgICAgICBfLmVsZS5zY3JvbGxMZWZ0ICtcbiAgICAgICAgKHNjcm9sbFRhcmdldCAtIF8uZWxlLnNjcm9sbExlZnQpICpcbiAgICAgICAgICBfLm9wdC5lYXNpbmcoMCwgbm93LCAwLCAxLCBzY3JvbGxEdXJhdGlvbilcbiAgICAgIGlmIChub3cgPCBzY3JvbGxEdXJhdGlvbiAmJiBhbmltYXRlSW5kZXggPT09IF8uYW5pbWF0ZV9pZCkge1xuICAgICAgICBfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXy5lbGUuc2Nyb2xsTGVmdCA9IHNjcm9sbFRhcmdldFxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKF8pXG4gICAgICB9XG4gICAgfVxuXG4gICAgX3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICBpZiAoXy5zbGlkZXMubGVuZ3RoKSB7XG4gICAgICBfLnRyYWNrLnJlbW92ZUNoaWxkKF8uc2xpZGVzW2luZGV4XSlcbiAgICAgIF8ucmVmcmVzaCh0cnVlKVxuICAgICAgXy5lbWl0KCdyZW1vdmUnKVxuICAgIH1cbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgXy50cmFjay5hcHBlbmRDaGlsZChlbGUpXG4gICAgXy5yZWZyZXNoKHRydWUpXG4gICAgXy5lbWl0KCdhZGQnKVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLmhhbmRsZU1vdXNlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgXyA9IHRoaXNcbiAgICBpZiAoXy5tb3VzZURvd24pIHtcbiAgICAgIF8uaXNEcmFnID0gdHJ1ZVxuICAgICAgXy5lbGUuc2Nyb2xsTGVmdCArPVxuICAgICAgICAoXy5tb3VzZURvd24gLSBlLmNsaWVudFgpICogKF8ub3B0LmRyYWdWZWxvY2l0eSB8fCAzLjMpXG4gICAgICBfLm1vdXNlRG93biA9IGUuY2xpZW50WFxuICAgIH1cbiAgfVxuXG4gIC8vIHVzZWQgdG8gcm91bmQgdG8gdGhlIG5lYXJlc3QgMC5YWCBmcmFjdGlvblxuICBnbGlkZXJQcm90b3R5cGUucm91bmQgPSBmdW5jdGlvbiAoZG91YmxlKSB7XG4gICAgdmFyIF8gPSB0aGlzXG4gICAgdmFyIHN0ZXAgPSBfLm9wdC5zbGlkZXNUb1Njcm9sbCAlIDEgfHwgMVxuICAgIHZhciBpbnYgPSAxLjAgLyBzdGVwXG4gICAgcmV0dXJuIE1hdGgucm91bmQoZG91YmxlICogaW52KSAvIGludlxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAocGFnaW5nKSB7XG4gICAgdmFyIF8gPSB0aGlzXG4gICAgXy5pbml0KHRydWUsIHBhZ2luZylcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiAob3B0LCBnbG9iYWwpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIGlmIChfLmJyZWFrcG9pbnQgJiYgIWdsb2JhbCkge1xuICAgICAgXy5fb3B0LnJlc3BvbnNpdmUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodi5icmVha3BvaW50ID09PSBfLmJyZWFrcG9pbnQpIHtcbiAgICAgICAgICB2LnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgdi5zZXR0aW5ncywgb3B0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBfLl9vcHQgPSBPYmplY3QuYXNzaWduKHt9LCBfLl9vcHQsIG9wdClcbiAgICB9XG5cbiAgICBfLmJyZWFrcG9pbnQgPSAwXG4gICAgXy5zZXR0aW5nc0JyZWFrcG9pbnQoKVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICB2YXIgcmVwbGFjZSA9IF8uZWxlLmNsb25lTm9kZSh0cnVlKVxuXG4gICAgdmFyIGNsZWFyID0gZnVuY3Rpb24gKGVsZSkge1xuICAgICAgZWxlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIFtdLmZvckVhY2guY2FsbChlbGUuY2xhc3NMaXN0LCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIC9eZ2xpZGVyLy50ZXN0KGNsYXNzTmFtZSkgJiYgZWxlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHRyYWNrXG4gICAgcmVwbGFjZS5jaGlsZHJlblswXS5vdXRlckhUTUwgPSByZXBsYWNlLmNoaWxkcmVuWzBdLmlubmVySFRNTFxuICAgIGNsZWFyKHJlcGxhY2UpO1xuICAgIFtdLmZvckVhY2guY2FsbChyZXBsYWNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyksIGNsZWFyKVxuICAgIF8uZWxlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHJlcGxhY2UsIF8uZWxlKVxuICAgIF8uZXZlbnQoX3dpbmRvdywgJ3JlbW92ZScsIHtcbiAgICAgIHJlc2l6ZTogXy5yZXNpemVcbiAgICB9KVxuICAgIF8uZW1pdCgnZGVzdHJveScpXG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmcpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIHZhciBlID0gbmV3IF93aW5kb3cuQ3VzdG9tRXZlbnQoJ2dsaWRlci0nICsgbmFtZSwge1xuICAgICAgYnViYmxlczogIV8ub3B0LmV2ZW50UHJvcGFnYXRlLFxuICAgICAgZGV0YWlsOiBhcmdcbiAgICB9KVxuICAgIF8uZWxlLmRpc3BhdGNoRXZlbnQoZSlcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uIChlbGUsIHR5cGUsIGFyZ3MpIHtcbiAgICB2YXIgZXZlbnRIYW5kbGVyID0gZWxlW3R5cGUgKyAnRXZlbnRMaXN0ZW5lciddLmJpbmQoZWxlKVxuICAgIE9iamVjdC5rZXlzKGFyZ3MpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGV2ZW50SGFuZGxlcihrLCBhcmdzW2tdKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gR2xpZGVyXG59KVxuIiwiaW1wb3J0IEdsaWRlciBmcm9tICdnbGlkZXItanMnO1xuLy8gY29kZSBmb3IgdGVzdGltb25pYWxzXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIHNldHVwVGVzdGltb25pYWxTbGlkZXIoKSB7XG4gIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZ2xpZGVyJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG4gICAgbmV3IEdsaWRlcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZ2xpZGVyJyksIHtcbiAgICAgIC8vIE1vYmlsZS1maXJzdCBkZWZhdWx0c1xuICAgICAgc2xpZGVzVG9TaG93OiAxLFxuICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gICAgICBzY3JvbGxMb2NrOiB0cnVlLFxuICAgICAgZG90czogJyNyZXNwLWRvdHMnLFxuICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgYXJyb3dzOiB7XG4gICAgICAgIHByZXY6ICcuZ2xpZGVyLXByZXYnLFxuICAgICAgICBuZXh0OiAnLmdsaWRlci1uZXh0JyxcbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBzY3JlZW5zIGdyZWF0ZXIgdGhhbiA+PSA3NzVweFxuICAgICAgICAgIGJyZWFrcG9pbnQ6IDAsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIC8vIFNldCB0byBgYXV0b2AgYW5kIHByb3ZpZGUgaXRlbSB3aWR0aCB0byBhZGp1c3QgdG8gdmlld3BvcnRcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvdzogMSxcbiAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICAgICAgICAgICAgaXRlbVdpZHRoOiAzMDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgLy8gc2NyZWVucyBncmVhdGVyIHRoYW4gPj0gMTAyNHB4XG4gICAgICAgICAgYnJlYWtwb2ludDogNTQwLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBzbGlkZXNUb1Nob3c6ICdhdXRvJyxcbiAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAnYXV0bycsXG4gICAgICAgICAgICBpdGVtV2lkdGg6IDMwMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pO1xuICB9XG59KTtcbiIsImltcG9ydCB7IHRvZ2dsZUNsYXNzLCByZW1vdmVDbGFzcyB9IGZyb20gJy4uL2hlbHBlcic7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudDtcbiAgaWYgKHRhcmdldC5jbG9zZXN0KCcuZHJvcGRvd24tbWVudScpKSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgLy8gY2xhc3M9XCJuYXZiYXItdG9nZ2xlclwiIGRhdGEtdHJpZ2dlcj1cIiNuYXZiYXJfbWFpblwiXG4gIGlmICh0YXJnZXQuY2xvc2VzdCgnLm5hdmJhci10b2dnbGVyW2RhdGEtdHJpZ2dlcl0nKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3Qgb2ZmY2FudmFzSWQgPSB0YXJnZXRcbiAgICAgIC5jbG9zZXN0KCcubmF2YmFyLXRvZ2dsZXJbZGF0YS10cmlnZ2VyXScpXG4gICAgICAuZ2V0QXR0cmlidXRlKCdkYXRhLXRyaWdnZXInKTtcbiAgICBjb25zdCBvZmZjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9mZmNhbnZhc0lkKTtcbiAgICBpZiAob2ZmY2FudmFzKSB7XG4gICAgICB0b2dnbGVDbGFzcyhvZmZjYW52YXMsICdzaG93Jyk7XG4gICAgfVxuICAgIHRvZ2dsZUNsYXNzKGRvY3VtZW50LmJvZHksICdvZmZjYW52YXMtYWN0aXZlJyk7XG4gICAgY29uc3Qgc2NyZWVuT3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zY3JlZW4tb3ZlcmxheScpO1xuICAgIGlmIChzY3JlZW5PdmVybGF5KSB7XG4gICAgICB0b2dnbGVDbGFzcyhzY3JlZW5PdmVybGF5LCAnc2hvdycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YXJnZXQuY2xvc2VzdCgnLmJ0bi1jbG9zZSwgLnNjcmVlbi1vdmVybGF5JykpIHtcbiAgICBjb25zdCBzY3JlZW5PdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNjcmVlbi1vdmVybGF5Jyk7XG4gICAgaWYgKHNjcmVlbk92ZXJsYXkpIHtcbiAgICAgIHJlbW92ZUNsYXNzKHNjcmVlbk92ZXJsYXksICdzaG93Jyk7XG4gICAgfVxuICAgIGNvbnN0IG1vYmlsZU9mZmNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tb2JpbGUtb2ZmY2FudmFzJyk7XG4gICAgaWYgKG1vYmlsZU9mZmNhbnZhcykge1xuICAgICAgcmVtb3ZlQ2xhc3MobW9iaWxlT2ZmY2FudmFzLCAnc2hvdycpO1xuICAgIH1cbiAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnb2ZmY2FudmFzLWFjdGl2ZScpO1xuICB9XG59KTtcbiIsIiFmdW5jdGlvbih0LG4pe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPW4oKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKG4pOnQuTWFjeT1uKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQsbil7dmFyIGU9dm9pZCAwO3JldHVybiBmdW5jdGlvbigpe2UmJmNsZWFyVGltZW91dChlKSxlPXNldFRpbWVvdXQodCxuKX19ZnVuY3Rpb24gbih0LG4pe2Zvcih2YXIgZT10Lmxlbmd0aCxyPWUsbz1bXTtlLS07KW8ucHVzaChuKHRbci1lLTFdKSk7cmV0dXJuIG99ZnVuY3Rpb24gZSh0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07aWYod2luZG93LlByb21pc2UpcmV0dXJuIEEodCxuLGUpO3QucmVjYWxjdWxhdGUoITAsITApfWZ1bmN0aW9uIHIodCl7Zm9yKHZhciBuPXQub3B0aW9ucyxlPXQucmVzcG9uc2l2ZU9wdGlvbnMscj10LmtleXMsbz10LmRvY1dpZHRoLGk9dm9pZCAwLHM9MDtzPHIubGVuZ3RoO3MrKyl7dmFyIGE9cGFyc2VJbnQocltzXSwxMCk7bz49YSYmKGk9bi5icmVha0F0W2FdLE8oaSxlKSl9cmV0dXJuIGV9ZnVuY3Rpb24gbyh0KXtmb3IodmFyIG49dC5vcHRpb25zLGU9dC5yZXNwb25zaXZlT3B0aW9ucyxyPXQua2V5cyxvPXQuZG9jV2lkdGgsaT12b2lkIDAscz1yLmxlbmd0aC0xO3M+PTA7cy0tKXt2YXIgYT1wYXJzZUludChyW3NdLDEwKTtvPD1hJiYoaT1uLmJyZWFrQXRbYV0sTyhpLGUpKX1yZXR1cm4gZX1mdW5jdGlvbiBpKHQpe3ZhciBuPXQudXNlQ29udGFpbmVyRm9yQnJlYWtwb2ludHM/dC5jb250YWluZXIuY2xpZW50V2lkdGg6d2luZG93LmlubmVyV2lkdGgsZT17Y29sdW1uczp0LmNvbHVtbnN9O2IodC5tYXJnaW4pP2UubWFyZ2luPXt4OnQubWFyZ2luLngseTp0Lm1hcmdpbi55fTplLm1hcmdpbj17eDp0Lm1hcmdpbix5OnQubWFyZ2lufTt2YXIgaT1PYmplY3Qua2V5cyh0LmJyZWFrQXQpO3JldHVybiB0Lm1vYmlsZUZpcnN0P3Ioe29wdGlvbnM6dCxyZXNwb25zaXZlT3B0aW9uczplLGtleXM6aSxkb2NXaWR0aDpufSk6byh7b3B0aW9uczp0LHJlc3BvbnNpdmVPcHRpb25zOmUsa2V5czppLGRvY1dpZHRoOm59KX1mdW5jdGlvbiBzKHQpe3JldHVybiBpKHQpLmNvbHVtbnN9ZnVuY3Rpb24gYSh0KXtyZXR1cm4gaSh0KS5tYXJnaW59ZnVuY3Rpb24gYyh0KXt2YXIgbj0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdLGU9cyh0KSxyPWEodCkueCxvPTEwMC9lO2lmKCFuKXJldHVybiBvO2lmKDE9PT1lKXJldHVyblwiMTAwJVwiO3ZhciBpPVwicHhcIjtpZihcInN0cmluZ1wiPT10eXBlb2Ygcil7dmFyIGM9cGFyc2VGbG9hdChyKTtpPXIucmVwbGFjZShjLFwiXCIpLHI9Y31yZXR1cm4gcj0oZS0xKSpyL2UsXCIlXCI9PT1pP28tcitcIiVcIjpcImNhbGMoXCIrbytcIiUgLSBcIityK2krXCIpXCJ9ZnVuY3Rpb24gdSh0LG4pe3ZhciBlPXModC5vcHRpb25zKSxyPTAsbz12b2lkIDAsaT12b2lkIDA7aWYoMT09PSsrbilyZXR1cm4gMDtpPWEodC5vcHRpb25zKS54O3ZhciB1PVwicHhcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgaSl7dmFyIGw9cGFyc2VGbG9hdChpLDEwKTt1PWkucmVwbGFjZShsLFwiXCIpLGk9bH1yZXR1cm4gbz0oaS0oZS0xKSppL2UpKihuLTEpLHIrPWModC5vcHRpb25zLCExKSoobi0xKSxcIiVcIj09PXU/citvK1wiJVwiOlwiY2FsYyhcIityK1wiJSArIFwiK28rdStcIilcIn1mdW5jdGlvbiBsKHQpe3ZhciBuPTAsZT10LmNvbnRhaW5lcixyPXQucm93czt2KHIsZnVuY3Rpb24odCl7bj10Pm4/dDpufSksZS5zdHlsZS5oZWlnaHQ9bitcInB4XCJ9ZnVuY3Rpb24gcCh0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0scj0hKGFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdKXx8YXJndW1lbnRzWzNdLG89cyh0Lm9wdGlvbnMpLGk9YSh0Lm9wdGlvbnMpLnk7TSh0LG8sZSksdihuLGZ1bmN0aW9uKG4pe3ZhciBlPTAsbz1wYXJzZUludChuLm9mZnNldEhlaWdodCwxMCk7aXNOYU4obyl8fCh0LnJvd3MuZm9yRWFjaChmdW5jdGlvbihuLHIpe248dC5yb3dzW2VdJiYoZT1yKX0pLG4uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLG4uc3R5bGUudG9wPXQucm93c1tlXStcInB4XCIsbi5zdHlsZS5sZWZ0PVwiXCIrdC5jb2xzW2VdLHQucm93c1tlXSs9aXNOYU4obyk/MDpvK2ksciYmKG4uZGF0YXNldC5tYWN5Q29tcGxldGU9MSkpfSksciYmKHQudG1wUm93cz1udWxsKSxsKHQpfWZ1bmN0aW9uIGYodCxuKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLHI9IShhcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSl8fGFyZ3VtZW50c1szXSxvPXModC5vcHRpb25zKSxpPWEodC5vcHRpb25zKS55O00odCxvLGUpLHYobixmdW5jdGlvbihuKXt0Lmxhc3Rjb2w9PT1vJiYodC5sYXN0Y29sPTApO3ZhciBlPUMobixcImhlaWdodFwiKTtlPXBhcnNlSW50KG4ub2Zmc2V0SGVpZ2h0LDEwKSxpc05hTihlKXx8KG4uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLG4uc3R5bGUudG9wPXQucm93c1t0Lmxhc3Rjb2xdK1wicHhcIixuLnN0eWxlLmxlZnQ9XCJcIit0LmNvbHNbdC5sYXN0Y29sXSx0LnJvd3NbdC5sYXN0Y29sXSs9aXNOYU4oZSk/MDplK2ksdC5sYXN0Y29sKz0xLHImJihuLmRhdGFzZXQubWFjeUNvbXBsZXRlPTEpKX0pLHImJih0LnRtcFJvd3M9bnVsbCksbCh0KX12YXIgaD1mdW5jdGlvbiB0KG4sZSl7aWYoISh0aGlzIGluc3RhbmNlb2YgdCkpcmV0dXJuIG5ldyB0KG4sZSk7aWYobiYmbi5ub2RlTmFtZSlyZXR1cm4gbjtpZihuPW4ucmVwbGFjZSgvXlxccyovLFwiXCIpLnJlcGxhY2UoL1xccyokLyxcIlwiKSxlKXJldHVybiB0aGlzLmJ5Q3NzKG4sZSk7Zm9yKHZhciByIGluIHRoaXMuc2VsZWN0b3JzKWlmKGU9ci5zcGxpdChcIi9cIiksbmV3IFJlZ0V4cChlWzFdLGVbMl0pLnRlc3QobikpcmV0dXJuIHRoaXMuc2VsZWN0b3JzW3JdKG4pO3JldHVybiB0aGlzLmJ5Q3NzKG4pfTtoLnByb3RvdHlwZS5ieUNzcz1mdW5jdGlvbih0LG4pe3JldHVybihufHxkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbCh0KX0saC5wcm90b3R5cGUuc2VsZWN0b3JzPXt9LGgucHJvdG90eXBlLnNlbGVjdG9yc1svXlxcLltcXHdcXC1dKyQvXT1mdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSh0LnN1YnN0cmluZygxKSl9LGgucHJvdG90eXBlLnNlbGVjdG9yc1svXlxcdyskL109ZnVuY3Rpb24odCl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHQpfSxoLnByb3RvdHlwZS5zZWxlY3RvcnNbL15cXCNbXFx3XFwtXSskL109ZnVuY3Rpb24odCl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQuc3Vic3RyaW5nKDEpKX07dmFyIHY9ZnVuY3Rpb24odCxuKXtmb3IodmFyIGU9dC5sZW5ndGgscj1lO2UtLTspbih0W3ItZS0xXSl9LG09ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdO3RoaXMucnVubmluZz0hMSx0aGlzLmV2ZW50cz1bXSx0aGlzLmFkZCh0KX07bS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7aWYoIXRoaXMucnVubmluZyYmdGhpcy5ldmVudHMubGVuZ3RoPjApe3ZhciB0PXRoaXMuZXZlbnRzLnNoaWZ0KCk7dGhpcy5ydW5uaW5nPSEwLHQoKSx0aGlzLnJ1bm5pbmc9ITEsdGhpcy5ydW4oKX19LG0ucHJvdG90eXBlLmFkZD1mdW5jdGlvbigpe3ZhciB0PXRoaXMsbj1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdO3JldHVybiEhbiYmKEFycmF5LmlzQXJyYXkobik/dihuLGZ1bmN0aW9uKG4pe3JldHVybiB0LmFkZChuKX0pOih0aGlzLmV2ZW50cy5wdXNoKG4pLHZvaWQgdGhpcy5ydW4oKSkpfSxtLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuZXZlbnRzPVtdfTt2YXIgZD1mdW5jdGlvbih0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307cmV0dXJuIHRoaXMuaW5zdGFuY2U9dCx0aGlzLmRhdGE9bix0aGlzfSx5PWZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTt0aGlzLmV2ZW50cz17fSx0aGlzLmluc3RhbmNlPXR9O3kucHJvdG90eXBlLm9uPWZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXSxuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV07cmV0dXJuISghdHx8IW4pJiYoQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50c1t0XSl8fCh0aGlzLmV2ZW50c1t0XT1bXSksdGhpcy5ldmVudHNbdF0ucHVzaChuKSl9LHkucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdLG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O2lmKCF0fHwhQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50c1t0XSkpcmV0dXJuITE7dmFyIGU9bmV3IGQodGhpcy5pbnN0YW5jZSxuKTt2KHRoaXMuZXZlbnRzW3RdLGZ1bmN0aW9uKHQpe3JldHVybiB0KGUpfSl9O3ZhciBnPWZ1bmN0aW9uKHQpe3JldHVybiEoXCJuYXR1cmFsSGVpZ2h0XCJpbiB0JiZ0Lm5hdHVyYWxIZWlnaHQrdC5uYXR1cmFsV2lkdGg9PT0wKXx8dC53aWR0aCt0LmhlaWdodCE9PTB9LEU9ZnVuY3Rpb24odCxuKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0LGUpe2lmKG4uY29tcGxldGUpcmV0dXJuIGcobik/dChuKTplKG4pO24uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbigpe3JldHVybiBnKG4pP3Qobik6ZShuKX0pLG4uYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZnVuY3Rpb24oKXtyZXR1cm4gZShuKX0pfSkudGhlbihmdW5jdGlvbihuKXtlJiZ0LmVtaXQodC5jb25zdGFudHMuRVZFTlRfSU1BR0VfTE9BRCx7aW1nOm59KX0pLmNhdGNoKGZ1bmN0aW9uKG4pe3JldHVybiB0LmVtaXQodC5jb25zdGFudHMuRVZFTlRfSU1BR0VfRVJST1Ise2ltZzpufSl9KX0sdz1mdW5jdGlvbih0LGUpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07cmV0dXJuIG4oZSxmdW5jdGlvbihuKXtyZXR1cm4gRSh0LG4scil9KX0sQT1mdW5jdGlvbih0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07cmV0dXJuIFByb21pc2UuYWxsKHcodCxuLGUpKS50aGVuKGZ1bmN0aW9uKCl7dC5lbWl0KHQuY29uc3RhbnRzLkVWRU5UX0lNQUdFX0NPTVBMRVRFKX0pfSxJPWZ1bmN0aW9uKG4pe3JldHVybiB0KGZ1bmN0aW9uKCl7bi5lbWl0KG4uY29uc3RhbnRzLkVWRU5UX1JFU0laRSksbi5xdWV1ZS5hZGQoZnVuY3Rpb24oKXtyZXR1cm4gbi5yZWNhbGN1bGF0ZSghMCwhMCl9KX0sMTAwKX0sTj1mdW5jdGlvbih0KXtpZih0LmNvbnRhaW5lcj1oKHQub3B0aW9ucy5jb250YWluZXIpLHQuY29udGFpbmVyIGluc3RhbmNlb2YgaHx8IXQuY29udGFpbmVyKXJldHVybiEhdC5vcHRpb25zLmRlYnVnJiZjb25zb2xlLmVycm9yKFwiRXJyb3I6IENvbnRhaW5lciBub3QgZm91bmRcIik7dC5jb250YWluZXIubGVuZ3RoJiYodC5jb250YWluZXI9dC5jb250YWluZXJbMF0pLHQub3B0aW9ucy5jb250YWluZXI9dC5jb250YWluZXIsdC5jb250YWluZXIuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwifSxUPWZ1bmN0aW9uKHQpe3QucXVldWU9bmV3IG0sdC5ldmVudHM9bmV3IHkodCksdC5yb3dzPVtdLHQucmVzaXplcj1JKHQpfSxMPWZ1bmN0aW9uKHQpe3ZhciBuPWgoXCJpbWdcIix0LmNvbnRhaW5lcik7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0LnJlc2l6ZXIpLHQub24odC5jb25zdGFudHMuRVZFTlRfSU1BR0VfTE9BRCxmdW5jdGlvbigpe3JldHVybiB0LnJlY2FsY3VsYXRlKCExLCExKX0pLHQub24odC5jb25zdGFudHMuRVZFTlRfSU1BR0VfQ09NUExFVEUsZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWNhbGN1bGF0ZSghMCwhMCl9KSx0Lm9wdGlvbnMudXNlT3duSW1hZ2VMb2FkZXJ8fGUodCxuLCF0Lm9wdGlvbnMud2FpdEZvckltYWdlcyksdC5lbWl0KHQuY29uc3RhbnRzLkVWRU5UX0lOSVRJQUxJWkVEKX0sXz1mdW5jdGlvbih0KXtOKHQpLFQodCksTCh0KX0sYj1mdW5jdGlvbih0KXtyZXR1cm4gdD09PU9iamVjdCh0KSYmXCJbb2JqZWN0IEFycmF5XVwiIT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfSxPPWZ1bmN0aW9uKHQsbil7Yih0KXx8KG4uY29sdW1ucz10KSxiKHQpJiZ0LmNvbHVtbnMmJihuLmNvbHVtbnM9dC5jb2x1bW5zKSxiKHQpJiZ0Lm1hcmdpbiYmIWIodC5tYXJnaW4pJiYobi5tYXJnaW49e3g6dC5tYXJnaW4seTp0Lm1hcmdpbn0pLGIodCkmJnQubWFyZ2luJiZiKHQubWFyZ2luKSYmdC5tYXJnaW4ueCYmKG4ubWFyZ2luLng9dC5tYXJnaW4ueCksYih0KSYmdC5tYXJnaW4mJmIodC5tYXJnaW4pJiZ0Lm1hcmdpbi55JiYobi5tYXJnaW4ueT10Lm1hcmdpbi55KX0sQz1mdW5jdGlvbih0LG4pe3JldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0LG51bGwpLmdldFByb3BlcnR5VmFsdWUobil9LE09ZnVuY3Rpb24odCxuKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdO2lmKHQubGFzdGNvbHx8KHQubGFzdGNvbD0wKSx0LnJvd3MubGVuZ3RoPDEmJihlPSEwKSxlKXt0LnJvd3M9W10sdC5jb2xzPVtdLHQubGFzdGNvbD0wO2Zvcih2YXIgcj1uLTE7cj49MDtyLS0pdC5yb3dzW3JdPTAsdC5jb2xzW3JdPXUodCxyKX1lbHNlIGlmKHQudG1wUm93cyl7dC5yb3dzPVtdO2Zvcih2YXIgcj1uLTE7cj49MDtyLS0pdC5yb3dzW3JdPXQudG1wUm93c1tyXX1lbHNle3QudG1wUm93cz1bXTtmb3IodmFyIHI9bi0xO3I+PTA7ci0tKXQudG1wUm93c1tyXT10LnJvd3Nbcl19fSxWPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0sZT0hKGFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdKXx8YXJndW1lbnRzWzJdLHI9bj90LmNvbnRhaW5lci5jaGlsZHJlbjpoKCc6c2NvcGUgPiAqOm5vdChbZGF0YS1tYWN5LWNvbXBsZXRlPVwiMVwiXSknLHQuY29udGFpbmVyKTtyPUFycmF5LmZyb20ocikuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dC5vZmZzZXRQYXJlbnR9KTt2YXIgbz1jKHQub3B0aW9ucyk7cmV0dXJuIHYocixmdW5jdGlvbih0KXtuJiYodC5kYXRhc2V0Lm1hY3lDb21wbGV0ZT0wKSx0LnN0eWxlLndpZHRoPW99KSx0Lm9wdGlvbnMudHJ1ZU9yZGVyPyhmKHQscixuLGUpLHQuZW1pdCh0LmNvbnN0YW50cy5FVkVOVF9SRUNBTENVTEFURUQpKToocCh0LHIsbixlKSx0LmVtaXQodC5jb25zdGFudHMuRVZFTlRfUkVDQUxDVUxBVEVEKSl9LFI9ZnVuY3Rpb24oKXtyZXR1cm4hIXdpbmRvdy5Qcm9taXNlfSx4PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspe3ZhciBlPWFyZ3VtZW50c1tuXTtmb3IodmFyIHIgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSl9cmV0dXJuIHR9O0FycmF5LmZyb218fChBcnJheS5mcm9tPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbj0wLGU9W107bjx0Lmxlbmd0aDspZS5wdXNoKHRbbisrXSk7cmV0dXJuIGV9KTt2YXIgaz17Y29sdW1uczo0LG1hcmdpbjoyLHRydWVPcmRlcjohMSx3YWl0Rm9ySW1hZ2VzOiExLHVzZUltYWdlTG9hZGVyOiEwLGJyZWFrQXQ6e30sdXNlT3duSW1hZ2VMb2FkZXI6ITEsb25Jbml0OiExLGNhbmNlbExlZ2FjeTohMSx1c2VDb250YWluZXJGb3JCcmVha3BvaW50czohMX07IWZ1bmN0aW9uKCl7dHJ5e2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpLnF1ZXJ5U2VsZWN0b3IoXCI6c2NvcGUgKlwiKX1jYXRjaCh0KXshZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3JldHVybiBmdW5jdGlvbihlKXtpZihlJiZuLnRlc3QoZSkpe3ZhciByPXRoaXMuZ2V0QXR0cmlidXRlKFwiaWRcIik7cnx8KHRoaXMuaWQ9XCJxXCIrTWF0aC5mbG9vcig5ZTYqTWF0aC5yYW5kb20oKSkrMWU2KSxhcmd1bWVudHNbMF09ZS5yZXBsYWNlKG4sXCIjXCIrdGhpcy5pZCk7dmFyIG89dC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIG51bGw9PT1yP3RoaXMucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik6cnx8KHRoaXMuaWQ9ciksb31yZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXZhciBuPS86c2NvcGVcXGIvZ2ksZT10KEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IpO0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3I9ZnVuY3Rpb24odCl7cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgcj10KEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwpO0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGw9ZnVuY3Rpb24odCl7cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0oKX19KCk7dmFyIHE9ZnVuY3Rpb24gdCgpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTprO2lmKCEodGhpcyBpbnN0YW5jZW9mIHQpKXJldHVybiBuZXcgdChuKTt0aGlzLm9wdGlvbnM9e30seCh0aGlzLm9wdGlvbnMsayxuKSx0aGlzLm9wdGlvbnMuY2FuY2VsTGVnYWN5JiYhUigpfHxfKHRoaXMpfTtyZXR1cm4gcS5pbml0PWZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJEZXByZWNpYXRlZDogTWFjeS5pbml0IHdpbGwgYmUgcmVtb3ZlZCBpbiB2My4wLjAgb3B0IHRvIHVzZSBNYWN5IGRpcmVjdGx5IGxpa2Ugc28gTWFjeSh7IC8qb3B0aW9ucyBoZXJlKi8gfSkgXCIpLG5ldyBxKHQpfSxxLnByb3RvdHlwZS5yZWNhbGN1bGF0ZU9uSW1hZ2VMb2FkPWZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTtyZXR1cm4gZSh0aGlzLGgoXCJpbWdcIix0aGlzLmNvbnRhaW5lciksIXQpfSxxLnByb3RvdHlwZS5ydW5PbkltYWdlTG9hZD1mdW5jdGlvbih0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLHI9aChcImltZ1wiLHRoaXMuY29udGFpbmVyKTtyZXR1cm4gdGhpcy5vbih0aGlzLmNvbnN0YW50cy5FVkVOVF9JTUFHRV9DT01QTEVURSx0KSxuJiZ0aGlzLm9uKHRoaXMuY29uc3RhbnRzLkVWRU5UX0lNQUdFX0xPQUQsdCksZSh0aGlzLHIsbil9LHEucHJvdG90eXBlLnJlY2FsY3VsYXRlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0sZT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdO3JldHVybiBlJiZ0aGlzLnF1ZXVlLmNsZWFyKCksdGhpcy5xdWV1ZS5hZGQoZnVuY3Rpb24oKXtyZXR1cm4gVih0LG4sZSl9KX0scS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLnJlc2l6ZXIpLHYodGhpcy5jb250YWluZXIuY2hpbGRyZW4sZnVuY3Rpb24odCl7dC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLW1hY3ktY29tcGxldGVcIiksdC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKX0pLHRoaXMuY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpfSxxLnByb3RvdHlwZS5yZUluaXQ9ZnVuY3Rpb24oKXt0aGlzLnJlY2FsY3VsYXRlKCEwLCEwKSx0aGlzLmVtaXQodGhpcy5jb25zdGFudHMuRVZFTlRfSU5JVElBTElaRUQpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5yZXNpemVyKSx0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCJ9LHEucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsbil7dGhpcy5ldmVudHMub24odCxuKX0scS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbih0LG4pe3RoaXMuZXZlbnRzLmVtaXQodCxuKX0scS5jb25zdGFudHM9e0VWRU5UX0lOSVRJQUxJWkVEOlwibWFjeS5pbml0aWFsaXplZFwiLEVWRU5UX1JFQ0FMQ1VMQVRFRDpcIm1hY3kucmVjYWxjdWxhdGVkXCIsRVZFTlRfSU1BR0VfTE9BRDpcIm1hY3kuaW1hZ2UubG9hZFwiLEVWRU5UX0lNQUdFX0VSUk9SOlwibWFjeS5pbWFnZS5lcnJvclwiLEVWRU5UX0lNQUdFX0NPTVBMRVRFOlwibWFjeS5pbWFnZXMuY29tcGxldGVcIixFVkVOVF9SRVNJWkU6XCJtYWN5LnJlc2l6ZVwifSxxLnByb3RvdHlwZS5jb25zdGFudHM9cS5jb25zdGFudHMscX0pO1xuIiwiaW1wb3J0IE1hY3kgZnJvbSAnbWFjeSc7XG5cbmlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5kZXgtc2VjdGlvbi0tbWFzb25yeSAuaW1hZ2VzLXdyYXBwZXInKSkge1xuICBNYWN5KHtcbiAgICBjb250YWluZXI6ICcuaW5kZXgtc2VjdGlvbi0tbWFzb25yeSAuaW1hZ2VzLXdyYXBwZXInLFxuICAgIGNvbHVtbnM6IDMsXG4gICAgYnJlYWtBdDoge1xuICAgICAgNTIwOiAyLFxuICAgICAgNDAwOiAxLFxuICAgIH0sXG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuY29uc3QgZGlyZWN0aXZlcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEJyYW5kcyBhIGZ1bmN0aW9uIGFzIGEgZGlyZWN0aXZlIGZhY3RvcnkgZnVuY3Rpb24gc28gdGhhdCBsaXQtaHRtbCB3aWxsIGNhbGxcbiAqIHRoZSBmdW5jdGlvbiBkdXJpbmcgdGVtcGxhdGUgcmVuZGVyaW5nLCByYXRoZXIgdGhhbiBwYXNzaW5nIGFzIGEgdmFsdWUuXG4gKlxuICogQSBfZGlyZWN0aXZlXyBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBQYXJ0IGFzIGFuIGFyZ3VtZW50LiBJdCBoYXMgdGhlXG4gKiBzaWduYXR1cmU6IGAocGFydDogUGFydCkgPT4gdm9pZGAuXG4gKlxuICogQSBkaXJlY3RpdmUgX2ZhY3RvcnlfIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcmd1bWVudHMgZm9yIGRhdGEgYW5kXG4gKiBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zIGEgZGlyZWN0aXZlLiBVc2VycyBvZiBkaXJlY3RpdmUgdXN1YWxseSByZWZlciB0b1xuICogdGhlIGRpcmVjdGl2ZSBmYWN0b3J5IGFzIHRoZSBkaXJlY3RpdmUuIEZvciBleGFtcGxlLCBcIlRoZSByZXBlYXQgZGlyZWN0aXZlXCIuXG4gKlxuICogVXN1YWxseSBhIHRlbXBsYXRlIGF1dGhvciB3aWxsIGludm9rZSBhIGRpcmVjdGl2ZSBmYWN0b3J5IGluIHRoZWlyIHRlbXBsYXRlXG4gKiB3aXRoIHJlbGV2YW50IGFyZ3VtZW50cywgd2hpY2ggd2lsbCB0aGVuIHJldHVybiBhIGRpcmVjdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBvZiB1c2luZyB0aGUgYHJlcGVhdCgpYCBkaXJlY3RpdmUgZmFjdG9yeSB0aGF0IHRha2VzIGFuXG4gKiBhcnJheSBhbmQgYSBmdW5jdGlvbiB0byByZW5kZXIgYW4gaXRlbTpcbiAqXG4gKiBgYGBqc1xuICogaHRtbGA8dWw+PCR7cmVwZWF0KGl0ZW1zLCAoaXRlbSkgPT4gaHRtbGA8bGk+JHtpdGVtfTwvbGk+YCl9PC91bD5gXG4gKiBgYGBcbiAqXG4gKiBXaGVuIGByZXBlYXRgIGlzIGludm9rZWQsIGl0IHJldHVybnMgYSBkaXJlY3RpdmUgZnVuY3Rpb24gdGhhdCBjbG9zZXMgb3ZlclxuICogYGl0ZW1zYCBhbmQgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLiBXaGVuIHRoZSBvdXRlciB0ZW1wbGF0ZSBpcyByZW5kZXJlZCwgdGhlXG4gKiByZXR1cm4gZGlyZWN0aXZlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBQYXJ0IGZvciB0aGUgZXhwcmVzc2lvbi5cbiAqIGByZXBlYXRgIHRoZW4gcGVyZm9ybXMgaXQncyBjdXN0b20gbG9naWMgdG8gcmVuZGVyIG11bHRpcGxlIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSBmIFRoZSBkaXJlY3RpdmUgZmFjdG9yeSBmdW5jdGlvbi4gTXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhXG4gKiBmdW5jdGlvbiBvZiB0aGUgc2lnbmF0dXJlIGAocGFydDogUGFydCkgPT4gdm9pZGAuIFRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsXG4gKiBiZSBjYWxsZWQgd2l0aCB0aGUgcGFydCBvYmplY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQge2RpcmVjdGl2ZSwgaHRtbH0gZnJvbSAnbGl0LWh0bWwnO1xuICpcbiAqIGNvbnN0IGltbXV0YWJsZSA9IGRpcmVjdGl2ZSgodikgPT4gKHBhcnQpID0+IHtcbiAqICAgaWYgKHBhcnQudmFsdWUgIT09IHYpIHtcbiAqICAgICBwYXJ0LnNldFZhbHVlKHYpXG4gKiAgIH1cbiAqIH0pO1xuICovXG5leHBvcnQgY29uc3QgZGlyZWN0aXZlID0gKGYpID0+ICgoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGQgPSBmKC4uLmFyZ3MpO1xuICAgIGRpcmVjdGl2ZXMuc2V0KGQsIHRydWUpO1xuICAgIHJldHVybiBkO1xufSk7XG5leHBvcnQgY29uc3QgaXNEaXJlY3RpdmUgPSAobykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyAmJiBkaXJlY3RpdmVzLmhhcyhvKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmUuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBUcnVlIGlmIHRoZSBjdXN0b20gZWxlbWVudHMgcG9seWZpbGwgaXMgaW4gdXNlLlxuICovXG5leHBvcnQgY29uc3QgaXNDRVBvbHlmaWxsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMgIT0gbnVsbCAmJlxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrICE9PVxuICAgICAgICB1bmRlZmluZWQ7XG4vKipcbiAqIFJlcGFyZW50cyBub2Rlcywgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIChpbmNsdXNpdmUpIHRvIGBlbmRgIChleGNsdXNpdmUpLFxuICogaW50byBhbm90aGVyIGNvbnRhaW5lciAoY291bGQgYmUgdGhlIHNhbWUgY29udGFpbmVyKSwgYmVmb3JlIGBiZWZvcmVgLiBJZlxuICogYGJlZm9yZWAgaXMgbnVsbCwgaXQgYXBwZW5kcyB0aGUgbm9kZXMgdG8gdGhlIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGFyZW50Tm9kZXMgPSAoY29udGFpbmVyLCBzdGFydCwgZW5kID0gbnVsbCwgYmVmb3JlID0gbnVsbCkgPT4ge1xuICAgIHdoaWxlIChzdGFydCAhPT0gZW5kKSB7XG4gICAgICAgIGNvbnN0IG4gPSBzdGFydC5uZXh0U2libGluZztcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShzdGFydCwgYmVmb3JlKTtcbiAgICAgICAgc3RhcnQgPSBuO1xuICAgIH1cbn07XG4vKipcbiAqIFJlbW92ZXMgbm9kZXMsIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCAoaW5jbHVzaXZlKSB0byBgZW5kYCAoZXhjbHVzaXZlKSwgZnJvbVxuICogYGNvbnRhaW5lcmAuXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVOb2RlcyA9IChjb250YWluZXIsIHN0YXJ0LCBlbmQgPSBudWxsKSA9PiB7XG4gICAgd2hpbGUgKHN0YXJ0ICE9PSBlbmQpIHtcbiAgICAgICAgY29uc3QgbiA9IHN0YXJ0Lm5leHRTaWJsaW5nO1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoc3RhcnQpO1xuICAgICAgICBzdGFydCA9IG47XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbS5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIEEgc2VudGluZWwgdmFsdWUgdGhhdCBzaWduYWxzIHRoYXQgYSB2YWx1ZSB3YXMgaGFuZGxlZCBieSBhIGRpcmVjdGl2ZSBhbmRcbiAqIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuICovXG5leHBvcnQgY29uc3Qgbm9DaGFuZ2UgPSB7fTtcbi8qKlxuICogQSBzZW50aW5lbCB2YWx1ZSB0aGF0IHNpZ25hbHMgYSBOb2RlUGFydCB0byBmdWxseSBjbGVhciBpdHMgY29udGVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vdGhpbmcgPSB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBBbiBleHByZXNzaW9uIG1hcmtlciB3aXRoIGVtYmVkZGVkIHVuaXF1ZSBrZXkgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGhcbiAqIHBvc3NpYmxlIHRleHQgaW4gdGVtcGxhdGVzLlxuICovXG5leHBvcnQgY29uc3QgbWFya2VyID0gYHt7bGl0LSR7U3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpfX19YDtcbi8qKlxuICogQW4gZXhwcmVzc2lvbiBtYXJrZXIgdXNlZCB0ZXh0LXBvc2l0aW9ucywgbXVsdGktYmluZGluZyBhdHRyaWJ1dGVzLCBhbmRcbiAqIGF0dHJpYnV0ZXMgd2l0aCBtYXJrdXAtbGlrZSB0ZXh0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vZGVNYXJrZXIgPSBgPCEtLSR7bWFya2VyfS0tPmA7XG5leHBvcnQgY29uc3QgbWFya2VyUmVnZXggPSBuZXcgUmVnRXhwKGAke21hcmtlcn18JHtub2RlTWFya2VyfWApO1xuLyoqXG4gKiBTdWZmaXggYXBwZW5kZWQgdG8gYWxsIGJvdW5kIGF0dHJpYnV0ZSBuYW1lcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGJvdW5kQXR0cmlidXRlU3VmZml4ID0gJyRsaXQkJztcbi8qKlxuICogQW4gdXBkYXRhYmxlIFRlbXBsYXRlIHRoYXQgdHJhY2tzIHRoZSBsb2NhdGlvbiBvZiBkeW5hbWljIHBhcnRzLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGUge1xuICAgIGNvbnN0cnVjdG9yKHJlc3VsdCwgZWxlbWVudCkge1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICAgICAgLy8gRWRnZSBuZWVkcyBhbGwgNCBwYXJhbWV0ZXJzIHByZXNlbnQ7IElFMTEgbmVlZHMgM3JkIHBhcmFtZXRlciB0byBiZSBudWxsXG4gICAgICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudC5jb250ZW50LCAxMzMgLyogTm9kZUZpbHRlci5TSE9XX3tFTEVNRU5UfENPTU1FTlR8VEVYVH0gKi8sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGxhc3QgaW5kZXggYXNzb2NpYXRlZCB3aXRoIGEgcGFydC4gV2UgdHJ5IHRvIGRlbGV0ZVxuICAgICAgICAvLyB1bm5lY2Vzc2FyeSBub2RlcywgYnV0IHdlIG5ldmVyIHdhbnQgdG8gYXNzb2NpYXRlIHR3byBkaWZmZXJlbnQgcGFydHNcbiAgICAgICAgLy8gdG8gdGhlIHNhbWUgaW5kZXguIFRoZXkgbXVzdCBoYXZlIGEgY29uc3RhbnQgbm9kZSBiZXR3ZWVuLlxuICAgICAgICBsZXQgbGFzdFBhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzLCB2YWx1ZXM6IHsgbGVuZ3RoIH0gfSA9IHJlc3VsdDtcbiAgICAgICAgd2hpbGUgKHBhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBleGhhdXN0ZWQgdGhlIGNvbnRlbnQgaW5zaWRlIGEgbmVzdGVkIHRlbXBsYXRlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB3ZSBzdGlsbCBoYXZlIHBhcnRzICh0aGUgb3V0ZXIgZm9yLWxvb3ApLCB3ZSBrbm93OlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlcmUgaXMgYSB0ZW1wbGF0ZSBpbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICAvLyAtIFRoZSB3YWxrZXIgd2lsbCBmaW5kIGEgbmV4dE5vZGUgb3V0c2lkZSB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBOb2RlLkVMRU1FTlRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYW1lZE5vZGVNYXAsXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIHJldHVybmVkIGluIGRvY3VtZW50IG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXJ0aWN1bGFyLCBFZGdlL0lFIGNhbiByZXR1cm4gdGhlbSBvdXQgb2Ygb3JkZXIsIHNvIHdlIGNhbm5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBhc3N1bWUgYSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHBhcnQgaW5kZXggYW5kIGF0dHJpYnV0ZSBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoKGF0dHJpYnV0ZXNbaV0ubmFtZSwgYm91bmRBdHRyaWJ1dGVTdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGVtcGxhdGUgbGl0ZXJhbCBzZWN0aW9uIGxlYWRpbmcgdXAgdG8gdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIGluIHRoaXMgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdGb3JQYXJ0ID0gc3RyaW5nc1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBsYXN0QXR0cmlidXRlTmFtZVJlZ2V4LmV4ZWMoc3RyaW5nRm9yUGFydClbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGJvdW5kIGF0dHJpYnV0ZXMgaGF2ZSBoYWQgYSBzdWZmaXggYWRkZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlbXBsYXRlUmVzdWx0I2dldEhUTUwgdG8gb3B0IG91dCBvZiBzcGVjaWFsIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxpbmcuIFRvIGxvb2sgdXAgdGhlIGF0dHJpYnV0ZSB2YWx1ZSB3ZSBhbHNvIG5lZWQgdG8gYWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3VmZml4LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlTG9va3VwTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKSArIGJvdW5kQXR0cmlidXRlU3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVMb29rdXBOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZUxvb2t1cE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljcyA9IGF0dHJpYnV0ZVZhbHVlLnNwbGl0KG1hcmtlclJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaCh7IHR5cGU6ICdhdHRyaWJ1dGUnLCBpbmRleCwgbmFtZSwgc3RyaW5nczogc3RhdGljcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCArPSBzdGF0aWNzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBOb2RlLlRFWFRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaW5kZXhPZihtYXJrZXIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdzID0gZGF0YS5zcGxpdChtYXJrZXJSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgdGV4dCBub2RlIGZvciBlYWNoIGxpdGVyYWwgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBub2RlcyBhcmUgYWxzbyB1c2VkIGFzIHRoZSBtYXJrZXJzIGZvciBub2RlIHBhcnRzXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHN0cmluZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBjcmVhdGVNYXJrZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbGFzdEF0dHJpYnV0ZU5hbWVSZWdleC5leGVjKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBlbmRzV2l0aChtYXRjaFsyXSwgYm91bmRBdHRyaWJ1dGVTdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIG1hdGNoWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdLnNsaWNlKDAsIC1ib3VuZEF0dHJpYnV0ZVN1ZmZpeC5sZW5ndGgpICsgbWF0Y2hbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShpbnNlcnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKHsgdHlwZTogJ25vZGUnLCBpbmRleDogKytpbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHRleHQsIHdlIG11c3QgaW5zZXJ0IGEgY29tbWVudCB0byBtYXJrIG91ciBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSwgd2UgY2FuIHRydXN0IGl0IHdpbGwgc3RpY2sgYXJvdW5kIGFmdGVyIGNsb25pbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdzW2xhc3RJbmRleF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNyZWF0ZU1hcmtlcigpLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHN0cmluZ3NbbGFzdEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgcGFydCBmb3IgZWFjaCBtYXRjaCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXggKz0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogTm9kZS5DT01NRU5UX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSBtYXJrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBuZXcgbWFya2VyIG5vZGUgdG8gYmUgdGhlIHN0YXJ0Tm9kZSBvZiB0aGUgUGFydCBpZiBhbnkgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gICogV2UgZG9uJ3QgaGF2ZSBhIHByZXZpb3VzU2libGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyAgKiBUaGUgcHJldmlvdXNTaWJsaW5nIGlzIGFscmVhZHkgdGhlIHN0YXJ0IG9mIGEgcHJldmlvdXMgcGFydFxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2aW91c1NpYmxpbmcgPT09IG51bGwgfHwgaW5kZXggPT09IGxhc3RQYXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNyZWF0ZU1hcmtlcigpLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0UGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaCh7IHR5cGU6ICdub2RlJywgaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBuZXh0U2libGluZywga2VlcCB0aGlzIG5vZGUgc28gd2UgaGF2ZSBhbiBlbmQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIHdlIGNhbiByZW1vdmUgaXQgdG8gc2F2ZSBmdXR1cmUgY29zdHMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGkgPSBub2RlLmRhdGEuaW5kZXhPZihtYXJrZXIsIGkgKyAxKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21tZW50IG5vZGUgaGFzIGEgYmluZGluZyBtYXJrZXIgaW5zaWRlLCBtYWtlIGFuIGluYWN0aXZlIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBiaW5kaW5nIHdvbid0IHdvcmssIGJ1dCBzdWJzZXF1ZW50IGJpbmRpbmdzIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gKGp1c3RpbmZhZ25hbmkpOiBjb25zaWRlciB3aGV0aGVyIGl0J3MgZXZlbiB3b3J0aCBpdCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBiaW5kaW5ncyBpbiBjb21tZW50cyB3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goeyB0eXBlOiAnbm9kZScsIGluZGV4OiAtMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0ZXh0IGJpbmRpbmcgbm9kZXMgYWZ0ZXIgdGhlIHdhbGsgdG8gbm90IGRpc3R1cmIgdGhlIFRyZWVXYWxrZXJcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIG5vZGVzVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc3VmZml4KSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aDtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBzdHIuc2xpY2UoaW5kZXgpID09PSBzdWZmaXg7XG59O1xuZXhwb3J0IGNvbnN0IGlzVGVtcGxhdGVQYXJ0QWN0aXZlID0gKHBhcnQpID0+IHBhcnQuaW5kZXggIT09IC0xO1xuLy8gQWxsb3dzIGBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKWAgdG8gYmUgcmVuYW1lZCBmb3IgYVxuLy8gc21hbGwgbWFudWFsIHNpemUtc2F2aW5ncy5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXJrZXIgPSAoKSA9PiBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKTtcbi8qKlxuICogVGhpcyByZWdleCBleHRyYWN0cyB0aGUgYXR0cmlidXRlIG5hbWUgcHJlY2VkaW5nIGFuIGF0dHJpYnV0ZS1wb3NpdGlvblxuICogZXhwcmVzc2lvbi4gSXQgZG9lcyB0aGlzIGJ5IG1hdGNoaW5nIHRoZSBzeW50YXggYWxsb3dlZCBmb3IgYXR0cmlidXRlc1xuICogYWdhaW5zdCB0aGUgc3RyaW5nIGxpdGVyYWwgZGlyZWN0bHkgcHJlY2VkaW5nIHRoZSBleHByZXNzaW9uLCBhc3N1bWluZyB0aGF0XG4gKiB0aGUgZXhwcmVzc2lvbiBpcyBpbiBhbiBhdHRyaWJ1dGUtdmFsdWUgcG9zaXRpb24uXG4gKlxuICogU2VlIGF0dHJpYnV0ZXMgaW4gdGhlIEhUTUwgc3BlYzpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50cy1hdHRyaWJ1dGVzXG4gKlxuICogXCIgXFx4MDlcXHgwYVxceDBjXFx4MGRcIiBhcmUgSFRNTCBzcGFjZSBjaGFyYWN0ZXJzOlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjc3BhY2UtY2hhcmFjdGVyc1xuICpcbiAqIFwiXFwwLVxceDFGXFx4N0YtXFx4OUZcIiBhcmUgVW5pY29kZSBjb250cm9sIGNoYXJhY3RlcnMsIHdoaWNoIGluY2x1ZGVzIGV2ZXJ5XG4gKiBzcGFjZSBjaGFyYWN0ZXIgZXhjZXB0IFwiIFwiLlxuICpcbiAqIFNvIGFuIGF0dHJpYnV0ZSBpczpcbiAqICAqIFRoZSBuYW1lOiBhbnkgY2hhcmFjdGVyIGV4Y2VwdCBhIGNvbnRyb2wgY2hhcmFjdGVyLCBzcGFjZSBjaGFyYWN0ZXIsICgnKSxcbiAqICAgIChcIiksIFwiPlwiLCBcIj1cIiwgb3IgXCIvXCJcbiAqICAqIEZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBzcGFjZSBjaGFyYWN0ZXJzXG4gKiAgKiBGb2xsb3dlZCBieSBcIj1cIlxuICogICogRm9sbG93ZWQgYnkgemVybyBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnNcbiAqICAqIEZvbGxvd2VkIGJ5OlxuICogICAgKiBBbnkgY2hhcmFjdGVyIGV4Y2VwdCBzcGFjZSwgKCcpLCAoXCIpLCBcIjxcIiwgXCI+XCIsIFwiPVwiLCAoYCksIG9yXG4gKiAgICAqIChcIikgdGhlbiBhbnkgbm9uLShcIiksIG9yXG4gKiAgICAqICgnKSB0aGVuIGFueSBub24tKCcpXG4gKi9cbmV4cG9ydCBjb25zdCBsYXN0QXR0cmlidXRlTmFtZVJlZ2V4ID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuLyhbIFxceDA5XFx4MGFcXHgwY1xceDBkXSkoW15cXDAtXFx4MUZcXHg3Ri1cXHg5RiBcIic+PS9dKykoWyBcXHgwOVxceDBhXFx4MGNcXHgwZF0qPVsgXFx4MDlcXHgwYVxceDBjXFx4MGRdKig/OlteIFxceDA5XFx4MGFcXHgwY1xceDBkXCInYDw+PV0qfFwiW15cIl0qfCdbXiddKikpJC87XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5pbXBvcnQgeyBpc0NFUG9seWZpbGwgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBpc1RlbXBsYXRlUGFydEFjdGl2ZSB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiBhIGBUZW1wbGF0ZWAgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSBhbmQgdXBkYXRlZFxuICogd2l0aCBuZXcgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVJbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGUsIHByb2Nlc3Nvciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9fcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgdXBkYXRlKHZhbHVlcykge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9fcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnNldFZhbHVlKHZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMuX19wYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnQuY29tbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Nsb25lKCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgYSBudW1iZXIgb2Ygc3RlcHMgaW4gdGhlIGxpZmVjeWNsZSBvZiBhIHRlbXBsYXRlIGluc3RhbmNlJ3NcbiAgICAgICAgLy8gRE9NIGZyYWdtZW50OlxuICAgICAgICAvLyAgMS4gQ2xvbmUgLSBjcmVhdGUgdGhlIGluc3RhbmNlIGZyYWdtZW50XG4gICAgICAgIC8vICAyLiBBZG9wdCAtIGFkb3B0IGludG8gdGhlIG1haW4gZG9jdW1lbnRcbiAgICAgICAgLy8gIDMuIFByb2Nlc3MgLSBmaW5kIHBhcnQgbWFya2VycyBhbmQgY3JlYXRlIHBhcnRzXG4gICAgICAgIC8vICA0LiBVcGdyYWRlIC0gdXBncmFkZSBjdXN0b20gZWxlbWVudHNcbiAgICAgICAgLy8gIDUuIFVwZGF0ZSAtIHNldCBub2RlLCBhdHRyaWJ1dGUsIHByb3BlcnR5LCBldGMuLCB2YWx1ZXNcbiAgICAgICAgLy8gIDYuIENvbm5lY3QgLSBjb25uZWN0IHRvIHRoZSBkb2N1bWVudC4gT3B0aW9uYWwgYW5kIG91dHNpZGUgb2YgdGhpc1xuICAgICAgICAvLyAgICAgbWV0aG9kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBoYXZlIGEgZmV3IGNvbnN0cmFpbnRzIG9uIHRoZSBvcmRlcmluZyBvZiB0aGVzZSBzdGVwczpcbiAgICAgICAgLy8gICogV2UgbmVlZCB0byB1cGdyYWRlIGJlZm9yZSB1cGRhdGluZywgc28gdGhhdCBwcm9wZXJ0eSB2YWx1ZXMgd2lsbCBwYXNzXG4gICAgICAgIC8vICAgIHRocm91Z2ggYW55IHByb3BlcnR5IHNldHRlcnMuXG4gICAgICAgIC8vICAqIFdlIHdvdWxkIGxpa2UgdG8gcHJvY2VzcyBiZWZvcmUgdXBncmFkaW5nIHNvIHRoYXQgd2UncmUgc3VyZSB0aGF0IHRoZVxuICAgICAgICAvLyAgICBjbG9uZWQgZnJhZ21lbnQgaXMgaW5lcnQgYW5kIG5vdCBkaXN0dXJiZWQgYnkgc2VsZi1tb2RpZnlpbmcgRE9NLlxuICAgICAgICAvLyAgKiBXZSB3YW50IGN1c3RvbSBlbGVtZW50cyB0byB1cGdyYWRlIGV2ZW4gaW4gZGlzY29ubmVjdGVkIGZyYWdtZW50cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gdGhlc2UgY29uc3RyYWludHMsIHdpdGggZnVsbCBjdXN0b20gZWxlbWVudHMgc3VwcG9ydCB3ZSB3b3VsZFxuICAgICAgICAvLyBwcmVmZXIgdGhlIG9yZGVyOiBDbG9uZSwgUHJvY2VzcywgQWRvcHQsIFVwZ3JhZGUsIFVwZGF0ZSwgQ29ubmVjdFxuICAgICAgICAvL1xuICAgICAgICAvLyBCdXQgU2FmYXJpIGRvZXMgbm90IGltcGxlbWVudCBDdXN0b21FbGVtZW50UmVnaXN0cnkjdXBncmFkZSwgc28gd2VcbiAgICAgICAgLy8gY2FuIG5vdCBpbXBsZW1lbnQgdGhhdCBvcmRlciBhbmQgc3RpbGwgaGF2ZSB1cGdyYWRlLWJlZm9yZS11cGRhdGUgYW5kXG4gICAgICAgIC8vIHVwZ3JhZGUgZGlzY29ubmVjdGVkIGZyYWdtZW50cy4gU28gd2UgaW5zdGVhZCBzYWNyaWZpY2UgdGhlXG4gICAgICAgIC8vIHByb2Nlc3MtYmVmb3JlLXVwZ3JhZGUgY29uc3RyYWludCwgc2luY2UgaW4gQ3VzdG9tIEVsZW1lbnRzIHYxIGVsZW1lbnRzXG4gICAgICAgIC8vIG11c3Qgbm90IG1vZGlmeSB0aGVpciBsaWdodCBET00gaW4gdGhlIGNvbnN0cnVjdG9yLiBXZSBzdGlsbCBoYXZlIGlzc3Vlc1xuICAgICAgICAvLyB3aGVuIGNvLWV4aXN0aW5nIHdpdGggQ0V2MCBlbGVtZW50cyBsaWtlIFBvbHltZXIgMSwgYW5kIHdpdGggcG9seWZpbGxzXG4gICAgICAgIC8vIHRoYXQgZG9uJ3Qgc3RyaWN0bHkgYWRoZXJlIHRvIHRoZSBuby1tb2RpZmljYXRpb24gcnVsZSBiZWNhdXNlIHNoYWRvd1xuICAgICAgICAvLyBET00sIHdoaWNoIG1heSBiZSBjcmVhdGVkIGluIHRoZSBjb25zdHJ1Y3RvciwgaXMgZW11bGF0ZWQgYnkgYmVpbmcgcGxhY2VkXG4gICAgICAgIC8vIGluIHRoZSBsaWdodCBET00uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSByZXN1bHRpbmcgb3JkZXIgaXMgb24gbmF0aXZlIGlzOiBDbG9uZSwgQWRvcHQsIFVwZ3JhZGUsIFByb2Nlc3MsXG4gICAgICAgIC8vIFVwZGF0ZSwgQ29ubmVjdC4gZG9jdW1lbnQuaW1wb3J0Tm9kZSgpIHBlcmZvcm1zIENsb25lLCBBZG9wdCwgYW5kIFVwZ3JhZGVcbiAgICAgICAgLy8gaW4gb25lIHN0ZXAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBDdXN0b20gRWxlbWVudHMgdjEgcG9seWZpbGwgc3VwcG9ydHMgdXBncmFkZSgpLCBzbyB0aGUgb3JkZXIgd2hlblxuICAgICAgICAvLyBwb2x5ZmlsbGVkIGlzIHRoZSBtb3JlIGlkZWFsOiBDbG9uZSwgUHJvY2VzcywgQWRvcHQsIFVwZ3JhZGUsIFVwZGF0ZSxcbiAgICAgICAgLy8gQ29ubmVjdC5cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBpc0NFUG9seWZpbGwgP1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5lbGVtZW50LmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpIDpcbiAgICAgICAgICAgIGRvY3VtZW50LmltcG9ydE5vZGUodGhpcy50ZW1wbGF0ZS5lbGVtZW50LmNvbnRlbnQsIHRydWUpO1xuICAgICAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMudGVtcGxhdGUucGFydHM7XG4gICAgICAgIC8vIEVkZ2UgbmVlZHMgYWxsIDQgcGFyYW1ldGVycyBwcmVzZW50OyBJRTExIG5lZWRzIDNyZCBwYXJhbWV0ZXIgdG8gYmUgbnVsbFxuICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGZyYWdtZW50LCAxMzMgLyogTm9kZUZpbHRlci5TSE9XX3tFTEVNRU5UfENPTU1FTlR8VEVYVH0gKi8sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBub2RlSW5kZXggPSAwO1xuICAgICAgICBsZXQgcGFydDtcbiAgICAgICAgbGV0IG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgbm9kZXMgYW5kIHBhcnRzIG9mIGEgdGVtcGxhdGVcbiAgICAgICAgd2hpbGUgKHBhcnRJbmRleCA8IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFydCA9IHBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzVGVtcGxhdGVQYXJ0QWN0aXZlKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3BhcnRzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2dyZXNzIHRoZSB0cmVlIHdhbGtlciB1bnRpbCB3ZSBmaW5kIG91ciBuZXh0IHBhcnQncyBub2RlLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG11bHRpcGxlIHBhcnRzIG1heSBzaGFyZSB0aGUgc2FtZSBub2RlIChhdHRyaWJ1dGUgcGFydHNcbiAgICAgICAgICAgIC8vIG9uIGEgc2luZ2xlIGVsZW1lbnQpLCBzbyB0aGlzIGxvb3AgbWF5IG5vdCBydW4gYXQgYWxsLlxuICAgICAgICAgICAgd2hpbGUgKG5vZGVJbmRleCA8IHBhcnQuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBub2RlSW5kZXgrKztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgobm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSd2ZSBleGhhdXN0ZWQgdGhlIGNvbnRlbnQgaW5zaWRlIGEgbmVzdGVkIHRlbXBsYXRlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2Ugc3RpbGwgaGF2ZSBwYXJ0cyAodGhlIG91dGVyIGZvci1sb29wKSwgd2Uga25vdzpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGVyZSBpcyBhIHRlbXBsYXRlIGluIHRoZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAvLyAtIFRoZSB3YWxrZXIgd2lsbCBmaW5kIGEgbmV4dE5vZGUgb3V0c2lkZSB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSd2ZSBhcnJpdmVkIGF0IG91ciBwYXJ0J3Mgbm9kZS5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09ICdub2RlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSB0aGlzLnByb2Nlc3Nvci5oYW5kbGVUZXh0RXhwcmVzc2lvbih0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHBhcnQuaW5zZXJ0QWZ0ZXJOb2RlKG5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX19wYXJ0cy5wdXNoKC4uLnRoaXMucHJvY2Vzc29yLmhhbmRsZUF0dHJpYnV0ZUV4cHJlc3Npb25zKG5vZGUsIHBhcnQubmFtZSwgcGFydC5zdHJpbmdzLCB0aGlzLm9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NFUG9seWZpbGwpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkb3B0Tm9kZShmcmFnbWVudCk7XG4gICAgICAgICAgICBjdXN0b21FbGVtZW50cy51cGdyYWRlKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUtaW5zdGFuY2UuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBAbW9kdWxlIGxpdC1odG1sXG4gKi9cbmltcG9ydCB7IHJlcGFyZW50Tm9kZXMgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBib3VuZEF0dHJpYnV0ZVN1ZmZpeCwgbGFzdEF0dHJpYnV0ZU5hbWVSZWdleCwgbWFya2VyLCBub2RlTWFya2VyIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG4vKipcbiAqIE91ciBUcnVzdGVkVHlwZVBvbGljeSBmb3IgSFRNTCB3aGljaCBpcyBkZWNsYXJlZCB1c2luZyB0aGUgaHRtbCB0ZW1wbGF0ZVxuICogdGFnIGZ1bmN0aW9uLlxuICpcbiAqIFRoYXQgSFRNTCBpcyBhIGRldmVsb3Blci1hdXRob3JlZCBjb25zdGFudCwgYW5kIGlzIHBhcnNlZCB3aXRoIGlubmVySFRNTFxuICogYmVmb3JlIGFueSB1bnRydXN0ZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuIG1peGVkIGluLiBUaGVyZWZvciBpdCBpc1xuICogY29uc2lkZXJlZCBzYWZlIGJ5IGNvbnN0cnVjdGlvbi5cbiAqL1xuY29uc3QgcG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcyAmJlxuICAgIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koJ2xpdC1odG1sJywgeyBjcmVhdGVIVE1MOiAocykgPT4gcyB9KTtcbmNvbnN0IGNvbW1lbnRNYXJrZXIgPSBgICR7bWFya2VyfSBgO1xuLyoqXG4gKiBUaGUgcmV0dXJuIHR5cGUgb2YgYGh0bWxgLCB3aGljaCBob2xkcyBhIFRlbXBsYXRlIGFuZCB0aGUgdmFsdWVzIGZyb21cbiAqIGludGVycG9sYXRlZCBleHByZXNzaW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMsIHR5cGUsIHByb2Nlc3Nvcikge1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgb2YgSFRNTCB1c2VkIHRvIGNyZWF0ZSBhIGA8dGVtcGxhdGU+YCBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldEhUTUwoKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLnN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IGh0bWwgPSAnJztcbiAgICAgICAgbGV0IGlzQ29tbWVudEJpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnN0cmluZ3NbaV07XG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBiaW5kaW5nIHdlIHdhbnQgdG8gZGV0ZXJtaW5lIHRoZSBraW5kIG9mIG1hcmtlciB0byBpbnNlcnRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIHRlbXBsYXRlIHNvdXJjZSBiZWZvcmUgaXQncyBwYXJzZWQgYnkgdGhlIGJyb3dzZXIncyBIVE1MXG4gICAgICAgICAgICAvLyBwYXJzZXIuIFRoZSBtYXJrZXIgdHlwZSBpcyBiYXNlZCBvbiB3aGV0aGVyIHRoZSBleHByZXNzaW9uIGlzIGluIGFuXG4gICAgICAgICAgICAvLyBhdHRyaWJ1dGUsIHRleHQsIG9yIGNvbW1lbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAvLyAgICogRm9yIG5vZGUtcG9zaXRpb24gYmluZGluZ3Mgd2UgaW5zZXJ0IGEgY29tbWVudCB3aXRoIHRoZSBtYXJrZXJcbiAgICAgICAgICAgIC8vICAgICBzZW50aW5lbCBhcyBpdHMgdGV4dCBjb250ZW50LCBsaWtlIDwhLS17e2xpdC1ndWlkfX0tLT4uXG4gICAgICAgICAgICAvLyAgICogRm9yIGF0dHJpYnV0ZSBiaW5kaW5ncyB3ZSBpbnNlcnQganVzdCB0aGUgbWFya2VyIHNlbnRpbmVsIGZvciB0aGVcbiAgICAgICAgICAgIC8vICAgICBmaXJzdCBiaW5kaW5nLCBzbyB0aGF0IHdlIHN1cHBvcnQgdW5xdW90ZWQgYXR0cmlidXRlIGJpbmRpbmdzLlxuICAgICAgICAgICAgLy8gICAgIFN1YnNlcXVlbnQgYmluZGluZ3MgY2FuIHVzZSBhIGNvbW1lbnQgbWFya2VyIGJlY2F1c2UgbXVsdGktYmluZGluZ1xuICAgICAgICAgICAgLy8gICAgIGF0dHJpYnV0ZXMgbXVzdCBiZSBxdW90ZWQuXG4gICAgICAgICAgICAvLyAgICogRm9yIGNvbW1lbnQgYmluZGluZ3Mgd2UgaW5zZXJ0IGp1c3QgdGhlIG1hcmtlciBzZW50aW5lbCBzbyB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gICAgIGNsb3NlIHRoZSBjb21tZW50LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBzY2FucyB0aGUgdGVtcGxhdGUgc291cmNlLCBidXQgaXMgKm5vdCogYW4gSFRNTFxuICAgICAgICAgICAgLy8gcGFyc2VyLiBXZSBkb24ndCBuZWVkIHRvIHRyYWNrIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgSFRNTCwgb25seVxuICAgICAgICAgICAgLy8gd2hldGhlciBhIGJpbmRpbmcgaXMgaW5zaWRlIGEgY29tbWVudCwgYW5kIGlmIG5vdCwgaWYgaXQgYXBwZWFycyB0byBiZVxuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGJpbmRpbmcgaW4gYW4gYXR0cmlidXRlLlxuICAgICAgICAgICAgY29uc3QgY29tbWVudE9wZW4gPSBzLmxhc3RJbmRleE9mKCc8IS0tJyk7XG4gICAgICAgICAgICAvLyBXZSdyZSBpbiBjb21tZW50IHBvc2l0aW9uIGlmIHdlIGhhdmUgYSBjb21tZW50IG9wZW4gd2l0aCBubyBmb2xsb3dpbmdcbiAgICAgICAgICAgIC8vIGNvbW1lbnQgY2xvc2UuIEJlY2F1c2UgPC0tIGNhbiBhcHBlYXIgaW4gYW4gYXR0cmlidXRlIHZhbHVlIHRoZXJlIGNhblxuICAgICAgICAgICAgLy8gYmUgZmFsc2UgcG9zaXRpdmVzLlxuICAgICAgICAgICAgaXNDb21tZW50QmluZGluZyA9IChjb21tZW50T3BlbiA+IC0xIHx8IGlzQ29tbWVudEJpbmRpbmcpICYmXG4gICAgICAgICAgICAgICAgcy5pbmRleE9mKCctLT4nLCBjb21tZW50T3BlbiArIDEpID09PSAtMTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFuIGF0dHJpYnV0ZS1saWtlIHNlcXVlbmNlIHByZWNlZGluZyB0aGVcbiAgICAgICAgICAgIC8vIGV4cHJlc3Npb24uIFRoaXMgY2FuIG1hdGNoIFwibmFtZT12YWx1ZVwiIGxpa2Ugc3RydWN0dXJlcyBpbiB0ZXh0LFxuICAgICAgICAgICAgLy8gY29tbWVudHMsIGFuZCBhdHRyaWJ1dGUgdmFsdWVzLCBzbyB0aGVyZSBjYW4gYmUgZmFsc2UtcG9zaXRpdmVzLlxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlTWF0Y2ggPSBsYXN0QXR0cmlidXRlTmFtZVJlZ2V4LmV4ZWMocyk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlTWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBvbmx5IGluIHRoaXMgYnJhbmNoIGlmIHdlIGRvbid0IGhhdmUgYSBhdHRyaWJ1dGUtbGlrZVxuICAgICAgICAgICAgICAgIC8vIHByZWNlZGluZyBzZXF1ZW5jZS4gRm9yIGNvbW1lbnRzLCB0aGlzIGd1YXJkcyBhZ2FpbnN0IHVudXN1YWxcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgdmFsdWVzIGxpa2UgPGRpdiBmb289XCI8IS0tJHsnYmFyJ31cIj4uIENhc2VzIGxpa2VcbiAgICAgICAgICAgICAgICAvLyA8IS0tIGZvbz0keydiYXInfS0tPiBhcmUgaGFuZGxlZCBjb3JyZWN0bHkgaW4gdGhlIGF0dHJpYnV0ZSBicmFuY2hcbiAgICAgICAgICAgICAgICAvLyBiZWxvdy5cbiAgICAgICAgICAgICAgICBodG1sICs9IHMgKyAoaXNDb21tZW50QmluZGluZyA/IGNvbW1lbnRNYXJrZXIgOiBub2RlTWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBhdHRyaWJ1dGVzIHdlIHVzZSBqdXN0IGEgbWFya2VyIHNlbnRpbmVsLCBhbmQgYWxzbyBhcHBlbmQgYVxuICAgICAgICAgICAgICAgIC8vICRsaXQkIHN1ZmZpeCB0byB0aGUgbmFtZSB0byBvcHQtb3V0IG9mIGF0dHJpYnV0ZS1zcGVjaWZpYyBwYXJzaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBJRSBhbmQgRWRnZSBkbyBmb3Igc3R5bGUgYW5kIGNlcnRhaW4gU1ZHIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgICAgaHRtbCArPSBzLnN1YnN0cigwLCBhdHRyaWJ1dGVNYXRjaC5pbmRleCkgKyBhdHRyaWJ1dGVNYXRjaFsxXSArXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU1hdGNoWzJdICsgYm91bmRBdHRyaWJ1dGVTdWZmaXggKyBhdHRyaWJ1dGVNYXRjaFszXSArXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sICs9IHRoaXMuc3RyaW5nc1tsXTtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIGdldFRlbXBsYXRlRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldEhUTUwoKTtcbiAgICAgICAgaWYgKHBvbGljeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHNlY3VyZSBiZWNhdXNlIGB0aGlzLnN0cmluZ3NgIGlzIGEgVGVtcGxhdGVTdHJpbmdzQXJyYXkuXG4gICAgICAgICAgICAvLyBUT0RPOiB2YWxpZGF0ZSB0aGlzIHdoZW5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWlzLXRlbXBsYXRlLW9iamVjdCBpc1xuICAgICAgICAgICAgLy8gaW1wbGVtZW50ZWQuXG4gICAgICAgICAgICB2YWx1ZSA9IHBvbGljeS5jcmVhdGVIVE1MKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbn1cbi8qKlxuICogQSBUZW1wbGF0ZVJlc3VsdCBmb3IgU1ZHIGZyYWdtZW50cy5cbiAqXG4gKiBUaGlzIGNsYXNzIHdyYXBzIEhUTUwgaW4gYW4gYDxzdmc+YCB0YWcgaW4gb3JkZXIgdG8gcGFyc2UgaXRzIGNvbnRlbnRzIGluIHRoZVxuICogU1ZHIG5hbWVzcGFjZSwgdGhlbiBtb2RpZmllcyB0aGUgdGVtcGxhdGUgdG8gcmVtb3ZlIHRoZSBgPHN2Zz5gIHRhZyBzbyB0aGF0XG4gKiBjbG9uZXMgb25seSBjb250YWluZXIgdGhlIG9yaWdpbmFsIGZyYWdtZW50LlxuICovXG5leHBvcnQgY2xhc3MgU1ZHVGVtcGxhdGVSZXN1bHQgZXh0ZW5kcyBUZW1wbGF0ZVJlc3VsdCB7XG4gICAgZ2V0SFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIGA8c3ZnPiR7c3VwZXIuZ2V0SFRNTCgpfTwvc3ZnPmA7XG4gICAgfVxuICAgIGdldFRlbXBsYXRlRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBzdXBlci5nZXRUZW1wbGF0ZUVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNvbnRlbnQucmVtb3ZlQ2hpbGQoc3ZnRWxlbWVudCk7XG4gICAgICAgIHJlcGFyZW50Tm9kZXMoY29udGVudCwgc3ZnRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLXJlc3VsdC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5pbXBvcnQgeyBpc0RpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7IHJlbW92ZU5vZGVzIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgbm9DaGFuZ2UsIG5vdGhpbmcgfSBmcm9tICcuL3BhcnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZSB9IGZyb20gJy4vdGVtcGxhdGUtaW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICcuL3RlbXBsYXRlLXJlc3VsdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVNYXJrZXIgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbmV4cG9ydCBjb25zdCBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAodmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgISh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykpO1xufTtcbmV4cG9ydCBjb25zdCBpc0l0ZXJhYmxlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICEhKHZhbHVlICYmIHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0pO1xufTtcbi8qKlxuICogV3JpdGVzIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gdGhlIERPTSBmb3IgYSBncm91cCBvZiBBdHRyaWJ1dGVQYXJ0cyBib3VuZCB0byBhXG4gKiBzaW5nbGUgYXR0cmlidXRlLiBUaGUgdmFsdWUgaXMgb25seSBzZXQgb25jZSBldmVuIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXJ0c1xuICogZm9yIGFuIGF0dHJpYnV0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZUNvbW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmFtZSwgc3RyaW5ncykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRzW2ldID0gdGhpcy5fY3JlYXRlUGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaW5nbGUgcGFydC4gT3ZlcnJpZGUgdGhpcyB0byBjcmVhdGUgYSBkaWZmZXJudCB0eXBlIG9mIHBhcnQuXG4gICAgICovXG4gICAgX2NyZWF0ZVBhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlUGFydCh0aGlzKTtcbiAgICB9XG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgICBjb25zdCBzdHJpbmdzID0gdGhpcy5zdHJpbmdzO1xuICAgICAgICBjb25zdCBsID0gc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMucGFydHM7XG4gICAgICAgIC8vIElmIHdlJ3JlIGFzc2lnbmluZyBhbiBhdHRyaWJ1dGUgdmlhIHN5bnRheCBsaWtlOlxuICAgICAgICAvLyAgICBhdHRyPVwiJHtmb299XCIgIG9yICBhdHRyPSR7Zm9vfVxuICAgICAgICAvLyBidXQgbm90XG4gICAgICAgIC8vICAgIGF0dHI9XCIke2Zvb30gJHtiYXJ9XCIgb3IgYXR0cj1cIiR7Zm9vfSBiYXpcIlxuICAgICAgICAvLyB0aGVuIHdlIGRvbid0IHdhbnQgdG8gY29lcmNlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgaW50byBvbmUgbG9uZ1xuICAgICAgICAvLyBzdHJpbmcuIEluc3RlYWQgd2Ugd2FudCB0byBqdXN0IHJldHVybiB0aGUgdmFsdWUgaXRzZWxmIGRpcmVjdGx5LFxuICAgICAgICAvLyBzbyB0aGF0IHNhbml0aXplRE9NVmFsdWUgY2FuIGdldCB0aGUgYWN0dWFsIHZhbHVlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vIFN0cmluZyh2YWx1ZSlcbiAgICAgICAgLy8gVGhlIGV4Y2VwdGlvbiBpcyBpZiB2IGlzIGFuIGFycmF5LCBpbiB3aGljaCBjYXNlIHdlIGRvIHdhbnQgdG8gc21hc2hcbiAgICAgICAgLy8gaXQgdG9nZXRoZXIgaW50byBhIHN0cmluZyB3aXRob3V0IGNhbGxpbmcgU3RyaW5nKCkgb24gdGhlIGFycmF5LlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGFsc28gYWxsb3dzIHRydXN0ZWQgdmFsdWVzICh3aGVuIHVzaW5nIFRydXN0ZWRUeXBlcykgYmVpbmdcbiAgICAgICAgLy8gYXNzaWduZWQgdG8gRE9NIHNpbmtzIHdpdGhvdXQgYmVpbmcgc3RyaW5naWZpZWQgaW4gdGhlIHByb2Nlc3MuXG4gICAgICAgIGlmIChsID09PSAxICYmIHN0cmluZ3NbMF0gPT09ICcnICYmIHN0cmluZ3NbMV0gPT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gcGFydHNbMF0udmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgIWlzSXRlcmFibGUodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGV4dCArPSBzdHJpbmdzW2ldO1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBwYXJ0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2KSB8fCAhaXNJdGVyYWJsZSh2KSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHYgOiBTdHJpbmcodik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2Ygdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB0eXBlb2YgdCA9PT0gJ3N0cmluZycgPyB0IDogU3RyaW5nKHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRleHQgKz0gc3RyaW5nc1tsXTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLCB0aGlzLl9nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBQYXJ0IHRoYXQgY29udHJvbHMgYWxsIG9yIHBhcnQgb2YgYW4gYXR0cmlidXRlIHZhbHVlLlxuICovXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlUGFydCB7XG4gICAgY29uc3RydWN0b3IoY29tbWl0dGVyKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29tbWl0dGVyID0gY29tbWl0dGVyO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IG5vQ2hhbmdlICYmICghaXNQcmltaXRpdmUodmFsdWUpIHx8IHZhbHVlICE9PSB0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgbm90IGEgZGlyZWN0aXZlLCBkaXJ0eSB0aGUgY29tbWl0dGVyIHNvIHRoYXQgaXQnbGxcbiAgICAgICAgICAgIC8vIGNhbGwgc2V0QXR0cmlidXRlLiBJZiB0aGUgdmFsdWUgaXMgYSBkaXJlY3RpdmUsIGl0J2xsIGRpcnR5IHRoZVxuICAgICAgICAgICAgLy8gY29tbWl0dGVyIGlmIGl0IGNhbGxzIHNldFZhbHVlKCkuXG4gICAgICAgICAgICBpZiAoIWlzRGlyZWN0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0dGVyLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIHdoaWxlIChpc0RpcmVjdGl2ZSh0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBub0NoYW5nZTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbW1pdHRlci5jb21taXQoKTtcbiAgICB9XG59XG4vKipcbiAqIEEgUGFydCB0aGF0IGNvbnRyb2xzIGEgbG9jYXRpb24gd2l0aGluIGEgTm9kZSB0cmVlLiBMaWtlIGEgUmFuZ2UsIE5vZGVQYXJ0XG4gKiBoYXMgc3RhcnQgYW5kIGVuZCBsb2NhdGlvbnMgYW5kIGNhbiBzZXQgYW5kIHVwZGF0ZSB0aGUgTm9kZXMgYmV0d2VlbiB0aG9zZVxuICogbG9jYXRpb25zLlxuICpcbiAqIE5vZGVQYXJ0cyBzdXBwb3J0IHNldmVyYWwgdmFsdWUgdHlwZXM6IHByaW1pdGl2ZXMsIE5vZGVzLCBUZW1wbGF0ZVJlc3VsdHMsXG4gKiBhcyB3ZWxsIGFzIGFycmF5cyBhbmQgaXRlcmFibGVzIG9mIHRob3NlIHR5cGVzLlxuICovXG5leHBvcnQgY2xhc3MgTm9kZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGlzIHBhcnQgaW50byBhIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIFRoaXMgcGFydCBtdXN0IGJlIGVtcHR5LCBhcyBpdHMgY29udGVudHMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IG1vdmVkLlxuICAgICAqL1xuICAgIGFwcGVuZEludG8oY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhcnROb2RlID0gY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZU1hcmtlcigpKTtcbiAgICAgICAgdGhpcy5lbmROb2RlID0gY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZU1hcmtlcigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGlzIHBhcnQgYWZ0ZXIgdGhlIGByZWZgIG5vZGUgKGJldHdlZW4gYHJlZmAgYW5kIGByZWZgJ3MgbmV4dFxuICAgICAqIHNpYmxpbmcpLiBCb3RoIGByZWZgIGFuZCBpdHMgbmV4dCBzaWJsaW5nIG11c3QgYmUgc3RhdGljLCB1bmNoYW5naW5nIG5vZGVzXG4gICAgICogc3VjaCBhcyB0aG9zZSB0aGF0IGFwcGVhciBpbiBhIGxpdGVyYWwgc2VjdGlvbiBvZiBhIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXJ0IG11c3QgYmUgZW1wdHksIGFzIGl0cyBjb250ZW50cyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgbW92ZWQuXG4gICAgICovXG4gICAgaW5zZXJ0QWZ0ZXJOb2RlKHJlZikge1xuICAgICAgICB0aGlzLnN0YXJ0Tm9kZSA9IHJlZjtcbiAgICAgICAgdGhpcy5lbmROb2RlID0gcmVmLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoaXMgcGFydCBpbnRvIGEgcGFyZW50IHBhcnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhcnQgbXVzdCBiZSBlbXB0eSwgYXMgaXRzIGNvbnRlbnRzIGFyZSBub3QgYXV0b21hdGljYWxseSBtb3ZlZC5cbiAgICAgKi9cbiAgICBhcHBlbmRJbnRvUGFydChwYXJ0KSB7XG4gICAgICAgIHBhcnQuX19pbnNlcnQodGhpcy5zdGFydE5vZGUgPSBjcmVhdGVNYXJrZXIoKSk7XG4gICAgICAgIHBhcnQuX19pbnNlcnQodGhpcy5lbmROb2RlID0gY3JlYXRlTWFya2VyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoaXMgcGFydCBhZnRlciB0aGUgYHJlZmAgcGFydC5cbiAgICAgKlxuICAgICAqIFRoaXMgcGFydCBtdXN0IGJlIGVtcHR5LCBhcyBpdHMgY29udGVudHMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IG1vdmVkLlxuICAgICAqL1xuICAgIGluc2VydEFmdGVyUGFydChyZWYpIHtcbiAgICAgICAgcmVmLl9faW5zZXJ0KHRoaXMuc3RhcnROb2RlID0gY3JlYXRlTWFya2VyKCkpO1xuICAgICAgICB0aGlzLmVuZE5vZGUgPSByZWYuZW5kTm9kZTtcbiAgICAgICAgcmVmLmVuZE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZTtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0Tm9kZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGlzRGlyZWN0aXZlKHRoaXMuX19wZW5kaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgICAgICAgICAgZGlyZWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBub0NoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jb21taXRUZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9fY29tbWl0VGVtcGxhdGVSZXN1bHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdE5vZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9fY29tbWl0SXRlcmFibGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBub3RoaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbm90aGluZztcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrLCB3aWxsIHJlbmRlciB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9fY29tbWl0VGV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19pbnNlcnQobm9kZSkge1xuICAgICAgICB0aGlzLmVuZE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgdGhpcy5lbmROb2RlKTtcbiAgICB9XG4gICAgX19jb21taXROb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fX2luc2VydCh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgX19jb21taXRUZXh0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgLy8gSWYgYHZhbHVlYCBpc24ndCBhbHJlYWR5IGEgc3RyaW5nLCB3ZSBleHBsaWNpdGx5IGNvbnZlcnQgaXQgaGVyZSBpbiBjYXNlXG4gICAgICAgIC8vIGl0IGNhbid0IGJlIGltcGxpY2l0bHkgY29udmVydGVkIC0gaS5lLiBpdCdzIGEgc3ltYm9sLlxuICAgICAgICBjb25zdCB2YWx1ZUFzU3RyaW5nID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuZW5kTm9kZS5wcmV2aW91c1NpYmxpbmcgJiZcbiAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgLyogTm9kZS5URVhUX05PREUgKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIG9ubHkgaGF2ZSBhIHNpbmdsZSB0ZXh0IG5vZGUgYmV0d2VlbiB0aGUgbWFya2Vycywgd2UgY2FuIGp1c3RcbiAgICAgICAgICAgIC8vIHNldCBpdHMgdmFsdWUsIHJhdGhlciB0aGFuIHJlcGxhY2luZyBpdC5cbiAgICAgICAgICAgIC8vIFRPRE8oanVzdGluZmFnbmFuaSk6IENhbiB3ZSBqdXN0IGNoZWNrIGlmIHRoaXMudmFsdWUgaXMgcHJpbWl0aXZlP1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFsdWVBc1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlQXNTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIF9fY29tbWl0VGVtcGxhdGVSZXN1bHQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVGYWN0b3J5KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZUluc3RhbmNlICYmXG4gICAgICAgICAgICB0aGlzLnZhbHVlLnRlbXBsYXRlID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS51cGRhdGUodmFsdWUudmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcm9wYWdhdGUgdGhlIHRlbXBsYXRlIHByb2Nlc3NvciBmcm9tIHRoZSBUZW1wbGF0ZVJlc3VsdFxuICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSB1c2UgaXRzIHN5bnRheCBleHRlbnNpb24sIGV0Yy4gVGhlIHRlbXBsYXRlIGZhY3RvcnkgY29tZXNcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIHJlbmRlciBmdW5jdGlvbiBvcHRpb25zIHNvIHRoYXQgaXQgY2FuIGNvbnRyb2wgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIGNhY2hpbmcgYW5kIHByZXByb2Nlc3NpbmcuXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBUZW1wbGF0ZUluc3RhbmNlKHRlbXBsYXRlLCB2YWx1ZS5wcm9jZXNzb3IsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGluc3RhbmNlLl9jbG9uZSgpO1xuICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKHZhbHVlLnZhbHVlcyk7XG4gICAgICAgICAgICB0aGlzLl9fY29tbWl0Tm9kZShmcmFnbWVudCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19jb21taXRJdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgICAvLyBGb3IgYW4gSXRlcmFibGUsIHdlIGNyZWF0ZSBhIG5ldyBJbnN0YW5jZVBhcnQgcGVyIGl0ZW0sIHRoZW4gc2V0IGl0c1xuICAgICAgICAvLyB2YWx1ZSB0byB0aGUgaXRlbS4gVGhpcyBpcyBhIGxpdHRsZSBiaXQgb2Ygb3ZlcmhlYWQgZm9yIGV2ZXJ5IGl0ZW0gaW5cbiAgICAgICAgLy8gYW4gSXRlcmFibGUsIGJ1dCBpdCBsZXRzIHVzIHJlY3Vyc2UgZWFzaWx5IGFuZCBlZmZpY2llbnRseSB1cGRhdGUgQXJyYXlzXG4gICAgICAgIC8vIG9mIFRlbXBsYXRlUmVzdWx0cyB0aGF0IHdpbGwgYmUgY29tbW9ubHkgcmV0dXJuZWQgZnJvbSBleHByZXNzaW9ucyBsaWtlOlxuICAgICAgICAvLyBhcnJheS5tYXAoKGkpID0+IGh0bWxgJHtpfWApLCBieSByZXVzaW5nIGV4aXN0aW5nIFRlbXBsYXRlSW5zdGFuY2VzLlxuICAgICAgICAvLyBJZiBfdmFsdWUgaXMgYW4gYXJyYXksIHRoZW4gdGhlIHByZXZpb3VzIHJlbmRlciB3YXMgb2YgYW5cbiAgICAgICAgLy8gaXRlcmFibGUgYW5kIF92YWx1ZSB3aWxsIGNvbnRhaW4gdGhlIE5vZGVQYXJ0cyBmcm9tIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyByZW5kZXIuIElmIF92YWx1ZSBpcyBub3QgYW4gYXJyYXksIGNsZWFyIHRoaXMgcGFydCBhbmQgbWFrZSBhIG5ld1xuICAgICAgICAvLyBhcnJheSBmb3IgTm9kZVBhcnRzLlxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMZXRzIHVzIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgaXRlbXMgd2Ugc3RhbXBlZCBzbyB3ZSBjYW4gY2xlYXIgbGVmdG92ZXJcbiAgICAgICAgLy8gaXRlbXMgZnJvbSBhIHByZXZpb3VzIHJlbmRlclxuICAgICAgICBjb25zdCBpdGVtUGFydHMgPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICAgICAgbGV0IGl0ZW1QYXJ0O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byByZXVzZSBhbiBleGlzdGluZyBwYXJ0XG4gICAgICAgICAgICBpdGVtUGFydCA9IGl0ZW1QYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgLy8gSWYgbm8gZXhpc3RpbmcgcGFydCwgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgICAgaWYgKGl0ZW1QYXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtUGFydCA9IG5ldyBOb2RlUGFydCh0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGl0ZW1QYXJ0cy5wdXNoKGl0ZW1QYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAocGFydEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1QYXJ0LmFwcGVuZEludG9QYXJ0KHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVBhcnQuaW5zZXJ0QWZ0ZXJQYXJ0KGl0ZW1QYXJ0c1twYXJ0SW5kZXggLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbVBhcnQuc2V0VmFsdWUoaXRlbSk7XG4gICAgICAgICAgICBpdGVtUGFydC5jb21taXQoKTtcbiAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0SW5kZXggPCBpdGVtUGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUcnVuY2F0ZSB0aGUgcGFydHMgYXJyYXkgc28gX3ZhbHVlIHJlZmxlY3RzIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICBpdGVtUGFydHMubGVuZ3RoID0gcGFydEluZGV4O1xuICAgICAgICAgICAgdGhpcy5jbGVhcihpdGVtUGFydCAmJiBpdGVtUGFydC5lbmROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcihzdGFydE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSkge1xuICAgICAgICByZW1vdmVOb2Rlcyh0aGlzLnN0YXJ0Tm9kZS5wYXJlbnROb2RlLCBzdGFydE5vZGUubmV4dFNpYmxpbmcsIHRoaXMuZW5kTm9kZSk7XG4gICAgfVxufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgYm9vbGVhbiBhdHRyaWJ1dGUsIHJvdWdobHkgYXMgZGVmaW5lZCBpbiB0aGUgSFRNTFxuICogc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgdHJ1dGh5LCB0aGVuIHRoZSBhdHRyaWJ1dGUgaXMgcHJlc2VudCB3aXRoIGEgdmFsdWUgb2ZcbiAqICcnLiBJZiB0aGUgdmFsdWUgaXMgZmFsc2V5LCB0aGUgYXR0cmlidXRlIGlzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBCb29sZWFuQXR0cmlidXRlUGFydCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmFtZSwgc3RyaW5ncykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3RyaW5ncy5sZW5ndGggIT09IDIgfHwgc3RyaW5nc1swXSAhPT0gJycgfHwgc3RyaW5nc1sxXSAhPT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm9vbGVhbiBhdHRyaWJ1dGVzIGNhbiBvbmx5IGNvbnRhaW4gYSBzaW5nbGUgZXhwcmVzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICB3aGlsZSAoaXNEaXJlY3RpdmUodGhpcy5fX3BlbmRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gbm9DaGFuZ2U7XG4gICAgICAgICAgICBkaXJlY3RpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX19wZW5kaW5nVmFsdWUgPT09IG5vQ2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSAhIXRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm5hbWUsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gbm9DaGFuZ2U7XG4gICAgfVxufVxuLyoqXG4gKiBTZXRzIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIFByb3BlcnR5UGFydHMsIHNvIHRoYXQgdGhlIHZhbHVlIGlzIG9ubHkgc2V0IG9uY2VcbiAqIGV2ZW4gaWYgdGhlcmUgYXJlIG11bHRpcGxlIHBhcnRzIGZvciBhIHByb3BlcnR5LlxuICpcbiAqIElmIGFuIGV4cHJlc3Npb24gY29udHJvbHMgdGhlIHdob2xlIHByb3BlcnR5IHZhbHVlLCB0aGVuIHRoZSB2YWx1ZSBpcyBzaW1wbHlcbiAqIGFzc2lnbmVkIHRvIHRoZSBwcm9wZXJ0eSB1bmRlciBjb250cm9sLiBJZiB0aGVyZSBhcmUgc3RyaW5nIGxpdGVyYWxzIG9yXG4gKiBtdWx0aXBsZSBleHByZXNzaW9ucywgdGhlbiB0aGUgc3RyaW5ncyBhcmUgZXhwcmVzc2lvbnMgYXJlIGludGVycG9sYXRlZCBpbnRvXG4gKiBhIHN0cmluZyBmaXJzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFByb3BlcnR5Q29tbWl0dGVyIGV4dGVuZHMgQXR0cmlidXRlQ29tbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpO1xuICAgICAgICB0aGlzLnNpbmdsZSA9XG4gICAgICAgICAgICAoc3RyaW5ncy5sZW5ndGggPT09IDIgJiYgc3RyaW5nc1swXSA9PT0gJycgJiYgc3RyaW5nc1sxXSA9PT0gJycpO1xuICAgIH1cbiAgICBfY3JlYXRlUGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVBhcnQodGhpcyk7XG4gICAgfVxuICAgIF9nZXRWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJ0c1swXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFZhbHVlKCk7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRbdGhpcy5uYW1lXSA9IHRoaXMuX2dldFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUHJvcGVydHlQYXJ0IGV4dGVuZHMgQXR0cmlidXRlUGFydCB7XG59XG4vLyBEZXRlY3QgZXZlbnQgbGlzdGVuZXIgb3B0aW9ucyBzdXBwb3J0LiBJZiB0aGUgYGNhcHR1cmVgIHByb3BlcnR5IGlzIHJlYWRcbi8vIGZyb20gdGhlIG9wdGlvbnMgb2JqZWN0LCB0aGVuIG9wdGlvbnMgYXJlIHN1cHBvcnRlZC4gSWYgbm90LCB0aGVuIHRoZSB0aGlyZFxuLy8gYXJndW1lbnQgdG8gYWRkL3JlbW92ZUV2ZW50TGlzdGVuZXIgaXMgaW50ZXJwcmV0ZWQgYXMgdGhlIGJvb2xlYW4gY2FwdHVyZVxuLy8gdmFsdWUgc28gd2Ugc2hvdWxkIG9ubHkgcGFzcyB0aGUgYGNhcHR1cmVgIHByb3BlcnR5LlxubGV0IGV2ZW50T3B0aW9uc1N1cHBvcnRlZCA9IGZhbHNlO1xuLy8gV3JhcCBpbnRvIGFuIElJRkUgYmVjYXVzZSBNUyBFZGdlIDw9IHY0MSBkb2VzIG5vdCBzdXBwb3J0IGhhdmluZyB0cnkvY2F0Y2hcbi8vIGJsb2NrcyByaWdodCBpbnRvIHRoZSBib2R5IG9mIGEgbW9kdWxlXG4oKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBnZXQgY2FwdHVyZSgpIHtcbiAgICAgICAgICAgICAgICBldmVudE9wdGlvbnNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9lKSB7XG4gICAgICAgIC8vIGV2ZW50IG9wdGlvbnMgbm90IHN1cHBvcnRlZFxuICAgIH1cbn0pKCk7XG5leHBvcnQgY2xhc3MgRXZlbnRQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBldmVudE5hbWUsIGV2ZW50Q29udGV4dCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgdGhpcy5ldmVudENvbnRleHQgPSBldmVudENvbnRleHQ7XG4gICAgICAgIHRoaXMuX19ib3VuZEhhbmRsZUV2ZW50ID0gKGUpID0+IHRoaXMuaGFuZGxlRXZlbnQoZSk7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICB3aGlsZSAoaXNEaXJlY3RpdmUodGhpcy5fX3BlbmRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gbm9DaGFuZ2U7XG4gICAgICAgICAgICBkaXJlY3RpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX19wZW5kaW5nVmFsdWUgPT09IG5vQ2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3TGlzdGVuZXIgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICBjb25zdCBvbGRMaXN0ZW5lciA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlbW92ZUxpc3RlbmVyID0gbmV3TGlzdGVuZXIgPT0gbnVsbCB8fFxuICAgICAgICAgICAgb2xkTGlzdGVuZXIgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIChuZXdMaXN0ZW5lci5jYXB0dXJlICE9PSBvbGRMaXN0ZW5lci5jYXB0dXJlIHx8XG4gICAgICAgICAgICAgICAgICAgIG5ld0xpc3RlbmVyLm9uY2UgIT09IG9sZExpc3RlbmVyLm9uY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV3TGlzdGVuZXIucGFzc2l2ZSAhPT0gb2xkTGlzdGVuZXIucGFzc2l2ZSk7XG4gICAgICAgIGNvbnN0IHNob3VsZEFkZExpc3RlbmVyID0gbmV3TGlzdGVuZXIgIT0gbnVsbCAmJiAob2xkTGlzdGVuZXIgPT0gbnVsbCB8fCBzaG91bGRSZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsIHRoaXMuX19ib3VuZEhhbmRsZUV2ZW50LCB0aGlzLl9fb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZEFkZExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9fb3B0aW9ucyA9IGdldE9wdGlvbnMobmV3TGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsIHRoaXMuX19ib3VuZEhhbmRsZUV2ZW50LCB0aGlzLl9fb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ld0xpc3RlbmVyO1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gbm9DaGFuZ2U7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5jYWxsKHRoaXMuZXZlbnRDb250ZXh0IHx8IHRoaXMuZWxlbWVudCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBXZSBjb3B5IG9wdGlvbnMgYmVjYXVzZSBvZiB0aGUgaW5jb25zaXN0ZW50IGJlaGF2aW9yIG9mIGJyb3dzZXJzIHdoZW4gcmVhZGluZ1xuLy8gdGhlIHRoaXJkIGFyZ3VtZW50IG9mIGFkZC9yZW1vdmVFdmVudExpc3RlbmVyLiBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBvcHRpb25zXG4vLyBhdCBhbGwuIENocm9tZSA0MSBvbmx5IHJlYWRzIGBjYXB0dXJlYCBpZiB0aGUgYXJndW1lbnQgaXMgYW4gb2JqZWN0LlxuY29uc3QgZ2V0T3B0aW9ucyA9IChvKSA9PiBvICYmXG4gICAgKGV2ZW50T3B0aW9uc1N1cHBvcnRlZCA/XG4gICAgICAgIHsgY2FwdHVyZTogby5jYXB0dXJlLCBwYXNzaXZlOiBvLnBhc3NpdmUsIG9uY2U6IG8ub25jZSB9IDpcbiAgICAgICAgby5jYXB0dXJlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRzLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IEF0dHJpYnV0ZUNvbW1pdHRlciwgQm9vbGVhbkF0dHJpYnV0ZVBhcnQsIEV2ZW50UGFydCwgTm9kZVBhcnQsIFByb3BlcnR5Q29tbWl0dGVyIH0gZnJvbSAnLi9wYXJ0cy5qcyc7XG4vKipcbiAqIENyZWF0ZXMgUGFydHMgd2hlbiBhIHRlbXBsYXRlIGlzIGluc3RhbnRpYXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhcnRzIGZvciBhbiBhdHRyaWJ1dGUtcG9zaXRpb24gYmluZGluZywgZ2l2ZW4gdGhlIGV2ZW50LCBhdHRyaWJ1dGVcbiAgICAgKiBuYW1lLCBhbmQgc3RyaW5nIGxpdGVyYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgYmluZGluZ1xuICAgICAqIEBwYXJhbSBuYW1lICBUaGUgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0gc3RyaW5ncyBUaGUgc3RyaW5nIGxpdGVyYWxzLiBUaGVyZSBhcmUgYWx3YXlzIGF0IGxlYXN0IHR3byBzdHJpbmdzLFxuICAgICAqICAgZXZlbnQgZm9yIGZ1bGx5LWNvbnRyb2xsZWQgYmluZGluZ3Mgd2l0aCBhIHNpbmdsZSBleHByZXNzaW9uLlxuICAgICAqL1xuICAgIGhhbmRsZUF0dHJpYnV0ZUV4cHJlc3Npb25zKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmFtZVswXTtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCBjb21taXR0ZXIgPSBuZXcgUHJvcGVydHlDb21taXR0ZXIoZWxlbWVudCwgbmFtZS5zbGljZSgxKSwgc3RyaW5ncyk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWl0dGVyLnBhcnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmaXggPT09ICdAJykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgRXZlbnRQYXJ0KGVsZW1lbnQsIG5hbWUuc2xpY2UoMSksIG9wdGlvbnMuZXZlbnRDb250ZXh0KV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJz8nKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBCb29sZWFuQXR0cmlidXRlUGFydChlbGVtZW50LCBuYW1lLnNsaWNlKDEpLCBzdHJpbmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tbWl0dGVyID0gbmV3IEF0dHJpYnV0ZUNvbW1pdHRlcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgcmV0dXJuIGNvbW1pdHRlci5wYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhcnRzIGZvciBhIHRleHQtcG9zaXRpb24gYmluZGluZy5cbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVGYWN0b3J5XG4gICAgICovXG4gICAgaGFuZGxlVGV4dEV4cHJlc3Npb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVQYXJ0KG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IgPSBuZXcgRGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5pbXBvcnQgeyBtYXJrZXIsIFRlbXBsYXRlIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRlbXBsYXRlRmFjdG9yeSB3aGljaCBjYWNoZXMgVGVtcGxhdGVzIGtleWVkIG9uXG4gKiByZXN1bHQudHlwZSBhbmQgcmVzdWx0LnN0cmluZ3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUZhY3RvcnkocmVzdWx0KSB7XG4gICAgbGV0IHRlbXBsYXRlQ2FjaGUgPSB0ZW1wbGF0ZUNhY2hlcy5nZXQocmVzdWx0LnR5cGUpO1xuICAgIGlmICh0ZW1wbGF0ZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGVtcGxhdGVDYWNoZSA9IHtcbiAgICAgICAgICAgIHN0cmluZ3NBcnJheTogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgICAgIGtleVN0cmluZzogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHRlbXBsYXRlQ2FjaGVzLnNldChyZXN1bHQudHlwZSwgdGVtcGxhdGVDYWNoZSk7XG4gICAgfVxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ2FjaGUuc3RyaW5nc0FycmF5LmdldChyZXN1bHQuc3RyaW5ncyk7XG4gICAgaWYgKHRlbXBsYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgVGVtcGxhdGVTdHJpbmdzQXJyYXkgaXMgbmV3LCBnZW5lcmF0ZSBhIGtleSBmcm9tIHRoZSBzdHJpbmdzXG4gICAgLy8gVGhpcyBrZXkgaXMgc2hhcmVkIGJldHdlZW4gYWxsIHRlbXBsYXRlcyB3aXRoIGlkZW50aWNhbCBjb250ZW50XG4gICAgY29uc3Qga2V5ID0gcmVzdWx0LnN0cmluZ3Muam9pbihtYXJrZXIpO1xuICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIFRlbXBsYXRlIGZvciB0aGlzIGtleVxuICAgIHRlbXBsYXRlID0gdGVtcGxhdGVDYWNoZS5rZXlTdHJpbmcuZ2V0KGtleSk7XG4gICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBub3Qgc2VlbiB0aGlzIGtleSBiZWZvcmUsIGNyZWF0ZSBhIG5ldyBUZW1wbGF0ZVxuICAgICAgICB0ZW1wbGF0ZSA9IG5ldyBUZW1wbGF0ZShyZXN1bHQsIHJlc3VsdC5nZXRUZW1wbGF0ZUVsZW1lbnQoKSk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBUZW1wbGF0ZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgdGVtcGxhdGVDYWNoZS5rZXlTdHJpbmcuc2V0KGtleSwgdGVtcGxhdGUpO1xuICAgIH1cbiAgICAvLyBDYWNoZSBhbGwgZnV0dXJlIHF1ZXJpZXMgZm9yIHRoaXMgVGVtcGxhdGVTdHJpbmdzQXJyYXlcbiAgICB0ZW1wbGF0ZUNhY2hlLnN0cmluZ3NBcnJheS5zZXQocmVzdWx0LnN0cmluZ3MsIHRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGVtcGxhdGU7XG59XG5leHBvcnQgY29uc3QgdGVtcGxhdGVDYWNoZXMgPSBuZXcgTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1mYWN0b3J5LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IHJlbW92ZU5vZGVzIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgTm9kZVBhcnQgfSBmcm9tICcuL3BhcnRzLmpzJztcbmltcG9ydCB7IHRlbXBsYXRlRmFjdG9yeSB9IGZyb20gJy4vdGVtcGxhdGUtZmFjdG9yeS5qcyc7XG5leHBvcnQgY29uc3QgcGFydHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBSZW5kZXJzIGEgdGVtcGxhdGUgcmVzdWx0IG9yIG90aGVyIHZhbHVlIHRvIGEgY29udGFpbmVyLlxuICpcbiAqIFRvIHVwZGF0ZSBhIGNvbnRhaW5lciB3aXRoIG5ldyB2YWx1ZXMsIHJlZXZhbHVhdGUgdGhlIHRlbXBsYXRlIGxpdGVyYWwgYW5kXG4gKiBjYWxsIGByZW5kZXJgIHdpdGggdGhlIG5ldyByZXN1bHQuXG4gKlxuICogQHBhcmFtIHJlc3VsdCBBbnkgdmFsdWUgcmVuZGVyYWJsZSBieSBOb2RlUGFydCAtIHR5cGljYWxseSBhIFRlbXBsYXRlUmVzdWx0XG4gKiAgICAgY3JlYXRlZCBieSBldmFsdWF0aW5nIGEgdGVtcGxhdGUgdGFnIGxpa2UgYGh0bWxgIG9yIGBzdmdgLlxuICogQHBhcmFtIGNvbnRhaW5lciBBIERPTSBwYXJlbnQgdG8gcmVuZGVyIHRvLiBUaGUgZW50aXJlIGNvbnRlbnRzIGFyZSBlaXRoZXJcbiAqICAgICByZXBsYWNlZCwgb3IgZWZmaWNpZW50bHkgdXBkYXRlZCBpZiB0aGUgc2FtZSByZXN1bHQgdHlwZSB3YXMgcHJldmlvdXNcbiAqICAgICByZW5kZXJlZCB0aGVyZS5cbiAqIEBwYXJhbSBvcHRpb25zIFJlbmRlck9wdGlvbnMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHRyZWUgcmVuZGVyZWQgdG8gdGhpc1xuICogICAgIGNvbnRhaW5lci4gUmVuZGVyIG9wdGlvbnMgbXVzdCAqbm90KiBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzIHRvIHRoZSBzYW1lXG4gKiAgICAgY29udGFpbmVyLCBhcyB0aG9zZSBjaGFuZ2VzIHdpbGwgbm90IGVmZmVjdCBwcmV2aW91c2x5IHJlbmRlcmVkIERPTS5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbmRlciA9IChyZXN1bHQsIGNvbnRhaW5lciwgb3B0aW9ucykgPT4ge1xuICAgIGxldCBwYXJ0ID0gcGFydHMuZ2V0KGNvbnRhaW5lcik7XG4gICAgaWYgKHBhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW1vdmVOb2Rlcyhjb250YWluZXIsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgcGFydHMuc2V0KGNvbnRhaW5lciwgcGFydCA9IG5ldyBOb2RlUGFydChPYmplY3QuYXNzaWduKHsgdGVtcGxhdGVGYWN0b3J5IH0sIG9wdGlvbnMpKSk7XG4gICAgICAgIHBhcnQuYXBwZW5kSW50byhjb250YWluZXIpO1xuICAgIH1cbiAgICBwYXJ0LnNldFZhbHVlKHJlc3VsdCk7XG4gICAgcGFydC5jb21taXQoKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXIuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKlxuICogTWFpbiBsaXQtaHRtbCBtb2R1bGUuXG4gKlxuICogTWFpbiBleHBvcnRzOlxuICpcbiAqIC0gIFtbaHRtbF1dXG4gKiAtICBbW3N2Z11dXG4gKiAtICBbW3JlbmRlcl1dXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbi8qKlxuICogRG8gbm90IHJlbW92ZSB0aGlzIGNvbW1lbnQ7IGl0IGtlZXBzIHR5cGVkb2MgZnJvbSBtaXNwbGFjaW5nIHRoZSBtb2R1bGVcbiAqIGRvY3MuXG4gKi9cbmltcG9ydCB7IGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciB9IGZyb20gJy4vbGliL2RlZmF1bHQtdGVtcGxhdGUtcHJvY2Vzc29yLmpzJztcbmltcG9ydCB7IFNWR1RlbXBsYXRlUmVzdWx0LCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJy4vbGliL3RlbXBsYXRlLXJlc3VsdC5qcyc7XG5leHBvcnQgeyBEZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IsIGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciB9IGZyb20gJy4vbGliL2RlZmF1bHQtdGVtcGxhdGUtcHJvY2Vzc29yLmpzJztcbmV4cG9ydCB7IGRpcmVjdGl2ZSwgaXNEaXJlY3RpdmUgfSBmcm9tICcuL2xpYi9kaXJlY3RpdmUuanMnO1xuLy8gVE9ETyhqdXN0aW5mYWduYW5pKTogcmVtb3ZlIGxpbmUgd2hlbiB3ZSBnZXQgTm9kZVBhcnQgbW92aW5nIG1ldGhvZHNcbmV4cG9ydCB7IHJlbW92ZU5vZGVzLCByZXBhcmVudE5vZGVzIH0gZnJvbSAnLi9saWIvZG9tLmpzJztcbmV4cG9ydCB7IG5vQ2hhbmdlLCBub3RoaW5nIH0gZnJvbSAnLi9saWIvcGFydC5qcyc7XG5leHBvcnQgeyBBdHRyaWJ1dGVDb21taXR0ZXIsIEF0dHJpYnV0ZVBhcnQsIEJvb2xlYW5BdHRyaWJ1dGVQYXJ0LCBFdmVudFBhcnQsIGlzSXRlcmFibGUsIGlzUHJpbWl0aXZlLCBOb2RlUGFydCwgUHJvcGVydHlDb21taXR0ZXIsIFByb3BlcnR5UGFydCB9IGZyb20gJy4vbGliL3BhcnRzLmpzJztcbmV4cG9ydCB7IHBhcnRzLCByZW5kZXIgfSBmcm9tICcuL2xpYi9yZW5kZXIuanMnO1xuZXhwb3J0IHsgdGVtcGxhdGVDYWNoZXMsIHRlbXBsYXRlRmFjdG9yeSB9IGZyb20gJy4vbGliL3RlbXBsYXRlLWZhY3RvcnkuanMnO1xuZXhwb3J0IHsgVGVtcGxhdGVJbnN0YW5jZSB9IGZyb20gJy4vbGliL3RlbXBsYXRlLWluc3RhbmNlLmpzJztcbmV4cG9ydCB7IFNWR1RlbXBsYXRlUmVzdWx0LCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJy4vbGliL3RlbXBsYXRlLXJlc3VsdC5qcyc7XG5leHBvcnQgeyBjcmVhdGVNYXJrZXIsIGlzVGVtcGxhdGVQYXJ0QWN0aXZlLCBUZW1wbGF0ZSB9IGZyb20gJy4vbGliL3RlbXBsYXRlLmpzJztcbi8vIElNUE9SVEFOVDogZG8gbm90IGNoYW5nZSB0aGUgcHJvcGVydHkgbmFtZSBvciB0aGUgYXNzaWdubWVudCBleHByZXNzaW9uLlxuLy8gVGhpcyBsaW5lIHdpbGwgYmUgdXNlZCBpbiByZWdleGVzIHRvIHNlYXJjaCBmb3IgbGl0LWh0bWwgdXNhZ2UuXG4vLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiBpbmplY3QgdmVyc2lvbiBudW1iZXIgYXQgYnVpbGQgdGltZVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgKHdpbmRvd1snbGl0SHRtbFZlcnNpb25zJ10gfHwgKHdpbmRvd1snbGl0SHRtbFZlcnNpb25zJ10gPSBbXSkpLnB1c2goJzEuMy4wJyk7XG59XG4vKipcbiAqIEludGVycHJldHMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGFuIEhUTUwgdGVtcGxhdGUgdGhhdCBjYW4gZWZmaWNpZW50bHlcbiAqIHJlbmRlciB0byBhbmQgdXBkYXRlIGEgY29udGFpbmVyLlxuICovXG5leHBvcnQgY29uc3QgaHRtbCA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IG5ldyBUZW1wbGF0ZVJlc3VsdChzdHJpbmdzLCB2YWx1ZXMsICdodG1sJywgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yKTtcbi8qKlxuICogSW50ZXJwcmV0cyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYW4gU1ZHIHRlbXBsYXRlIHRoYXQgY2FuIGVmZmljaWVudGx5XG4gKiByZW5kZXIgdG8gYW5kIHVwZGF0ZSBhIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN2ZyA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IG5ldyBTVkdUZW1wbGF0ZVJlc3VsdChzdHJpbmdzLCB2YWx1ZXMsICdzdmcnLCBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl0LWh0bWwuanMubWFwIiwibGV0IGN1cnJlbnQ7XG5sZXQgY3VycmVudElkID0gMDtcbmZ1bmN0aW9uIHNldEN1cnJlbnQoc3RhdGUpIHtcbiAgICBjdXJyZW50ID0gc3RhdGU7XG59XG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjdXJyZW50ID0gbnVsbDtcbiAgICBjdXJyZW50SWQgPSAwO1xufVxuZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIHJldHVybiBjdXJyZW50SWQrKztcbn1cbmV4cG9ydCB7IGNsZWFyLCBjdXJyZW50LCBzZXRDdXJyZW50LCBub3RpZnkgfTtcbiIsImNvbnN0IHBoYXNlU3ltYm9sID0gU3ltYm9sKCdoYXVudGVkLnBoYXNlJyk7XG5jb25zdCBob29rU3ltYm9sID0gU3ltYm9sKCdoYXVudGVkLmhvb2snKTtcbmNvbnN0IHVwZGF0ZVN5bWJvbCA9IFN5bWJvbCgnaGF1bnRlZC51cGRhdGUnKTtcbmNvbnN0IGNvbW1pdFN5bWJvbCA9IFN5bWJvbCgnaGF1bnRlZC5jb21taXQnKTtcbmNvbnN0IGVmZmVjdHNTeW1ib2wgPSBTeW1ib2woJ2hhdW50ZWQuZWZmZWN0cycpO1xuY29uc3QgbGF5b3V0RWZmZWN0c1N5bWJvbCA9IFN5bWJvbCgnaGF1bnRlZC5sYXlvdXRFZmZlY3RzJyk7XG5jb25zdCBjb250ZXh0RXZlbnQgPSAnaGF1bnRlZC5jb250ZXh0JztcbmV4cG9ydCB7IHBoYXNlU3ltYm9sLCBob29rU3ltYm9sLCB1cGRhdGVTeW1ib2wsIGNvbW1pdFN5bWJvbCwgZWZmZWN0c1N5bWJvbCwgbGF5b3V0RWZmZWN0c1N5bWJvbCwgY29udGV4dEV2ZW50LCB9O1xuIiwiaW1wb3J0IHsgc2V0Q3VycmVudCwgY2xlYXIgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBob29rU3ltYm9sLCBlZmZlY3RzU3ltYm9sLCBsYXlvdXRFZmZlY3RzU3ltYm9sIH0gZnJvbSAnLi9zeW1ib2xzJztcbmNsYXNzIFN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih1cGRhdGUsIGhvc3QpIHtcbiAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXNbaG9va1N5bWJvbF0gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXNbZWZmZWN0c1N5bWJvbF0gPSBbXTtcbiAgICAgICAgdGhpc1tsYXlvdXRFZmZlY3RzU3ltYm9sXSA9IFtdO1xuICAgIH1cbiAgICBydW4oY2IpIHtcbiAgICAgICAgc2V0Q3VycmVudCh0aGlzKTtcbiAgICAgICAgbGV0IHJlcyA9IGNiKCk7XG4gICAgICAgIGNsZWFyKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9ydW5FZmZlY3RzKHBoYXNlKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gdGhpc1twaGFzZV07XG4gICAgICAgIHNldEN1cnJlbnQodGhpcyk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBlZmZlY3QuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhcigpO1xuICAgIH1cbiAgICBydW5FZmZlY3RzKCkge1xuICAgICAgICB0aGlzLl9ydW5FZmZlY3RzKGVmZmVjdHNTeW1ib2wpO1xuICAgIH1cbiAgICBydW5MYXlvdXRFZmZlY3RzKCkge1xuICAgICAgICB0aGlzLl9ydW5FZmZlY3RzKGxheW91dEVmZmVjdHNTeW1ib2wpO1xuICAgIH1cbiAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgbGV0IGhvb2tzID0gdGhpc1tob29rU3ltYm9sXTtcbiAgICAgICAgaG9va3MuZm9yRWFjaChob29rID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaG9vay50ZWFyZG93biA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhvb2sudGVhcmRvd24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IHsgU3RhdGUgfTtcbiIsImltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi9zdGF0ZSc7XG5pbXBvcnQgeyBjb21taXRTeW1ib2wsIHBoYXNlU3ltYm9sLCB1cGRhdGVTeW1ib2wsIGVmZmVjdHNTeW1ib2wsIGxheW91dEVmZmVjdHNTeW1ib2wgfSBmcm9tICcuL3N5bWJvbHMnO1xuY29uc3QgZGVmZXIgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpO1xuZnVuY3Rpb24gcnVubmVyKCkge1xuICAgIGxldCB0YXNrcyA9IFtdO1xuICAgIGxldCBpZDtcbiAgICBmdW5jdGlvbiBydW5UYXNrcygpIHtcbiAgICAgICAgaWQgPSBudWxsO1xuICAgICAgICBsZXQgdCA9IHRhc2tzO1xuICAgICAgICB0YXNrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdFtpXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICB0YXNrcy5wdXNoKHRhc2spO1xuICAgICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWQgPSBkZWZlcihydW5UYXNrcyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgcmVhZCA9IHJ1bm5lcigpO1xuY29uc3Qgd3JpdGUgPSBydW5uZXIoKTtcbmNsYXNzIEJhc2VTY2hlZHVsZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBob3N0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpLCBob3N0KTtcbiAgICAgICAgdGhpc1twaGFzZVN5bWJvbF0gPSBudWxsO1xuICAgICAgICB0aGlzLl91cGRhdGVRdWV1ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fdXBkYXRlUXVldWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmhhbmRsZVBoYXNlKHVwZGF0ZVN5bWJvbCk7XG4gICAgICAgICAgICB3cml0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQaGFzZShjb21taXRTeW1ib2wsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgd3JpdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBoYXNlKGVmZmVjdHNTeW1ib2wpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVF1ZXVlZCA9IHRydWU7XG4gICAgfVxuICAgIGhhbmRsZVBoYXNlKHBoYXNlLCBhcmcpIHtcbiAgICAgICAgdGhpc1twaGFzZVN5bWJvbF0gPSBwaGFzZTtcbiAgICAgICAgc3dpdGNoIChwaGFzZSkge1xuICAgICAgICAgICAgY2FzZSBjb21taXRTeW1ib2w6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXQoYXJnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bkVmZmVjdHMobGF5b3V0RWZmZWN0c1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSB1cGRhdGVTeW1ib2w6IHJldHVybiB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgY2FzZSBlZmZlY3RzU3ltYm9sOiByZXR1cm4gdGhpcy5ydW5FZmZlY3RzKGVmZmVjdHNTeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbcGhhc2VTeW1ib2xdID0gbnVsbDtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ydW4oKCkgPT4gdGhpcy5yZW5kZXJlci5jYWxsKHRoaXMuaG9zdCwgdGhpcy5ob3N0KSk7XG4gICAgfVxuICAgIHJ1bkVmZmVjdHMocGhhc2UpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5fcnVuRWZmZWN0cyhwaGFzZSk7XG4gICAgfVxuICAgIHRlYXJkb3duKCkge1xuICAgICAgICB0aGlzLnN0YXRlLnRlYXJkb3duKCk7XG4gICAgfVxufVxuZXhwb3J0IHsgQmFzZVNjaGVkdWxlciB9O1xuIiwiaW1wb3J0IHsgQmFzZVNjaGVkdWxlciB9IGZyb20gJy4vc2NoZWR1bGVyJztcbmNvbnN0IHRvQ2FtZWxDYXNlID0gKHZhbCA9ICcnKSA9PiB2YWwucmVwbGFjZSgvLSsoW2Etel0pPy9nLCAoXywgY2hhcikgPT4gY2hhciA/IGNoYXIudG9VcHBlckNhc2UoKSA6ICcnKTtcbmZ1bmN0aW9uIG1ha2VDb21wb25lbnQocmVuZGVyKSB7XG4gICAgY2xhc3MgU2NoZWR1bGVyIGV4dGVuZHMgQmFzZVNjaGVkdWxlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBmcmFnLCBob3N0KSB7XG4gICAgICAgICAgICBzdXBlcihyZW5kZXJlciwgaG9zdCB8fCBmcmFnKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0KHJlc3VsdCkge1xuICAgICAgICAgICAgcmVuZGVyKHJlc3VsdCwgdGhpcy5mcmFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wb25lbnQocmVuZGVyZXIsIGJhc2VFbGVtZW50T3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IEJhc2VFbGVtZW50ID0gKG9wdGlvbnMgfHwgYmFzZUVsZW1lbnRPck9wdGlvbnMgfHwge30pLmJhc2VFbGVtZW50IHx8IEhUTUxFbGVtZW50O1xuICAgICAgICBjb25zdCB7IG9ic2VydmVkQXR0cmlidXRlcyA9IFtdLCB1c2VTaGFkb3dET00gPSB0cnVlLCBzaGFkb3dSb290SW5pdCA9IHt9IH0gPSBvcHRpb25zIHx8IGJhc2VFbGVtZW50T3JPcHRpb25zIHx8IHt9O1xuICAgICAgICBjbGFzcyBFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlU2hhZG93RE9NID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKHJlbmRlcmVyLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nLCAuLi5zaGFkb3dSb290SW5pdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcihyZW5kZXJlciwgdGhpcy5zaGFkb3dSb290LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzIHx8IG9ic2VydmVkQXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlci51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlci50ZWFyZG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gbmV3VmFsdWUgPT09ICcnID8gdHJ1ZSA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIFJlZmxlY3Quc2V0KHRoaXMsIHRvQ2FtZWxDYXNlKG5hbWUpLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZnVuY3Rpb24gcmVmbGVjdGl2ZVByb3AoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVyLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3RvID0gbmV3IFByb3h5KEJhc2VFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJyB8fCBrZXlbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSByZWZsZWN0aXZlUHJvcCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYy5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFbGVtZW50LnByb3RvdHlwZSwgcHJvdG8pO1xuICAgICAgICByZXR1cm4gRWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmV4cG9ydCB7IG1ha2VDb21wb25lbnQgfTtcbiIsImltcG9ydCB7IGN1cnJlbnQsIG5vdGlmeSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IGhvb2tTeW1ib2wgfSBmcm9tICcuL3N5bWJvbHMnO1xuY2xhc3MgSG9vayB7XG4gICAgY29uc3RydWN0b3IoaWQsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVzZShIb29rLCAuLi5hcmdzKSB7XG4gICAgbGV0IGlkID0gbm90aWZ5KCk7XG4gICAgbGV0IGhvb2tzID0gY3VycmVudFtob29rU3ltYm9sXTtcbiAgICBsZXQgaG9vayA9IGhvb2tzLmdldChpZCk7XG4gICAgaWYgKCFob29rKSB7XG4gICAgICAgIGhvb2sgPSBuZXcgSG9vayhpZCwgY3VycmVudCwgLi4uYXJncyk7XG4gICAgICAgIGhvb2tzLnNldChpZCwgaG9vayk7XG4gICAgfVxuICAgIHJldHVybiBob29rLnVwZGF0ZSguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGhvb2soSG9vaykge1xuICAgIHJldHVybiB1c2UuYmluZChudWxsLCBIb29rKTtcbn1cbmV4cG9ydCB7IGhvb2ssIEhvb2sgfTtcbiIsImltcG9ydCB7IEhvb2ssIGhvb2sgfSBmcm9tICcuL2hvb2snO1xuZnVuY3Rpb24gY3JlYXRlRWZmZWN0KHNldEVmZmVjdHMpIHtcbiAgICByZXR1cm4gaG9vayhjbGFzcyBleHRlbmRzIEhvb2sge1xuICAgICAgICBjb25zdHJ1Y3RvcihpZCwgc3RhdGUsIGlnbm9yZWQxLCBpZ25vcmVkMikge1xuICAgICAgICAgICAgc3VwZXIoaWQsIHN0YXRlKTtcbiAgICAgICAgICAgIHNldEVmZmVjdHMoc3RhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZShjYWxsYmFjaywgdmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhbGwoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsdWVzIHx8IHRoaXMuaGFzQ2hhbmdlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBydW4oKSB7XG4gICAgICAgICAgICB0aGlzLnRlYXJkb3duKCk7XG4gICAgICAgICAgICB0aGlzLl90ZWFyZG93biA9IHRoaXMuY2FsbGJhY2suY2FsbCh0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdGVhcmRvd24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZWFyZG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhc0NoYW5nZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMubGFzdFZhbHVlcyB8fCB0aGlzLnZhbHVlcy5zb21lKCh2YWx1ZSwgaSkgPT4gdGhpcy5sYXN0VmFsdWVzW2ldICE9PSB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCB7IGNyZWF0ZUVmZmVjdCB9O1xuIiwiaW1wb3J0IHsgZWZmZWN0c1N5bWJvbCB9IGZyb20gJy4vc3ltYm9scyc7XG5pbXBvcnQgeyBjcmVhdGVFZmZlY3QgfSBmcm9tICcuL2NyZWF0ZS1lZmZlY3QnO1xuZnVuY3Rpb24gc2V0RWZmZWN0cyhzdGF0ZSwgY2IpIHtcbiAgICBzdGF0ZVtlZmZlY3RzU3ltYm9sXS5wdXNoKGNiKTtcbn1cbmNvbnN0IHVzZUVmZmVjdCA9IGNyZWF0ZUVmZmVjdChzZXRFZmZlY3RzKTtcbmV4cG9ydCB7IHNldEVmZmVjdHMsIHVzZUVmZmVjdCB9O1xuIiwiaW1wb3J0IHsgaG9vaywgSG9vayB9IGZyb20gJy4vaG9vayc7XG5pbXBvcnQgeyBjb250ZXh0RXZlbnQgfSBmcm9tICcuL3N5bWJvbHMnO1xuaW1wb3J0IHsgc2V0RWZmZWN0cyB9IGZyb20gJy4vdXNlLWVmZmVjdCc7XG5jb25zdCB1c2VDb250ZXh0ID0gaG9vayhjbGFzcyBleHRlbmRzIEhvb2sge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBzdGF0ZSwgXykge1xuICAgICAgICBzdXBlcihpZCwgc3RhdGUpO1xuICAgICAgICB0aGlzLl91cGRhdGVyID0gdGhpcy5fdXBkYXRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yYW5FZmZlY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSBudWxsO1xuICAgICAgICBzZXRFZmZlY3RzKHN0YXRlLCB0aGlzKTtcbiAgICB9XG4gICAgdXBkYXRlKENvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmlydHVhbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGJlIHVzZWQgd2l0aCB2aXJ0dWFsIGNvbXBvbmVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5Db250ZXh0ICE9PSBDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLkNvbnRleHQgPSBDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBjYWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JhbkVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmFuRWZmZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl91bnN1YnNjcmliZSlcbiAgICAgICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKHRoaXMuQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGUoKTtcbiAgICB9XG4gICAgX3N1YnNjcmliZShDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGRldGFpbCA9IHsgQ29udGV4dCwgY2FsbGJhY2s6IHRoaXMuX3VwZGF0ZXIgfTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ob3N0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGNvbnRleHRFdmVudCwge1xuICAgICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB7IHVuc3Vic2NyaWJlLCB2YWx1ZSB9ID0gZGV0YWlsO1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5zdWJzY3JpYmUgPyB2YWx1ZSA6IENvbnRleHQuZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlO1xuICAgIH1cbiAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5leHBvcnQgeyB1c2VDb250ZXh0IH07XG4iLCJpbXBvcnQgeyBjb250ZXh0RXZlbnQgfSBmcm9tICcuL3N5bWJvbHMnO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJy4vdXNlLWNvbnRleHQnO1xuZnVuY3Rpb24gbWFrZUNvbnRleHQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIChkZWZhdWx0VmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgQ29udGV4dCA9IHtcbiAgICAgICAgICAgIFByb3ZpZGVyOiBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihjb250ZXh0RXZlbnQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNvbnRleHRFdmVudCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldGFpbC5Db250ZXh0ID09PSBDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWwudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsLnVuc3Vic2NyaWJlID0gdGhpcy51bnN1YnNjcmliZS5iaW5kKHRoaXMsIGRldGFpbC5jYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5hZGQoZGV0YWlsLmNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb25zdW1lcjogY29tcG9uZW50KGZ1bmN0aW9uICh7IHJlbmRlciB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcihjb250ZXh0KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29udGV4dDtcbiAgICB9O1xufVxuZXhwb3J0IHsgbWFrZUNvbnRleHQgfTtcbiIsImltcG9ydCB7IGhvb2ssIEhvb2sgfSBmcm9tICcuL2hvb2snO1xuY29uc3QgdXNlTWVtbyA9IGhvb2soY2xhc3MgZXh0ZW5kcyBIb29rIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgc3RhdGUsIGZuLCB2YWx1ZXMpIHtcbiAgICAgICAgc3VwZXIoaWQsIHN0YXRlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGZuKCk7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICB1cGRhdGUoZm4sIHZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5oYXNDaGFuZ2VkKHZhbHVlcykpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIGhhc0NoYW5nZWQodmFsdWVzID0gW10pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5zb21lKCh2YWx1ZSwgaSkgPT4gdGhpcy52YWx1ZXNbaV0gIT09IHZhbHVlKTtcbiAgICB9XG59KTtcbmV4cG9ydCB7IHVzZU1lbW8gfTtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICcuL3VzZS1tZW1vJztcbmNvbnN0IHVzZUNhbGxiYWNrID0gKGZuLCBpbnB1dHMpID0+IHVzZU1lbW8oKCkgPT4gZm4sIGlucHV0cyk7XG5leHBvcnQgeyB1c2VDYWxsYmFjayB9O1xuIiwiaW1wb3J0IHsgbGF5b3V0RWZmZWN0c1N5bWJvbCB9IGZyb20gJy4vc3ltYm9scyc7XG5pbXBvcnQgeyBjcmVhdGVFZmZlY3QgfSBmcm9tICcuL2NyZWF0ZS1lZmZlY3QnO1xuZnVuY3Rpb24gc2V0TGF5b3V0RWZmZWN0cyhzdGF0ZSwgY2IpIHtcbiAgICBzdGF0ZVtsYXlvdXRFZmZlY3RzU3ltYm9sXS5wdXNoKGNiKTtcbn1cbmNvbnN0IHVzZUxheW91dEVmZmVjdCA9IGNyZWF0ZUVmZmVjdChzZXRMYXlvdXRFZmZlY3RzKTtcbmV4cG9ydCB7IHVzZUxheW91dEVmZmVjdCB9O1xuIiwiaW1wb3J0IHsgaG9vaywgSG9vayB9IGZyb20gJy4vaG9vayc7XG5jb25zdCB1c2VTdGF0ZSA9IGhvb2soY2xhc3MgZXh0ZW5kcyBIb29rIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgc3RhdGUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBzdXBlcihpZCwgc3RhdGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZXIgPSB0aGlzLnVwZGF0ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFrZUFyZ3MoaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgIH1cbiAgICB1cGRhdGVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXJGbiA9IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgW3ByZXZpb3VzVmFsdWVdID0gdGhpcy5hcmdzO1xuICAgICAgICAgICAgdmFsdWUgPSB1cGRhdGVyRm4ocHJldmlvdXNWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWtlQXJncyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUudXBkYXRlKCk7XG4gICAgfVxuICAgIG1ha2VBcmdzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXJncyA9IE9iamVjdC5mcmVlemUoW3ZhbHVlLCB0aGlzLnVwZGF0ZXJdKTtcbiAgICB9XG59KTtcbmV4cG9ydCB7IHVzZVN0YXRlIH07XG4iLCJpbXBvcnQgeyBob29rLCBIb29rIH0gZnJvbSAnLi9ob29rJztcbmNvbnN0IHVzZVJlZHVjZXIgPSBob29rKGNsYXNzIGV4dGVuZHMgSG9vayB7XG4gICAgY29uc3RydWN0b3IoaWQsIHN0YXRlLCBfLCBpbml0aWFsU3RhdGUsIGluaXQpIHtcbiAgICAgICAgc3VwZXIoaWQsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBpbml0ICE9PSB1bmRlZmluZWQgPyBpbml0KGluaXRpYWxTdGF0ZSkgOiBpbml0aWFsU3RhdGU7XG4gICAgfVxuICAgIHVwZGF0ZShyZWR1Y2VyKSB7XG4gICAgICAgIHRoaXMucmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICAgIHJldHVybiBbdGhpcy5jdXJyZW50U3RhdGUsIHRoaXMuZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB0aGlzLnJlZHVjZXIodGhpcy5jdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIHRoaXMuc3RhdGUudXBkYXRlKCk7XG4gICAgfVxufSk7XG5leHBvcnQgeyB1c2VSZWR1Y2VyIH07XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAnLi91c2UtbWVtbyc7XG5jb25zdCB1c2VSZWYgPSAoaW5pdGlhbFZhbHVlKSA9PiB1c2VNZW1vKCgpID0+ICh7XG4gICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG59KSwgW10pO1xuZXhwb3J0IHsgdXNlUmVmIH07XG4iLCJpbXBvcnQgeyBtYWtlQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgbWFrZUNvbnRleHQgfSBmcm9tICcuL2NyZWF0ZS1jb250ZXh0JztcbmZ1bmN0aW9uIGhhdW50ZWQoeyByZW5kZXIgfSkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IG1ha2VDb21wb25lbnQocmVuZGVyKTtcbiAgICBjb25zdCBjcmVhdGVDb250ZXh0ID0gbWFrZUNvbnRleHQoY29tcG9uZW50KTtcbiAgICByZXR1cm4geyBjb21wb25lbnQsIGNyZWF0ZUNvbnRleHQgfTtcbn1cbmV4cG9ydCB7IGhhdW50ZWQgYXMgZGVmYXVsdCB9O1xuZXhwb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICcuL3VzZS1jYWxsYmFjayc7XG5leHBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICcuL3VzZS1lZmZlY3QnO1xuZXhwb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi91c2UtbGF5b3V0LWVmZmVjdCc7XG5leHBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJy4vdXNlLXN0YXRlJztcbmV4cG9ydCB7IHVzZVJlZHVjZXIgfSBmcm9tICcuL3VzZS1yZWR1Y2VyJztcbmV4cG9ydCB7IHVzZU1lbW8gfSBmcm9tICcuL3VzZS1tZW1vJztcbmV4cG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICcuL3VzZS1jb250ZXh0JztcbmV4cG9ydCB7IHVzZVJlZiB9IGZyb20gJy4vdXNlLXJlZic7XG5leHBvcnQgeyBob29rLCBIb29rIH0gZnJvbSAnLi9ob29rJztcbmV4cG9ydCB7IEJhc2VTY2hlZHVsZXIgfSBmcm9tICcuL3NjaGVkdWxlcic7XG5leHBvcnQgeyBTdGF0ZSB9IGZyb20gJy4vc3RhdGUnO1xuIiwiaW1wb3J0IHsgaHRtbCwgcmVuZGVyIH0gZnJvbSAnbGl0LWh0bWwnO1xuaW1wb3J0IGhhdW50ZWQgZnJvbSAnLi9jb3JlJztcbmltcG9ydCB7IG1ha2VWaXJ0dWFsIH0gZnJvbSAnLi92aXJ0dWFsJztcbmNvbnN0IHsgY29tcG9uZW50LCBjcmVhdGVDb250ZXh0IH0gPSBoYXVudGVkKHsgcmVuZGVyIH0pO1xuY29uc3QgdmlydHVhbCA9IG1ha2VWaXJ0dWFsKCk7XG5leHBvcnQgeyBjb21wb25lbnQsIGNyZWF0ZUNvbnRleHQsIHZpcnR1YWwsIGh0bWwsIHJlbmRlciB9O1xuIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAnaGF1bnRlZCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWJvdW5jZWRDYWxsYmFjayhcbiAgZnVuYyxcbiAgcmF3V2FpdCxcbiAgb3B0aW9ucyA9IHsgbGVhZGluZzogZmFsc2UsIHRyYWlsaW5nOiB0cnVlIH1cbikge1xuICBjb25zdCBsYXN0Q2FsbFRpbWUgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgY29uc3QgbGFzdEludm9rZVRpbWUgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IHRpbWVySWQgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgY29uc3QgbGFzdEFyZ3MgPSB1c2VSZWYoW10pO1xuICBjb25zdCBsYXN0VGhpcyA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBmdW5jUmVmID0gdXNlUmVmKGZ1bmMpO1xuICBjb25zdCBtb3VudGVkID0gdXNlUmVmKHRydWUpO1xuICBmdW5jUmVmLmN1cnJlbnQgPSBmdW5jO1xuXG4gIC8vIEJ5cGFzcyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBieSBleHBsaWNpdGx5IHNldHRpbmcgYHdhaXQ9MGAuXG4gIGNvbnN0IHVzZVJBRiA9XG4gICAgIXJhd1dhaXQgJiZcbiAgICByYXdXYWl0ICE9PSAwICYmXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgY29uc3Qgd2FpdCA9IE51bWJlcihyYXdXYWl0KSB8fCAwO1xuICBjb25zdCBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gIGNvbnN0IHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJ1ZTtcbiAgY29uc3QgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gIGNvbnN0IG1heFdhaXQgPSBtYXhpbmdcbiAgICA/IE1hdGgubWF4KE51bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgaW52b2tlRnVuYyA9IHVzZUNhbGxiYWNrKCh0aW1lKSA9PiB7XG4gICAgY29uc3QgYXJncyA9IGxhc3RBcmdzLmN1cnJlbnQ7XG4gICAgY29uc3QgdGhpc0FyZyA9IGxhc3RUaGlzLmN1cnJlbnQ7XG5cbiAgICBsYXN0VGhpcy5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIGxhc3RBcmdzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUuY3VycmVudCA9IHRpbWU7XG4gICAgcmVzdWx0LmN1cnJlbnQgPSBmdW5jUmVmLmN1cnJlbnQuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdC5jdXJyZW50O1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc3RhcnRUaW1lciA9IHVzZUNhbGxiYWNrKFxuICAgIChwZW5kaW5nRnVuYywgdGltZW91dCkgPT4ge1xuICAgICAgaWYgKHVzZVJBRikge1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGltZXJJZC5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGVuZGluZ0Z1bmMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQocGVuZGluZ0Z1bmMsIHRpbWVvdXQpO1xuICAgIH0sXG4gICAgW3VzZVJBRl1cbiAgKTtcblxuICBjb25zdCBjYW5jZWxUaW1lciA9IHVzZUNhbGxiYWNrKFxuICAgIChpZCkgPT4ge1xuICAgICAgaWYgKHVzZVJBRikge1xuICAgICAgICByZXR1cm4gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIFt1c2VSQUZdXG4gICk7XG5cbiAgY29uc3QgcmVtYWluaW5nV2FpdCA9IHVzZUNhbGxiYWNrKFxuICAgICh0aW1lKSA9PiB7XG4gICAgICBjb25zdCB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUuY3VycmVudDtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUuY3VycmVudDtcbiAgICAgIGNvbnN0IHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgID8gTWF0aC5taW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICA6IHRpbWVXYWl0aW5nO1xuICAgIH0sXG4gICAgW21heFdhaXQsIG1heGluZywgd2FpdF1cbiAgKTtcblxuICBjb25zdCBzaG91bGRJbnZva2UgPSB1c2VDYWxsYmFjayhcbiAgICAodGltZSkgPT4ge1xuICAgICAgaWYgKCFtb3VudGVkLmN1cnJlbnQpIHJldHVybiBmYWxzZTtcblxuICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLmN1cnJlbnQ7XG4gICAgICBjb25zdCB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLmN1cnJlbnQ7XG5cbiAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgbGFzdENhbGxUaW1lLmN1cnJlbnQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICB0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0IHx8XG4gICAgICAgIHRpbWVTaW5jZUxhc3RDYWxsIDwgMCB8fFxuICAgICAgICAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbbWF4V2FpdCwgbWF4aW5nLCB3YWl0XVxuICApO1xuXG4gIGNvbnN0IHRyYWlsaW5nRWRnZSA9IHVzZUNhbGxiYWNrKFxuICAgICh0aW1lKSA9PiB7XG4gICAgICB0aW1lcklkLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICB9XG4gICAgICBsYXN0VGhpcy5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgbGFzdEFyZ3MuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQuY3VycmVudDtcbiAgICB9LFxuICAgIFtpbnZva2VGdW5jLCB0cmFpbGluZ11cbiAgKTtcblxuICBjb25zdCB0aW1lckV4cGlyZWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgdGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZC5jdXJyZW50ID0gc3RhcnRUaW1lcih0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBbcmVtYWluaW5nV2FpdCwgc2hvdWxkSW52b2tlLCBzdGFydFRpbWVyLCB0cmFpbGluZ0VkZ2VdKTtcblxuICBjb25zdCBsZWFkaW5nRWRnZSA9IHVzZUNhbGxiYWNrKFxuICAgICh0aW1lKSA9PiB7XG4gICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgbGFzdEludm9rZVRpbWUuY3VycmVudCA9IHRpbWU7XG4gICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgdGltZXJJZC5jdXJyZW50ID0gc3RhcnRUaW1lcih0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQuY3VycmVudDtcbiAgICB9LFxuICAgIFtpbnZva2VGdW5jLCBzdGFydFRpbWVyLCBsZWFkaW5nLCB0aW1lckV4cGlyZWQsIHdhaXRdXG4gICk7XG5cbiAgY29uc3QgY2FuY2VsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0aW1lcklkLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FuY2VsVGltZXIodGltZXJJZC5jdXJyZW50KTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUuY3VycmVudCA9IDA7XG4gICAgdGltZXJJZC5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIGxhc3RUaGlzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgbGFzdENhbGxUaW1lLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEFyZ3MuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSwgW2NhbmNlbFRpbWVyXSk7XG5cbiAgY29uc3QgZmx1c2ggPSB1c2VDYWxsYmFjayhcbiAgICAoKSA9PlxuICAgICAgdGltZXJJZC5jdXJyZW50ID09PSB1bmRlZmluZWQgPyByZXN1bHQuY3VycmVudCA6IHRyYWlsaW5nRWRnZShEYXRlLm5vdygpKSxcbiAgICBbdHJhaWxpbmdFZGdlXVxuICApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGRlYm91bmNlZCA9IHVzZUNhbGxiYWNrKFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgIGxhc3RBcmdzLmN1cnJlbnQgPSBhcmdzO1xuICAgICAgbGFzdFRoaXMuY3VycmVudCA9IHRoaXM7XG4gICAgICBsYXN0Q2FsbFRpbWUuY3VycmVudCA9IHRpbWU7XG5cbiAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgIGlmICh0aW1lcklkLmN1cnJlbnQgPT09IHVuZGVmaW5lZCAmJiBtb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgIHRpbWVySWQuY3VycmVudCA9IHN0YXJ0VGltZXIodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcklkLmN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lcklkLmN1cnJlbnQgPSBzdGFydFRpbWVyKHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0LmN1cnJlbnQ7XG4gICAgfSxcbiAgICBbXG4gICAgICBpbnZva2VGdW5jLFxuICAgICAgbGVhZGluZ0VkZ2UsXG4gICAgICBtYXhpbmcsXG4gICAgICBzaG91bGRJbnZva2UsXG4gICAgICBzdGFydFRpbWVyLFxuICAgICAgdGltZXJFeHBpcmVkLFxuICAgICAgd2FpdCxcbiAgICBdXG4gICk7XG5cbiAgY29uc3QgcGVuZGluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHRpbWVySWQuY3VycmVudCAhPT0gdW5kZWZpbmVkLCBbXSk7XG5cbiAgY29uc3QgZGVib3VuY2VkU3RhdGUgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBjYWxsYmFjazogZGVib3VuY2VkLFxuICAgICAgY2FuY2VsLFxuICAgICAgZmx1c2gsXG4gICAgICBwZW5kaW5nLFxuICAgIH0pLFxuICAgIFtkZWJvdW5jZWQsIGNhbmNlbCwgZmx1c2gsIHBlbmRpbmddXG4gICk7XG5cbiAgcmV0dXJuIGRlYm91bmNlZFN0YXRlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IHVzZURlYm91bmNlZENhbGxiYWNrIH07XG4iLCJpbXBvcnQgeyBodG1sLCBjb21wb25lbnQsIHVzZVN0YXRlIH0gZnJvbSAnaGF1bnRlZCc7XG5pbXBvcnQgeyB1c2VEZWJvdW5jZWRDYWxsYmFjayB9IGZyb20gJy4vY3VzdG9tLWhvb2tzJztcbmltcG9ydCB7IGdldFByZWRpY3RpdmVTZWFyY2hSZXN1bHRzIH0gZnJvbSAnLi4vYWpheGFwaXMnO1xuXG5mdW5jdGlvbiBwcmVkaWN0aXZlU2VhcmNoKCkge1xuICBjb25zdCBbcSwgc2V0UV0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtyZXN1bHRzLCBzZXRSZXN1bHRzXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IGRlYm91bmNlZCA9IHVzZURlYm91bmNlZENhbGxiYWNrKCgpID0+IHtcbiAgICBnZXRQcmVkaWN0aXZlU2VhcmNoUmVzdWx0cyhxKS50aGVuKGZ1bmN0aW9uIHNldFZhbHVlKHJlc3BvbnNlKSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIGlmIChyZXNwb25zZS5tZXNzYWdlKSB7XG4gICAgICAgIHNldFJlc3VsdHMoe30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UmVzdWx0cyhyZXNwb25zZS5yZXNvdXJjZXMucmVzdWx0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIDUwMCk7XG5cbiAgY29uc3QgaGFuZGxlS2V5dXAgPSAoZXZlbnQpID0+IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldFEoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICBkZWJvdW5jZWQuY2FsbGJhY2soZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4gaHRtbGBcbiAgICA8aDE+JHtgJHtsb2FkaW5nID8gJ2xvYWRpbmcuLi4nIDogJ2xvYWRlZCd9YH08L2gxPlxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIEBrZXl1cD0ke2hhbmRsZUtleXVwfSB2YWx1ZT0ke3F9IC8+XG4gICAgPGRpdj4ke0pTT04uc3RyaW5naWZ5KHJlc3VsdHMpfTwvZGl2PlxuICBgO1xufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXG4gICdwcmVkaWN0aXZlLXNlYXJjaCcsXG4gIGNvbXBvbmVudChwcmVkaWN0aXZlU2VhcmNoLCB7IHVzZVNoYWRvd0RPTTogZmFsc2UgfSlcbik7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXN0ZWQtdGVybmFyeSAqL1xuaW1wb3J0IHsgaHRtbCwgY29tcG9uZW50LCB1c2VTdGF0ZSB9IGZyb20gJ2hhdW50ZWQnO1xuaW1wb3J0IHsgYWRkSXRlbUZyb21Gb3JtLCBnZXRDYXJ0IH0gZnJvbSAnLi4vYWpheGFwaXMnO1xuaW1wb3J0IHsgZGlzcGF0Y2hDdXN0b21FdmVudCwgZm9ybWF0TW9uZXkgfSBmcm9tICcuLi9oZWxwZXInO1xuXG5mdW5jdGlvbiBhdGNEcm9wZG93bklucHV0cyh7XG4gIGRhdGFQcm9kdWN0LFxuICBkYXRhU2VsZWN0ZWRPckZpcnN0QXZhaWxhYmxlVmFyaWFudCxcbiAgZGF0YU9wdGlvbnNXaXRoVmFsdWVzLFxuICBzZWxlY3RvcldyYXBwZXJDdXN0b21DbGFzc2VzID0gJycsXG4gIHNlbGVjdG9yTGFiZWxDdXN0b21DbGFzc2VzID0gJycsXG4gIHNlbGVjdG9yQ3VzdG9tQ2xhc3NlcyA9ICcnLFxuICBxdWFudGl0eUlucHV0Q3VzdG9tQ2xhc3NlcyA9ICcnLFxuICBhdGNCdXR0b25DdXN0b21DbGFzc2VzID0gJycsXG59KSB7XG4gIGNvbnN0IHByb2R1Y3QgPSBKU09OLnBhcnNlKGRhdGFQcm9kdWN0KTtcbiAgY29uc3Qgb3B0aW9uc1dpdGhWYWx1ZXMgPSBKU09OLnBhcnNlKGRhdGFPcHRpb25zV2l0aFZhbHVlcyk7XG4gIGNvbnN0IFtjdXJyZW50VmFyaWFudCwgc2V0Q3VycmVudFZhcmlhbnRdID0gdXNlU3RhdGUoXG4gICAgcHJvZHVjdC52YXJpYW50cy5maW5kKFxuICAgICAgKHZhcmlhbnQpID0+XG4gICAgICAgIHZhcmlhbnQuaWQgPT09IHBhcnNlSW50KGRhdGFTZWxlY3RlZE9yRmlyc3RBdmFpbGFibGVWYXJpYW50LCAxMClcbiAgICApXG4gICk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZSgnc3VzcGVuZGVkJyk7IC8vIHRoZXJlIHNob3VsZCBiZSBmb3VyIGtpbmRzIG9mIHN0YXR1cywgc3VzcGVuZGVkLCBsb2FkaW5nLCBzdWNjZXNzLCBlcnJvclxuICBjb25zdCBbZXJyb3JEZXNjcmlwdGlvbiwgc2V0RXJyb3JEZXNjcmlwdGlvbl0gPSB1c2VTdGF0ZSgnJyk7XG5cbiAgY29uc3QgaGFuZGxlT3B0aW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgIGNvbnN0IGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICBjb25zdCBvcHRpb24xID1cbiAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0W2RhdGEtb3B0aW9uPVwib3B0aW9uMVwiXScpICYmXG4gICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdFtkYXRhLW9wdGlvbj1cIm9wdGlvbjFcIl0nKS52YWx1ZTtcbiAgICBjb25zdCBvcHRpb24yID1cbiAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0W2RhdGEtb3B0aW9uPVwib3B0aW9uMlwiXScpICYmXG4gICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdFtkYXRhLW9wdGlvbj1cIm9wdGlvbjJcIl0nKS52YWx1ZTtcbiAgICBjb25zdCBvcHRpb24zID1cbiAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0W2RhdGEtb3B0aW9uPVwib3B0aW9uM1wiXScpICYmXG4gICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdFtkYXRhLW9wdGlvbj1cIm9wdGlvbjNcIl0nKS52YWx1ZTtcbiAgICBjb25zdCBjVmFyaWFudCA9IHByb2R1Y3QudmFyaWFudHMuZmluZChcbiAgICAgICh2YXJpYW50KSA9PlxuICAgICAgICB2YXJpYW50Lm9wdGlvbjEgPT09IG9wdGlvbjEgJiZcbiAgICAgICAgdmFyaWFudC5vcHRpb24yID09PSBvcHRpb24yICYmXG4gICAgICAgIHZhcmlhbnQub3B0aW9uMyA9PT0gb3B0aW9uM1xuICAgICk7XG5cbiAgICBzZXRDdXJyZW50VmFyaWFudChjVmFyaWFudCk7XG5cbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50KGZvcm0sICd2YXJpYW50Y2hhbmdlZCcsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGRldGFpbDogeyBjdXJyZW50VmFyaWFudDogY1ZhcmlhbnQsIGZvcm1hdE1vbmV5IH0sXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQVRDQnV0dG9uQ2xpY2sgPSAoZSkgPT4ge1xuICAgIGlmICh0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5pZCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgZm9ybSA9IHRoaXMuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgc2V0U3RhdHVzKCdsb2FkaW5nJyk7XG4gICAgICBhZGRJdGVtRnJvbUZvcm0oZm9ybSkudGhlbigoYWRkZWRJdGVtKSA9PiB7XG4gICAgICAgIGlmIChhZGRlZEl0ZW0uaWQpIHtcbiAgICAgICAgICBzZXRTdGF0dXMoJ3N1Y2Nlc3MnKTtcbiAgICAgICAgICBnZXRDYXJ0KCkudGhlbigoY2FydCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudChmb3JtLCAnY2FydHVwZGF0ZWQnLCB7XG4gICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICAgICAgICBkZXRhaWw6IHsgY2FydCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0dXMoJ3N1c3BlbmRlZCcpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFkZGVkSXRlbS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgIHNldFN0YXR1cygnZXJyb3InKTtcbiAgICAgICAgICBzZXRFcnJvckRlc2NyaXB0aW9uKGFkZGVkSXRlbS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRFcnJvckRlc2NyaXB0aW9uKCcnKTtcbiAgICAgICAgICAgIHNldFN0YXR1cygnc3VzcGVuZGVkJyk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gaHRtbGA8aW5wdXRcbiAgICAgIG5hbWU9XCJpZFwiXG4gICAgICB2YWx1ZT1cIiR7Y3VycmVudFZhcmlhbnQgJiYgY3VycmVudFZhcmlhbnQuaWR9XCJcbiAgICAgIHR5cGU9XCJoaWRkZW5cIlxuICAgIC8+XG4gICAgJHtvcHRpb25zV2l0aFZhbHVlcy5tYXAoXG4gICAgICAob3B0aW9uKSA9PlxuICAgICAgICBodG1sYDxkaXZcbiAgICAgICAgICBjbGFzcz1cInNlbGVjdG9yLXdyYXBwZXIgZm9ybS1ncm91cCAke3NlbGVjdG9yV3JhcHBlckN1c3RvbUNsYXNzZXN9XCJcbiAgICAgICAgICA/aGlkZGVuPSR7b3B0aW9uLm5hbWUgPT09ICdUaXRsZScgJiZcbiAgICAgICAgICBvcHRpb24udmFsdWVzWzBdID09PSAnRGVmYXVsdCBUaXRsZSd9XG4gICAgICAgID5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCIke3NlbGVjdG9yTGFiZWxDdXN0b21DbGFzc2VzfVwiIGZvcj1cIiR7b3B0aW9uLm5hbWV9XCJcbiAgICAgICAgICAgID4ke29wdGlvbi5uYW1lfTo8L2xhYmVsXG4gICAgICAgICAgPlxuICAgICAgICAgIDxzZWxlY3RcbiAgICAgICAgICAgIGlkPVwiJHtvcHRpb24ubmFtZX1cIlxuICAgICAgICAgICAgZGF0YS1vcHRpb249XCJvcHRpb24ke29wdGlvbi5wb3NpdGlvbn1cIlxuICAgICAgICAgICAgQGNoYW5nZT0ke2hhbmRsZU9wdGlvbkNoYW5nZX1cbiAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sICR7c2VsZWN0b3JDdXN0b21DbGFzc2VzfVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgJHtvcHRpb24udmFsdWVzLm1hcChcbiAgICAgICAgICAgICAgKHZhbHVlKSA9PlxuICAgICAgICAgICAgICAgIGh0bWxgPG9wdGlvblxuICAgICAgICAgICAgICAgICAgdmFsdWU9XCIke3ZhbHVlfVwiXG4gICAgICAgICAgICAgICAgICA/c2VsZWN0ZWQ9JHtjdXJyZW50VmFyaWFudCAmJlxuICAgICAgICAgICAgICAgICAgY3VycmVudFZhcmlhbnRbYG9wdGlvbiR7b3B0aW9uLnBvc2l0aW9ufWBdID09PSB2YWx1ZX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAke3ZhbHVlfVxuICAgICAgICAgICAgICAgIDwvb3B0aW9uPmBcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PmBcbiAgICApfVxuICAgIDxpbnB1dFxuICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgcXVhbnRpdHlfaW5wdXQgJHtxdWFudGl0eUlucHV0Q3VzdG9tQ2xhc3Nlc31cIlxuICAgICAgbmFtZT1cInF1YW50aXR5XCJcbiAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgdmFsdWU9XCIxXCJcbiAgICAgIHN0ZXA9XCIxXCJcbiAgICAvPlxuICAgIDxidXR0b25cbiAgICAgID9kaXNhYmxlZD0keyFjdXJyZW50VmFyaWFudCB8fCAhY3VycmVudFZhcmlhbnQuYXZhaWxhYmxlfVxuICAgICAgQGNsaWNrPSR7aGFuZGxlQVRDQnV0dG9uQ2xpY2t9XG4gICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgIG5hbWU9XCJhZGRcIlxuICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgQWRkVG9DYXJ0IGJ0biAke2F0Y0J1dHRvbkN1c3RvbUNsYXNzZXN9XCJcbiAgICA+XG4gICAgICA8c3BhbiBjbGFzcz1cIkFkZFRvQ2FydFRleHRcIlxuICAgICAgICA+JHtjdXJyZW50VmFyaWFudCAmJiAhY3VycmVudFZhcmlhbnQuYXZhaWxhYmxlXG4gICAgICAgICAgPyBodG1sYE5vdCBBdmFpbGFibGVgXG4gICAgICAgICAgOiBzdGF0dXMgPT09ICdzdXNwZW5kZWQnXG4gICAgICAgICAgPyBodG1sYEFkZCBUbyBDYXJ0YFxuICAgICAgICAgIDogc3RhdHVzID09PSAnbG9hZGluZydcbiAgICAgICAgICA/IGh0bWxgPHNwYW4gY2xhc3M9XCJzcGlubmVyLWJvcmRlclwiPjwvc3Bhbj5gXG4gICAgICAgICAgOiBzdGF0dXMgPT09ICdzdWNjZXNzJ1xuICAgICAgICAgID8gaHRtbGBBZGRlZGBcbiAgICAgICAgICA6IGh0bWxgYH08L3NwYW5cbiAgICAgID5cbiAgICA8L2J1dHRvbj5cbiAgICA8ZGl2IGNsYXNzPVwiZXJyb3ItZGVzY3JpcHRpb25cIiA/aGlkZGVuPSR7ZXJyb3JEZXNjcmlwdGlvbiA9PT0gJyd9PlxuICAgICAgJHtlcnJvckRlc2NyaXB0aW9ufVxuICAgIDwvZGl2PmA7XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgJ2F0Yy1kcm9wZG93bi1pbnB1dHMnLFxuICBjb21wb25lbnQoYXRjRHJvcGRvd25JbnB1dHMsIHtcbiAgICB1c2VTaGFkb3dET006IGZhbHNlLFxuICAgIG9ic2VydmVkQXR0cmlidXRlczogW1xuICAgICAgJ2RhdGEtcHJvZHVjdCcsXG4gICAgICAnZGF0YS1zZWxlY3RlZC1vci1maXJzdC1hdmFpbGFibGUtdmFyaWFudCcsXG4gICAgICAnZGF0YS1vcHRpb25zLXdpdGgtdmFsdWVzJyxcbiAgICAgICdzZWxlY3Rvci13cmFwcGVyLWN1c3RvbS1jbGFzc2VzJyxcbiAgICAgICdzZWxlY3Rvci1sYWJlbC1jdXN0b20tY2xhc3NlcycsXG4gICAgICAnc2VsZWN0b3ItY3VzdG9tLWNsYXNzZXMnLFxuICAgICAgJ3F1YW50aXR5LWlucHV0LWN1c3RvbS1jbGFzc2VzJyxcbiAgICAgICdhdGMtYnV0dG9uLWN1c3RvbS1jbGFzc2VzJyxcbiAgICBdLFxuICB9KVxuKTtcbiIsImltcG9ydCBCU04gZnJvbSAnYm9vdHN0cmFwLm5hdGl2ZSc7XG5pbXBvcnQgYXBpcyBmcm9tICcuL2FqYXhhcGlzJztcbmltcG9ydCAnLi9zZWN0aW9ucy90ZXN0aW1vbmlhbHMnO1xuaW1wb3J0ICcuL3NlY3Rpb25zL2hlYWRlcic7XG5pbXBvcnQgJy4vc2VjdGlvbnMvbWFzb25yeS1nYWxsZXJ5JztcbmltcG9ydCAnLi9jb21wb25lbnRzL3ByZWRpY3RpdmUtc2VhcmNoJztcbmltcG9ydCAnLi9jb21wb25lbnRzL2F0Yy1kcm9wZG93bi1pbnB1dHMnO1xuXG53aW5kb3cuZGF0b21hciA9IHtcbiAgQlNOLFxuICBhcGlzLFxufTtcbiJdLCJuYW1lcyI6WyJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJkb2N1bWVudCIsImhlYWQiLCJzdHlsZSIsInN1cHBvcnRUcmFuc2l0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiZ2V0RWxlbWVudFRyYW5zaXRpb25EdXJhdGlvbiIsImVsZW1lbnQiLCJkdXJhdGlvbiIsInBhcnNlRmxvYXQiLCJnZXRDb21wdXRlZFN0eWxlIiwiaXNOYU4iLCJlbXVsYXRlVHJhbnNpdGlvbkVuZCIsImhhbmRsZXIiLCJjYWxsZWQiLCJhZGRFdmVudExpc3RlbmVyIiwidHJhbnNpdGlvbkVuZFdyYXBwZXIiLCJlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJxdWVyeUVsZW1lbnQiLCJzZWxlY3RvciIsInBhcmVudCIsImxvb2tVcCIsIkVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiYm9vdHN0cmFwQ3VzdG9tRXZlbnQiLCJldmVudE5hbWUiLCJjb21wb25lbnROYW1lIiwicmVsYXRlZCIsIk9yaWdpbmFsQ3VzdG9tRXZlbnQiLCJDdXN0b21FdmVudCIsImNhbmNlbGFibGUiLCJyZWxhdGVkVGFyZ2V0IiwiZGlzcGF0Y2hDdXN0b21FdmVudCIsImN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIkFsZXJ0Iiwic2VsZiIsImFsZXJ0IiwiY2xvc2VDdXN0b21FdmVudCIsImNsb3NlZEN1c3RvbUV2ZW50IiwidHJpZ2dlckhhbmRsZXIiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsInRyYW5zaXRpb25FbmRIYW5kbGVyIiwidG9nZ2xlRXZlbnRzIiwiYWN0aW9uIiwiY2xpY2tIYW5kbGVyIiwidGFyZ2V0IiwiY2xvc2VzdCIsImNsb3NlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY2FsbCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJkaXNwb3NlIiwicmVtb3ZlIiwiQnV0dG9uIiwibGFiZWxzIiwiY2hhbmdlQ3VzdG9tRXZlbnQiLCJ0b2dnbGUiLCJpbnB1dCIsImxhYmVsIiwidGFnTmFtZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwidHlwZSIsImNoZWNrZWQiLCJhZGQiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJ0b2dnbGVkIiwic2NyZWVuWCIsInNjcmVlblkiLCJBcnJheSIsImZyb20iLCJtYXAiLCJvdGhlckxhYmVsIiwib3RoZXJJbnB1dCIsImtleUhhbmRsZXIiLCJrZXkiLCJ3aGljaCIsImtleUNvZGUiLCJhY3RpdmVFbGVtZW50IiwicHJldmVudFNjcm9sbCIsInByZXZlbnREZWZhdWx0IiwiZm9jdXNUb2dnbGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwibGVuZ3RoIiwiYnRuIiwibW91c2VIb3ZlckV2ZW50cyIsInN1cHBvcnRQYXNzaXZlIiwicmVzdWx0Iiwib3B0cyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwid3JhcCIsInBhc3NpdmVIYW5kbGVyIiwicGFzc2l2ZSIsImlzRWxlbWVudEluU2Nyb2xsUmFuZ2UiLCJiY3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ2aWV3cG9ydEhlaWdodCIsIndpbmRvdyIsImlubmVySGVpZ2h0IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50SGVpZ2h0IiwidG9wIiwiYm90dG9tIiwiQ2Fyb3VzZWwiLCJvcHRpb25zIiwidmFycyIsIm9wcyIsInNsaWRlQ3VzdG9tRXZlbnQiLCJzbGlkQ3VzdG9tRXZlbnQiLCJzbGlkZXMiLCJsZWZ0QXJyb3ciLCJyaWdodEFycm93IiwiaW5kaWNhdG9yIiwiaW5kaWNhdG9ycyIsInBhdXNlSGFuZGxlciIsImludGVydmFsIiwiaXNTbGlkaW5nIiwiY2xlYXJJbnRlcnZhbCIsInRpbWVyIiwicmVzdW1lSGFuZGxlciIsImN5Y2xlIiwiaW5kaWNhdG9ySGFuZGxlciIsImV2ZW50VGFyZ2V0IiwiaW5kZXgiLCJwYXJzZUludCIsInNsaWRlVG8iLCJjb250cm9sc0hhbmRsZXIiLCJjdXJyZW50VGFyZ2V0Iiwic3JjRWxlbWVudCIsInJlZiIsInBhdXNlIiwidG91Y2giLCJ0b3VjaERvd25IYW5kbGVyIiwia2V5Ym9hcmQiLCJ0b2dnbGVUb3VjaEV2ZW50cyIsInRvdWNoTW92ZUhhbmRsZXIiLCJ0b3VjaEVuZEhhbmRsZXIiLCJpc1RvdWNoIiwidG91Y2hQb3NpdGlvbiIsInN0YXJ0WCIsImNoYW5nZWRUb3VjaGVzIiwicGFnZVgiLCJjdXJyZW50WCIsImVuZFgiLCJNYXRoIiwiYWJzIiwic2V0QWN0aXZlUGFnZSIsInBhZ2VJbmRleCIsIngiLCJuZXh0IiwidGltZW91dCIsImVsYXBzZWRUaW1lIiwiYWN0aXZlSXRlbSIsImdldEFjdGl2ZUluZGV4Iiwib3JpZW50YXRpb24iLCJkaXJlY3Rpb24iLCJoaWRkZW4iLCJzZXRJbnRlcnZhbCIsImlkeCIsIm9mZnNldFdpZHRoIiwiaW5kZXhPZiIsIml0ZW1DbGFzc2VzIiwic2xpZGUiLCJjbHMiLCJpbnRlcnZhbEF0dHJpYnV0ZSIsImludGVydmFsRGF0YSIsInRvdWNoRGF0YSIsInBhdXNlRGF0YSIsImtleWJvYXJkRGF0YSIsImludGVydmFsT3B0aW9uIiwidG91Y2hPcHRpb24iLCJDb2xsYXBzZSIsImFjY29yZGlvbiIsImNvbGxhcHNlIiwiYWN0aXZlQ29sbGFwc2UiLCJzaG93Q3VzdG9tRXZlbnQiLCJzaG93bkN1c3RvbUV2ZW50IiwiaGlkZUN1c3RvbUV2ZW50IiwiaGlkZGVuQ3VzdG9tRXZlbnQiLCJvcGVuQWN0aW9uIiwiY29sbGFwc2VFbGVtZW50IiwiaXNBbmltYXRpbmciLCJoZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJjbG9zZUFjdGlvbiIsInNob3ciLCJoaWRlIiwiaWQiLCJhY2NvcmRpb25EYXRhIiwic2V0Rm9jdXMiLCJmb2N1cyIsInNldEFjdGl2ZSIsIkRyb3Bkb3duIiwib3B0aW9uIiwibWVudSIsIm1lbnVJdGVtcyIsInBlcnNpc3QiLCJwcmV2ZW50RW1wdHlBbmNob3IiLCJhbmNob3IiLCJocmVmIiwic2xpY2UiLCJ0b2dnbGVEaXNtaXNzIiwib3BlbiIsImRpc21pc3NIYW5kbGVyIiwiaGFzRGF0YSIsImlzU2FtZUVsZW1lbnQiLCJpc0luc2lkZU1lbnUiLCJpc01lbnVJdGVtIiwiY2hpbGRyZW4iLCJjaGlsZCIsInB1c2giLCJNb2RhbCIsIm1vZGFsIiwic2Nyb2xsQmFyV2lkdGgiLCJvdmVybGF5Iiwib3ZlcmxheURlbGF5IiwiZml4ZWRJdGVtcyIsInNldFNjcm9sbGJhciIsIm9wZW5Nb2RhbCIsImJvZHkiLCJib2R5UGFkIiwicGFkZGluZ1JpZ2h0IiwiYm9keU92ZXJmbG93IiwibW9kYWxPdmVyZmxvdyIsIm1lYXN1cmVTY3JvbGxiYXIiLCJmaXhlZCIsIml0ZW1QYWQiLCJyZXNldFNjcm9sbGJhciIsInNjcm9sbERpdiIsImNyZWF0ZUVsZW1lbnQiLCJ3aWR0aFZhbHVlIiwiY2xhc3NOYW1lIiwiYXBwZW5kQ2hpbGQiLCJjbGllbnRXaWR0aCIsImNyZWF0ZU92ZXJsYXkiLCJuZXdPdmVybGF5IiwiYW5pbWF0aW9uIiwicmVtb3ZlT3ZlcmxheSIsInVwZGF0ZSIsImJlZm9yZVNob3ciLCJkaXNwbGF5IiwidHJpZ2dlclNob3ciLCJ0cmlnZ2VySGlkZSIsImZvcmNlIiwiY2xpY2tUYXJnZXQiLCJtb2RhbElEIiwidGFyZ2V0QXR0clZhbHVlIiwiZWxlbUF0dHJWYWx1ZSIsIm1vZGFsVHJpZ2dlciIsInBhcmVudFdpdGhEYXRhIiwiYmFja2Ryb3AiLCJjdXJyZW50T3BlbiIsInNldENvbnRlbnQiLCJjb250ZW50IiwiaW5uZXJIVE1MIiwiY2hlY2tNb2RhbCIsImNvbmNhdCIsInRyaW0iLCJtb3VzZUNsaWNrRXZlbnRzIiwiZG93biIsInVwIiwiZ2V0U2Nyb2xsIiwieSIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVhPZmZzZXQiLCJzY3JvbGxMZWZ0Iiwic3R5bGVUaXAiLCJsaW5rIiwicG9zaXRpb24iLCJ0aXBQb3NpdGlvbnMiLCJlbGVtZW50RGltZW5zaW9ucyIsInciLCJoIiwib2Zmc2V0SGVpZ2h0Iiwid2luZG93V2lkdGgiLCJ3aW5kb3dIZWlnaHQiLCJyZWN0Iiwic2Nyb2xsIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsImxpbmtEaW1lbnNpb25zIiwicmlnaHQiLCJsZWZ0IiwiaXNQb3BvdmVyIiwiYXJyb3ciLCJoYWxmVG9wRXhjZWVkIiwiaGFsZkxlZnRFeGNlZWQiLCJoYWxmUmlnaHRFeGNlZWQiLCJoYWxmQm90dG9tRXhjZWVkIiwidG9wRXhjZWVkIiwibGVmdEV4Y2VlZCIsImJvdHRvbUV4Y2VlZCIsInJpZ2h0RXhjZWVkIiwidG9wUG9zaXRpb24iLCJsZWZ0UG9zaXRpb24iLCJhcnJvd1RvcCIsImFycm93TGVmdCIsImFycm93V2lkdGgiLCJhcnJvd0hlaWdodCIsInJlcGxhY2UiLCJQb3BvdmVyIiwicG9wb3ZlciIsImlzSXBob25lIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRpdGxlU3RyaW5nIiwiY29udGVudFN0cmluZyIsInRyaWdnZXJEYXRhIiwiYW5pbWF0aW9uRGF0YSIsInBsYWNlbWVudERhdGEiLCJkaXNtaXNzaWJsZURhdGEiLCJkZWxheURhdGEiLCJjb250YWluZXJEYXRhIiwiY2xvc2VCdG4iLCJjb250YWluZXJFbGVtZW50IiwiY29udGFpbmVyRGF0YUVsZW1lbnQiLCJuYXZiYXJGaXhlZFRvcCIsIm5hdmJhckZpeGVkQm90dG9tIiwicGxhY2VtZW50Q2xhc3MiLCJkaXNtaXNzaWJsZUhhbmRsZXIiLCJnZXRDb250ZW50cyIsInRpdGxlIiwicmVtb3ZlUG9wb3ZlciIsImNvbnRhaW5lciIsImNyZWF0ZVBvcG92ZXIiLCJwb3BvdmVyQXJyb3ciLCJ0ZW1wbGF0ZSIsInBvcG92ZXJUaXRsZSIsImRpc21pc3NpYmxlIiwicG9wb3ZlckJvZHlNYXJrdXAiLCJwb3BvdmVyVGVtcGxhdGUiLCJmaXJzdENoaWxkIiwicG9wb3ZlckhlYWRlciIsInBvcG92ZXJCb2R5Iiwic2hvd1BvcG92ZXIiLCJ1cGRhdGVQb3BvdmVyIiwicGxhY2VtZW50IiwiZm9yY2VGb2N1cyIsInRyaWdnZXIiLCJ0b3VjaEhhbmRsZXIiLCJkaXNtaXNzSGFuZGxlclRvZ2dsZSIsInNob3dUcmlnZ2VyIiwiaGlkZVRyaWdnZXIiLCJjbGVhclRpbWVvdXQiLCJkZWxheSIsInBvcG92ZXJDb250ZW50cyIsIlNjcm9sbFNweSIsInRhcmdldERhdGEiLCJvZmZzZXREYXRhIiwic3B5VGFyZ2V0Iiwic2Nyb2xsVGFyZ2V0IiwidXBkYXRlVGFyZ2V0cyIsImxpbmtzIiwiaXRlbXMiLCJ0YXJnZXRzIiwidGFyZ2V0SXRlbSIsImNoYXJBdCIsInVwZGF0ZUl0ZW0iLCJpdGVtIiwiZHJvcG1lbnUiLCJkcm9wTGluayIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJuZXh0U2libGluZyIsIm5leHRFbGVtZW50U2libGluZyIsImFjdGl2ZVNpYmxpbmciLCJ0YXJnZXRSZWN0IiwiaXNXaW5kb3ciLCJpc0FjdGl2ZSIsInRvcEVkZ2UiLCJzY3JvbGxPZmZzZXQiLCJvZmZzZXQiLCJib3R0b21FZGdlIiwiaW5zaWRlIiwidXBkYXRlSXRlbXMiLCJsIiwicmVmcmVzaCIsIlRhYiIsImhlaWdodERhdGEiLCJ0YWJzIiwiZHJvcGRvd24iLCJ0YWJzQ29udGVudENvbnRhaW5lciIsImFjdGl2ZVRhYiIsImFjdGl2ZUNvbnRlbnQiLCJuZXh0Q29udGVudCIsImNvbnRhaW5lckhlaWdodCIsImVxdWFsQ29udGVudHMiLCJuZXh0SGVpZ2h0IiwiYW5pbWF0ZUhlaWdodCIsInRyaWdnZXJFbmQiLCJnZXRBY3RpdmVUYWIiLCJhY3RpdmVUYWJzIiwiZ2V0QWN0aXZlQ29udGVudCIsIlRvYXN0IiwidG9hc3QiLCJhdXRvaGlkZURhdGEiLCJzaG93Q29tcGxldGUiLCJhdXRvaGlkZSIsImhpZGVDb21wbGV0ZSIsImRpc3Bvc2VDb21wbGV0ZSIsIm5vVGltZXIiLCJUb29sdGlwIiwidG9vbHRpcCIsImdldFRpdGxlIiwicmVtb3ZlVG9vbFRpcCIsImNyZWF0ZVRvb2xUaXAiLCJ0b29sdGlwTWFya3VwIiwidG9vbHRpcEFycm93IiwidG9vbHRpcElubmVyIiwidXBkYXRlVG9vbHRpcCIsInNob3dUb29sdGlwIiwidG9nZ2xlQWN0aW9uIiwic2hvd0FjdGlvbiIsImhpZGVBY3Rpb24iLCJjb21wb25lbnRzSW5pdCIsImluaXRpYWxpemVEYXRhQVBJIiwiQ29uc3RydWN0b3IiLCJjb2xsZWN0aW9uIiwiaW5pdENhbGxiYWNrIiwiY29tcG9uZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImluaXRXcmFwcGVyIiwicmVtb3ZlRWxlbWVudERhdGFBUEkiLCJDb25zdHJ1Y3Rvck5hbWUiLCJyZW1vdmVEYXRhQVBJIiwidmVyc2lvbiIsIlZlcnNpb24iLCJiaW5kIiwiZm4iLCJ0aGlzQXJnIiwiYXJncyIsImFyZ3VtZW50cyIsImkiLCJhcHBseSIsInRvU3RyaW5nIiwicHJvdG90eXBlIiwiaXNBcnJheSIsInZhbCIsImlzVW5kZWZpbmVkIiwiaXNCdWZmZXIiLCJjb25zdHJ1Y3RvciIsImlzQXJyYXlCdWZmZXIiLCJpc0Zvcm1EYXRhIiwiRm9ybURhdGEiLCJpc0FycmF5QnVmZmVyVmlldyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzT2JqZWN0IiwiaXNQbGFpbk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiaXNEYXRlIiwiaXNGaWxlIiwiaXNCbG9iIiwiaXNGdW5jdGlvbiIsImlzU3RyZWFtIiwicGlwZSIsImlzVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic3RyIiwiaXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJwcm9kdWN0IiwiZm9yRWFjaCIsIm9iaiIsImhhc093blByb3BlcnR5IiwibWVyZ2UiLCJhc3NpZ25WYWx1ZSIsImV4dGVuZCIsImEiLCJiIiwic3RyaXBCT00iLCJjaGFyQ29kZUF0IiwiZW5jb2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiYnVpbGRVUkwiLCJ1cmwiLCJwYXJhbXMiLCJwYXJhbXNTZXJpYWxpemVyIiwic2VyaWFsaXplZFBhcmFtcyIsInV0aWxzIiwicGFydHMiLCJzZXJpYWxpemUiLCJwYXJzZVZhbHVlIiwidiIsInRvSVNPU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImpvaW4iLCJoYXNobWFya0luZGV4IiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiaGFuZGxlcnMiLCJ1c2UiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsImVqZWN0IiwiZm9yRWFjaEhhbmRsZXIiLCJ0cmFuc2Zvcm1EYXRhIiwiZGF0YSIsImhlYWRlcnMiLCJmbnMiLCJ0cmFuc2Zvcm0iLCJpc0NhbmNlbCIsInZhbHVlIiwiX19DQU5DRUxfXyIsIm5vcm1hbGl6ZUhlYWRlck5hbWUiLCJub3JtYWxpemVkTmFtZSIsInByb2Nlc3NIZWFkZXIiLCJuYW1lIiwidG9VcHBlckNhc2UiLCJlbmhhbmNlRXJyb3IiLCJlcnJvciIsImNvbmZpZyIsImNvZGUiLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJpc0F4aW9zRXJyb3IiLCJ0b0pTT04iLCJtZXNzYWdlIiwiZGVzY3JpcHRpb24iLCJudW1iZXIiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJzdGFjayIsImNyZWF0ZUVycm9yIiwiRXJyb3IiLCJzZXR0bGUiLCJyZXNvbHZlIiwicmVqZWN0IiwidmFsaWRhdGVTdGF0dXMiLCJzdGF0dXMiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJ3cml0ZSIsImV4cGlyZXMiLCJwYXRoIiwiZG9tYWluIiwic2VjdXJlIiwiY29va2llIiwiRGF0ZSIsInRvR01UU3RyaW5nIiwicmVhZCIsIm1hdGNoIiwiUmVnRXhwIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwibm93Iiwibm9uU3RhbmRhcmRCcm93c2VyRW52IiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwiYmFzZVVSTCIsInJlbGF0aXZlVVJMIiwiYnVpbGRGdWxsUGF0aCIsInJlcXVlc3RlZFVSTCIsImlnbm9yZUR1cGxpY2F0ZU9mIiwicGFyc2VIZWFkZXJzIiwicGFyc2VkIiwic3BsaXQiLCJwYXJzZXIiLCJsaW5lIiwic3Vic3RyIiwidG9Mb3dlckNhc2UiLCJtc2llIiwidXJsUGFyc2luZ05vZGUiLCJvcmlnaW5VUkwiLCJyZXNvbHZlVVJMIiwicHJvdG9jb2wiLCJob3N0Iiwic2VhcmNoIiwiaGFzaCIsImhvc3RuYW1lIiwicG9ydCIsInBhdGhuYW1lIiwibG9jYXRpb24iLCJpc1VSTFNhbWVPcmlnaW4iLCJyZXF1ZXN0VVJMIiwieGhyQWRhcHRlciIsIlByb21pc2UiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZXF1ZXN0RGF0YSIsInJlcXVlc3RIZWFkZXJzIiwiWE1MSHR0cFJlcXVlc3QiLCJhdXRoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInVuZXNjYXBlIiwiQXV0aG9yaXphdGlvbiIsImJ0b2EiLCJmdWxsUGF0aCIsIm1ldGhvZCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJzdGF0dXNUZXh0Iiwib25hYm9ydCIsImhhbmRsZUFib3J0Iiwib25lcnJvciIsImhhbmRsZUVycm9yIiwib250aW1lb3V0IiwiaGFuZGxlVGltZW91dCIsInRpbWVvdXRFcnJvck1lc3NhZ2UiLCJ4c3JmVmFsdWUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ4c3JmQ29va2llTmFtZSIsImNvb2tpZXMiLCJ1bmRlZmluZWQiLCJ4c3JmSGVhZGVyTmFtZSIsInNldFJlcXVlc3RIZWFkZXIiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJvblVwbG9hZFByb2dyZXNzIiwidXBsb2FkIiwiY2FuY2VsVG9rZW4iLCJwcm9taXNlIiwidGhlbiIsIm9uQ2FuY2VsZWQiLCJjYW5jZWwiLCJhYm9ydCIsInNlbmQiLCJERUZBVUxUX0NPTlRFTlRfVFlQRSIsInNldENvbnRlbnRUeXBlSWZVbnNldCIsImdldERlZmF1bHRBZGFwdGVyIiwiYWRhcHRlciIsInJlcXVpcmUkJDAiLCJwcm9jZXNzIiwicmVxdWlyZSQkMSIsImRlZmF1bHRzIiwidHJhbnNmb3JtUmVxdWVzdCIsInRyYW5zZm9ybVJlc3BvbnNlIiwicGFyc2UiLCJtYXhDb250ZW50TGVuZ3RoIiwibWF4Qm9keUxlbmd0aCIsImNvbW1vbiIsImZvckVhY2hNZXRob2ROb0RhdGEiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwidGhyb3dJZlJlcXVlc3RlZCIsImRpc3BhdGNoUmVxdWVzdCIsImNsZWFuSGVhZGVyQ29uZmlnIiwib25BZGFwdGVyUmVzb2x1dGlvbiIsIm9uQWRhcHRlclJlamVjdGlvbiIsInJlYXNvbiIsIm1lcmdlQ29uZmlnIiwiY29uZmlnMSIsImNvbmZpZzIiLCJ2YWx1ZUZyb21Db25maWcyS2V5cyIsIm1lcmdlRGVlcFByb3BlcnRpZXNLZXlzIiwiZGVmYXVsdFRvQ29uZmlnMktleXMiLCJkaXJlY3RNZXJnZUtleXMiLCJnZXRNZXJnZWRWYWx1ZSIsInNvdXJjZSIsIm1lcmdlRGVlcFByb3BlcnRpZXMiLCJwcm9wIiwidmFsdWVGcm9tQ29uZmlnMiIsImRlZmF1bHRUb0NvbmZpZzIiLCJheGlvc0tleXMiLCJvdGhlcktleXMiLCJrZXlzIiwiZmlsdGVyIiwiZmlsdGVyQXhpb3NLZXlzIiwiQXhpb3MiLCJpbnN0YW5jZUNvbmZpZyIsImludGVyY2VwdG9ycyIsImNoYWluIiwidW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvciIsInVuc2hpZnQiLCJwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMiLCJzaGlmdCIsImdldFVyaSIsIkNhbmNlbCIsIkNhbmNlbFRva2VuIiwiZXhlY3V0b3IiLCJUeXBlRXJyb3IiLCJyZXNvbHZlUHJvbWlzZSIsInByb21pc2VFeGVjdXRvciIsInRva2VuIiwiYyIsInNwcmVhZCIsImNhbGxiYWNrIiwiYXJyIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwiY29udGV4dCIsImluc3RhbmNlIiwiYXhpb3MiLCJjcmVhdGUiLCJyZXF1aXJlJCQyIiwiYWxsIiwicHJvbWlzZXMiLCJyZXF1aXJlJCQzIiwiVkVSU0lPTiIsIkxBUkdFX0FSUkFZX1NJWkUiLCJDT1JFX0VSUk9SX1RFWFQiLCJGVU5DX0VSUk9SX1RFWFQiLCJIQVNIX1VOREVGSU5FRCIsIk1BWF9NRU1PSVpFX1NJWkUiLCJQTEFDRUhPTERFUiIsIkNMT05FX0RFRVBfRkxBRyIsIkNMT05FX0ZMQVRfRkxBRyIsIkNMT05FX1NZTUJPTFNfRkxBRyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsIldSQVBfQklORF9GTEFHIiwiV1JBUF9CSU5EX0tFWV9GTEFHIiwiV1JBUF9DVVJSWV9CT1VORF9GTEFHIiwiV1JBUF9DVVJSWV9GTEFHIiwiV1JBUF9DVVJSWV9SSUdIVF9GTEFHIiwiV1JBUF9QQVJUSUFMX0ZMQUciLCJXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyIsIldSQVBfQVJZX0ZMQUciLCJXUkFQX1JFQVJHX0ZMQUciLCJXUkFQX0ZMSVBfRkxBRyIsIkRFRkFVTFRfVFJVTkNfTEVOR1RIIiwiREVGQVVMVF9UUlVOQ19PTUlTU0lPTiIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwiTEFaWV9GSUxURVJfRkxBRyIsIkxBWllfTUFQX0ZMQUciLCJMQVpZX1dISUxFX0ZMQUciLCJJTkZJTklUWSIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNQVhfSU5URUdFUiIsIk5BTiIsIk1BWF9BUlJBWV9MRU5HVEgiLCJNQVhfQVJSQVlfSU5ERVgiLCJIQUxGX01BWF9BUlJBWV9MRU5HVEgiLCJ3cmFwRmxhZ3MiLCJhcmdzVGFnIiwiYXJyYXlUYWciLCJhc3luY1RhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZG9tRXhjVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwibnVsbFRhZyIsIm9iamVjdFRhZyIsInByb21pc2VUYWciLCJwcm94eVRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsInN5bWJvbFRhZyIsInVuZGVmaW5lZFRhZyIsIndlYWtNYXBUYWciLCJ3ZWFrU2V0VGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInJlRW1wdHlTdHJpbmdMZWFkaW5nIiwicmVFbXB0eVN0cmluZ01pZGRsZSIsInJlRW1wdHlTdHJpbmdUcmFpbGluZyIsInJlRXNjYXBlZEh0bWwiLCJyZVVuZXNjYXBlZEh0bWwiLCJyZUhhc0VzY2FwZWRIdG1sIiwicmVIYXNVbmVzY2FwZWRIdG1sIiwicmVFc2NhcGUiLCJyZUV2YWx1YXRlIiwicmVJbnRlcnBvbGF0ZSIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJyZVByb3BOYW1lIiwicmVSZWdFeHBDaGFyIiwicmVIYXNSZWdFeHBDaGFyIiwicmVUcmltIiwicmVUcmltU3RhcnQiLCJyZVRyaW1FbmQiLCJyZVdyYXBDb21tZW50IiwicmVXcmFwRGV0YWlscyIsInJlU3BsaXREZXRhaWxzIiwicmVBc2NpaVdvcmQiLCJyZUVzY2FwZUNoYXIiLCJyZUVzVGVtcGxhdGUiLCJyZUZsYWdzIiwicmVJc0JhZEhleCIsInJlSXNCaW5hcnkiLCJyZUlzSG9zdEN0b3IiLCJyZUlzT2N0YWwiLCJyZUlzVWludCIsInJlTGF0aW4iLCJyZU5vTWF0Y2giLCJyZVVuZXNjYXBlZFN0cmluZyIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc0RpbmdiYXRSYW5nZSIsInJzTG93ZXJSYW5nZSIsInJzTWF0aE9wUmFuZ2UiLCJyc05vbkNoYXJSYW5nZSIsInJzUHVuY3R1YXRpb25SYW5nZSIsInJzU3BhY2VSYW5nZSIsInJzVXBwZXJSYW5nZSIsInJzVmFyUmFuZ2UiLCJyc0JyZWFrUmFuZ2UiLCJyc0Fwb3MiLCJyc0FzdHJhbCIsInJzQnJlYWsiLCJyc0NvbWJvIiwicnNEaWdpdHMiLCJyc0RpbmdiYXQiLCJyc0xvd2VyIiwicnNNaXNjIiwicnNGaXR6IiwicnNNb2RpZmllciIsInJzTm9uQXN0cmFsIiwicnNSZWdpb25hbCIsInJzU3VyclBhaXIiLCJyc1VwcGVyIiwicnNaV0oiLCJyc01pc2NMb3dlciIsInJzTWlzY1VwcGVyIiwicnNPcHRDb250ckxvd2VyIiwicnNPcHRDb250clVwcGVyIiwicmVPcHRNb2QiLCJyc09wdFZhciIsInJzT3B0Sm9pbiIsInJzT3JkTG93ZXIiLCJyc09yZFVwcGVyIiwicnNTZXEiLCJyc0Vtb2ppIiwicnNTeW1ib2wiLCJyZUFwb3MiLCJyZUNvbWJvTWFyayIsInJlVW5pY29kZSIsInJlVW5pY29kZVdvcmQiLCJyZUhhc1VuaWNvZGUiLCJyZUhhc1VuaWNvZGVXb3JkIiwiY29udGV4dFByb3BzIiwidGVtcGxhdGVDb3VudGVyIiwidHlwZWRBcnJheVRhZ3MiLCJjbG9uZWFibGVUYWdzIiwiZGVidXJyZWRMZXR0ZXJzIiwiaHRtbEVzY2FwZXMiLCJodG1sVW5lc2NhcGVzIiwic3RyaW5nRXNjYXBlcyIsImZyZWVQYXJzZUZsb2F0IiwiZnJlZVBhcnNlSW50IiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwibm9kZUlzQXJyYXlCdWZmZXIiLCJub2RlSXNEYXRlIiwibm9kZUlzTWFwIiwiaXNNYXAiLCJub2RlSXNSZWdFeHAiLCJpc1JlZ0V4cCIsIm5vZGVJc1NldCIsImlzU2V0Iiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImZ1bmMiLCJhcnJheUFnZ3JlZ2F0b3IiLCJhcnJheSIsInNldHRlciIsIml0ZXJhdGVlIiwiYWNjdW11bGF0b3IiLCJhcnJheUVhY2giLCJhcnJheUVhY2hSaWdodCIsImFycmF5RXZlcnkiLCJwcmVkaWNhdGUiLCJhcnJheUZpbHRlciIsInJlc0luZGV4IiwiYXJyYXlJbmNsdWRlcyIsImJhc2VJbmRleE9mIiwiYXJyYXlJbmNsdWRlc1dpdGgiLCJjb21wYXJhdG9yIiwiYXJyYXlNYXAiLCJhcnJheVB1c2giLCJ2YWx1ZXMiLCJhcnJheVJlZHVjZSIsImluaXRBY2N1bSIsImFycmF5UmVkdWNlUmlnaHQiLCJhcnJheVNvbWUiLCJhc2NpaVNpemUiLCJiYXNlUHJvcGVydHkiLCJhc2NpaVRvQXJyYXkiLCJzdHJpbmciLCJhc2NpaVdvcmRzIiwiYmFzZUZpbmRLZXkiLCJlYWNoRnVuYyIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJmcm9tUmlnaHQiLCJzdHJpY3RJbmRleE9mIiwiYmFzZUlzTmFOIiwiYmFzZUluZGV4T2ZXaXRoIiwiYmFzZU1lYW4iLCJiYXNlU3VtIiwib2JqZWN0IiwiYmFzZVByb3BlcnR5T2YiLCJiYXNlUmVkdWNlIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVyIiwic29ydCIsImN1cnJlbnQiLCJiYXNlVGltZXMiLCJuIiwiYmFzZVRvUGFpcnMiLCJwcm9wcyIsImJhc2VVbmFyeSIsImJhc2VWYWx1ZXMiLCJjYWNoZUhhcyIsImNhY2hlIiwiaGFzIiwiY2hhcnNTdGFydEluZGV4Iiwic3RyU3ltYm9scyIsImNoclN5bWJvbHMiLCJjaGFyc0VuZEluZGV4IiwiY291bnRIb2xkZXJzIiwicGxhY2Vob2xkZXIiLCJkZWJ1cnJMZXR0ZXIiLCJlc2NhcGVIdG1sQ2hhciIsImVzY2FwZVN0cmluZ0NoYXIiLCJjaHIiLCJnZXRWYWx1ZSIsImhhc1VuaWNvZGUiLCJoYXNVbmljb2RlV29yZCIsIml0ZXJhdG9yVG9BcnJheSIsIml0ZXJhdG9yIiwiZG9uZSIsIm1hcFRvQXJyYXkiLCJzaXplIiwib3ZlckFyZyIsImFyZyIsInJlcGxhY2VIb2xkZXJzIiwic2V0VG9BcnJheSIsInNldCIsInNldFRvUGFpcnMiLCJzdHJpY3RMYXN0SW5kZXhPZiIsInN0cmluZ1NpemUiLCJ1bmljb2RlU2l6ZSIsInN0cmluZ1RvQXJyYXkiLCJ1bmljb2RlVG9BcnJheSIsInVuZXNjYXBlSHRtbENoYXIiLCJsYXN0SW5kZXgiLCJ1bmljb2RlV29yZHMiLCJydW5JbkNvbnRleHQiLCJfIiwicGljayIsIlN0cmluZyIsImFycmF5UHJvdG8iLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byIsImNvcmVKc0RhdGEiLCJmdW5jVG9TdHJpbmciLCJpZENvdW50ZXIiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsIklFX1BST1RPIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJvYmplY3RDdG9yU3RyaW5nIiwib2xkRGFzaCIsInJlSXNOYXRpdmUiLCJCdWZmZXIiLCJTeW1ib2wiLCJVaW50OEFycmF5IiwiYWxsb2NVbnNhZmUiLCJnZXRQcm90b3R5cGUiLCJvYmplY3RDcmVhdGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInNwbGljZSIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJzeW1JdGVyYXRvciIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXROYXRpdmUiLCJjdHhDbGVhclRpbWVvdXQiLCJjdHhOb3ciLCJjdHhTZXRUaW1lb3V0IiwibmF0aXZlQ2VpbCIsImNlaWwiLCJuYXRpdmVGbG9vciIsImZsb29yIiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm5hdGl2ZUlzQnVmZmVyIiwibmF0aXZlSXNGaW5pdGUiLCJpc0Zpbml0ZSIsIm5hdGl2ZUpvaW4iLCJuYXRpdmVLZXlzIiwibmF0aXZlTWF4IiwibWF4IiwibmF0aXZlTWluIiwibWluIiwibmF0aXZlTm93IiwibmF0aXZlUGFyc2VJbnQiLCJuYXRpdmVSYW5kb20iLCJyYW5kb20iLCJuYXRpdmVSZXZlcnNlIiwicmV2ZXJzZSIsIkRhdGFWaWV3IiwiTWFwIiwiU2V0IiwiV2Vha01hcCIsIm5hdGl2ZUNyZWF0ZSIsIm1ldGFNYXAiLCJyZWFsTmFtZXMiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJ0b1NvdXJjZSIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJzeW1ib2xUb1N0cmluZyIsImxvZGFzaCIsImlzT2JqZWN0TGlrZSIsIkxhenlXcmFwcGVyIiwiTG9kYXNoV3JhcHBlciIsIndyYXBwZXJDbG9uZSIsImJhc2VDcmVhdGUiLCJwcm90byIsImJhc2VMb2Rhc2giLCJjaGFpbkFsbCIsIl9fd3JhcHBlZF9fIiwiX19hY3Rpb25zX18iLCJfX2NoYWluX18iLCJfX2luZGV4X18iLCJfX3ZhbHVlc19fIiwidGVtcGxhdGVTZXR0aW5ncyIsIl9fZGlyX18iLCJfX2ZpbHRlcmVkX18iLCJfX2l0ZXJhdGVlc19fIiwiX190YWtlQ291bnRfXyIsIl9fdmlld3NfXyIsImxhenlDbG9uZSIsImNvcHlBcnJheSIsImxhenlSZXZlcnNlIiwiY2xvbmUiLCJsYXp5VmFsdWUiLCJkaXIiLCJpc0FyciIsImlzUmlnaHQiLCJhcnJMZW5ndGgiLCJ2aWV3IiwiZ2V0VmlldyIsInN0YXJ0IiwiZW5kIiwiaXRlcmF0ZWVzIiwiaXRlckxlbmd0aCIsInRha2VDb3VudCIsImJhc2VXcmFwcGVyVmFsdWUiLCJvdXRlciIsIml0ZXJJbmRleCIsImNvbXB1dGVkIiwiSGFzaCIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5IiwiaGFzaENsZWFyIiwiX19kYXRhX18iLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiTGlzdENhY2hlIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJhc3NvY0luZGV4T2YiLCJwb3AiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJNYXBDYWNoZSIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsImdldE1hcERhdGEiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJTZXRDYWNoZSIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJTdGFjayIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsInBhaXJzIiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJnIiwiaXNBcmd1bWVudHMiLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsImlzSW5kZXgiLCJhcnJheVNhbXBsZSIsImJhc2VSYW5kb20iLCJhcnJheVNhbXBsZVNpemUiLCJzaHVmZmxlU2VsZiIsImJhc2VDbGFtcCIsImFycmF5U2h1ZmZsZSIsImFzc2lnbk1lcmdlVmFsdWUiLCJlcSIsImJhc2VBc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiYmFzZUFnZ3JlZ2F0b3IiLCJiYXNlRWFjaCIsImJhc2VBc3NpZ24iLCJjb3B5T2JqZWN0IiwiYmFzZUFzc2lnbkluIiwia2V5c0luIiwiYmFzZUF0IiwicGF0aHMiLCJza2lwIiwibG93ZXIiLCJ1cHBlciIsImJhc2VDbG9uZSIsImJpdG1hc2siLCJjdXN0b21pemVyIiwiaXNEZWVwIiwiaXNGbGF0IiwiaXNGdWxsIiwiaW5pdENsb25lQXJyYXkiLCJ0YWciLCJnZXRUYWciLCJpc0Z1bmMiLCJjbG9uZUJ1ZmZlciIsImluaXRDbG9uZU9iamVjdCIsImNvcHlTeW1ib2xzSW4iLCJjb3B5U3ltYm9scyIsImluaXRDbG9uZUJ5VGFnIiwic3RhY2tlZCIsInN1YlZhbHVlIiwia2V5c0Z1bmMiLCJnZXRBbGxLZXlzSW4iLCJnZXRBbGxLZXlzIiwiYmFzZUNvbmZvcm1zIiwiYmFzZUNvbmZvcm1zVG8iLCJiYXNlRGVsYXkiLCJ3YWl0IiwiYmFzZURpZmZlcmVuY2UiLCJpbmNsdWRlcyIsImlzQ29tbW9uIiwidmFsdWVzTGVuZ3RoIiwidmFsdWVzSW5kZXgiLCJjcmVhdGVCYXNlRWFjaCIsImJhc2VGb3JPd24iLCJiYXNlRWFjaFJpZ2h0IiwiYmFzZUZvck93blJpZ2h0IiwiYmFzZUV2ZXJ5IiwiYmFzZUV4dHJlbXVtIiwiaXNTeW1ib2wiLCJiYXNlRmlsbCIsInRvSW50ZWdlciIsInRvTGVuZ3RoIiwiYmFzZUZpbHRlciIsImJhc2VGbGF0dGVuIiwiZGVwdGgiLCJpc1N0cmljdCIsImlzRmxhdHRlbmFibGUiLCJiYXNlRm9yIiwiY3JlYXRlQmFzZUZvciIsImJhc2VGb3JSaWdodCIsImJhc2VGdW5jdGlvbnMiLCJiYXNlR2V0IiwiY2FzdFBhdGgiLCJ0b0tleSIsImJhc2VHZXRBbGxLZXlzIiwic3ltYm9sc0Z1bmMiLCJiYXNlR2V0VGFnIiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJiYXNlR3QiLCJvdGhlciIsImJhc2VIYXMiLCJiYXNlSGFzSW4iLCJiYXNlSW5SYW5nZSIsImJhc2VJbnRlcnNlY3Rpb24iLCJhcnJheXMiLCJvdGhMZW5ndGgiLCJvdGhJbmRleCIsImNhY2hlcyIsIm1heExlbmd0aCIsIkluZmluaXR5Iiwic2VlbiIsImJhc2VJbnZlcnRlciIsImJhc2VJbnZva2UiLCJsYXN0IiwiYmFzZUlzQXJndW1lbnRzIiwiYmFzZUlzQXJyYXlCdWZmZXIiLCJiYXNlSXNEYXRlIiwiYmFzZUlzRXF1YWwiLCJiYXNlSXNFcXVhbERlZXAiLCJlcXVhbEZ1bmMiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsImVxdWFsQXJyYXlzIiwiZXF1YWxCeVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImVxdWFsT2JqZWN0cyIsImJhc2VJc01hcCIsImJhc2VJc01hdGNoIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwic3JjVmFsdWUiLCJiYXNlSXNOYXRpdmUiLCJpc01hc2tlZCIsInBhdHRlcm4iLCJiYXNlSXNSZWdFeHAiLCJiYXNlSXNTZXQiLCJiYXNlSXNUeXBlZEFycmF5IiwiaXNMZW5ndGgiLCJiYXNlSXRlcmF0ZWUiLCJpZGVudGl0eSIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJiYXNlTWF0Y2hlcyIsInByb3BlcnR5IiwiYmFzZUtleXMiLCJpc1Byb3RvdHlwZSIsImJhc2VLZXlzSW4iLCJuYXRpdmVLZXlzSW4iLCJpc1Byb3RvIiwiYmFzZUx0IiwiYmFzZU1hcCIsImlzQXJyYXlMaWtlIiwiZ2V0TWF0Y2hEYXRhIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJpc0tleSIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImhhc0luIiwiYmFzZU1lcmdlIiwic3JjSW5kZXgiLCJiYXNlTWVyZ2VEZWVwIiwibmV3VmFsdWUiLCJzYWZlR2V0IiwibWVyZ2VGdW5jIiwiaXNUeXBlZCIsImlzQXJyYXlMaWtlT2JqZWN0IiwiY2xvbmVUeXBlZEFycmF5IiwidG9QbGFpbk9iamVjdCIsImJhc2VOdGgiLCJiYXNlT3JkZXJCeSIsIm9yZGVycyIsImdldEl0ZXJhdGVlIiwiY3JpdGVyaWEiLCJjb21wYXJlTXVsdGlwbGUiLCJiYXNlUGljayIsImJhc2VQaWNrQnkiLCJiYXNlU2V0IiwiYmFzZVByb3BlcnR5RGVlcCIsImJhc2VQdWxsQWxsIiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJwcmV2aW91cyIsImJhc2VVbnNldCIsImJhc2VSYW5nZSIsInN0ZXAiLCJiYXNlUmVwZWF0IiwiYmFzZVJlc3QiLCJzZXRUb1N0cmluZyIsIm92ZXJSZXN0IiwiYmFzZVNhbXBsZSIsImJhc2VTYW1wbGVTaXplIiwibmVzdGVkIiwiYmFzZVNldERhdGEiLCJiYXNlU2V0VG9TdHJpbmciLCJjb25zdGFudCIsImJhc2VTaHVmZmxlIiwiYmFzZVNsaWNlIiwiYmFzZVNvbWUiLCJiYXNlU29ydGVkSW5kZXgiLCJyZXRIaWdoZXN0IiwibG93IiwiaGlnaCIsIm1pZCIsImJhc2VTb3J0ZWRJbmRleEJ5IiwidmFsSXNOYU4iLCJ2YWxJc051bGwiLCJ2YWxJc1N5bWJvbCIsInZhbElzVW5kZWZpbmVkIiwib3RoSXNEZWZpbmVkIiwib3RoSXNOdWxsIiwib3RoSXNSZWZsZXhpdmUiLCJvdGhJc1N5bWJvbCIsInNldExvdyIsImJhc2VTb3J0ZWRVbmlxIiwiYmFzZVRvTnVtYmVyIiwiYmFzZVRvU3RyaW5nIiwiYmFzZVVuaXEiLCJjcmVhdGVTZXQiLCJzZWVuSW5kZXgiLCJiYXNlVXBkYXRlIiwidXBkYXRlciIsImJhc2VXaGlsZSIsImlzRHJvcCIsImFjdGlvbnMiLCJiYXNlWG9yIiwiYmFzZVppcE9iamVjdCIsImFzc2lnbkZ1bmMiLCJ2YWxzTGVuZ3RoIiwiY2FzdEFycmF5TGlrZU9iamVjdCIsImNhc3RGdW5jdGlvbiIsInN0cmluZ1RvUGF0aCIsImNhc3RSZXN0IiwiY2FzdFNsaWNlIiwiY29weSIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJjbG9uZURhdGFWaWV3IiwiZGF0YVZpZXciLCJieXRlT2Zmc2V0IiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJjbG9uZVN5bWJvbCIsInN5bWJvbCIsInR5cGVkQXJyYXkiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNSZWZsZXhpdmUiLCJvYmpDcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJjb21wb3NlQXJncyIsInBhcnRpYWxzIiwiaG9sZGVycyIsImlzQ3VycmllZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJob2xkZXJzTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdExlbmd0aCIsInJhbmdlTGVuZ3RoIiwiaXNVbmN1cnJpZWQiLCJjb21wb3NlQXJnc1JpZ2h0IiwiaG9sZGVyc0luZGV4IiwicmlnaHRJbmRleCIsInJpZ2h0TGVuZ3RoIiwiaXNOZXciLCJnZXRTeW1ib2xzIiwiZ2V0U3ltYm9sc0luIiwiY3JlYXRlQWdncmVnYXRvciIsImluaXRpYWxpemVyIiwiY3JlYXRlQXNzaWduZXIiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsImlzSXRlcmF0ZWVDYWxsIiwiaXRlcmFibGUiLCJjcmVhdGVCaW5kIiwiaXNCaW5kIiwiQ3RvciIsImNyZWF0ZUN0b3IiLCJ3cmFwcGVyIiwiY3JlYXRlQ2FzZUZpcnN0IiwibWV0aG9kTmFtZSIsInRyYWlsaW5nIiwiY3JlYXRlQ29tcG91bmRlciIsIndvcmRzIiwiZGVidXJyIiwidGhpc0JpbmRpbmciLCJjcmVhdGVDdXJyeSIsImFyaXR5IiwiZ2V0SG9sZGVyIiwiY3JlYXRlUmVjdXJyeSIsImNyZWF0ZUh5YnJpZCIsImNyZWF0ZUZpbmQiLCJmaW5kSW5kZXhGdW5jIiwiY3JlYXRlRmxvdyIsImZsYXRSZXN0IiwiZnVuY3MiLCJwcmVyZXEiLCJ0aHJ1IiwiZ2V0RnVuY05hbWUiLCJmdW5jTmFtZSIsImdldERhdGEiLCJpc0xhemlhYmxlIiwicGxhbnQiLCJwYXJ0aWFsc1JpZ2h0IiwiaG9sZGVyc1JpZ2h0IiwiYXJnUG9zIiwiYXJ5IiwiaXNBcnkiLCJpc0JpbmRLZXkiLCJpc0ZsaXAiLCJob2xkZXJzQ291bnQiLCJuZXdIb2xkZXJzIiwicmVvcmRlciIsImNyZWF0ZUludmVydGVyIiwidG9JdGVyYXRlZSIsImNyZWF0ZU1hdGhPcGVyYXRpb24iLCJvcGVyYXRvciIsImRlZmF1bHRWYWx1ZSIsImNyZWF0ZU92ZXIiLCJhcnJheUZ1bmMiLCJjcmVhdGVQYWRkaW5nIiwiY2hhcnMiLCJjaGFyc0xlbmd0aCIsImNyZWF0ZVBhcnRpYWwiLCJjcmVhdGVSYW5nZSIsInRvRmluaXRlIiwiY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiIsInRvTnVtYmVyIiwid3JhcEZ1bmMiLCJpc0N1cnJ5IiwibmV3SG9sZGVyc1JpZ2h0IiwibmV3UGFydGlhbHMiLCJuZXdQYXJ0aWFsc1JpZ2h0IiwibmV3RGF0YSIsInNldERhdGEiLCJzZXRXcmFwVG9TdHJpbmciLCJjcmVhdGVSb3VuZCIsInByZWNpc2lvbiIsInBhaXIiLCJub29wIiwiY3JlYXRlVG9QYWlycyIsImNyZWF0ZVdyYXAiLCJtZXJnZURhdGEiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwiY3VzdG9tRGVmYXVsdHNNZXJnZSIsImN1c3RvbU9taXRDbG9uZSIsImlzUGFydGlhbCIsImFyclN0YWNrZWQiLCJvdGhTdGFja2VkIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwiY29udmVydCIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJvYmpTdGFja2VkIiwic2tpcEN0b3IiLCJvYmpDdG9yIiwib3RoQ3RvciIsImZsYXR0ZW4iLCJvdGhlckZ1bmMiLCJpc0tleWFibGUiLCJpc093biIsInVubWFza2VkIiwic3R1YkFycmF5IiwiY3RvclN0cmluZyIsInRyYW5zZm9ybXMiLCJnZXRXcmFwRGV0YWlscyIsImhhc1BhdGgiLCJoYXNGdW5jIiwiaW5zZXJ0V3JhcERldGFpbHMiLCJkZXRhaWxzIiwiaXNNYXNrYWJsZSIsInN0dWJGYWxzZSIsIm1lbW9pemVDYXBwZWQiLCJtZW1vaXplIiwic3JjQml0bWFzayIsIm5ld0JpdG1hc2siLCJpc0NvbWJvIiwib3RoZXJBcmdzIiwib2xkQXJyYXkiLCJzaG9ydE91dCIsInJlZmVyZW5jZSIsInVwZGF0ZVdyYXBEZXRhaWxzIiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJyYW5kIiwicXVvdGUiLCJzdWJTdHJpbmciLCJjaHVuayIsImNvbXBhY3QiLCJkaWZmZXJlbmNlIiwiZGlmZmVyZW5jZUJ5IiwiZGlmZmVyZW5jZVdpdGgiLCJkcm9wIiwiZHJvcFJpZ2h0IiwiZHJvcFJpZ2h0V2hpbGUiLCJkcm9wV2hpbGUiLCJmaWxsIiwiZmluZEluZGV4IiwiZmluZExhc3RJbmRleCIsImZsYXR0ZW5EZWVwIiwiZmxhdHRlbkRlcHRoIiwiZnJvbVBhaXJzIiwiaW5pdGlhbCIsImludGVyc2VjdGlvbiIsIm1hcHBlZCIsImludGVyc2VjdGlvbkJ5IiwiaW50ZXJzZWN0aW9uV2l0aCIsInNlcGFyYXRvciIsImxhc3RJbmRleE9mIiwibnRoIiwicHVsbCIsInB1bGxBbGwiLCJwdWxsQWxsQnkiLCJwdWxsQWxsV2l0aCIsInB1bGxBdCIsInNvcnRlZEluZGV4Iiwic29ydGVkSW5kZXhCeSIsInNvcnRlZEluZGV4T2YiLCJzb3J0ZWRMYXN0SW5kZXgiLCJzb3J0ZWRMYXN0SW5kZXhCeSIsInNvcnRlZExhc3RJbmRleE9mIiwic29ydGVkVW5pcSIsInNvcnRlZFVuaXFCeSIsInRhaWwiLCJ0YWtlIiwidGFrZVJpZ2h0IiwidGFrZVJpZ2h0V2hpbGUiLCJ0YWtlV2hpbGUiLCJ1bmlvbiIsInVuaW9uQnkiLCJ1bmlvbldpdGgiLCJ1bmlxIiwidW5pcUJ5IiwidW5pcVdpdGgiLCJ1bnppcCIsImdyb3VwIiwidW56aXBXaXRoIiwid2l0aG91dCIsInhvciIsInhvckJ5IiwieG9yV2l0aCIsInppcCIsInppcE9iamVjdCIsInppcE9iamVjdERlZXAiLCJ6aXBXaXRoIiwidGFwIiwid3JhcHBlckF0Iiwid3JhcHBlckNoYWluIiwid3JhcHBlckNvbW1pdCIsIndyYXBwZXJOZXh0IiwidG9BcnJheSIsIndyYXBwZXJUb0l0ZXJhdG9yIiwid3JhcHBlclBsYW50Iiwid3JhcHBlclJldmVyc2UiLCJ3cmFwcGVkIiwid3JhcHBlclZhbHVlIiwiY291bnRCeSIsImV2ZXJ5IiwiZmluZCIsImZpbmRMYXN0IiwiZmxhdE1hcCIsImZsYXRNYXBEZWVwIiwiZmxhdE1hcERlcHRoIiwiZm9yRWFjaFJpZ2h0IiwiZ3JvdXBCeSIsImludm9rZU1hcCIsImtleUJ5Iiwib3JkZXJCeSIsInBhcnRpdGlvbiIsInJlZHVjZSIsInJlZHVjZVJpZ2h0IiwibmVnYXRlIiwic2FtcGxlIiwic2FtcGxlU2l6ZSIsInNodWZmbGUiLCJzb21lIiwic29ydEJ5IiwiYWZ0ZXIiLCJiZWZvcmUiLCJiaW5kS2V5IiwiY3VycnkiLCJjdXJyeVJpZ2h0IiwiZGVib3VuY2UiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJpbnZva2VGdW5jIiwidGltZSIsImxlYWRpbmdFZGdlIiwidGltZXJFeHBpcmVkIiwicmVtYWluaW5nV2FpdCIsInRpbWVTaW5jZUxhc3RDYWxsIiwidGltZVNpbmNlTGFzdEludm9rZSIsInRpbWVXYWl0aW5nIiwic2hvdWxkSW52b2tlIiwidHJhaWxpbmdFZGdlIiwiZmx1c2giLCJkZWJvdW5jZWQiLCJpc0ludm9raW5nIiwiZGVmZXIiLCJmbGlwIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwib25jZSIsIm92ZXJBcmdzIiwiZnVuY3NMZW5ndGgiLCJwYXJ0aWFsIiwicGFydGlhbFJpZ2h0IiwicmVhcmciLCJyZXN0IiwidGhyb3R0bGUiLCJ1bmFyeSIsImNhc3RBcnJheSIsImNsb25lV2l0aCIsImNsb25lRGVlcCIsImNsb25lRGVlcFdpdGgiLCJjb25mb3Jtc1RvIiwiZ3QiLCJndGUiLCJpc0Jvb2xlYW4iLCJpc0VsZW1lbnQiLCJpc0VtcHR5IiwiaXNFcXVhbCIsImlzRXF1YWxXaXRoIiwiaXNFcnJvciIsImlzSW50ZWdlciIsImlzTWF0Y2giLCJpc01hdGNoV2l0aCIsImlzTmF0aXZlIiwiaXNOdWxsIiwiaXNOaWwiLCJpc1NhZmVJbnRlZ2VyIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwibHQiLCJsdGUiLCJzaWduIiwicmVtYWluZGVyIiwiaXNCaW5hcnkiLCJ0b1NhZmVJbnRlZ2VyIiwiYXNzaWduIiwiYXNzaWduSW4iLCJhc3NpZ25JbldpdGgiLCJhc3NpZ25XaXRoIiwiYXQiLCJwcm9wZXJ0aWVzIiwicHJvcHNJbmRleCIsInByb3BzTGVuZ3RoIiwiZGVmYXVsdHNEZWVwIiwibWVyZ2VXaXRoIiwiZmluZEtleSIsImZpbmRMYXN0S2V5IiwiZm9ySW4iLCJmb3JJblJpZ2h0IiwiZm9yT3duIiwiZm9yT3duUmlnaHQiLCJmdW5jdGlvbnMiLCJmdW5jdGlvbnNJbiIsImludmVydCIsImludmVydEJ5IiwiaW52b2tlIiwibWFwS2V5cyIsIm1hcFZhbHVlcyIsIm9taXQiLCJvbWl0QnkiLCJwaWNrQnkiLCJzZXRXaXRoIiwidG9QYWlycyIsInRvUGFpcnNJbiIsImlzQXJyTGlrZSIsInVuc2V0IiwidXBkYXRlV2l0aCIsInZhbHVlc0luIiwiY2xhbXAiLCJpblJhbmdlIiwiZmxvYXRpbmciLCJ0ZW1wIiwiY2FtZWxDYXNlIiwid29yZCIsImNhcGl0YWxpemUiLCJ1cHBlckZpcnN0IiwiZW5kc1dpdGgiLCJlc2NhcGUiLCJlc2NhcGVSZWdFeHAiLCJrZWJhYkNhc2UiLCJsb3dlckNhc2UiLCJsb3dlckZpcnN0IiwicGFkIiwic3RyTGVuZ3RoIiwicGFkRW5kIiwicGFkU3RhcnQiLCJyYWRpeCIsInJlcGVhdCIsInNuYWtlQ2FzZSIsImxpbWl0Iiwic3RhcnRDYXNlIiwic3RhcnRzV2l0aCIsInNldHRpbmdzIiwiaW1wb3J0cyIsImltcG9ydHNLZXlzIiwiaW1wb3J0c1ZhbHVlcyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsInZhcmlhYmxlIiwiYXR0ZW1wdCIsInRvTG93ZXIiLCJ0b1VwcGVyIiwidHJpbUVuZCIsInRyaW1TdGFydCIsInRydW5jYXRlIiwib21pc3Npb24iLCJzdWJzdHJpbmciLCJuZXdFbmQiLCJ1cHBlckNhc2UiLCJiaW5kQWxsIiwibWV0aG9kTmFtZXMiLCJjb25kIiwiY29uZm9ybXMiLCJkZWZhdWx0VG8iLCJmbG93IiwiZmxvd1JpZ2h0IiwibWF0Y2hlcyIsIm1hdGNoZXNQcm9wZXJ0eSIsIm1ldGhvZE9mIiwibWl4aW4iLCJub0NvbmZsaWN0IiwibnRoQXJnIiwib3ZlciIsIm92ZXJFdmVyeSIsIm92ZXJTb21lIiwicHJvcGVydHlPZiIsInJhbmdlIiwicmFuZ2VSaWdodCIsInN0dWJPYmplY3QiLCJzdHViU3RyaW5nIiwic3R1YlRydWUiLCJ0aW1lcyIsInRvUGF0aCIsInVuaXF1ZUlkIiwicHJlZml4IiwiYXVnZW5kIiwiYWRkZW5kIiwiZGl2aWRlIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwibWF4QnkiLCJtZWFuIiwibWVhbkJ5IiwibWluQnkiLCJtdWx0aXBseSIsIm11bHRpcGxpZXIiLCJtdWx0aXBsaWNhbmQiLCJyb3VuZCIsInN1YnRyYWN0IiwibWludWVuZCIsInN1YnRyYWhlbmQiLCJzdW0iLCJzdW1CeSIsImVudHJpZXNJbiIsImV4dGVuZFdpdGgiLCJlYWNoIiwiZWFjaFJpZ2h0IiwiZmlyc3QiLCJpc0ZpbHRlciIsInRha2VOYW1lIiwiZHJvcE5hbWUiLCJjaGVja0l0ZXJhdGVlIiwiaXNUYWtlciIsImxvZGFzaEZ1bmMiLCJyZXRVbndyYXBwZWQiLCJpc0xhenkiLCJ1c2VMYXp5IiwiaXNIeWJyaWQiLCJpc1Vud3JhcHBlZCIsIm9ubHlMYXp5IiwiY2hhaW5OYW1lIiwiY29tbWl0IiwidGhpcyIsImF0dHJpYnV0ZVRvU3RyaW5nIiwiYXR0cmlidXRlIiwidG9nZ2xlQ2xhc3MiLCJlbGVtIiwicmVtb3ZlQ2xhc3MiLCJjbGFzc05hbWVzIiwiZm9ybWF0TW9uZXkiLCJjZW50cyIsImZvcm1hdCIsInBsYWNlaG9sZGVyUmVnZXgiLCJmb3JtYXRTdHJpbmciLCJmb3JtYXRXaXRoRGVsaW1pdGVycyIsInRob3VzYW5kcyIsImRlY2ltYWwiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiZG9sbGFyc0Ftb3VudCIsImNlbnRzQW1vdW50IiwiYWpheFRlbXBsYXRlRnVuYyIsImVuY29kZWQiLCJlbmNvZGVVUkkiLCJwb3N0IiwiZ2V0Q2FydCIsImdldFByb2R1Y3QiLCJoYW5kbGUiLCJjbGVhckNhcnQiLCJ1cGRhdGVDYXJ0RnJvbUZvcm0iLCJmb3JtIiwiY2hhbmdlSXRlbUJ5S2V5T3JJZCIsInF1YW50aXR5IiwicmVtb3ZlSXRlbUJ5S2V5T3JJZCIsImNoYW5nZUl0ZW1CeUxpbmUiLCJyZW1vdmVJdGVtQnlMaW5lIiwiYWRkSXRlbSIsImFkZEl0ZW1Gcm9tRm9ybSIsInVwZGF0ZUNhcnRBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsInVwZGF0ZUNhcnROb3RlIiwibm90ZSIsImdldFJlY29tbWVuZGVkUHJvZHVjdHMiLCJwcm9kdWN0SWQiLCJnZXRQcmVkaWN0aXZlU2VhcmNoUmVzdWx0cyIsInEiLCJ1bmF2YWlsYWJsZVByb2R1Y3RzIiwiZmllbGRzIiwicGFyYW1zU3RyaW5nIiwiZmFjdG9yeSIsIl93aW5kb3ciLCJHbGlkZXIiLCJfZ2xpZGVyIiwiZWxlIiwib3B0Iiwic2xpZGVzVG9TY3JvbGwiLCJzbGlkZXNUb1Nob3ciLCJyZXNpemVMb2NrIiwiZWFzaW5nIiwidCIsImQiLCJhbmltYXRlX2lkIiwicGFnZSIsImFycm93cyIsIl9vcHQiLCJza2lwVHJhY2siLCJ0cmFjayIsImluaXQiLCJyZXNpemUiLCJldmVudCIsInVwZGF0ZUNvbnRyb2xzIiwiZ2xpZGVyUHJvdG90eXBlIiwicGFnaW5nIiwid2lkdGgiLCJjb250YWluZXJXaWR0aCIsImJyZWFrcG9pbnRDaGFuZ2VkIiwic2V0dGluZ3NCcmVha3BvaW50IiwiX2F1dG9TbGlkZSIsInNsaWRlQ291bnQiLCJpdGVtV2lkdGgiLCJleGFjdFdpZHRoIiwiX18iLCJ0cmFja1dpZHRoIiwiaXNEcmFnIiwicHJldmVudENsaWNrIiwic2Nyb2xsVG8iLCJiaW5kQXJyb3dzIiwiYnVpbGREb3RzIiwiYmluZERyYWciLCJlbWl0IiwibW91c2UiLCJoYW5kbGVNb3VzZSIsIm1vdXNldXAiLCJtb3VzZURvd24iLCJldmVudHMiLCJtb3VzZWxlYXZlIiwibW91c2Vkb3duIiwic3RvcFByb3BhZ2F0aW9uIiwiY2xpZW50WCIsIm1vdXNlbW92ZSIsImNsaWNrIiwiZHJhZ2dhYmxlIiwiZG90cyIsImRvdCIsImRhdGFzZXQiLCJzY3JvbGxJdGVtIiwiX2Z1bmMiLCJzY3JvbGxQcm9wYWdhdGUiLCJkaXNhYmxlQXJyb3dzIiwicmV3aW5kIiwicHJldiIsIm1pZGRsZSIsImV4dHJhTWlkZGxlIiwic2xpZGVDbGFzc2VzIiwid2FzVmlzaWJsZSIsIml0ZW1TdGFydCIsIml0ZW1FbmQiLCJpc1Zpc2libGUiLCJzY3JvbGxMb2NrIiwic2Nyb2xsTG9ja0RlbGF5Iiwib3JpZ2luYWxTbGlkZSIsImJhY2t3YXJkcyIsInJlc3AiLCJyZXNwb25zaXZlIiwiYnJlYWtwb2ludCIsImlubmVyV2lkdGgiLCJzY3JvbGxEdXJhdGlvbiIsImdldFRpbWUiLCJhbmltYXRlSW5kZXgiLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVtb3ZlSXRlbSIsImRyYWdWZWxvY2l0eSIsImRvdWJsZSIsImludiIsInNldE9wdGlvbiIsImRlc3Ryb3kiLCJjbG9uZU5vZGUiLCJvdXRlckhUTUwiLCJyZXBsYWNlQ2hpbGQiLCJidWJibGVzIiwiZXZlbnRQcm9wYWdhdGUiLCJkZXRhaWwiLCJldmVudEhhbmRsZXIiLCJrIiwic2V0dXBUZXN0aW1vbmlhbFNsaWRlciIsIm9mZmNhbnZhc0lkIiwib2ZmY2FudmFzIiwic2NyZWVuT3ZlcmxheSIsIm1vYmlsZU9mZmNhbnZhcyIsInIiLCJvIiwiQSIsInJlY2FsY3VsYXRlIiwicmVzcG9uc2l2ZU9wdGlvbnMiLCJkb2NXaWR0aCIsInMiLCJicmVha0F0IiwiTyIsInVzZUNvbnRhaW5lckZvckJyZWFrcG9pbnRzIiwiY29sdW1ucyIsIm1hcmdpbiIsIm1vYmlsZUZpcnN0IiwidSIsInJvd3MiLCJwIiwiTSIsImNvbHMiLCJtYWN5Q29tcGxldGUiLCJ0bXBSb3dzIiwiZiIsImxhc3Rjb2wiLCJDIiwibm9kZU5hbWUiLCJieUNzcyIsInNlbGVjdG9ycyIsImdldEVsZW1lbnRCeUlkIiwibSIsInJ1bm5pbmciLCJydW4iLCJvbiIsImciLCJuYXR1cmFsSGVpZ2h0IiwibmF0dXJhbFdpZHRoIiwiRSIsImNvbXBsZXRlIiwiY29uc3RhbnRzIiwiRVZFTlRfSU1BR0VfTE9BRCIsImltZyIsIkVWRU5UX0lNQUdFX0VSUk9SIiwiRVZFTlRfSU1BR0VfQ09NUExFVEUiLCJJIiwiRVZFTlRfUkVTSVpFIiwicXVldWUiLCJOIiwiZGVidWciLCJjb25zb2xlIiwiVCIsInJlc2l6ZXIiLCJMIiwidXNlT3duSW1hZ2VMb2FkZXIiLCJ3YWl0Rm9ySW1hZ2VzIiwiRVZFTlRfSU5JVElBTElaRUQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiViIsIm9mZnNldFBhcmVudCIsInRydWVPcmRlciIsIkVWRU5UX1JFQ0FMQ1VMQVRFRCIsIlIiLCJ1c2VJbWFnZUxvYWRlciIsIm9uSW5pdCIsImNhbmNlbExlZ2FjeSIsIndhcm4iLCJyZWNhbGN1bGF0ZU9uSW1hZ2VMb2FkIiwicnVuT25JbWFnZUxvYWQiLCJyZUluaXQiLCJNYWN5IiwiY3VycmVudElkIiwic2V0Q3VycmVudCIsInN0YXRlIiwibm90aWZ5IiwicGhhc2VTeW1ib2wiLCJob29rU3ltYm9sIiwidXBkYXRlU3ltYm9sIiwiY29tbWl0U3ltYm9sIiwiZWZmZWN0c1N5bWJvbCIsImxheW91dEVmZmVjdHNTeW1ib2wiLCJjb250ZXh0RXZlbnQiLCJTdGF0ZSIsImNiIiwicmVzIiwicGhhc2UiLCJlZmZlY3RzIiwiZWZmZWN0IiwiX3J1bkVmZmVjdHMiLCJob29rcyIsImhvb2siLCJ0ZWFyZG93biIsInJ1bm5lciIsInRhc2tzIiwicnVuVGFza3MiLCJsZW4iLCJ0YXNrIiwiQmFzZVNjaGVkdWxlciIsInJlbmRlcmVyIiwiX3VwZGF0ZVF1ZXVlZCIsImhhbmRsZVBoYXNlIiwicnVuRWZmZWN0cyIsInJlbmRlciIsInRvQ2FtZWxDYXNlIiwiY2hhciIsIm1ha2VDb21wb25lbnQiLCJTY2hlZHVsZXIiLCJmcmFnIiwiYmFzZUVsZW1lbnRPck9wdGlvbnMiLCJCYXNlRWxlbWVudCIsImJhc2VFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJvYnNlcnZlZEF0dHJpYnV0ZXMiLCJ1c2VTaGFkb3dET00iLCJzaGFkb3dSb290SW5pdCIsIl9zY2hlZHVsZXIiLCJhdHRhY2hTaGFkb3ciLCJtb2RlIiwic2hhZG93Um9vdCIsIm9sZFZhbHVlIiwiUmVmbGVjdCIsInJlZmxlY3RpdmVQcm9wIiwiaW5pdGlhbFZhbHVlIiwiZnJlZXplIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIlByb3h5IiwicmVjZWl2ZXIiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwid3JpdGFibGUiLCJzZXRQcm90b3R5cGVPZiIsIkhvb2siLCJjcmVhdGVFZmZlY3QiLCJzZXRFZmZlY3RzIiwiaWdub3JlZDEiLCJpZ25vcmVkMiIsImxhc3RWYWx1ZXMiLCJoYXNDaGFuZ2VkIiwiX3RlYXJkb3duIiwidXNlRWZmZWN0IiwidXNlQ29udGV4dCIsIl91cGRhdGVyIiwiX3JhbkVmZmVjdCIsIl91bnN1YnNjcmliZSIsIkNvbnRleHQiLCJ2aXJ0dWFsIiwiX3N1YnNjcmliZSIsImNvbXBvc2VkIiwidW5zdWJzY3JpYmUiLCJtYWtlQ29udGV4dCIsIlByb3ZpZGVyIiwibGlzdGVuZXJzIiwiX3ZhbHVlIiwiQ29uc3VtZXIiLCJ1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCJpbnB1dHMiLCJzZXRMYXlvdXRFZmZlY3RzIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlU3RhdGUiLCJtYWtlQXJncyIsInVwZGF0ZXJGbiIsInByZXZpb3VzVmFsdWUiLCJ1c2VSZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwiZGlzcGF0Y2giLCJjdXJyZW50U3RhdGUiLCJyZWR1Y2VyIiwidXNlUmVmIiwiaGF1bnRlZCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VEZWJvdW5jZWRDYWxsYmFjayIsInJhd1dhaXQiLCJmdW5jUmVmIiwibW91bnRlZCIsInVzZVJBRiIsInN0YXJ0VGltZXIiLCJwZW5kaW5nRnVuYyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsVGltZXIiLCJwZW5kaW5nIiwiZGVib3VuY2VkU3RhdGUiLCJwcmVkaWN0aXZlU2VhcmNoIiwic2V0USIsInJlc3VsdHMiLCJzZXRSZXN1bHRzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJzZXRWYWx1ZSIsInJlc291cmNlcyIsImhhbmRsZUtleXVwIiwiaHRtbCIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIiwiYXRjRHJvcGRvd25JbnB1dHMiLCJkYXRhUHJvZHVjdCIsImRhdGFTZWxlY3RlZE9yRmlyc3RBdmFpbGFibGVWYXJpYW50IiwiZGF0YU9wdGlvbnNXaXRoVmFsdWVzIiwic2VsZWN0b3JXcmFwcGVyQ3VzdG9tQ2xhc3NlcyIsInNlbGVjdG9yTGFiZWxDdXN0b21DbGFzc2VzIiwic2VsZWN0b3JDdXN0b21DbGFzc2VzIiwicXVhbnRpdHlJbnB1dEN1c3RvbUNsYXNzZXMiLCJhdGNCdXR0b25DdXN0b21DbGFzc2VzIiwib3B0aW9uc1dpdGhWYWx1ZXMiLCJ2YXJpYW50cyIsInZhcmlhbnQiLCJjdXJyZW50VmFyaWFudCIsInNldEN1cnJlbnRWYXJpYW50Iiwic2V0U3RhdHVzIiwiZXJyb3JEZXNjcmlwdGlvbiIsInNldEVycm9yRGVzY3JpcHRpb24iLCJoYW5kbGVPcHRpb25DaGFuZ2UiLCJvcHRpb24xIiwib3B0aW9uMiIsIm9wdGlvbjMiLCJjVmFyaWFudCIsImhhbmRsZUFUQ0J1dHRvbkNsaWNrIiwiYWRkZWRJdGVtIiwiY2FydCIsImF2YWlsYWJsZSIsImRhdG9tYXIiLCJCU04iLCJhcGlzIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBOzs7OztFQUtBLElBQUlBLGtCQUFrQixHQUFHLHNCQUFzQkMsUUFBUSxDQUFDQyxJQUFULENBQWNDLEtBQXBDLEdBQTRDLHFCQUE1QyxHQUFvRSxlQUE3RjtFQUVBLElBQUlDLGlCQUFpQixHQUFHLHNCQUFzQkgsUUFBUSxDQUFDQyxJQUFULENBQWNDLEtBQXBDLElBQTZDLGdCQUFnQkYsUUFBUSxDQUFDQyxJQUFULENBQWNDLEtBQW5HO0VBRUEsSUFBSUUsa0JBQWtCLEdBQUcsc0JBQXNCSixRQUFRLENBQUNDLElBQVQsQ0FBY0MsS0FBcEMsR0FBNEMsMEJBQTVDLEdBQXlFLG9CQUFsRzs7RUFFQSxTQUFTRyw0QkFBVCxDQUFzQ0MsT0FBdEMsRUFBK0M7RUFDN0MsTUFBSUMsUUFBUSxHQUFHSixpQkFBaUIsR0FBR0ssVUFBVSxDQUFDQyxnQkFBZ0IsQ0FBQ0gsT0FBRCxDQUFoQixDQUEwQkYsa0JBQTFCLENBQUQsQ0FBYixHQUErRCxDQUEvRjtFQUNBRyxFQUFBQSxRQUFRLEdBQUcsT0FBT0EsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxDQUFDRyxLQUFLLENBQUNILFFBQUQsQ0FBdEMsR0FBbURBLFFBQVEsR0FBRyxJQUE5RCxHQUFxRSxDQUFoRjtFQUNBLFNBQU9BLFFBQVA7RUFDRDs7RUFFRCxTQUFTSSxvQkFBVCxDQUE4QkwsT0FBOUIsRUFBc0NNLE9BQXRDLEVBQThDO0VBQzVDLE1BQUlDLE1BQU0sR0FBRyxDQUFiO0VBQUEsTUFBZ0JOLFFBQVEsR0FBR0YsNEJBQTRCLENBQUNDLE9BQUQsQ0FBdkQ7RUFDQUMsRUFBQUEsUUFB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
