(function (factory) {
  typeof define === 'function' && define.amd ? define('index', factory) :
  factory();
}((function () { 'use strict';

  /*!
    * Native JavaScript for Bootstrap v3.0.10 (https://thednp.github.io/bootstrap.native/)
    * Copyright 2015-2020 © dnp_theme
    * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)
    */
  var transitionEndEvent = 'webkitTransition' in document.head.style ? 'webkitTransitionEnd' : 'transitionend';
  var supportTransition = 'webkitTransition' in document.head.style || 'transition' in document.head.style;
  var transitionDuration = 'webkitTransition' in document.head.style ? 'webkitTransitionDuration' : 'transitionDuration';

  function getElementTransitionDuration(element) {
    var duration = supportTransition ? parseFloat(getComputedStyle(element)[transitionDuration]) : 0;
    duration = typeof duration === 'number' && !isNaN(duration) ? duration * 1000 : 0;
    return duration;
  }

  function emulateTransitionEnd(element, handler) {
    var called = 0,
        duration = getElementTransitionDuration(element);
    duration ? element.addEventListener(transitionEndEvent, function transitionEndWrapper(e) {
      !called && handler(e), called = 1;
      element.removeEventListener(transitionEndEvent, transitionEndWrapper);
    }) : setTimeout(function () {
      !called && handler(), called = 1;
    }, 17);
  }

  function queryElement(selector, parent) {
    var lookUp = parent && parent instanceof Element ? parent : document;
    return selector instanceof Element ? selector : lookUp.querySelector(selector);
  }

  function bootstrapCustomEvent(eventName, componentName, related) {
    var OriginalCustomEvent = new CustomEvent(eventName + '.bs.' + componentName, {
      cancelable: true
    });
    OriginalCustomEvent.relatedTarget = related;
    return OriginalCustomEvent;
  }

  function dispatchCustomEvent(customEvent) {
    this && this.dispatchEvent(customEvent);
  }

  function Alert(element) {
    var self = this,
        alert,
        closeCustomEvent = bootstrapCustomEvent('close', 'alert'),
        closedCustomEvent = bootstrapCustomEvent('closed', 'alert');

    function triggerHandler() {
      alert.classList.contains('fade') ? emulateTransitionEnd(alert, transitionEndHandler) : transitionEndHandler();
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      element[action]('click', clickHandler, false);
    }

    function clickHandler(e) {
      alert = e && e.target.closest(".alert");
      element = queryElement('[data-dismiss="alert"]', alert);
      element && alert && (element === e.target || element.contains(e.target)) && self.close();
    }

    function transitionEndHandler() {
      toggleEvents();
      alert.parentNode.removeChild(alert);
      dispatchCustomEvent.call(alert, closedCustomEvent);
    }

    self.close = function () {
      if (alert && element && alert.classList.contains('show')) {
        dispatchCustomEvent.call(alert, closeCustomEvent);

        if (closeCustomEvent.defaultPrevented) {
          return;
        }

        self.dispose();
        alert.classList.remove('show');
        triggerHandler();
      }
    };

    self.dispose = function () {
      toggleEvents();
      delete element.Alert;
    };

    element = queryElement(element);
    alert = element.closest('.alert');
    element.Alert && element.Alert.dispose();

    if (!element.Alert) {
      toggleEvents(1);
    }

    self.element = element;
    element.Alert = self;
  }

  function Button(element) {
    var self = this,
        labels,
        changeCustomEvent = bootstrapCustomEvent('change', 'button');

    function toggle(e) {
      var input,
          label = e.target.tagName === 'LABEL' ? e.target : e.target.closest('LABEL') ? e.target.closest('LABEL') : null;
      input = label && label.getElementsByTagName('INPUT')[0];

      if (!input) {
        return;
      }

      dispatchCustomEvent.call(input, changeCustomEvent);
      dispatchCustomEvent.call(element, changeCustomEvent);

      if (input.type === 'checkbox') {
        if (changeCustomEvent.defaultPrevented) {
          return;
        }

        if (!input.checked) {
          label.classList.add('active');
          input.getAttribute('checked');
          input.setAttribute('checked', 'checked');
          input.checked = true;
        } else {
          label.classList.remove('active');
          input.getAttribute('checked');
          input.removeAttribute('checked');
          input.checked = false;
        }

        if (!element.toggled) {
          element.toggled = true;
        }
      }

      if (input.type === 'radio' && !element.toggled) {
        if (changeCustomEvent.defaultPrevented) {
          return;
        }

        if (!input.checked || e.screenX === 0 && e.screenY == 0) {
          label.classList.add('active');
          label.classList.add('focus');
          input.setAttribute('checked', 'checked');
          input.checked = true;
          element.toggled = true;
          Array.from(labels).map(function (otherLabel) {
            var otherInput = otherLabel.getElementsByTagName('INPUT')[0];

            if (otherLabel !== label && otherLabel.classList.contains('active')) {
              dispatchCustomEvent.call(otherInput, changeCustomEvent);
              otherLabel.classList.remove('active');
              otherInput.removeAttribute('checked');
              otherInput.checked = false;
            }
          });
        }
      }

      setTimeout(function () {
        element.toggled = false;
      }, 50);
    }

    function keyHandler(e) {
      var key = e.which || e.keyCode;
      key === 32 && e.target === document.activeElement && toggle(e);
    }

    function preventScroll(e) {
      var key = e.which || e.keyCode;
      key === 32 && e.preventDefault();
    }

    function focusToggle(e) {
      if (e.target.tagName === 'INPUT') {
        var action = e.type === 'focusin' ? 'add' : 'remove';
        e.target.closest('.btn').classList[action]('focus');
      }
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      element[action]('click', toggle, false);
      element[action]('keyup', keyHandler, false), element[action]('keydown', preventScroll, false);
      element[action]('focusin', focusToggle, false), element[action]('focusout', focusToggle, false);
    }

    self.dispose = function () {
      toggleEvents();
      delete element.Button;
    };

    element = queryElement(element);
    element.Button && element.Button.dispose();
    labels = element.getElementsByClassName('btn');

    if (!labels.length) {
      return;
    }

    if (!element.Button) {
      toggleEvents(1);
    }

    element.toggled = false;
    element.Button = self;
    Array.from(labels).map(function (btn) {
      !btn.classList.contains('active') && queryElement('input:checked', btn) && btn.classList.add('active');
      btn.classList.contains('active') && !queryElement('input:checked', btn) && btn.classList.remove('active');
    });
  }

  var mouseHoverEvents = 'onmouseleave' in document ? ['mouseenter', 'mouseleave'] : ['mouseover', 'mouseout'];

  var supportPassive = function () {
    var result = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          result = true;
        }
      });
      document.addEventListener('DOMContentLoaded', function wrap() {
        document.removeEventListener('DOMContentLoaded', wrap, opts);
      }, opts);
    } catch (e) {}

    return result;
  }();

  var passiveHandler = supportPassive ? {
    passive: true
  } : false;

  function isElementInScrollRange(element) {
    var bcr = element.getBoundingClientRect(),
        viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    return bcr.top <= viewportHeight && bcr.bottom >= 0;
  }

  function Carousel(element, options) {
    options = options || {};
    var self = this,
        vars,
        ops,
        slideCustomEvent,
        slidCustomEvent,
        slides,
        leftArrow,
        rightArrow,
        indicator,
        indicators;

    function pauseHandler() {
      if (ops.interval !== false && !element.classList.contains('paused')) {
        element.classList.add('paused');
        !vars.isSliding && (clearInterval(vars.timer), vars.timer = null);
      }
    }

    function resumeHandler() {
      if (ops.interval !== false && element.classList.contains('paused')) {
        element.classList.remove('paused');
        !vars.isSliding && (clearInterval(vars.timer), vars.timer = null);
        !vars.isSliding && self.cycle();
      }
    }

    function indicatorHandler(e) {
      e.preventDefault();

      if (vars.isSliding) {
        return;
      }

      var eventTarget = e.target;

      if (eventTarget && !eventTarget.classList.contains('active') && eventTarget.getAttribute('data-slide-to')) {
        vars.index = parseInt(eventTarget.getAttribute('data-slide-to'));
      } else {
        return false;
      }

      self.slideTo(vars.index);
    }

    function controlsHandler(e) {
      e.preventDefault();

      if (vars.isSliding) {
        return;
      }

      var eventTarget = e.currentTarget || e.srcElement;

      if (eventTarget === rightArrow) {
        vars.index++;
      } else if (eventTarget === leftArrow) {
        vars.index--;
      }

      self.slideTo(vars.index);
    }

    function keyHandler(ref) {
      var which = ref.which;

      if (vars.isSliding) {
        return;
      }

      switch (which) {
        case 39:
          vars.index++;
          break;

        case 37:
          vars.index--;
          break;

        default:
          return;
      }

      self.slideTo(vars.index);
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';

      if (ops.pause && ops.interval) {
        element[action](mouseHoverEvents[0], pauseHandler, false);
        element[action](mouseHoverEvents[1], resumeHandler, false);
        element[action]('touchstart', pauseHandler, passiveHandler);
        element[action]('touchend', resumeHandler, passiveHandler);
      }

      ops.touch && slides.length > 1 && element[action]('touchstart', touchDownHandler, passiveHandler);
      rightArrow && rightArrow[action]('click', controlsHandler, false);
      leftArrow && leftArrow[action]('click', controlsHandler, false);
      indicator && indicator[action]('click', indicatorHandler, false);
      ops.keyboard && window[action]('keydown', keyHandler, false);
    }

    function toggleTouchEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      element[action]('touchmove', touchMoveHandler, passiveHandler);
      element[action]('touchend', touchEndHandler, passiveHandler);
    }

    function touchDownHandler(e) {
      if (vars.isTouch) {
        return;
      }

      vars.touchPosition.startX = e.changedTouches[0].pageX;

      if (element.contains(e.target)) {
        vars.isTouch = true;
        toggleTouchEvents(1);
      }
    }

    function touchMoveHandler(e) {
      if (!vars.isTouch) {
        e.preventDefault();
        return;
      }

      vars.touchPosition.currentX = e.changedTouches[0].pageX;

      if (e.type === 'touchmove' && e.changedTouches.length > 1) {
        e.preventDefault();
        return false;
      }
    }

    function touchEndHandler(e) {
      if (!vars.isTouch || vars.isSliding) {
        return;
      }

      vars.touchPosition.endX = vars.touchPosition.currentX || e.changedTouches[0].pageX;

      if (vars.isTouch) {
        if ((!element.contains(e.target) || !element.contains(e.relatedTarget)) && Math.abs(vars.touchPosition.startX - vars.touchPosition.endX) < 75) {
          return false;
        } else {
          if (vars.touchPosition.currentX < vars.touchPosition.startX) {
            vars.index++;
          } else if (vars.touchPosition.currentX > vars.touchPosition.startX) {
            vars.index--;
          }

          vars.isTouch = false;
          self.slideTo(vars.index);
        }

        toggleTouchEvents();
      }
    }

    function setActivePage(pageIndex) {
      Array.from(indicators).map(function (x) {
        x.classList.remove('active');
      });
      indicators[pageIndex] && indicators[pageIndex].classList.add('active');
    }

    function transitionEndHandler(e) {
      if (vars.touchPosition) {
        var next = vars.index,
            timeout = e && e.target !== slides[next] ? e.elapsedTime * 1000 + 100 : 20,
            activeItem = self.getActiveIndex(),
            orientation = vars.direction === 'left' ? 'next' : 'prev';
        vars.isSliding && setTimeout(function () {
          if (vars.touchPosition) {
            vars.isSliding = false;
            slides[next].classList.add('active');
            slides[activeItem].classList.remove('active');
            slides[next].classList.remove("carousel-item-" + orientation);
            slides[next].classList.remove("carousel-item-" + vars.direction);
            slides[activeItem].classList.remove("carousel-item-" + vars.direction);
            dispatchCustomEvent.call(element, slidCustomEvent);

            if (!document.hidden && ops.interval && !element.classList.contains('paused')) {
              self.cycle();
            }
          }
        }, timeout);
      }
    }

    self.cycle = function () {
      if (vars.timer) {
        clearInterval(vars.timer);
        vars.timer = null;
      }

      vars.timer = setInterval(function () {
        var idx = vars.index || self.getActiveIndex();
        isElementInScrollRange(element) && (idx++, self.slideTo(idx));
      }, ops.interval);
    };

    self.slideTo = function (next) {
      if (vars.isSliding) {
        return;
      }

      var activeItem = self.getActiveIndex(),
          orientation;

      if (activeItem === next) {
        return;
      } else if (activeItem < next || activeItem === 0 && next === slides.length - 1) {
        vars.direction = 'left';
      } else if (activeItem > next || activeItem === slides.length - 1 && next === 0) {
        vars.direction = 'right';
      }

      if (next < 0) {
        next = slides.length - 1;
      } else if (next >= slides.length) {
        next = 0;
      }

      orientation = vars.direction === 'left' ? 'next' : 'prev';
      slideCustomEvent = bootstrapCustomEvent('slide', 'carousel', slides[next]);
      slidCustomEvent = bootstrapCustomEvent('slid', 'carousel', slides[next]);
      dispatchCustomEvent.call(element, slideCustomEvent);

      if (slideCustomEvent.defaultPrevented) {
        return;
      }

      vars.index = next;
      vars.isSliding = true;
      clearInterval(vars.timer);
      vars.timer = null;
      setActivePage(next);

      if (getElementTransitionDuration(slides[next]) && element.classList.contains('slide')) {
        slides[next].classList.add("carousel-item-" + orientation);
        slides[next].offsetWidth;
        slides[next].classList.add("carousel-item-" + vars.direction);
        slides[activeItem].classList.add("carousel-item-" + vars.direction);
        emulateTransitionEnd(slides[next], transitionEndHandler);
      } else {
        slides[next].classList.add('active');
        slides[next].offsetWidth;
        slides[activeItem].classList.remove('active');
        setTimeout(function () {
          vars.isSliding = false;

          if (ops.interval && element && !element.classList.contains('paused')) {
            self.cycle();
          }

          dispatchCustomEvent.call(element, slidCustomEvent);
        }, 100);
      }
    };

    self.getActiveIndex = function () {
      return Array.from(slides).indexOf(element.getElementsByClassName('carousel-item active')[0]) || 0;
    };

    self.dispose = function () {
      var itemClasses = ['left', 'right', 'prev', 'next'];
      Array.from(slides).map(function (slide, idx) {
        slide.classList.contains('active') && setActivePage(idx);
        itemClasses.map(function (cls) {
          return slide.classList.remove("carousel-item-" + cls);
        });
      });
      clearInterval(vars.timer);
      toggleEvents();
      vars = {};
      ops = {};
      delete element.Carousel;
    };

    element = queryElement(element);
    element.Carousel && element.Carousel.dispose();
    slides = element.getElementsByClassName('carousel-item');
    leftArrow = element.getElementsByClassName('carousel-control-prev')[0];
    rightArrow = element.getElementsByClassName('carousel-control-next')[0];
    indicator = element.getElementsByClassName('carousel-indicators')[0];
    indicators = indicator && indicator.getElementsByTagName("LI") || [];

    if (slides.length < 2) {
      return;
    }

    var intervalAttribute = element.getAttribute('data-interval'),
        intervalData = intervalAttribute === 'false' ? 0 : parseInt(intervalAttribute),
        touchData = element.getAttribute('data-touch') === 'false' ? 0 : 1,
        pauseData = element.getAttribute('data-pause') === 'hover' || false,
        keyboardData = element.getAttribute('data-keyboard') === 'true' || false,
        intervalOption = options.interval,
        touchOption = options.touch;
    ops = {};
    ops.keyboard = options.keyboard === true || keyboardData;
    ops.pause = options.pause === 'hover' || pauseData ? 'hover' : false;
    ops.touch = touchOption || touchData;
    ops.interval = typeof intervalOption === 'number' ? intervalOption : intervalOption === false || intervalData === 0 || intervalData === false ? 0 : isNaN(intervalData) ? 5000 : intervalData;

    if (self.getActiveIndex() < 0) {
      slides.length && slides[0].classList.add('active');
      indicators.length && setActivePage(0);
    }

    vars = {};
    vars.direction = 'left';
    vars.index = 0;
    vars.timer = null;
    vars.isSliding = false;
    vars.isTouch = false;
    vars.touchPosition = {
      startX: 0,
      currentX: 0,
      endX: 0
    };
    toggleEvents(1);

    if (ops.interval) {
      self.cycle();
    }

    element.Carousel = self;
  }

  function Collapse(element, options) {
    options = options || {};
    var self = this;
    var accordion = null,
        collapse = null,
        activeCollapse,
        activeElement,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent;

    function openAction(collapseElement, toggle) {
      dispatchCustomEvent.call(collapseElement, showCustomEvent);

      if (showCustomEvent.defaultPrevented) {
        return;
      }

      collapseElement.isAnimating = true;
      collapseElement.classList.add('collapsing');
      collapseElement.classList.remove('collapse');
      collapseElement.style.height = collapseElement.scrollHeight + "px";
      emulateTransitionEnd(collapseElement, function () {
        collapseElement.isAnimating = false;
        collapseElement.setAttribute('aria-expanded', 'true');
        toggle.setAttribute('aria-expanded', 'true');
        collapseElement.classList.remove('collapsing');
        collapseElement.classList.add('collapse');
        collapseElement.classList.add('show');
        collapseElement.style.height = '';
        dispatchCustomEvent.call(collapseElement, shownCustomEvent);
      });
    }

    function closeAction(collapseElement, toggle) {
      dispatchCustomEvent.call(collapseElement, hideCustomEvent);

      if (hideCustomEvent.defaultPrevented) {
        return;
      }

      collapseElement.isAnimating = true;
      collapseElement.style.height = collapseElement.scrollHeight + "px";
      collapseElement.classList.remove('collapse');
      collapseElement.classList.remove('show');
      collapseElement.classList.add('collapsing');
      collapseElement.offsetWidth;
      collapseElement.style.height = '0px';
      emulateTransitionEnd(collapseElement, function () {
        collapseElement.isAnimating = false;
        collapseElement.setAttribute('aria-expanded', 'false');
        toggle.setAttribute('aria-expanded', 'false');
        collapseElement.classList.remove('collapsing');
        collapseElement.classList.add('collapse');
        collapseElement.style.height = '';
        dispatchCustomEvent.call(collapseElement, hiddenCustomEvent);
      });
    }

    self.toggle = function (e) {
      if (e && e.target.tagName === 'A' || element.tagName === 'A') {
        e.preventDefault();
      }

      if (element.contains(e.target) || e.target === element) {
        if (!collapse.classList.contains('show')) {
          self.show();
        } else {
          self.hide();
        }
      }
    };

    self.hide = function () {
      if (collapse.isAnimating) {
        return;
      }

      closeAction(collapse, element);
      element.classList.add('collapsed');
    };

    self.show = function () {
      if (accordion) {
        activeCollapse = accordion.getElementsByClassName("collapse show")[0];
        activeElement = activeCollapse && (queryElement("[data-target=\"#" + activeCollapse.id + "\"]", accordion) || queryElement("[href=\"#" + activeCollapse.id + "\"]", accordion));
      }

      if (!collapse.isAnimating) {
        if (activeElement && activeCollapse !== collapse) {
          closeAction(activeCollapse, activeElement);
          activeElement.classList.add('collapsed');
        }

        openAction(collapse, element);
        element.classList.remove('collapsed');
      }
    };

    self.dispose = function () {
      element.removeEventListener('click', self.toggle, false);
      delete element.Collapse;
    };

    element = queryElement(element);
    element.Collapse && element.Collapse.dispose();
    var accordionData = element.getAttribute('data-parent');
    showCustomEvent = bootstrapCustomEvent('show', 'collapse');
    shownCustomEvent = bootstrapCustomEvent('shown', 'collapse');
    hideCustomEvent = bootstrapCustomEvent('hide', 'collapse');
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'collapse');
    collapse = queryElement(options.target || element.getAttribute('data-target') || element.getAttribute('href'));
    collapse.isAnimating = false;
    accordion = element.closest(options.parent || accordionData);

    if (!element.Collapse) {
      element.addEventListener('click', self.toggle, false);
    }

    element.Collapse = self;
  }

  function setFocus(element) {
    element.focus ? element.focus() : element.setActive();
  }

  function Dropdown(element, option) {
    var self = this,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent,
        relatedTarget = null,
        parent,
        menu,
        menuItems = [],
        persist;

    function preventEmptyAnchor(anchor) {
      (anchor.href && anchor.href.slice(-1) === '#' || anchor.parentNode && anchor.parentNode.href && anchor.parentNode.href.slice(-1) === '#') && this.preventDefault();
    }

    function toggleDismiss() {
      var action = element.open ? 'addEventListener' : 'removeEventListener';
      document[action]('click', dismissHandler, false);
      document[action]('keydown', preventScroll, false);
      document[action]('keyup', keyHandler, false);
      document[action]('focus', dismissHandler, false);
    }

    function dismissHandler(e) {
      var eventTarget = e.target,
          hasData = eventTarget && (eventTarget.getAttribute('data-toggle') || eventTarget.parentNode && eventTarget.parentNode.getAttribute && eventTarget.parentNode.getAttribute('data-toggle'));

      if (e.type === 'focus' && (eventTarget === element || eventTarget === menu || menu.contains(eventTarget))) {
        return;
      }

      if ((eventTarget === menu || menu.contains(eventTarget)) && (persist || hasData)) {
        return;
      } else {
        relatedTarget = eventTarget === element || element.contains(eventTarget) ? element : null;
        self.hide();
      }

      preventEmptyAnchor.call(e, eventTarget);
    }

    function clickHandler(e) {
      relatedTarget = element;
      self.show();
      preventEmptyAnchor.call(e, e.target);
    }

    function preventScroll(e) {
      var key = e.which || e.keyCode;

      if (key === 38 || key === 40) {
        e.preventDefault();
      }
    }

    function keyHandler(e) {
      var key = e.which || e.keyCode,
          activeItem = document.activeElement,
          isSameElement = activeItem === element,
          isInsideMenu = menu.contains(activeItem),
          isMenuItem = activeItem.parentNode === menu || activeItem.parentNode.parentNode === menu,
          idx = menuItems.indexOf(activeItem);

      if (isMenuItem) {
        idx = isSameElement ? 0 : key === 38 ? idx > 1 ? idx - 1 : 0 : key === 40 ? idx < menuItems.length - 1 ? idx + 1 : idx : idx;
        menuItems[idx] && setFocus(menuItems[idx]);
      }

      if ((menuItems.length && isMenuItem || !menuItems.length && (isInsideMenu || isSameElement) || !isInsideMenu) && element.open && key === 27) {
        self.toggle();
        relatedTarget = null;
      }
    }

    self.show = function () {
      showCustomEvent = bootstrapCustomEvent('show', 'dropdown', relatedTarget);
      dispatchCustomEvent.call(parent, showCustomEvent);

      if (showCustomEvent.defaultPrevented) {
        return;
      }

      menu.classList.add('show');
      parent.classList.add('show');
      element.setAttribute('aria-expanded', true);
      element.open = true;
      element.removeEventListener('click', clickHandler, false);
      setTimeout(function () {
        setFocus(menu.getElementsByTagName('INPUT')[0] || element);
        toggleDismiss();
        shownCustomEvent = bootstrapCustomEvent('shown', 'dropdown', relatedTarget);
        dispatchCustomEvent.call(parent, shownCustomEvent);
      }, 1);
    };

    self.hide = function () {
      hideCustomEvent = bootstrapCustomEvent('hide', 'dropdown', relatedTarget);
      dispatchCustomEvent.call(parent, hideCustomEvent);

      if (hideCustomEvent.defaultPrevented) {
        return;
      }

      menu.classList.remove('show');
      parent.classList.remove('show');
      element.setAttribute('aria-expanded', false);
      element.open = false;
      toggleDismiss();
      setFocus(element);
      setTimeout(function () {
        element.Dropdown && element.addEventListener('click', clickHandler, false);
      }, 1);
      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'dropdown', relatedTarget);
      dispatchCustomEvent.call(parent, hiddenCustomEvent);
    };

    self.toggle = function () {
      if (parent.classList.contains('show') && element.open) {
        self.hide();
      } else {
        self.show();
      }
    };

    self.dispose = function () {
      if (parent.classList.contains('show') && element.open) {
        self.hide();
      }

      element.removeEventListener('click', clickHandler, false);
      delete element.Dropdown;
    };

    element = queryElement(element);
    element.Dropdown && element.Dropdown.dispose();
    parent = element.parentNode;
    menu = queryElement('.dropdown-menu', parent);
    Array.from(menu.children).map(function (child) {
      child.children.length && child.children[0].tagName === 'A' && menuItems.push(child.children[0]);
      child.tagName === 'A' && menuItems.push(child);
    });

    if (!element.Dropdown) {
      !('tabindex' in menu) && menu.setAttribute('tabindex', '0');
      element.addEventListener('click', clickHandler, false);
    }

    persist = option === true || element.getAttribute('data-persist') === 'true' || false;
    element.open = false;
    element.Dropdown = self;
  }

  function Modal(element, options) {
    options = options || {};
    var self = this,
        modal,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent,
        relatedTarget = null,
        scrollBarWidth,
        overlay,
        overlayDelay,
        fixedItems,
        ops = {};

    function setScrollbar() {
      var openModal = document.body.classList.contains('modal-open'),
          bodyPad = parseInt(getComputedStyle(document.body).paddingRight),
          bodyOverflow = document.documentElement.clientHeight !== document.documentElement.scrollHeight || document.body.clientHeight !== document.body.scrollHeight,
          modalOverflow = modal.clientHeight !== modal.scrollHeight;
      scrollBarWidth = measureScrollbar();
      modal.style.paddingRight = !modalOverflow && scrollBarWidth ? scrollBarWidth + "px" : '';
      document.body.style.paddingRight = modalOverflow || bodyOverflow ? bodyPad + (openModal ? 0 : scrollBarWidth) + "px" : '';
      fixedItems.length && fixedItems.map(function (fixed) {
        var itemPad = getComputedStyle(fixed).paddingRight;
        fixed.style.paddingRight = modalOverflow || bodyOverflow ? parseInt(itemPad) + (openModal ? 0 : scrollBarWidth) + "px" : parseInt(itemPad) + "px";
      });
    }

    function resetScrollbar() {
      document.body.style.paddingRight = '';
      modal.style.paddingRight = '';
      fixedItems.length && fixedItems.map(function (fixed) {
        fixed.style.paddingRight = '';
      });
    }

    function measureScrollbar() {
      var scrollDiv = document.createElement('div'),
          widthValue;
      scrollDiv.className = 'modal-scrollbar-measure';
      document.body.appendChild(scrollDiv);
      widthValue = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return widthValue;
    }

    function createOverlay() {
      var newOverlay = document.createElement('div');
      overlay = queryElement('.modal-backdrop');

      if (overlay === null) {
        newOverlay.setAttribute('class', 'modal-backdrop' + (ops.animation ? ' fade' : ''));
        overlay = newOverlay;
        document.body.appendChild(overlay);
      }

      return overlay;
    }

    function removeOverlay() {
      overlay = queryElement('.modal-backdrop');

      if (overlay && !document.getElementsByClassName('modal show')[0]) {
        document.body.removeChild(overlay);
        overlay = null;
      }

      overlay === null && (document.body.classList.remove('modal-open'), resetScrollbar());
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      window[action]('resize', self.update, passiveHandler);
      modal[action]('click', dismissHandler, false);
      document[action]('keydown', keyHandler, false);
    }

    function beforeShow() {
      modal.style.display = 'block';
      setScrollbar();
      !document.getElementsByClassName('modal show')[0] && document.body.classList.add('modal-open');
      modal.classList.add('show');
      modal.setAttribute('aria-hidden', false);
      modal.classList.contains('fade') ? emulateTransitionEnd(modal, triggerShow) : triggerShow();
    }

    function triggerShow() {
      setFocus(modal);
      modal.isAnimating = false;
      toggleEvents(1);
      shownCustomEvent = bootstrapCustomEvent('shown', 'modal', relatedTarget);
      dispatchCustomEvent.call(modal, shownCustomEvent);
    }

    function triggerHide(force) {
      modal.style.display = '';
      element && setFocus(element);
      overlay = queryElement('.modal-backdrop');

      if (force !== 1 && overlay && overlay.classList.contains('show') && !document.getElementsByClassName('modal show')[0]) {
        overlay.classList.remove('show');
        emulateTransitionEnd(overlay, removeOverlay);
      } else {
        removeOverlay();
      }

      toggleEvents();
      modal.isAnimating = false;
      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'modal');
      dispatchCustomEvent.call(modal, hiddenCustomEvent);
    }

    function clickHandler(e) {
      if (modal.isAnimating) {
        return;
      }

      var clickTarget = e.target,
          modalID = "#" + modal.getAttribute('id'),
          targetAttrValue = clickTarget.getAttribute('data-target') || clickTarget.getAttribute('href'),
          elemAttrValue = element.getAttribute('data-target') || element.getAttribute('href');

      if (!modal.classList.contains('show') && (clickTarget === element && targetAttrValue === modalID || element.contains(clickTarget) && elemAttrValue === modalID)) {
        modal.modalTrigger = element;
        relatedTarget = element;
        self.show();
        e.preventDefault();
      }
    }

    function keyHandler(ref) {
      var which = ref.which;

      if (!modal.isAnimating && ops.keyboard && which == 27 && modal.classList.contains('show')) {
        self.hide();
      }
    }

    function dismissHandler(e) {
      if (modal.isAnimating) {
        return;
      }

      var clickTarget = e.target,
          hasData = clickTarget.getAttribute('data-dismiss') === 'modal',
          parentWithData = clickTarget.closest('[data-dismiss="modal"]');

      if (modal.classList.contains('show') && (parentWithData || hasData || clickTarget === modal && ops.backdrop !== 'static')) {
        self.hide();
        relatedTarget = null;
        e.preventDefault();
      }
    }

    self.toggle = function () {
      if (modal.classList.contains('show')) {
        self.hide();
      } else {
        self.show();
      }
    };

    self.show = function () {
      if (modal.classList.contains('show') && !!modal.isAnimating) {
        return;
      }

      showCustomEvent = bootstrapCustomEvent('show', 'modal', relatedTarget);
      dispatchCustomEvent.call(modal, showCustomEvent);

      if (showCustomEvent.defaultPrevented) {
        return;
      }

      modal.isAnimating = true;
      var currentOpen = document.getElementsByClassName('modal show')[0];

      if (currentOpen && currentOpen !== modal) {
        currentOpen.modalTrigger && currentOpen.modalTrigger.Modal.hide();
        currentOpen.Modal && currentOpen.Modal.hide();
      }

      if (ops.backdrop) {
        overlay = createOverlay();
      }

      if (overlay && !currentOpen && !overlay.classList.contains('show')) {
        overlay.offsetWidth;
        overlayDelay = getElementTransitionDuration(overlay);
        overlay.classList.add('show');
      }

      !currentOpen ? setTimeout(beforeShow, overlay && overlayDelay ? overlayDelay : 0) : beforeShow();
    };

    self.hide = function (force) {
      if (!modal.classList.contains('show')) {
        return;
      }

      hideCustomEvent = bootstrapCustomEvent('hide', 'modal');
      dispatchCustomEvent.call(modal, hideCustomEvent);

      if (hideCustomEvent.defaultPrevented) {
        return;
      }

      modal.isAnimating = true;
      modal.classList.remove('show');
      modal.setAttribute('aria-hidden', true);
      modal.classList.contains('fade') && force !== 1 ? emulateTransitionEnd(modal, triggerHide) : triggerHide();
    };

    self.setContent = function (content) {
      queryElement('.modal-content', modal).innerHTML = content;
    };

    self.update = function () {
      if (modal.classList.contains('show')) {
        setScrollbar();
      }
    };

    self.dispose = function () {
      self.hide(1);

      if (element) {
        element.removeEventListener('click', clickHandler, false);
        delete element.Modal;
      } else {
        delete modal.Modal;
      }
    };

    element = queryElement(element);
    var checkModal = queryElement(element.getAttribute('data-target') || element.getAttribute('href'));
    modal = element.classList.contains('modal') ? element : checkModal;
    fixedItems = Array.from(document.getElementsByClassName('fixed-top')).concat(Array.from(document.getElementsByClassName('fixed-bottom')));

    if (element.classList.contains('modal')) {
      element = null;
    }

    element && element.Modal && element.Modal.dispose();
    modal && modal.Modal && modal.Modal.dispose();
    ops.keyboard = options.keyboard === false || modal.getAttribute('data-keyboard') === 'false' ? false : true;
    ops.backdrop = options.backdrop === 'static' || modal.getAttribute('data-backdrop') === 'static' ? 'static' : true;
    ops.backdrop = options.backdrop === false || modal.getAttribute('data-backdrop') === 'false' ? false : ops.backdrop;
    ops.animation = modal.classList.contains('fade') ? true : false;
    ops.content = options.content;
    modal.isAnimating = false;

    if (element && !element.Modal) {
      element.addEventListener('click', clickHandler, false);
    }

    if (ops.content) {
      self.setContent(ops.content.trim());
    }

    if (element) {
      modal.modalTrigger = element;
      element.Modal = self;
    } else {
      modal.Modal = self;
    }
  }

  var mouseClickEvents = {
    down: 'mousedown',
    up: 'mouseup'
  };

  function getScroll() {
    return {
      y: window.pageYOffset || document.documentElement.scrollTop,
      x: window.pageXOffset || document.documentElement.scrollLeft
    };
  }

  function styleTip(link, element, position, parent) {
    var tipPositions = /\b(top|bottom|left|right)+/,
        elementDimensions = {
      w: element.offsetWidth,
      h: element.offsetHeight
    },
        windowWidth = document.documentElement.clientWidth || document.body.clientWidth,
        windowHeight = document.documentElement.clientHeight || document.body.clientHeight,
        rect = link.getBoundingClientRect(),
        scroll = parent === document.body ? getScroll() : {
      x: parent.offsetLeft + parent.scrollLeft,
      y: parent.offsetTop + parent.scrollTop
    },
        linkDimensions = {
      w: rect.right - rect.left,
      h: rect.bottom - rect.top
    },
        isPopover = element.classList.contains('popover'),
        arrow = element.getElementsByClassName('arrow')[0],
        halfTopExceed = rect.top + linkDimensions.h / 2 - elementDimensions.h / 2 < 0,
        halfLeftExceed = rect.left + linkDimensions.w / 2 - elementDimensions.w / 2 < 0,
        halfRightExceed = rect.left + elementDimensions.w / 2 + linkDimensions.w / 2 >= windowWidth,
        halfBottomExceed = rect.top + elementDimensions.h / 2 + linkDimensions.h / 2 >= windowHeight,
        topExceed = rect.top - elementDimensions.h < 0,
        leftExceed = rect.left - elementDimensions.w < 0,
        bottomExceed = rect.top + elementDimensions.h + linkDimensions.h >= windowHeight,
        rightExceed = rect.left + elementDimensions.w + linkDimensions.w >= windowWidth;
    position = (position === 'left' || position === 'right') && leftExceed && rightExceed ? 'top' : position;
    position = position === 'top' && topExceed ? 'bottom' : position;
    position = position === 'bottom' && bottomExceed ? 'top' : position;
    position = position === 'left' && leftExceed ? 'right' : position;
    position = position === 'right' && rightExceed ? 'left' : position;
    var topPosition, leftPosition, arrowTop, arrowLeft, arrowWidth, arrowHeight;
    element.className.indexOf(position) === -1 && (element.className = element.className.replace(tipPositions, position));
    arrowWidth = arrow.offsetWidth;
    arrowHeight = arrow.offsetHeight;

    if (position === 'left' || position === 'right') {
      if (position === 'left') {
        leftPosition = rect.left + scroll.x - elementDimensions.w - (isPopover ? arrowWidth : 0);
      } else {
        leftPosition = rect.left + scroll.x + linkDimensions.w;
      }

      if (halfTopExceed) {
        topPosition = rect.top + scroll.y;
        arrowTop = linkDimensions.h / 2 - arrowWidth;
      } else if (halfBottomExceed) {
        topPosition = rect.top + scroll.y - elementDimensions.h + linkDimensions.h;
        arrowTop = elementDimensions.h - linkDimensions.h / 2 - arrowWidth;
      } else {
        topPosition = rect.top + scroll.y - elementDimensions.h / 2 + linkDimensions.h / 2;
        arrowTop = elementDimensions.h / 2 - (isPopover ? arrowHeight * 0.9 : arrowHeight / 2);
      }
    } else if (position === 'top' || position === 'bottom') {
      if (position === 'top') {
        topPosition = rect.top + scroll.y - elementDimensions.h - (isPopover ? arrowHeight : 0);
      } else {
        topPosition = rect.top + scroll.y + linkDimensions.h;
      }

      if (halfLeftExceed) {
        leftPosition = 0;
        arrowLeft = rect.left + linkDimensions.w / 2 - arrowWidth;
      } else if (halfRightExceed) {
        leftPosition = windowWidth - elementDimensions.w * 1.01;
        arrowLeft = elementDimensions.w - (windowWidth - rect.left) + linkDimensions.w / 2 - arrowWidth / 2;
      } else {
        leftPosition = rect.left + scroll.x - elementDimensions.w / 2 + linkDimensions.w / 2;
        arrowLeft = elementDimensions.w / 2 - (isPopover ? arrowWidth : arrowWidth / 2);
      }
    }

    element.style.top = topPosition + 'px';
    element.style.left = leftPosition + 'px';
    arrowTop && (arrow.style.top = arrowTop + 'px');
    arrowLeft && (arrow.style.left = arrowLeft + 'px');
  }

  function Popover(element, options) {
    options = options || {};
    var self = this;
    var popover = null,
        timer = 0,
        isIphone = /(iPhone|iPod|iPad)/.test(navigator.userAgent),
        titleString,
        contentString,
        ops = {};
    var triggerData, animationData, placementData, dismissibleData, delayData, containerData, closeBtn, showCustomEvent, shownCustomEvent, hideCustomEvent, hiddenCustomEvent, containerElement, containerDataElement, modal, navbarFixedTop, navbarFixedBottom, placementClass;

    function dismissibleHandler(e) {
      if (popover !== null && e.target === queryElement('.close', popover)) {
        self.hide();
      }
    }

    function getContents() {
      return {
        0: options.title || element.getAttribute('data-title') || null,
        1: options.content || element.getAttribute('data-content') || null
      };
    }

    function removePopover() {
      ops.container.removeChild(popover);
      timer = null;
      popover = null;
    }

    function createPopover() {
      titleString = getContents()[0] || null;
      contentString = getContents()[1];
      contentString = !!contentString ? contentString.trim() : null;
      popover = document.createElement('div');
      var popoverArrow = document.createElement('div');
      popoverArrow.classList.add('arrow');
      popover.appendChild(popoverArrow);

      if (contentString !== null && ops.template === null) {
        popover.setAttribute('role', 'tooltip');

        if (titleString !== null) {
          var popoverTitle = document.createElement('h3');
          popoverTitle.classList.add('popover-header');
          popoverTitle.innerHTML = ops.dismissible ? titleString + closeBtn : titleString;
          popover.appendChild(popoverTitle);
        }

        var popoverBodyMarkup = document.createElement('div');
        popoverBodyMarkup.classList.add('popover-body');
        popoverBodyMarkup.innerHTML = ops.dismissible && titleString === null ? contentString + closeBtn : contentString;
        popover.appendChild(popoverBodyMarkup);
      } else {
        var popoverTemplate = document.createElement('div');
        popoverTemplate.innerHTML = ops.template.trim();
        popover.className = popoverTemplate.firstChild.className;
        popover.innerHTML = popoverTemplate.firstChild.innerHTML;
        var popoverHeader = queryElement('.popover-header', popover),
            popoverBody = queryElement('.popover-body', popover);
        titleString && popoverHeader && (popoverHeader.innerHTML = titleString.trim());
        contentString && popoverBody && (popoverBody.innerHTML = contentString.trim());
      }

      ops.container.appendChild(popover);
      popover.style.display = 'block';
      !popover.classList.contains('popover') && popover.classList.add('popover');
      !popover.classList.contains(ops.animation) && popover.classList.add(ops.animation);
      !popover.classList.contains(placementClass) && popover.classList.add(placementClass);
    }

    function showPopover() {
      !popover.classList.contains('show') && popover.classList.add('show');
    }

    function updatePopover() {
      styleTip(element, popover, ops.placement, ops.container);
    }

    function forceFocus() {
      if (popover === null) {
        element.focus();
      }
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';

      if (ops.trigger === 'hover') {
        element[action](mouseClickEvents.down, self.show);
        element[action](mouseHoverEvents[0], self.show);

        if (!ops.dismissible) {
          element[action](mouseHoverEvents[1], self.hide);
        }
      } else if ('click' == ops.trigger) {
        element[action](ops.trigger, self.toggle);
      } else if ('focus' == ops.trigger) {
        isIphone && element[action]('click', forceFocus, false);
        element[action](ops.trigger, self.toggle);
      }
    }

    function touchHandler(e) {
      if (popover && popover.contains(e.target) || e.target === element || element.contains(e.target)) ;else {
        self.hide();
      }
    }

    function dismissHandlerToggle(action) {
      action = action ? 'addEventListener' : 'removeEventListener';

      if (ops.dismissible) {
        document[action]('click', dismissibleHandler, false);
      } else {
        'focus' == ops.trigger && element[action]('blur', self.hide);
        'hover' == ops.trigger && document[action]('touchstart', touchHandler, passiveHandler);
      }

      window[action]('resize', self.hide, passiveHandler);
    }

    function showTrigger() {
      dismissHandlerToggle(1);
      dispatchCustomEvent.call(element, shownCustomEvent);
    }

    function hideTrigger() {
      dismissHandlerToggle();
      removePopover();
      dispatchCustomEvent.call(element, hiddenCustomEvent);
    }

    self.toggle = function () {
      if (popover === null) {
        self.show();
      } else {
        self.hide();
      }
    };

    self.show = function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        if (popover === null) {
          dispatchCustomEvent.call(element, showCustomEvent);

          if (showCustomEvent.defaultPrevented) {
            return;
          }

          createPopover();
          updatePopover();
          showPopover();
          !!ops.animation ? emulateTransitionEnd(popover, showTrigger) : showTrigger();
        }
      }, 20);
    };

    self.hide = function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        if (popover && popover !== null && popover.classList.contains('show')) {
          dispatchCustomEvent.call(element, hideCustomEvent);

          if (hideCustomEvent.defaultPrevented) {
            return;
          }

          popover.classList.remove('show');
          !!ops.animation ? emulateTransitionEnd(popover, hideTrigger) : hideTrigger();
        }
      }, ops.delay);
    };

    self.dispose = function () {
      self.hide();
      toggleEvents();
      delete element.Popover;
    };

    element = queryElement(element);
    element.Popover && element.Popover.dispose();
    triggerData = element.getAttribute('data-trigger');
    animationData = element.getAttribute('data-animation');
    placementData = element.getAttribute('data-placement');
    dismissibleData = element.getAttribute('data-dismissible');
    delayData = element.getAttribute('data-delay');
    containerData = element.getAttribute('data-container');
    closeBtn = '<button type="button" class="close">×</button>';
    showCustomEvent = bootstrapCustomEvent('show', 'popover');
    shownCustomEvent = bootstrapCustomEvent('shown', 'popover');
    hideCustomEvent = bootstrapCustomEvent('hide', 'popover');
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'popover');
    containerElement = queryElement(options.container);
    containerDataElement = queryElement(containerData);
    modal = element.closest('.modal');
    navbarFixedTop = element.closest('.fixed-top');
    navbarFixedBottom = element.closest('.fixed-bottom');
    ops.template = options.template ? options.template : null;
    ops.trigger = options.trigger ? options.trigger : triggerData || 'hover';
    ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';
    ops.placement = options.placement ? options.placement : placementData || 'top';
    ops.delay = parseInt(options.delay || delayData) || 200;
    ops.dismissible = options.dismissible || dismissibleData === 'true' ? true : false;
    ops.container = containerElement ? containerElement : containerDataElement ? containerDataElement : navbarFixedTop ? navbarFixedTop : navbarFixedBottom ? navbarFixedBottom : modal ? modal : document.body;
    placementClass = "bs-popover-" + ops.placement;
    var popoverContents = getContents();
    titleString = popoverContents[0];
    contentString = popoverContents[1];

    if (!contentString && !ops.template) {
      return;
    }

    if (!element.Popover) {
      toggleEvents(1);
    }

    element.Popover = self;
  }

  function ScrollSpy(element, options) {
    options = options || {};
    var self = this,
        vars,
        targetData,
        offsetData,
        spyTarget,
        scrollTarget,
        ops = {};

    function updateTargets() {
      var links = spyTarget.getElementsByTagName('A');

      if (vars.length !== links.length) {
        vars.items = [];
        vars.targets = [];
        Array.from(links).map(function (link) {
          var href = link.getAttribute('href'),
              targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#' && queryElement(href);

          if (targetItem) {
            vars.items.push(link);
            vars.targets.push(targetItem);
          }
        });
        vars.length = links.length;
      }
    }

    function updateItem(index) {
      var item = vars.items[index],
          targetItem = vars.targets[index],
          dropmenu = item.classList.contains('dropdown-item') && item.closest('.dropdown-menu'),
          dropLink = dropmenu && dropmenu.previousElementSibling,
          nextSibling = item.nextElementSibling,
          activeSibling = nextSibling && nextSibling.getElementsByClassName('active').length,
          targetRect = vars.isWindow && targetItem.getBoundingClientRect(),
          isActive = item.classList.contains('active') || false,
          topEdge = (vars.isWindow ? targetRect.top + vars.scrollOffset : targetItem.offsetTop) - ops.offset,
          bottomEdge = vars.isWindow ? targetRect.bottom + vars.scrollOffset - ops.offset : vars.targets[index + 1] ? vars.targets[index + 1].offsetTop - ops.offset : element.scrollHeight,
          inside = activeSibling || vars.scrollOffset >= topEdge && bottomEdge > vars.scrollOffset;

      if (!isActive && inside) {
        item.classList.add('active');

        if (dropLink && !dropLink.classList.contains('active')) {
          dropLink.classList.add('active');
        }

        dispatchCustomEvent.call(element, bootstrapCustomEvent('activate', 'scrollspy', vars.items[index]));
      } else if (isActive && !inside) {
        item.classList.remove('active');

        if (dropLink && dropLink.classList.contains('active') && !item.parentNode.getElementsByClassName('active').length) {
          dropLink.classList.remove('active');
        }
      } else if (isActive && inside || !inside && !isActive) {
        return;
      }
    }

    function updateItems() {
      updateTargets();
      vars.scrollOffset = vars.isWindow ? getScroll().y : element.scrollTop;
      vars.items.map(function (l, idx) {
        return updateItem(idx);
      });
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      scrollTarget[action]('scroll', self.refresh, passiveHandler);
      window[action]('resize', self.refresh, passiveHandler);
    }

    self.refresh = function () {
      updateItems();
    };

    self.dispose = function () {
      toggleEvents();
      delete element.ScrollSpy;
    };

    element = queryElement(element);
    element.ScrollSpy && element.ScrollSpy.dispose();
    targetData = element.getAttribute('data-target');
    offsetData = element.getAttribute('data-offset');
    spyTarget = queryElement(options.target || targetData);
    scrollTarget = element.offsetHeight < element.scrollHeight ? element : window;

    if (!spyTarget) {
      return;
    }

    ops.target = spyTarget;
    ops.offset = parseInt(options.offset || offsetData) || 10;
    vars = {};
    vars.length = 0;
    vars.items = [];
    vars.targets = [];
    vars.isWindow = scrollTarget === window;

    if (!element.ScrollSpy) {
      toggleEvents(1);
    }

    self.refresh();
    element.ScrollSpy = self;
  }

  function Tab(element, options) {
    options = options || {};
    var self = this,
        heightData,
        tabs,
        dropdown,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent,
        next,
        tabsContentContainer = false,
        activeTab,
        activeContent,
        nextContent,
        containerHeight,
        equalContents,
        nextHeight,
        animateHeight;

    function triggerEnd() {
      tabsContentContainer.style.height = '';
      tabsContentContainer.classList.remove('collapsing');
      tabs.isAnimating = false;
    }

    function triggerShow() {
      if (tabsContentContainer) {
        if (equalContents) {
          triggerEnd();
        } else {
          setTimeout(function () {
            tabsContentContainer.style.height = nextHeight + "px";
            tabsContentContainer.offsetWidth;
            emulateTransitionEnd(tabsContentContainer, triggerEnd);
          }, 50);
        }
      } else {
        tabs.isAnimating = false;
      }

      shownCustomEvent = bootstrapCustomEvent('shown', 'tab', activeTab);
      dispatchCustomEvent.call(next, shownCustomEvent);
    }

    function triggerHide() {
      if (tabsContentContainer) {
        activeContent.style["float"] = 'left';
        nextContent.style["float"] = 'left';
        containerHeight = activeContent.scrollHeight;
      }

      showCustomEvent = bootstrapCustomEvent('show', 'tab', activeTab);
      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tab', next);
      dispatchCustomEvent.call(next, showCustomEvent);

      if (showCustomEvent.defaultPrevented) {
        return;
      }

      nextContent.classList.add('active');
      activeContent.classList.remove('active');

      if (tabsContentContainer) {
        nextHeight = nextContent.scrollHeight;
        equalContents = nextHeight === containerHeight;
        tabsContentContainer.classList.add('collapsing');
        tabsContentContainer.style.height = containerHeight + "px";
        tabsContentContainer.offsetHeight;
        activeContent.style["float"] = '';
        nextContent.style["float"] = '';
      }

      if (nextContent.classList.contains('fade')) {
        setTimeout(function () {
          nextContent.classList.add('show');
          emulateTransitionEnd(nextContent, triggerShow);
        }, 20);
      } else {
        triggerShow();
      }

      dispatchCustomEvent.call(activeTab, hiddenCustomEvent);
    }

    function getActiveTab() {
      var activeTabs = tabs.getElementsByClassName('active'),
          activeTab;

      if (activeTabs.length === 1 && !activeTabs[0].parentNode.classList.contains('dropdown')) {
        activeTab = activeTabs[0];
      } else if (activeTabs.length > 1) {
        activeTab = activeTabs[activeTabs.length - 1];
      }

      return activeTab;
    }

    function getActiveContent() {
      return queryElement(getActiveTab().getAttribute('href'));
    }

    function clickHandler(e) {
      e.preventDefault();
      next = e.currentTarget;
      !tabs.isAnimating && self.show();
    }

    self.show = function () {
      next = next || element;

      if (!next.classList.contains('active')) {
        nextContent = queryElement(next.getAttribute('href'));
        activeTab = getActiveTab();
        activeContent = getActiveContent();
        hideCustomEvent = bootstrapCustomEvent('hide', 'tab', next);
        dispatchCustomEvent.call(activeTab, hideCustomEvent);

        if (hideCustomEvent.defaultPrevented) {
          return;
        }

        tabs.isAnimating = true;
        activeTab.classList.remove('active');
        activeTab.setAttribute('aria-selected', 'false');
        next.classList.add('active');
        next.setAttribute('aria-selected', 'true');

        if (dropdown) {
          if (!element.parentNode.classList.contains('dropdown-menu')) {
            if (dropdown.classList.contains('active')) {
              dropdown.classList.remove('active');
            }
          } else {
            if (!dropdown.classList.contains('active')) {
              dropdown.classList.add('active');
            }
          }
        }

        if (activeContent.classList.contains('fade')) {
          activeContent.classList.remove('show');
          emulateTransitionEnd(activeContent, triggerHide);
        } else {
          triggerHide();
        }
      }
    };

    self.dispose = function () {
      element.removeEventListener('click', clickHandler, false);
      delete element.Tab;
    };

    element = queryElement(element);
    element.Tab && element.Tab.dispose();
    heightData = element.getAttribute('data-height');
    tabs = element.closest('.nav');
    dropdown = tabs && queryElement('.dropdown-toggle', tabs);
    animateHeight = !supportTransition || options.height === false || heightData === 'false' ? false : true;
    tabs.isAnimating = false;

    if (!element.Tab) {
      element.addEventListener('click', clickHandler, false);
    }

    if (animateHeight) {
      tabsContentContainer = getActiveContent().parentNode;
    }

    element.Tab = self;
  }

  function Toast(element, options) {
    options = options || {};
    var self = this,
        toast,
        timer = 0,
        animationData,
        autohideData,
        delayData,
        showCustomEvent,
        hideCustomEvent,
        shownCustomEvent,
        hiddenCustomEvent,
        ops = {};

    function showComplete() {
      toast.classList.remove('showing');
      toast.classList.add('show');
      dispatchCustomEvent.call(toast, shownCustomEvent);

      if (ops.autohide) {
        self.hide();
      }
    }

    function hideComplete() {
      toast.classList.add('hide');
      dispatchCustomEvent.call(toast, hiddenCustomEvent);
    }

    function close() {
      toast.classList.remove('show');
      ops.animation ? emulateTransitionEnd(toast, hideComplete) : hideComplete();
    }

    function disposeComplete() {
      clearTimeout(timer);
      element.removeEventListener('click', self.hide, false);
      delete element.Toast;
    }

    self.show = function () {
      if (toast && !toast.classList.contains('show')) {
        dispatchCustomEvent.call(toast, showCustomEvent);

        if (showCustomEvent.defaultPrevented) {
          return;
        }

        ops.animation && toast.classList.add('fade');
        toast.classList.remove('hide');
        toast.offsetWidth;
        toast.classList.add('showing');
        ops.animation ? emulateTransitionEnd(toast, showComplete) : showComplete();
      }
    };

    self.hide = function (noTimer) {
      if (toast && toast.classList.contains('show')) {
        dispatchCustomEvent.call(toast, hideCustomEvent);

        if (hideCustomEvent.defaultPrevented) {
          return;
        }

        noTimer ? close() : timer = setTimeout(close, ops.delay);
      }
    };

    self.dispose = function () {
      ops.animation ? emulateTransitionEnd(toast, disposeComplete) : disposeComplete();
    };

    element = queryElement(element);
    element.Toast && element.Toast.dispose();
    toast = element.closest('.toast');
    animationData = element.getAttribute('data-animation');
    autohideData = element.getAttribute('data-autohide');
    delayData = element.getAttribute('data-delay');
    showCustomEvent = bootstrapCustomEvent('show', 'toast');
    hideCustomEvent = bootstrapCustomEvent('hide', 'toast');
    shownCustomEvent = bootstrapCustomEvent('shown', 'toast');
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'toast');
    ops.animation = options.animation === false || animationData === 'false' ? 0 : 1;
    ops.autohide = options.autohide === false || autohideData === 'false' ? 0 : 1;
    ops.delay = parseInt(options.delay || delayData) || 500;

    if (!element.Toast) {
      element.addEventListener('click', self.hide, false);
    }

    element.Toast = self;
  }

  function Tooltip(element, options) {
    options = options || {};
    var self = this,
        tooltip = null,
        timer = 0,
        titleString,
        animationData,
        placementData,
        delayData,
        containerData,
        showCustomEvent,
        shownCustomEvent,
        hideCustomEvent,
        hiddenCustomEvent,
        containerElement,
        containerDataElement,
        modal,
        navbarFixedTop,
        navbarFixedBottom,
        placementClass,
        ops = {};

    function getTitle() {
      return element.getAttribute('title') || element.getAttribute('data-title') || element.getAttribute('data-original-title');
    }

    function removeToolTip() {
      ops.container.removeChild(tooltip);
      tooltip = null;
      timer = null;
    }

    function createToolTip() {
      titleString = getTitle();

      if (titleString) {
        tooltip = document.createElement('div');

        if (ops.template) {
          var tooltipMarkup = document.createElement('div');
          tooltipMarkup.innerHTML = ops.template.trim();
          tooltip.className = tooltipMarkup.firstChild.className;
          tooltip.innerHTML = tooltipMarkup.firstChild.innerHTML;
          queryElement('.tooltip-inner', tooltip).innerHTML = titleString.trim();
        } else {
          var tooltipArrow = document.createElement('div');
          tooltipArrow.classList.add('arrow');
          tooltip.appendChild(tooltipArrow);
          var tooltipInner = document.createElement('div');
          tooltipInner.classList.add('tooltip-inner');
          tooltip.appendChild(tooltipInner);
          tooltipInner.innerHTML = titleString;
        }

        tooltip.style.left = '0';
        tooltip.style.top = '0';
        tooltip.setAttribute('role', 'tooltip');
        !tooltip.classList.contains('tooltip') && tooltip.classList.add('tooltip');
        !tooltip.classList.contains(ops.animation) && tooltip.classList.add(ops.animation);
        !tooltip.classList.contains(placementClass) && tooltip.classList.add(placementClass);
        ops.container.appendChild(tooltip);
      }
    }

    function updateTooltip() {
      styleTip(element, tooltip, ops.placement, ops.container);
    }

    function showTooltip() {
      !tooltip.classList.contains('show') && tooltip.classList.add('show');
    }

    function touchHandler(e) {
      if (tooltip && tooltip.contains(e.target) || e.target === element || element.contains(e.target)) ;else {
        self.hide();
      }
    }

    function toggleAction(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      document[action]('touchstart', touchHandler, passiveHandler);
      window[action]('resize', self.hide, passiveHandler);
    }

    function showAction() {
      toggleAction(1);
      dispatchCustomEvent.call(element, shownCustomEvent);
    }

    function hideAction() {
      toggleAction();
      removeToolTip();
      dispatchCustomEvent.call(element, hiddenCustomEvent);
    }

    function toggleEvents(action) {
      action = action ? 'addEventListener' : 'removeEventListener';
      element[action](mouseClickEvents.down, self.show, false);
      element[action](mouseHoverEvents[0], self.show, false);
      element[action](mouseHoverEvents[1], self.hide, false);
    }

    self.show = function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        if (tooltip === null) {
          dispatchCustomEvent.call(element, showCustomEvent);

          if (showCustomEvent.defaultPrevented) {
            return;
          }

          if (createToolTip() !== false) {
            updateTooltip();
            showTooltip();
            !!ops.animation ? emulateTransitionEnd(tooltip, showAction) : showAction();
          }
        }
      }, 20);
    };

    self.hide = function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        if (tooltip && tooltip.classList.contains('show')) {
          dispatchCustomEvent.call(element, hideCustomEvent);

          if (hideCustomEvent.defaultPrevented) {
            return;
          }

          tooltip.classList.remove('show');
          !!ops.animation ? emulateTransitionEnd(tooltip, hideAction) : hideAction();
        }
      }, ops.delay);
    };

    self.toggle = function () {
      if (!tooltip) {
        self.show();
      } else {
        self.hide();
      }
    };

    self.dispose = function () {
      toggleEvents();
      self.hide();
      element.setAttribute('title', element.getAttribute('data-original-title'));
      element.removeAttribute('data-original-title');
      delete element.Tooltip;
    };

    element = queryElement(element);
    element.Tooltip && element.Tooltip.dispose();
    animationData = element.getAttribute('data-animation');
    placementData = element.getAttribute('data-placement');
    delayData = element.getAttribute('data-delay');
    containerData = element.getAttribute('data-container');
    showCustomEvent = bootstrapCustomEvent('show', 'tooltip');
    shownCustomEvent = bootstrapCustomEvent('shown', 'tooltip');
    hideCustomEvent = bootstrapCustomEvent('hide', 'tooltip');
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tooltip');
    containerElement = queryElement(options.container);
    containerDataElement = queryElement(containerData);
    modal = element.closest('.modal');
    navbarFixedTop = element.closest('.fixed-top');
    navbarFixedBottom = element.closest('.fixed-bottom');
    ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';
    ops.placement = options.placement ? options.placement : placementData || 'top';
    ops.template = options.template ? options.template : null;
    ops.delay = parseInt(options.delay || delayData) || 200;
    ops.container = containerElement ? containerElement : containerDataElement ? containerDataElement : navbarFixedTop ? navbarFixedTop : navbarFixedBottom ? navbarFixedBottom : modal ? modal : document.body;
    placementClass = "bs-tooltip-" + ops.placement;
    titleString = getTitle();

    if (!titleString) {
      return;
    }

    if (!element.Tooltip) {
      element.setAttribute('data-original-title', titleString);
      element.removeAttribute('title');
      toggleEvents(1);
    }

    element.Tooltip = self;
  }

  var componentsInit = {};

  function initializeDataAPI(Constructor, collection) {
    Array.from(collection).map(function (x) {
      return new Constructor(x);
    });
  }

  function initCallback(lookUp) {
    lookUp = lookUp || document;

    for (var component in componentsInit) {
      initializeDataAPI(componentsInit[component][0], lookUp.querySelectorAll(componentsInit[component][1]));
    }
  }

  componentsInit.Alert = [Alert, '[data-dismiss="alert"]'];
  componentsInit.Button = [Button, '[data-toggle="buttons"]'];
  componentsInit.Carousel = [Carousel, '[data-ride="carousel"]'];
  componentsInit.Collapse = [Collapse, '[data-toggle="collapse"]'];
  componentsInit.Dropdown = [Dropdown, '[data-toggle="dropdown"]'];
  componentsInit.Modal = [Modal, '[data-toggle="modal"]'];
  componentsInit.Popover = [Popover, '[data-toggle="popover"],[data-tip="popover"]'];
  componentsInit.ScrollSpy = [ScrollSpy, '[data-spy="scroll"]'];
  componentsInit.Tab = [Tab, '[data-toggle="tab"]'];
  componentsInit.Toast = [Toast, '[data-dismiss="toast"]'];
  componentsInit.Tooltip = [Tooltip, '[data-toggle="tooltip"],[data-tip="tooltip"]'];
  document.body ? initCallback() : document.addEventListener('DOMContentLoaded', function initWrapper() {
    initCallback();
    document.removeEventListener('DOMContentLoaded', initWrapper, false);
  }, false);

  function removeElementDataAPI(ConstructorName, collection) {
    Array.from(collection).map(function (x) {
      return x[ConstructorName].dispose();
    });
  }

  function removeDataAPI(lookUp) {
    lookUp = lookUp || document;

    for (var component in componentsInit) {
      removeElementDataAPI(component, lookUp.querySelectorAll(componentsInit[component][1]));
    }
  }

  var version = "3.0.10";
  var index = {
    Alert: Alert,
    Button: Button,
    Carousel: Carousel,
    Collapse: Collapse,
    Dropdown: Dropdown,
    Modal: Modal,
    Popover: Popover,
    ScrollSpy: ScrollSpy,
    Tab: Tab,
    Toast: Toast,
    Tooltip: Tooltip,
    initCallback: initCallback,
    removeDataAPI: removeDataAPI,
    componentsInit: componentsInit,
    Version: version
  };

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var bind = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      return fn.apply(thisArg, args);
    };
  };

  /*global toString:true*/
  // utils is a library of generic helper functions non-specific to axios


  var toString = Object.prototype.toString;
  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */

  function isArray(val) {
    return toString.call(val) === '[object Array]';
  }
  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */


  function isUndefined(val) {
    return typeof val === 'undefined';
  }
  /**
   * Determine if a value is a Buffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Buffer, otherwise false
   */


  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
  }
  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */


  function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
  }
  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */


  function isFormData(val) {
    return typeof FormData !== 'undefined' && val instanceof FormData;
  }
  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */


  function isArrayBufferView(val) {
    var result;

    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }

    return result;
  }
  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */


  function isString(val) {
    return typeof val === 'string';
  }
  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */


  function isNumber(val) {
    return typeof val === 'number';
  }
  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */


  function isObject(val) {
    return val !== null && _typeof(val) === 'object';
  }
  /**
   * Determine if a value is a plain Object
   *
   * @param {Object} val The value to test
   * @return {boolean} True if value is a plain Object, otherwise false
   */


  function isPlainObject(val) {
    if (toString.call(val) !== '[object Object]') {
      return false;
    }

    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */


  function isDate(val) {
    return toString.call(val) === '[object Date]';
  }
  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */


  function isFile(val) {
    return toString.call(val) === '[object File]';
  }
  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */


  function isBlob(val) {
    return toString.call(val) === '[object Blob]';
  }
  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */


  function isFunction(val) {
    return toString.call(val) === '[object Function]';
  }
  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */


  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */


  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }
  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */


  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }
  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */


  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
      return false;
    }

    return typeof window !== 'undefined' && typeof document !== 'undefined';
  }
  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */


  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    } // Force an array if not already something iterable


    if (_typeof(obj) !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */


  function merge()
  /* obj1, obj2, obj3, ... */
  {
    var result = {};

    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }

    return result;
  }
  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */


  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  /**
   * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
   *
   * @param {string} content with BOM
   * @return {string} content value without BOM
   */


  function stripBOM(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
      content = content.slice(1);
    }

    return content;
  }

  var utils = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM
  };

  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  }
  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */


  var buildURL = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;

    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }

          parts.push(encode(key) + '=' + encode(v));
        });
      });
      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');

      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  function InterceptorManager() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */


  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */


  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */


  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager;

  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */


  var transformData = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };

  var isCancel = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */

  var enhanceError = function enhanceError(error, config, code, request, response) {
    error.config = config;

    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };

    return error;
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */


  var createError = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */


  var settle = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;

    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
    }
  };

  var cookies = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  }() : // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() {
        return null;
      },
      remove: function remove() {}
    };
  }();

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */

  var isAbsoluteURL = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */

  var combineURLs = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
  };

  /**
   * Creates a new URL by combining the baseURL with the requestedURL,
   * only when the requestedURL is not already an absolute URL.
   * If the requestURL is absolute, this function returns the requestedURL untouched.
   *
   * @param {string} baseURL The base URL
   * @param {string} requestedURL Absolute or relative URL to combine
   * @returns {string} The combined full path
   */


  var buildFullPath = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }

    return requestedURL;
  };

  // c.f. https://nodejs.org/api/http.html#http_message_headers


  var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */

  var parseHeaders = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) {
      return parsed;
    }

    utils.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }

        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });
    return parsed;
  };

  var isURLSameOrigin = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */

    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */

    return function isURLSameOrigin(requestURL) {
      var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();

  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      if ((utils.isBlob(requestData) || utils.isFile(requestData)) && requestData.type) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest(); // HTTP basic authentication

      if (config.auth) {
        var username = config.auth.username || '';
        var password = unescape(encodeURIComponent(config.auth.password)) || '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

      request.timeout = config.timeout; // Listen for ready state

      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        } // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request


        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        } // Prepare the response


        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };
        settle(resolve, reject, response); // Clean up request

        request = null;
      }; // Handle browser request cancellation (as opposed to a manual cancellation)


      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Handle low level network errors


      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request)); // Clean up request

        request = null;
      }; // Handle timeout


      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }

        reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.


      if (utils.isStandardBrowserEnv()) {
        // Add xsrf header
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      } // Add headers to the request


      if ('setRequestHeader' in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      } // Add withCredentials to request if needed


      if (!utils.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      } // Add responseType to request if needed


      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
          // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      } // Handle progress if needed


      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      } // Not all browsers support upload events


      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel); // Clean up request

          request = null;
        });
      }

      if (!requestData) {
        requestData = null;
      } // Send the request


      request.send(requestData);
    });
  };

  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter;

    if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    }

    return adapter;
  }

  var defaults = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');

      if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
        return data;
      }

      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }

      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }

      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
        return JSON.stringify(data);
      }

      return data;
    }],
    transformResponse: [function transformResponse(data) {
      /*eslint no-param-reassign:0*/
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) {
          /* Ignore */
        }
      }

      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };
  utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });
  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults;

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */


  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */


  var dispatchRequest = function dispatchRequest(config) {
    throwIfCancellationRequested(config); // Ensure headers exist

    config.headers = config.headers || {}; // Transform request data

    config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults_1.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config); // Transform response data

      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config); // Transform response data

        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }

      return Promise.reject(reason);
    });
  };

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */


  var mergeConfig = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ['url', 'method', 'data'];
    var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
    var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
    var directMergeKeys = ['validateStatus'];

    function getMergedValue(target, source) {
      if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
        return utils.merge(target, source);
      } else if (utils.isPlainObject(source)) {
        return utils.merge({}, source);
      } else if (utils.isArray(source)) {
        return source.slice();
      }

      return source;
    }

    function mergeDeepProperties(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    }

    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(undefined, config2[prop]);
      }
    });
    utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(undefined, config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    });
    utils.forEach(directMergeKeys, function merge(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils.forEach(otherKeys, mergeDeepProperties);
    return config;
  };

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */


  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_1(),
      response: new InterceptorManager_1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */


  Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig(this.defaults, config); // Set config.method

    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = 'get';
    } // Hook up interceptors middleware


    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  };

  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  }; // Provide aliases for supported request methods


  utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function (url, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        url: url
      }));
    };
  });
  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function (url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });
  var Axios_1 = Axios;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */

  function Cancel(message) {
    this.message = message;
  }

  Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */


  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel_1(message);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `Cancel` if cancellation has been requested.
   */


  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */


  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */

  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */


  function createInstance(defaultConfig) {
    var context = new Axios_1(defaultConfig);
    var instance = bind(Axios_1.prototype.request, context); // Copy axios.prototype to instance

    utils.extend(instance, Axios_1.prototype, context); // Copy context to instance

    utils.extend(instance, context);
    return instance;
  } // Create the default instance to be exported


  var axios = createInstance(defaults_1); // Expose Axios class to allow class inheritance

  axios.Axios = Axios_1; // Factory for creating new instances

  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  }; // Expose Cancel & CancelToken


  axios.Cancel = Cancel_1;
  axios.CancelToken = CancelToken_1;
  axios.isCancel = isCancel; // Expose all/spread

  axios.all = function all(promises) {
    return Promise.all(promises);
  };

  axios.spread = spread;
  var axios_1 = axios; // Allow use of default import syntax in TypeScript

  var _default = axios;
  axios_1["default"] = _default;

  var axios$1 = axios_1;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var lodash=createCommonjsModule(function(module,exports){(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined$1;/** Used as the semantic version number. */var VERSION='4.17.20';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
     * Used to match
     * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
     */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange="\\ud800-\\udfff",rsComboMarksRange="\\u0300-\\u036f",reComboHalfMarksRange="\\ufe20-\\ufe2f",rsComboSymbolsRange="\\u20d0-\\u20ff",rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange="\\u2700-\\u27bf",rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange="\\u2000-\\u206f",rsSpaceRange=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange="\\ufe0e\\ufe0f",rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz="\\ud83c[\\udffb-\\udfff]",rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}",rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]",rsUpper='['+rsUpperRange+']',rsZWJ="\\u200d";/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
  '\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
  "\u0100":'A',"\u0102":'A',"\u0104":'A',"\u0101":'a',"\u0103":'a',"\u0105":'a',"\u0106":'C',"\u0108":'C',"\u010A":'C',"\u010C":'C',"\u0107":'c',"\u0109":'c',"\u010B":'c',"\u010D":'c',"\u010E":'D',"\u0110":'D',"\u010F":'d',"\u0111":'d',"\u0112":'E',"\u0114":'E',"\u0116":'E',"\u0118":'E',"\u011A":'E',"\u0113":'e',"\u0115":'e',"\u0117":'e',"\u0119":'e',"\u011B":'e',"\u011C":'G',"\u011E":'G',"\u0120":'G',"\u0122":'G',"\u011D":'g',"\u011F":'g',"\u0121":'g',"\u0123":'g',"\u0124":'H',"\u0126":'H',"\u0125":'h',"\u0127":'h',"\u0128":'I',"\u012A":'I',"\u012C":'I',"\u012E":'I',"\u0130":'I',"\u0129":'i',"\u012B":'i',"\u012D":'i',"\u012F":'i',"\u0131":'i',"\u0134":'J',"\u0135":'j',"\u0136":'K',"\u0137":'k',"\u0138":'k',"\u0139":'L',"\u013B":'L',"\u013D":'L',"\u013F":'L',"\u0141":'L',"\u013A":'l',"\u013C":'l',"\u013E":'l',"\u0140":'l',"\u0142":'l',"\u0143":'N',"\u0145":'N',"\u0147":'N',"\u014A":'N',"\u0144":'n',"\u0146":'n',"\u0148":'n',"\u014B":'n',"\u014C":'O',"\u014E":'O',"\u0150":'O',"\u014D":'o',"\u014F":'o',"\u0151":'o',"\u0154":'R',"\u0156":'R',"\u0158":'R',"\u0155":'r',"\u0157":'r',"\u0159":'r',"\u015A":'S',"\u015C":'S',"\u015E":'S',"\u0160":'S',"\u015B":'s',"\u015D":'s',"\u015F":'s',"\u0161":'s',"\u0162":'T',"\u0164":'T',"\u0166":'T',"\u0163":'t',"\u0165":'t',"\u0167":'t',"\u0168":'U',"\u016A":'U',"\u016C":'U',"\u016E":'U',"\u0170":'U',"\u0172":'U',"\u0169":'u',"\u016B":'u',"\u016D":'u',"\u016F":'u',"\u0171":'u',"\u0173":'u',"\u0174":'W',"\u0175":'w',"\u0176":'Y',"\u0177":'y',"\u0178":'Y',"\u0179":'Z',"\u017B":'Z',"\u017D":'Z',"\u017A":'z',"\u017C":'z',"\u017E":'z',"\u0132":'IJ',"\u0133":'ij',"\u0152":'Oe',"\u0153":'oe',"\u0149":"'n","\u017F":'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r',"\u2028":'u2028',"\u2029":'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(commonjsGlobal)=='object'&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&'object'=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
  var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
  return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
     * A specialized version of `baseAggregator` for arrays.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
     * A specialized version of `_.forEachRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
     * A specialized version of `_.every` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */function arrayIncludes(array,value){var length=array==null?0:array.length;return !!length&&baseIndexOf(array,value,0)>-1;}/**
     * This function is like `arrayIncludes` except that it accepts a comparator.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
     * A specialized version of `_.reduceRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the last element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */var asciiSize=baseProperty('length');/**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function asciiToArray(string){return string.split('');}/**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
     * The base implementation of methods like `_.findKey` and `_.findLastKey`,
     * without support for iteratee shorthands, which iterates over `collection`
     * using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return -1;}/**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
     * This function is like `baseIndexOf` except that it accepts a comparator.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return -1;}/**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */function baseIsNaN(value){return value!==value;}/**
     * The base implementation of `_.mean` and `_.meanBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the mean.
     */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function baseProperty(key){return function(object){return object==null?undefined$1:object[key];};}/**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyOf(object){return function(key){return object==null?undefined$1:object[key];};}/**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of
     *  `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
     * The base implementation of `_.sortBy` which uses `comparer` to define the
     * sort order of `array` and replaces criteria objects with their corresponding
     * values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
     * The base implementation of `_.sum` and `_.sumBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined$1){result=result===undefined$1?current:result+current;}}return result;}/**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
     * of key-value pairs for `object` corresponding to the property names of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the key-value pairs.
     */function baseToPairs(object,props){return arrayMap(props,function(key){return [key,object[key]];});}/**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */function baseUnary(func){return function(value){return func(value);};}/**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function cacheHas(cache,key){return cache.has(key);}/**
     * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the first unmatched string symbol.
     */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the last unmatched string symbol.
     */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
     * Gets the number of `placeholder` occurrences in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} placeholder The placeholder to search for.
     * @returns {number} Returns the placeholder count.
     */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */var deburrLetter=basePropertyOf(deburredLetters);/**
     * Used by `_.escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
     * Used by `_.template` to escape characters for inclusion in compiled string literals.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */function escapeStringChar(chr){return '\\'+stringEscapes[chr];}/**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function getValue(object,key){return object==null?undefined$1:object[key];}/**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */function hasUnicode(string){return reHasUnicode.test(string);}/**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
     * Converts `set` to its value-value pairs.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the value-value pairs.
     */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return -1;}/**
     * A specialized version of `_.lastIndexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
     * Used by `_.unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} chr The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
     * Create a new pristine `lodash` function using the `context` object.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Util
     * @param {Object} [context=root] The context object.
     * @returns {Function} Returns a new `lodash` function.
     * @example
     *
     * _.mixin({ 'foo': _.constant('foo') });
     *
     * var lodash = _.runInContext();
     * lodash.mixin({ 'bar': lodash.constant('bar') });
     *
     * _.isFunction(_.foo);
     * // => true
     * _.isFunction(_.bar);
     * // => false
     *
     * lodash.isFunction(lodash.foo);
     * // => false
     * lodash.isFunction(lodash.bar);
     * // => true
     *
     * // Create a suped-up `defer` in Node.js.
     * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
     */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined$1,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined$1,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=_Symbol?_Symbol.isConcatSpreadable:undefined$1,symIterator=_Symbol?_Symbol.iterator:undefined$1,symToStringTag=_Symbol?_Symbol.toStringTag:undefined$1;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined$1,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined$1,symbolValueOf=symbolProto?symbolProto.valueOf:undefined$1,symbolToString=symbolProto?symbolProto.toString:undefined$1;/*------------------------------------------------------------------------*/ /**
       * Creates a `lodash` object which wraps `value` to enable implicit method
       * chain sequences. Methods that operate on and return arrays, collections,
       * and functions can be chained together. Methods that retrieve a single value
       * or may return a primitive value will automatically end the chain sequence
       * and return the unwrapped value. Otherwise, the value must be unwrapped
       * with `_#value`.
       *
       * Explicit chain sequences, which must be unwrapped with `_#value`, may be
       * enabled using `_.chain`.
       *
       * The execution of chained methods is lazy, that is, it's deferred until
       * `_#value` is implicitly or explicitly called.
       *
       * Lazy evaluation allows several methods to support shortcut fusion.
       * Shortcut fusion is an optimization to merge iteratee calls; this avoids
       * the creation of intermediate arrays and can greatly reduce the number of
       * iteratee executions. Sections of a chain sequence qualify for shortcut
       * fusion if the section is applied to an array and iteratees accept only
       * one argument. The heuristic for whether a section qualifies for shortcut
       * fusion is subject to change.
       *
       * Chaining is supported in custom builds as long as the `_#value` method is
       * directly or indirectly included in the build.
       *
       * In addition to lodash methods, wrappers have `Array` and `String` methods.
       *
       * The wrapper `Array` methods are:
       * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
       *
       * The wrapper `String` methods are:
       * `replace` and `split`
       *
       * The wrapper methods that support shortcut fusion are:
       * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
       * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
       * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
       *
       * The chainable wrapper methods are:
       * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
       * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
       * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
       * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
       * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
       * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
       * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
       * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
       * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
       * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
       * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
       * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
       * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
       * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
       * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
       * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
       * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
       * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
       * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
       * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
       * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
       * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
       * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
       * `zipObject`, `zipObjectDeep`, and `zipWith`
       *
       * The wrapper methods that are **not** chainable by default are:
       * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
       * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
       * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
       * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
       * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
       * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
       * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
       * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
       * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
       * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
       * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
       * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
       * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
       * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
       * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
       * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
       * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
       * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
       * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
       * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
       * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
       * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
       * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
       * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
       * `upperFirst`, `value`, and `words`
       *
       * @name _
       * @constructor
       * @category Seq
       * @param {*} value The value to wrap in a `lodash` instance.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2, 3]);
       *
       * // Returns an unwrapped value.
       * wrapped.reduce(_.add);
       * // => 6
       *
       * // Returns a wrapped value.
       * var squares = wrapped.map(square);
       *
       * _.isArray(squares);
       * // => false
       *
       * _.isArray(squares.value());
       * // => true
       */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
       * The base implementation of `_.create` without support for assigning
       * properties to the created object.
       *
       * @private
       * @param {Object} proto The object to inherit from.
       * @returns {Object} Returns the new object.
       */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return {};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined$1;return result;};}();/**
       * The function whose prototype chain sequence wrappers inherit from.
       *
       * @private
       */function baseLodash(){// No operation performed.
  }/**
       * The base constructor for creating `lodash` wrapper objects.
       *
       * @private
       * @param {*} value The value to wrap.
       * @param {boolean} [chainAll] Enable explicit method chain sequences.
       */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined$1;}/**
       * By default, the template delimiters used by lodash are like those in
       * embedded Ruby (ERB) as well as ES2015 template strings. Change the
       * following template settings to use alternative delimiters.
       *
       * @static
       * @memberOf _
       * @type {Object}
       */lodash.templateSettings={/**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'escape':reEscape,/**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'evaluate':reEvaluate,/**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'interpolate':reInterpolate,/**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */'variable':'',/**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */'imports':{/**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
  lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
       * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
       *
       * @private
       * @constructor
       * @param {*} value The value to wrap.
       */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
       * Creates a clone of the lazy wrapper object.
       *
       * @private
       * @name clone
       * @memberOf LazyWrapper
       * @returns {Object} Returns the cloned `LazyWrapper` object.
       */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
       * Reverses the direction of lazy iteration.
       *
       * @private
       * @name reverse
       * @memberOf LazyWrapper
       * @returns {Object} Returns the new reversed `LazyWrapper` object.
       */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else {result=this.clone();result.__dir__*=-1;}return result;}/**
       * Extracts the unwrapped value from its lazy wrapper.
       *
       * @private
       * @name value
       * @memberOf LazyWrapper
       * @returns {*} Returns the unwrapped value.
       */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else {break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
  LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
       * Creates a hash object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the hash.
       *
       * @private
       * @name clear
       * @memberOf Hash
       */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
       * Removes `key` and its value from the hash.
       *
       * @private
       * @name delete
       * @memberOf Hash
       * @param {Object} hash The hash to modify.
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
       * Gets the hash value for `key`.
       *
       * @private
       * @name get
       * @memberOf Hash
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined$1:result;}return hasOwnProperty.call(data,key)?data[key]:undefined$1;}/**
       * Checks if a hash value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Hash
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined$1:hasOwnProperty.call(data,key);}/**
       * Sets the hash `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Hash
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the hash instance.
       */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined$1?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
  Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
       * Creates an list cache object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the list cache.
       *
       * @private
       * @name clear
       * @memberOf ListCache
       */function listCacheClear(){this.__data__=[];this.size=0;}/**
       * Removes `key` and its value from the list cache.
       *
       * @private
       * @name delete
       * @memberOf ListCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else {splice.call(data,index,1);}--this.size;return true;}/**
       * Gets the list cache value for `key`.
       *
       * @private
       * @name get
       * @memberOf ListCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined$1:data[index][1];}/**
       * Checks if a list cache value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf ListCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
       * Sets the list cache `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf ListCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the list cache instance.
       */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else {data[index][1]=value;}return this;}// Add methods to `ListCache`.
  ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
       * Creates a map cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the map.
       *
       * @private
       * @name clear
       * @memberOf MapCache
       */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
       * Removes `key` and its value from the map.
       *
       * @private
       * @name delete
       * @memberOf MapCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
       * Gets the map value for `key`.
       *
       * @private
       * @name get
       * @memberOf MapCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
       * Checks if a map value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf MapCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
       * Sets the map `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf MapCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the map cache instance.
       */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
  MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
       *
       * Creates an array cache object to store unique values.
       *
       * @private
       * @constructor
       * @param {Array} [values] The values to cache.
       */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
       * Adds `value` to the array cache.
       *
       * @private
       * @name add
       * @memberOf SetCache
       * @alias push
       * @param {*} value The value to cache.
       * @returns {Object} Returns the cache instance.
       */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
       * Checks if `value` is in the array cache.
       *
       * @private
       * @name has
       * @memberOf SetCache
       * @param {*} value The value to search for.
       * @returns {number} Returns `true` if `value` is found, else `false`.
       */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
  SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
       * Creates a stack cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
       * Removes all key-value entries from the stack.
       *
       * @private
       * @name clear
       * @memberOf Stack
       */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
       * Removes `key` and its value from the stack.
       *
       * @private
       * @name delete
       * @memberOf Stack
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
       * Gets the stack value for `key`.
       *
       * @private
       * @name get
       * @memberOf Stack
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function stackGet(key){return this.__data__.get(key);}/**
       * Checks if a stack value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Stack
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function stackHas(key){return this.__data__.has(key);}/**
       * Sets the stack `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Stack
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the stack cache instance.
       */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
  Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
       * Creates an array of the enumerable property names of the array-like `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @param {boolean} inherited Specify returning inherited property names.
       * @returns {Array} Returns the array of property names.
       */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
  key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
  isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
  isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
  isIndex(key,length)))){result.push(key);}}return result;}/**
       * A specialized version of `_.sample` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @returns {*} Returns the random element.
       */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined$1;}/**
       * A specialized version of `_.sampleSize` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
       * A specialized version of `_.shuffle` for arrays.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
       * This function is like `assignValue` except that it doesn't assign
       * `undefined` values.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function assignMergeValue(object,key,value){if(value!==undefined$1&&!eq(object[key],value)||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
       * Assigns `value` to `key` of `object` if the existing value is not equivalent
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
       * Gets the index at which the `key` is found in `array` of key-value pairs.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} key The key to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return -1;}/**
       * Aggregates elements of `collection` on `accumulator` with keys transformed
       * by `iteratee` and values set by `setter`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
       * The base implementation of `_.assign` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
       * The base implementation of `_.assignIn` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
       * The base implementation of `assignValue` and `assignMergeValue` without
       * value checks.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else {object[key]=value;}}/**
       * The base implementation of `_.at` without support for individual paths.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {string[]} paths The property paths to pick.
       * @returns {Array} Returns the picked elements.
       */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined$1:get(object,paths[index]);}return result;}/**
       * The base implementation of `_.clamp` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined$1){number=number<=upper?number:upper;}if(lower!==undefined$1){number=number>=lower?number:lower;}}return number;}/**
       * The base implementation of `_.clone` and `_.cloneDeep` which tracks
       * traversed objects.
       *
       * @private
       * @param {*} value The value to clone.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Deep clone
       *  2 - Flatten inherited properties
       *  4 - Clone symbols
       * @param {Function} [customizer] The function to customize cloning.
       * @param {string} [key] The key of `value`.
       * @param {Object} [object] The parent object of `value`.
       * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
       * @returns {*} Returns the cloned value.
       */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined$1){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else {var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else {if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
  stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined$1:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
  assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
       * The base implementation of `_.conforms` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
       * The base implementation of `_.conformsTo` which accepts `props` to check.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return !length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined$1&&!(key in object)||!predicate(value)){return false;}}return true;}/**
       * The base implementation of `_.delay` and `_.defer` which accepts `args`
       * to provide to `func`.
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {Array} args The arguments to provide to `func`.
       * @returns {number|Object} Returns the timer id or timeout object.
       */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined$1,args);},wait);}/**
       * The base implementation of methods like `_.difference` without support
       * for excluding multiple arrays or iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Array} values The values to exclude.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
       * The base implementation of `_.forEach` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */var baseEach=createBaseEach(baseForOwn);/**
       * The base implementation of `_.forEachRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
       * The base implementation of `_.every` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`
       */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
       * The base implementation of methods like `_.max` and `_.min` which accepts a
       * `comparator` to determine the extremum value.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The iteratee invoked per iteration.
       * @param {Function} comparator The comparator used to compare values.
       * @returns {*} Returns the extremum value.
       */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined$1?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
       * The base implementation of `_.fill` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined$1||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
       * The base implementation of `_.filter` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
       * The base implementation of `_.flatten` with support for restricting flattening.
       *
       * @private
       * @param {Array} array The array to flatten.
       * @param {number} depth The maximum recursion depth.
       * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
       * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
       * @param {Array} [result=[]] The initial result value.
       * @returns {Array} Returns the new flattened array.
       */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
  baseFlatten(value,depth-1,predicate,isStrict,result);}else {arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
       * The base implementation of `baseForOwn` which iterates over `object`
       * properties returned by `keysFunc` and invokes `iteratee` for each property.
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */var baseFor=createBaseFor();/**
       * This function is like `baseFor` except that it iterates over properties
       * in the opposite order.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */var baseForRight=createBaseFor(true);/**
       * The base implementation of `_.forOwn` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
       * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
       * The base implementation of `_.functions` which creates an array of
       * `object` function property names filtered from `props`.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Array} props The property names to filter.
       * @returns {Array} Returns the function names.
       */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
       * The base implementation of `_.get` without support for default values.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @returns {*} Returns the resolved value.
       */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined$1;}/**
       * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
       * `keysFunc` and `symbolsFunc` to get the enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @param {Function} symbolsFunc The function to get the symbols of `object`.
       * @returns {Array} Returns the array of property names and symbols.
       */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */function baseGetTag(value){if(value==null){return value===undefined$1?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
       * The base implementation of `_.gt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       */function baseGt(value,other){return value>other;}/**
       * The base implementation of `_.has` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
       * The base implementation of `_.hasIn` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
       * The base implementation of `_.inRange` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to check.
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
       * The base implementation of methods like `_.intersection`, without support
       * for iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of shared values.
       */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined$1;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
       * The base implementation of `_.invert` and `_.invertBy` which inverts
       * `object` with values transformed by `iteratee` and set by `setter`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform values.
       * @param {Object} accumulator The initial inverted object.
       * @returns {Function} Returns `accumulator`.
       */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
       * The base implementation of `_.invoke` without support for individual
       * method arguments.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {Array} args The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined$1:apply(func,object,args);}/**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
       * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
       * The base implementation of `_.isDate` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
       * The base implementation of `_.isEqual` which supports partial comparisons
       * and tracks traversed objects.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Unordered comparison
       *  2 - Partial comparison
       * @param {Function} [customizer] The function to customize comparisons.
       * @param {Object} [stack] Tracks traversed `value` and `other` objects.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
       * A specialized version of `baseIsEqual` for arrays and objects which performs
       * deep comparisons and tracks traversed objects enabling objects with circular
       * references to be compared.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} [stack] Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
       * The base implementation of `_.isMap` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
       * The base implementation of `_.isMatch` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Array} matchData The property names, values, and compare flags to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return !length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined$1&&!(key in object)){return false;}}else {var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined$1?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
       * The base implementation of `_.isRegExp` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
       * The base implementation of `_.isSet` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
       * The base implementation of `_.isTypedArray` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
       * The base implementation of `_.iteratee`.
       *
       * @private
       * @param {*} [value=_.identity] The value to convert to an iteratee.
       * @returns {Function} Returns the iteratee.
       */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if(typeof value=='function'){return value;}if(value==null){return identity;}if(_typeof(value)=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
       * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
       * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
       * The base implementation of `_.lt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       */function baseLt(value,other){return value<other;}/**
       * The base implementation of `_.map` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
       * The base implementation of `_.matches` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
       * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
       *
       * @private
       * @param {string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined$1&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
       * The base implementation of `_.merge` without support for multiple sources.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} [customizer] The function to customize merged values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else {var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined$1;if(newValue===undefined$1){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
       * A specialized version of `baseMerge` for arrays and objects which performs
       * deep merges and tracks traversed objects enabling objects with circular
       * references to be merged.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {string} key The key of the value to merge.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} mergeFunc The function to merge values.
       * @param {Function} [customizer] The function to customize assigned values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined$1;var isCommon=newValue===undefined$1;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else {newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else {isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
  stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
       * The base implementation of `_.nth` which doesn't coerce arguments.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {number} n The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined$1;}/**
       * The base implementation of `_.orderBy` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
       * @param {string[]} orders The sort orders of `iteratees`.
       * @returns {Array} Returns the new sorted array.
       */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else {iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return {'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
       * The base implementation of `_.pick` without support for individual
       * property identifiers.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @returns {Object} Returns the new object.
       */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
       * The base implementation of  `_.pickBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @param {Function} predicate The function invoked per property.
       * @returns {Object} Returns the new object.
       */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
       * A specialized version of `baseProperty` which supports deep paths.
       *
       * @private
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
       * The base implementation of `_.pullAllBy` without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
       * The base implementation of `_.pullAt` without support for individual
       * indexes or capturing the removed elements.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {number[]} indexes The indexes of elements to remove.
       * @returns {Array} Returns `array`.
       */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else {baseUnset(array,index);}}}return array;}/**
       * The base implementation of `_.random` without support for returning
       * floating-point numbers.
       *
       * @private
       * @param {number} lower The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the random number.
       */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
       * The base implementation of `_.range` and `_.rangeRight` which doesn't
       * coerce arguments.
       *
       * @private
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @param {number} step The value to increment or decrement by.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the range of numbers.
       */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
       * The base implementation of `_.repeat` which doesn't coerce arguments.
       *
       * @private
       * @param {string} string The string to repeat.
       * @param {number} n The number of times to repeat the string.
       * @returns {string} Returns the repeated string.
       */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
       * The base implementation of `_.sample`.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       */function baseSample(collection){return arraySample(values(collection));}/**
       * The base implementation of `_.sampleSize` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
       * The base implementation of `_.set`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined$1;if(newValue===undefined$1){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
       * The base implementation of `setData` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
       * The base implementation of `_.shuffle`.
       *
       * @private
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
       * The base implementation of `_.slice` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
       * The base implementation of `_.some` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return !result;});return !!result;}/**
       * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
       * performs a binary search of `array` to determine the index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else {high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
       * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
       * which invokes `iteratee` for `value` and each element of `array` to compute
       * their sort ranking. The iteratee is invoked with one argument; (value).
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} iteratee The iteratee invoked per element.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined$1;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined$1,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else {setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else {high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
       * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
       * The base implementation of `_.toNumber` which doesn't ensure correct
       * conversions of binary, hexadecimal, or octal string values.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return +value;}/**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
  if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
  return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
       * The base implementation of `_.uniqBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else {seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
       * The base implementation of `_.unset`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The property path to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
       * The base implementation of `_.update`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to update.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
       * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
       * without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {Function} predicate The function invoked per iteration.
       * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the slice of `array`.
       */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
       * The base implementation of `wrapperValue` which returns the result of
       * performing a sequence of actions on the unwrapped `value`, where each
       * successive action is supplied the return value of the previous.
       *
       * @private
       * @param {*} value The unwrapped value.
       * @param {Array} actions Actions to perform to resolve the unwrapped value.
       * @returns {*} Returns the resolved value.
       */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
       * The base implementation of methods like `_.xor`, without support for
       * iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of values.
       */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
       * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
       *
       * @private
       * @param {Array} props The property identifiers.
       * @param {Array} values The property values.
       * @param {Function} assignFunc The function to assign values.
       * @returns {Object} Returns the new object.
       */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined$1;assignFunc(result,props[index],value);}return result;}/**
       * Casts `value` to an empty array if it's not an array like object.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Array|Object} Returns the cast array-like object.
       */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
       * Casts `value` to `identity` if it's not a function.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Function} Returns cast function.
       */function castFunction(value){return typeof value=='function'?value:identity;}/**
       * Casts `value` to a path array if it's not one.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {Object} [object] The object to query keys on.
       * @returns {Array} Returns the cast property path array.
       */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
       * A `baseRest` alias which can be replaced with `identity` by module
       * replacement plugins.
       *
       * @private
       * @type {Function}
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */var castRest=baseRest;/**
       * Casts `array` to a slice if it's needed.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {number} start The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the cast slice.
       */function castSlice(array,start,end){var length=array.length;end=end===undefined$1?length:end;return !start&&end>=length?array:baseSlice(array,start,end);}/**
       * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
       *
       * @private
       * @param {number|Object} id The timer id or timeout object of the timer to clear.
       */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
       * Creates a clone of  `buffer`.
       *
       * @private
       * @param {Buffer} buffer The buffer to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Buffer} Returns the cloned buffer.
       */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
       * Creates a clone of `arrayBuffer`.
       *
       * @private
       * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
       * @returns {ArrayBuffer} Returns the cloned array buffer.
       */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
       * Creates a clone of `dataView`.
       *
       * @private
       * @param {Object} dataView The data view to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned data view.
       */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
       * Creates a clone of `regexp`.
       *
       * @private
       * @param {Object} regexp The regexp to clone.
       * @returns {Object} Returns the cloned regexp.
       */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
       * Creates a clone of the `symbol` object.
       *
       * @private
       * @param {Object} symbol The symbol object to clone.
       * @returns {Object} Returns the cloned symbol object.
       */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
       * Creates a clone of `typedArray`.
       *
       * @private
       * @param {Object} typedArray The typed array to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned typed array.
       */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
       * Compares values to sort them in ascending order.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined$1,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined$1,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return -1;}}return 0;}/**
       * Used by `_.orderBy` to compare multiple properties of a value to another
       * and stable sort them.
       *
       * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
       * specify an order of "desc" for descending or "asc" for ascending sort order
       * of corresponding values.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {boolean[]|string[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index-other.index;}/**
       * Creates an array that is the composition of partially applied arguments,
       * placeholders, and provided arguments into a single array of arguments.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to prepend to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
       * This function is like `composeArgs` except that the arguments composition
       * is tailored for `_.partialRight`.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to append to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
       * Copies the values of `source` to `array`.
       *
       * @private
       * @param {Array} source The array to copy values from.
       * @param {Array} [array=[]] The array to copy values to.
       * @returns {Array} Returns `array`.
       */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
       * Copies properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Array} props The property identifiers to copy.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Function} [customizer] The function to customize copied values.
       * @returns {Object} Returns `object`.
       */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined$1;if(newValue===undefined$1){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else {assignValue(object,key,newValue);}}return object;}/**
       * Copies own symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
       * Copies own and inherited symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
       * Creates a function like `_.groupBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} [initializer] The accumulator object initializer.
       * @returns {Function} Returns the new aggregator function.
       */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
       * Creates a function like `_.assign`.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined$1,guard=length>2?sources[2]:undefined$1;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined$1:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
       * Creates a `baseEach` or `baseEachRight` function.
       *
       * @private
       * @param {Function} eachFunc The function to iterate over a collection.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
       * Creates a base function for methods like `_.forIn` and `_.forOwn`.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
       * Creates a function that wraps `func` to invoke it with the optional `this`
       * binding of `thisArg`.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
       * Creates a function like `_.lowerFirst`.
       *
       * @private
       * @param {string} methodName The name of the `String` case method to use.
       * @returns {Function} Returns the new case function.
       */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined$1;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
       * Creates a function like `_.camelCase`.
       *
       * @private
       * @param {Function} callback The function to combine each word.
       * @returns {Function} Returns the new compounder function.
       */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
       * Creates a function that produces an instance of `Ctor` regardless of
       * whether it was invoked as part of a `new` expression or by `call` or `apply`.
       *
       * @private
       * @param {Function} Ctor The constructor to wrap.
       * @returns {Function} Returns the new wrapped function.
       */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
  // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
  // for more details.
  var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
  // See https://es5.github.io/#x13.2.2 for more details.
  return isObject(result)?result:thisBinding;};}/**
       * Creates a function that wraps `func` to enable currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {number} arity The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined$1,args,holders,undefined$1,undefined$1,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
       * Creates a `_.find` or `_.findLast` function.
       *
       * @private
       * @param {Function} findIndexFunc The function to find the collection index.
       * @returns {Function} Returns the new find function.
       */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined$1;};}/**
       * Creates a `_.flow` or `_.flowRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new flow function.
       */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined$1;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else {wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
       * Creates a function that wraps `func` to invoke it with optional `this`
       * binding of `thisArg`, partial application, and currying.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [partialsRight] The arguments to append to those provided
       *  to the new function.
       * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined$1:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
       * Creates a function like `_.invertBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} toIteratee The function to resolve iteratees.
       * @returns {Function} Returns the new inverter function.
       */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
       * Creates a function that performs a mathematical operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @param {number} [defaultValue] The value used for `undefined` arguments.
       * @returns {Function} Returns the new mathematical operation function.
       */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined$1&&other===undefined$1){return defaultValue;}if(value!==undefined$1){result=value;}if(other!==undefined$1){if(result===undefined$1){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else {value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
       * Creates a function like `_.over`.
       *
       * @private
       * @param {Function} arrayFunc The function to iterate over iteratees.
       * @returns {Function} Returns the new over function.
       */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
       * Creates the padding for `string` based on `length`. The `chars` string
       * is truncated if the number of characters exceeds `length`.
       *
       * @private
       * @param {number} length The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padding for `string`.
       */function createPadding(length,chars){chars=chars===undefined$1?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
       * Creates a function that wraps `func` to invoke it with the `this` binding
       * of `thisArg` and `partials` prepended to the arguments it receives.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} partials The arguments to prepend to those provided to
       *  the new function.
       * @returns {Function} Returns the new wrapped function.
       */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
       * Creates a `_.range` or `_.rangeRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new range function.
       */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined$1;}// Ensure the sign of `-0` is preserved.
  start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}step=step===undefined$1?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
       * Creates a function that performs a relational operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @returns {Function} Returns the new relational operation function.
       */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
       * Creates a function that wraps `func` to continue currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {Function} wrapFunc The function to create the `func` wrapper.
       * @param {*} placeholder The placeholder value.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined$1,newHoldersRight=isCurry?undefined$1:holders,newPartials=isCurry?partials:undefined$1,newPartialsRight=isCurry?undefined$1:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined$1,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
       * Creates a function like `_.round`.
       *
       * @private
       * @param {string} methodName The name of the `Math` method to use when rounding.
       * @returns {Function} Returns the new round function.
       */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
  // See [MDN](https://mdn.io/round#Examples) for more details.
  var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return +(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
       * Creates a set object of `values`.
       *
       * @private
       * @param {Array} values The values to add to the set.
       * @returns {Object} Returns the new set.
       */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
       * Creates a `_.toPairs` or `_.toPairsIn` function.
       *
       * @private
       * @param {Function} keysFunc The function to get the keys of a given object.
       * @returns {Function} Returns the new pairs function.
       */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
       * Creates a function that either curries or invokes `func` with optional
       * `this` binding and partially applied arguments.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags.
       *    1 - `_.bind`
       *    2 - `_.bindKey`
       *    4 - `_.curry` or `_.curryRight` of a bound function
       *    8 - `_.curry`
       *   16 - `_.curryRight`
       *   32 - `_.partial`
       *   64 - `_.partialRight`
       *  128 - `_.rearg`
       *  256 - `_.ary`
       *  512 - `_.flip`
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to be partially applied.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined$1;}ary=ary===undefined$1?ary:nativeMax(toInteger(ary),0);arity=arity===undefined$1?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined$1;}var data=isBindKey?undefined$1:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined$1?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else {result=createHybrid.apply(undefined$1,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
       * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
       * of source objects to the destination object for all destination properties
       * that resolve to `undefined`.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to assign.
       * @param {Object} object The parent object of `objValue`.
       * @returns {*} Returns the value to assign.
       */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined$1||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
       * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
       * objects into destination objects that are passed thru.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to merge.
       * @param {Object} object The parent object of `objValue`.
       * @param {Object} source The parent object of `srcValue`.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       * @returns {*} Returns the value to assign.
       */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
  stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined$1,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
       * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
       * objects.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {string} key The key of the property to inspect.
       * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
       */function customOmitClone(value){return isPlainObject(value)?undefined$1:value;}/**
       * A specialized version of `baseIsEqualDeep` for arrays with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Array} array The array to compare.
       * @param {Array} other The other array to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `array` and `other` objects.
       * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
       */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
  var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined$1;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
  while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined$1){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
  if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
       * A specialized version of `baseIsEqualDeep` for comparing objects of
       * the same `toStringTag`.
       *
       * **Note:** This function only supports comparing values with tags of
       * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {string} tag The `toStringTag` of the objects to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
  // Invalid dates are coerced to `NaN`.
  return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
  // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
  // for more details.
  return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
  var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
  stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
       * A specialized version of `baseIsEqualDeep` for objects with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
  var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
  if(!(compared===undefined$1?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
  if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
       * A specialized version of `baseRest` which flattens the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */function flatRest(func){return setToString(overRest(func,undefined$1,flatten),func+'');}/**
       * Creates an array of own enumerable property names and symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
       * Creates an array of own and inherited enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
       * Gets metadata for `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {*} Returns the metadata for `func`.
       */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
       * Gets the name of `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {string} Returns the function name.
       */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
       * Gets the argument placeholder value for `func`.
       *
       * @private
       * @param {Function} func The function to inspect.
       * @returns {*} Returns the placeholder value.
       */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
       * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
       * this function returns the custom method, otherwise it returns `baseIteratee`.
       * If arguments are provided, the chosen function is invoked with them and
       * its result is returned.
       *
       * @private
       * @param {*} [value] The value to convert to an iteratee.
       * @param {number} [arity] The arity of the created iteratee.
       * @returns {Function} Returns the chosen function or its result.
       */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
       * Gets the data for `map`.
       *
       * @private
       * @param {Object} map The map to query.
       * @param {string} key The reference key.
       * @returns {*} Returns the map data.
       */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
       * Gets the property names, values, and compare flags of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the match data of `object`.
       */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined$1;}/**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined$1;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else {delete value[symToStringTag];}}return result;}/**
       * Creates an array of the own enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return [];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
       * Creates an array of the own and inherited enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
       * Gets the `toStringTag` of `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined$1,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
       * Gets the view, applying any `transforms` to the `start` and `end` positions.
       *
       * @private
       * @param {number} start The start of the view.
       * @param {number} end The end of the view.
       * @param {Array} transforms The transformations to apply to the view.
       * @returns {Object} Returns an object containing the `start` and `end`
       *  positions of the view.
       */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return {'start':start,'end':end};}/**
       * Extracts wrapper details from the `source` body comment.
       *
       * @private
       * @param {string} source The source to inspect.
       * @returns {Array} Returns the wrapper details.
       */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
       * Checks if `path` exists on `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @param {Function} hasFunc The function to check properties.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return !!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
       * Initializes an array clone.
       *
       * @private
       * @param {Array} array The array to clone.
       * @returns {Array} Returns the initialized clone.
       */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
  if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
       * Initializes an object clone.
       *
       * @private
       * @param {Object} object The object to clone.
       * @returns {Object} Returns the initialized clone.
       */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
       * Initializes an object clone based on its `toStringTag`.
       *
       * **Note:** This function only supports cloning values with tags of
       * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
       *
       * @private
       * @param {Object} object The object to clone.
       * @param {string} tag The `toStringTag` of the object to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the initialized clone.
       */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
       * Inserts wrapper `details` in a comment at the top of the `source` body.
       *
       * @private
       * @param {string} source The source to modify.
       * @returns {Array} details The details to insert.
       * @returns {string} Returns the modified source.
       */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
       * Checks if `value` is a flattenable `arguments` object or array.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
       */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */function isIndex(value,length){var type=_typeof(value);length=length==null?MAX_SAFE_INTEGER:length;return !!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
       * Checks if `value` is a property name and not a property path.
       *
       * @private
       * @param {*} value The value to check.
       * @param {Object} [object] The object to query keys on.
       * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
       */function isKey(value,object){if(isArray(value)){return false;}var type=_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
       * Checks if `value` is suitable for use as unique object key.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
       */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
       * Checks if `func` has a lazy counterpart.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
       *  else `false`.
       */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return !!data&&func===data[0];}/**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */function isMasked(func){return !!maskSrcKey&&maskSrcKey in func;}/**
       * Checks if `func` is capable of being masked.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
       */var isMaskable=coreJsData?isFunction:stubFalse;/**
       * Checks if `value` is likely a prototype object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
       */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
       * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` if suitable for strict
       *  equality comparisons, else `false`.
       */function isStrictComparable(value){return value===value&&!isObject(value);}/**
       * A specialized version of `matchesProperty` for source values suitable
       * for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined$1||key in Object(object));};}/**
       * A specialized version of `_.memoize` which clears the memoized function's
       * cache when it exceeds `MAX_MEMOIZE_SIZE`.
       *
       * @private
       * @param {Function} func The function to have its output memoized.
       * @returns {Function} Returns the new memoized function.
       */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
       * Merges the function metadata of `source` into `data`.
       *
       * Merging metadata reduces the number of wrappers used to invoke a function.
       * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
       * may be applied regardless of execution order. Methods like `_.ary` and
       * `_.rearg` modify function arguments, making the order in which they are
       * executed important, preventing the merging of metadata. However, we make
       * an exception for a safe combined case where curried functions have `_.ary`
       * and or `_.rearg` applied.
       *
       * @private
       * @param {Array} data The destination metadata.
       * @param {Array} source The source metadata.
       * @returns {Array} Returns `data`.
       */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
  if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
  if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
  newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
  var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
  value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
  value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
  if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
  if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
  data[0]=source[0];data[1]=newBitmask;return data;}/**
       * This function is like
       * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * except that it includes inherited enumerable properties.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */function objectToString(value){return nativeObjectToString.call(value);}/**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */function overRest(func,start,transform){start=nativeMax(start===undefined$1?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
       * Gets the parent value at `path` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} path The path to get the parent value of.
       * @returns {*} Returns the parent value.
       */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
       * Reorder `array` according to the specified indexes where the element at
       * the first index is assigned as the first element, the element at
       * the second index is assigned as the second element, and so on.
       *
       * @private
       * @param {Array} array The array to reorder.
       * @param {Array} indexes The arranged array indexes.
       * @returns {Array} Returns `array`.
       */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined$1;}return array;}/**
       * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
       * Sets metadata for `func`.
       *
       * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
       * period of time, it will trip its breaker and transition to an identity
       * function to avoid garbage collection pauses in V8. See
       * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
       * for more details.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */var setData=shortOut(baseSetData);/**
       * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @returns {number|Object} Returns the timer id or timeout object.
       */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */var setToString=shortOut(baseSetToString);/**
       * Sets the `toString` method of `wrapper` to mimic the source of `reference`
       * with wrapper details in a comment at the top of the source body.
       *
       * @private
       * @param {Function} wrapper The function to modify.
       * @param {Function} reference The reference function.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Function} Returns `wrapper`.
       */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else {count=0;}return func.apply(undefined$1,arguments);};}/**
       * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @param {number} [size=array.length] The size of `array`.
       * @returns {Array} Returns `array`.
       */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined$1?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
       * Converts `string` to a property path array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the property path array.
       */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
       * Converts `value` to a string key if it's not a string or symbol.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {string|symbol} Returns the key.
       */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return '';}/**
       * Updates wrapper `details` based on `bitmask` flags.
       *
       * @private
       * @returns {Array} details The details to modify.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Array} Returns `details`.
       */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
       * Creates a clone of `wrapper`.
       *
       * @private
       * @param {Object} wrapper The wrapper to clone.
       * @returns {Object} Returns the cloned wrapper.
       */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
       * Creates an array of elements split into groups the length of `size`.
       * If `array` can't be split evenly, the final chunk will be the remaining
       * elements.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to process.
       * @param {number} [size=1] The length of each chunk
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the new array of chunks.
       * @example
       *
       * _.chunk(['a', 'b', 'c', 'd'], 2);
       * // => [['a', 'b'], ['c', 'd']]
       *
       * _.chunk(['a', 'b', 'c', 'd'], 3);
       * // => [['a', 'b', 'c'], ['d']]
       */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined$1){size=1;}else {size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return [];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
       * Creates an array with all falsey values removed. The values `false`, `null`,
       * `0`, `""`, `undefined`, and `NaN` are falsey.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to compact.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.compact([0, 1, false, 2, '', 3]);
       * // => [1, 2, 3]
       */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
       * Creates a new array concatenating `array` with any additional arrays
       * and/or values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to concatenate.
       * @param {...*} [values] The values to concatenate.
       * @returns {Array} Returns the new concatenated array.
       * @example
       *
       * var array = [1];
       * var other = _.concat(array, 2, [3], [[4]]);
       *
       * console.log(other);
       * // => [1, 2, 3, [4]]
       *
       * console.log(array);
       * // => [1]
       */function concat(){var length=arguments.length;if(!length){return [];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
       * Creates an array of `array` values not included in the other given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * **Note:** Unlike `_.pullAll`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.without, _.xor
       * @example
       *
       * _.difference([2, 1], [2, 3]);
       * // => [1]
       */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
       * This method is like `_.difference` except that it accepts `iteratee` which
       * is invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
       * This method is like `_.difference` except that it accepts `comparator`
       * which is invoked to compare elements of `array` to `values`. The order and
       * references of result values are determined by the first array. The comparator
       * is invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       *
       * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }]
       */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined$1,comparator):[];});/**
       * Creates a slice of `array` with `n` elements dropped from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.drop([1, 2, 3]);
       * // => [2, 3]
       *
       * _.drop([1, 2, 3], 2);
       * // => [3]
       *
       * _.drop([1, 2, 3], 5);
       * // => []
       *
       * _.drop([1, 2, 3], 0);
       * // => [1, 2, 3]
       */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
       * Creates a slice of `array` with `n` elements dropped from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.dropRight([1, 2, 3]);
       * // => [1, 2]
       *
       * _.dropRight([1, 2, 3], 2);
       * // => [1]
       *
       * _.dropRight([1, 2, 3], 5);
       * // => []
       *
       * _.dropRight([1, 2, 3], 0);
       * // => [1, 2, 3]
       */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
       * Creates a slice of `array` excluding elements dropped from the end.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.dropRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropRightWhile(users, ['active', false]);
       * // => objects for ['barney']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropRightWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
       * Creates a slice of `array` excluding elements dropped from the beginning.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.dropWhile(users, function(o) { return !o.active; });
       * // => objects for ['pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropWhile(users, ['active', false]);
       * // => objects for ['pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
       * Fills elements of `array` with `value` from `start` up to, but not
       * including, `end`.
       *
       * **Note:** This method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Array
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.fill(array, 'a');
       * console.log(array);
       * // => ['a', 'a', 'a']
       *
       * _.fill(Array(3), 2);
       * // => [2, 2, 2]
       *
       * _.fill([4, 6, 8, 10], '*', 1, 3);
       * // => [4, '*', '*', 10]
       */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return [];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
       * This method is like `_.find` except that it returns the index of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.findIndex(users, function(o) { return o.user == 'barney'; });
       * // => 0
       *
       * // The `_.matches` iteratee shorthand.
       * _.findIndex(users, { 'user': 'fred', 'active': false });
       * // => 1
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findIndex(users, ['active', false]);
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.findIndex(users, 'active');
       * // => 2
       */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
       * This method is like `_.findIndex` except that it iterates over elements
       * of `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
       * // => 2
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastIndex(users, { 'user': 'barney', 'active': true });
       * // => 0
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastIndex(users, ['active', false]);
       * // => 2
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastIndex(users, 'active');
       * // => 0
       */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length-1;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
       * Flattens `array` a single level deep.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flatten([1, [2, [3, [4]], 5]]);
       * // => [1, 2, [3, [4]], 5]
       */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
       * Recursively flattens `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flattenDeep([1, [2, [3, [4]], 5]]);
       * // => [1, 2, 3, 4, 5]
       */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
       * Recursively flatten `array` up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * var array = [1, [2, [3, [4]], 5]];
       *
       * _.flattenDepth(array, 1);
       * // => [1, 2, [3, [4]], 5]
       *
       * _.flattenDepth(array, 2);
       * // => [1, 2, 3, [4], 5]
       */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return [];}depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(array,depth);}/**
       * The inverse of `_.toPairs`; this method returns an object composed
       * from key-value `pairs`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} pairs The key-value pairs.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.fromPairs([['a', 1], ['b', 2]]);
       * // => { 'a': 1, 'b': 2 }
       */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
       * Gets the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias first
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the first element of `array`.
       * @example
       *
       * _.head([1, 2, 3]);
       * // => 1
       *
       * _.head([]);
       * // => undefined
       */function head(array){return array&&array.length?array[0]:undefined$1;}/**
       * Gets the index at which the first occurrence of `value` is found in `array`
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. If `fromIndex` is negative, it's used as the
       * offset from the end of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.indexOf([1, 2, 1, 2], 2);
       * // => 1
       *
       * // Search from the `fromIndex`.
       * _.indexOf([1, 2, 1, 2], 2, 2);
       * // => 3
       */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
       * Gets all but the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.initial([1, 2, 3]);
       * // => [1, 2]
       */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
       * Creates an array of unique values that are included in all given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersection([2, 1], [2, 3]);
       * // => [2]
       */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
       * This method is like `_.intersection` except that it accepts `iteratee`
       * which is invoked for each element of each `arrays` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [2.1]
       *
       * // The `_.property` iteratee shorthand.
       * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }]
       */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined$1;}else {mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
       * This method is like `_.intersection` except that it accepts `comparator`
       * which is invoked to compare elements of `arrays`. The order and references
       * of result values are determined by the first array. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.intersectionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }]
       */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined$1;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined$1,comparator):[];});/**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
       * Gets the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the last element of `array`.
       * @example
       *
       * _.last([1, 2, 3]);
       * // => 3
       */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined$1;}/**
       * This method is like `_.indexOf` except that it iterates over elements of
       * `array` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.lastIndexOf([1, 2, 1, 2], 2);
       * // => 3
       *
       * // Search from the `fromIndex`.
       * _.lastIndexOf([1, 2, 1, 2], 2, 2);
       * // => 1
       */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
       * Gets the element at index `n` of `array`. If `n` is negative, the nth
       * element from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.11.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=0] The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       *
       * _.nth(array, 1);
       * // => 'b'
       *
       * _.nth(array, -2);
       * // => 'c';
       */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined$1;}/**
       * Removes all given values from `array` using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
       * to remove elements from an array by predicate.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...*} [values] The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pull(array, 'a', 'c');
       * console.log(array);
       * // => ['b', 'b']
       */var pull=baseRest(pullAll);/**
       * This method is like `_.pull` except that it accepts an array of values to remove.
       *
       * **Note:** Unlike `_.difference`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pullAll(array, ['a', 'c']);
       * console.log(array);
       * // => ['b', 'b']
       */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
       * This method is like `_.pullAll` except that it accepts `iteratee` which is
       * invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The iteratee is invoked with one argument: (value).
       *
       * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
       *
       * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
       * console.log(array);
       * // => [{ 'x': 2 }]
       */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
       * This method is like `_.pullAll` except that it accepts `comparator` which
       * is invoked to compare elements of `array` to `values`. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
       *
       * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
       * console.log(array);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
       */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined$1,comparator):array;}/**
       * Removes elements from `array` corresponding to `indexes` and returns an
       * array of removed elements.
       *
       * **Note:** Unlike `_.at`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...(number|number[])} [indexes] The indexes of elements to remove.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       * var pulled = _.pullAt(array, [1, 3]);
       *
       * console.log(array);
       * // => ['a', 'c']
       *
       * console.log(pulled);
       * // => ['b', 'd']
       */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
       * Removes all elements from `array` that `predicate` returns truthy for
       * and returns an array of the removed elements. The predicate is invoked
       * with three arguments: (value, index, array).
       *
       * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
       * to pull elements from an array by value.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = [1, 2, 3, 4];
       * var evens = _.remove(array, function(n) {
       *   return n % 2 == 0;
       * });
       *
       * console.log(array);
       * // => [1, 3]
       *
       * console.log(evens);
       * // => [2, 4]
       */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
       * Reverses `array` so that the first element becomes the last, the second
       * element becomes the second to last, and so on.
       *
       * **Note:** This method mutates `array` and is based on
       * [`Array#reverse`](https://mdn.io/Array/reverse).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.reverse(array);
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
       * Creates a slice of `array` from `start` up to, but not including, `end`.
       *
       * **Note:** This method is used instead of
       * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
       * returned.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return [];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else {start=start==null?0:toInteger(start);end=end===undefined$1?length:toInteger(end);}return baseSlice(array,start,end);}/**
       * Uses a binary search to determine the lowest index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedIndex([30, 50], 40);
       * // => 1
       */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
       * This method is like `_.sortedIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
       * // => 0
       */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
       * This method is like `_.indexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
       * // => 1
       */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return -1;}/**
       * This method is like `_.sortedIndex` except that it returns the highest
       * index at which `value` should be inserted into `array` in order to
       * maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
       * // => 4
       */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
       * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 1
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
       * // => 1
       */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
       * This method is like `_.lastIndexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
       * // => 3
       */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return -1;}/**
       * This method is like `_.uniq` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniq([1, 1, 2]);
       * // => [1, 2]
       */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
       * This method is like `_.uniqBy` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
       * // => [1.1, 2.3]
       */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
       * Gets all but the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.tail([1, 2, 3]);
       * // => [2, 3]
       */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
       * Creates a slice of `array` with `n` elements taken from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.take([1, 2, 3]);
       * // => [1]
       *
       * _.take([1, 2, 3], 2);
       * // => [1, 2]
       *
       * _.take([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.take([1, 2, 3], 0);
       * // => []
       */function take(array,n,guard){if(!(array&&array.length)){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
       * Creates a slice of `array` with `n` elements taken from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.takeRight([1, 2, 3]);
       * // => [3]
       *
       * _.takeRight([1, 2, 3], 2);
       * // => [2, 3]
       *
       * _.takeRight([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.takeRight([1, 2, 3], 0);
       * // => []
       */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
       * Creates a slice of `array` with elements taken from the end. Elements are
       * taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.takeRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeRightWhile(users, ['active', false]);
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeRightWhile(users, 'active');
       * // => []
       */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
       * Creates a slice of `array` with elements taken from the beginning. Elements
       * are taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.takeWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeWhile(users, ['active', false]);
       * // => objects for ['barney', 'fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeWhile(users, 'active');
       * // => []
       */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
       * Creates an array of unique values, in order, from all given arrays using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.union([2], [1, 2]);
       * // => [2, 1]
       */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
       * This method is like `_.union` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which uniqueness is computed. Result values are chosen from the first
       * array in which the value occurs. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.unionBy([2.1], [1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
       * This method is like `_.union` except that it accepts `comparator` which
       * is invoked to compare elements of `arrays`. Result values are chosen from
       * the first array in which the value occurs. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.unionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined$1,comparator);});/**
       * Creates a duplicate-free version of an array, using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons, in which only the first occurrence of each element
       * is kept. The order of result values is determined by the order they occur
       * in the array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniq([2, 1, 2]);
       * // => [2, 1]
       */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
       * This method is like `_.uniq` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * uniqueness is computed. The order of result values is determined by the
       * order they occur in the array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
       * This method is like `_.uniq` except that it accepts `comparator` which
       * is invoked to compare elements of `array`. The order of result values is
       * determined by the order they occur in the array.The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.uniqWith(objects, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
       */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined$1;return array&&array.length?baseUniq(array,undefined$1,comparator):[];}/**
       * This method is like `_.zip` except that it accepts an array of grouped
       * elements and creates an array regrouping the elements to their pre-zip
       * configuration.
       *
       * @static
       * @memberOf _
       * @since 1.2.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       *
       * _.unzip(zipped);
       * // => [['a', 'b'], [1, 2], [true, false]]
       */function unzip(array){if(!(array&&array.length)){return [];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
       * This method is like `_.unzip` except that it accepts `iteratee` to specify
       * how regrouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  regrouped values.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
       * // => [[1, 10, 100], [2, 20, 200]]
       *
       * _.unzipWith(zipped, _.add);
       * // => [3, 30, 300]
       */function unzipWith(array,iteratee){if(!(array&&array.length)){return [];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined$1,group);});}/**
       * Creates an array excluding all given values using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.pull`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...*} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.xor
       * @example
       *
       * _.without([2, 1, 2, 3], 1, 2);
       * // => [3]
       */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
       * Creates an array of unique values that is the
       * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
       * of the given arrays. The order of result values is determined by the order
       * they occur in the arrays.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.without
       * @example
       *
       * _.xor([2, 1], [2, 3]);
       * // => [1, 3]
       */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
       * This method is like `_.xor` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which by which they're compared. The order of result values is determined
       * by the order they occur in the arrays. The iteratee is invoked with one
       * argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2, 3.4]
       *
       * // The `_.property` iteratee shorthand.
       * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
       * This method is like `_.xor` except that it accepts `comparator` which is
       * invoked to compare elements of `arrays`. The order of result values is
       * determined by the order they occur in the arrays. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.xorWith(objects, others, _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined$1,comparator);});/**
       * Creates an array of grouped elements, the first of which contains the
       * first elements of the given arrays, the second of which contains the
       * second elements of the given arrays, and so on.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       */var zip=baseRest(unzip);/**
       * This method is like `_.fromPairs` except that it accepts two arrays,
       * one of property identifiers and one of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 0.4.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObject(['a', 'b'], [1, 2]);
       * // => { 'a': 1, 'b': 2 }
       */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
       * This method is like `_.zipObject` except that it supports property paths.
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
       * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
       */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
       * This method is like `_.zip` except that it accepts `iteratee` to specify
       * how grouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  grouped values.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
       *   return a + b + c;
       * });
       * // => [111, 222]
       */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined$1;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined$1;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
       * Creates a `lodash` wrapper instance that wraps `value` with explicit method
       * chain sequences enabled. The result of such sequences must be unwrapped
       * with `_#value`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Seq
       * @param {*} value The value to wrap.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36 },
       *   { 'user': 'fred',    'age': 40 },
       *   { 'user': 'pebbles', 'age': 1 }
       * ];
       *
       * var youngest = _
       *   .chain(users)
       *   .sortBy('age')
       *   .map(function(o) {
       *     return o.user + ' is ' + o.age;
       *   })
       *   .head()
       *   .value();
       * // => 'pebbles is 1'
       */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
       * This method invokes `interceptor` and returns `value`. The interceptor
       * is invoked with one argument; (value). The purpose of this method is to
       * "tap into" a method chain sequence in order to modify intermediate results.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns `value`.
       * @example
       *
       * _([1, 2, 3])
       *  .tap(function(array) {
       *    // Mutate input array.
       *    array.pop();
       *  })
       *  .reverse()
       *  .value();
       * // => [2, 1]
       */function tap(value,interceptor){interceptor(value);return value;}/**
       * This method is like `_.tap` except that it returns the result of `interceptor`.
       * The purpose of this method is to "pass thru" values replacing intermediate
       * results in a method chain sequence.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns the result of `interceptor`.
       * @example
       *
       * _('  abc  ')
       *  .chain()
       *  .trim()
       *  .thru(function(value) {
       *    return [value];
       *  })
       *  .value();
       * // => ['abc']
       */function thru(value,interceptor){return interceptor(value);}/**
       * This method is the wrapper version of `_.at`.
       *
       * @name at
       * @memberOf _
       * @since 1.0.0
       * @category Seq
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _(object).at(['a[0].b.c', 'a[1]']).value();
       * // => [3, 4]
       */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined$1);}return array;});});/**
       * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
       *
       * @name chain
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * // A sequence without explicit chaining.
       * _(users).head();
       * // => { 'user': 'barney', 'age': 36 }
       *
       * // A sequence with explicit chaining.
       * _(users)
       *   .chain()
       *   .head()
       *   .pick('user')
       *   .value();
       * // => { 'user': 'barney' }
       */function wrapperChain(){return chain(this);}/**
       * Executes the chain sequence and returns the wrapped result.
       *
       * @name commit
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2];
       * var wrapped = _(array).push(3);
       *
       * console.log(array);
       * // => [1, 2]
       *
       * wrapped = wrapped.commit();
       * console.log(array);
       * // => [1, 2, 3]
       *
       * wrapped.last();
       * // => 3
       *
       * console.log(array);
       * // => [1, 2, 3]
       */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
       * Gets the next value on a wrapped object following the
       * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
       *
       * @name next
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the next iterator value.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 1 }
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 2 }
       *
       * wrapped.next();
       * // => { 'done': true, 'value': undefined }
       */function wrapperNext(){if(this.__values__===undefined$1){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined$1:this.__values__[this.__index__++];return {'done':done,'value':value};}/**
       * Enables the wrapper to be iterable.
       *
       * @name Symbol.iterator
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the wrapper object.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped[Symbol.iterator]() === wrapped;
       * // => true
       *
       * Array.from(wrapped);
       * // => [1, 2]
       */function wrapperToIterator(){return this;}/**
       * Creates a clone of the chain sequence planting `value` as the wrapped value.
       *
       * @name plant
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @param {*} value The value to plant.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2]).map(square);
       * var other = wrapped.plant([3, 4]);
       *
       * other.value();
       * // => [9, 16]
       *
       * wrapped.value();
       * // => [1, 4]
       */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined$1;if(result){previous.__wrapped__=clone;}else {result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
       * This method is the wrapper version of `_.reverse`.
       *
       * **Note:** This method mutates the wrapped array.
       *
       * @name reverse
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _(array).reverse().value()
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined$1});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
       * Executes the chain sequence to resolve the unwrapped value.
       *
       * @name value
       * @memberOf _
       * @since 0.1.0
       * @alias toJSON, valueOf
       * @category Seq
       * @returns {*} Returns the resolved unwrapped value.
       * @example
       *
       * _([1, 2, 3]).value();
       * // => [1, 2, 3]
       */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the number of times the key was returned by `iteratee`. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.countBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': 1, '6': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.countBy(['one', 'two', 'three'], 'length');
       * // => { '3': 2, '5': 1 }
       */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else {baseAssignValue(result,key,1);}});/**
       * Checks if `predicate` returns truthy for **all** elements of `collection`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * **Note:** This method returns `true` for
       * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
       * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
       * elements of empty collections.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * _.every([true, 1, null, 'yes'], Boolean);
       * // => false
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.every(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.every(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.every(users, 'active');
       * // => false
       */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
       * Iterates over elements of `collection`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * **Note:** Unlike `_.remove`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.reject
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * _.filter(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, { 'age': 36, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.filter(users, 'active');
       * // => objects for ['barney']
       *
       * // Combining several predicates using `_.overEvery` or `_.overSome`.
       * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
       * // => objects for ['fred', 'barney']
       */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
       * Iterates over elements of `collection`, returning the first element
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': true },
       *   { 'user': 'fred',    'age': 40, 'active': false },
       *   { 'user': 'pebbles', 'age': 1,  'active': true }
       * ];
       *
       * _.find(users, function(o) { return o.age < 40; });
       * // => object for 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.find(users, { 'age': 1, 'active': true });
       * // => object for 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.find(users, ['active', false]);
       * // => object for 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.find(users, 'active');
       * // => object for 'barney'
       */var find=createFind(findIndex);/**
       * This method is like `_.find` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=collection.length-1] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * _.findLast([1, 2, 3, 4], function(n) {
       *   return n % 2 == 1;
       * });
       * // => 3
       */var findLast=createFind(findLastIndex);/**
       * Creates a flattened array of values by running each element in `collection`
       * thru `iteratee` and flattening the mapped results. The iteratee is invoked
       * with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [n, n];
       * }
       *
       * _.flatMap([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDeep([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDepth([1, 2], duplicate, 2);
       * // => [[1, 1], [2, 2]]
       */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * **Note:** As with other "Collections" methods, objects with a "length"
       * property are iterated like arrays. To avoid this behavior use `_.forIn`
       * or `_.forOwn` for object iteration.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias each
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEachRight
       * @example
       *
       * _.forEach([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `1` then `2`.
       *
       * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
       * This method is like `_.forEach` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @alias eachRight
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEach
       * @example
       *
       * _.forEachRight([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `2` then `1`.
       */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The order of grouped values
       * is determined by the order they occur in `collection`. The corresponding
       * value of each key is an array of elements responsible for generating the
       * key. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.groupBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': [4.2], '6': [6.1, 6.3] }
       *
       * // The `_.property` iteratee shorthand.
       * _.groupBy(['one', 'two', 'three'], 'length');
       * // => { '3': ['one', 'two'], '5': ['three'] }
       */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else {baseAssignValue(result,key,[value]);}});/**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * is used for equality comparisons. If `fromIndex` is negative, it's used as
       * the offset from the end of `collection`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes([1, 2, 3], 1, 2);
       * // => false
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
       * Invokes the method at `path` of each element in `collection`, returning
       * an array of the results of each invoked method. Any additional arguments
       * are provided to each invoked method. If `path` is a function, it's invoked
       * for, and `this` bound to, each element in `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array|Function|string} path The path of the method to invoke or
       *  the function invoked per iteration.
       * @param {...*} [args] The arguments to invoke each method with.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
       * // => [[1, 5, 7], [1, 2, 3]]
       *
       * _.invokeMap([123, 456], String.prototype.split, '');
       * // => [['1', '2', '3'], ['4', '5', '6']]
       */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the last element responsible for generating the key. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * var array = [
       *   { 'dir': 'left', 'code': 97 },
       *   { 'dir': 'right', 'code': 100 }
       * ];
       *
       * _.keyBy(array, function(o) {
       *   return String.fromCharCode(o.code);
       * });
       * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
       *
       * _.keyBy(array, 'dir');
       * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
       */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
       * Creates an array of values by running each element in `collection` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
       *
       * The guarded methods are:
       * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
       * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
       * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
       * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * _.map([4, 8], square);
       * // => [16, 64]
       *
       * _.map({ 'a': 4, 'b': 8 }, square);
       * // => [16, 64] (iteration order is not guaranteed)
       *
       * var users = [
       *   { 'user': 'barney' },
       *   { 'user': 'fred' }
       * ];
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, 'user');
       * // => ['barney', 'fred']
       */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
       * This method is like `_.sortBy` except that it allows specifying the sort
       * orders of the iteratees to sort by. If `orders` is unspecified, all values
       * are sorted in ascending order. Otherwise, specify an order of "desc" for
       * descending or "asc" for ascending sort order of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @param {string[]} [orders] The sort orders of `iteratees`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 34 },
       *   { 'user': 'fred',   'age': 40 },
       *   { 'user': 'barney', 'age': 36 }
       * ];
       *
       * // Sort by `user` in ascending order and by `age` in descending order.
       * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
       */function orderBy(collection,iteratees,orders,guard){if(collection==null){return [];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined$1:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
       * Creates an array of elements split into two groups, the first of which
       * contains elements `predicate` returns truthy for, the second of which
       * contains elements `predicate` returns falsey for. The predicate is
       * invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of grouped elements.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': false },
       *   { 'user': 'fred',    'age': 40, 'active': true },
       *   { 'user': 'pebbles', 'age': 1,  'active': false }
       * ];
       *
       * _.partition(users, function(o) { return o.active; });
       * // => objects for [['fred'], ['barney', 'pebbles']]
       *
       * // The `_.matches` iteratee shorthand.
       * _.partition(users, { 'age': 1, 'active': false });
       * // => objects for [['pebbles'], ['barney', 'fred']]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.partition(users, ['active', false]);
       * // => objects for [['barney', 'pebbles'], ['fred']]
       *
       * // The `_.property` iteratee shorthand.
       * _.partition(users, 'active');
       * // => objects for [['fred'], ['barney', 'pebbles']]
       */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return [[],[]];});/**
       * Reduces `collection` to a value which is the accumulated result of running
       * each element in `collection` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `collection` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.reduce`, `_.reduceRight`, and `_.transform`.
       *
       * The guarded methods are:
       * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
       * and `sortBy`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduceRight
       * @example
       *
       * _.reduce([1, 2], function(sum, n) {
       *   return sum + n;
       * }, 0);
       * // => 3
       *
       * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       *   return result;
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
       */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
       * This method is like `_.reduce` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduce
       * @example
       *
       * var array = [[0, 1], [2, 3], [4, 5]];
       *
       * _.reduceRight(array, function(flattened, other) {
       *   return flattened.concat(other);
       * }, []);
       * // => [4, 5, 2, 3, 0, 1]
       */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
       * The opposite of `_.filter`; this method returns the elements of `collection`
       * that `predicate` does **not** return truthy for.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.filter
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': true }
       * ];
       *
       * _.reject(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.reject(users, { 'age': 40, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.reject(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.reject(users, 'active');
       * // => objects for ['barney']
       */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
       * Gets a random element from `collection`.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       * @example
       *
       * _.sample([1, 2, 3, 4]);
       * // => 2
       */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
       * Gets `n` random elements at unique keys from `collection` up to the
       * size of `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @param {number} [n=1] The number of elements to sample.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the random elements.
       * @example
       *
       * _.sampleSize([1, 2, 3], 2);
       * // => [3, 1]
       *
       * _.sampleSize([1, 2, 3], 4);
       * // => [2, 3, 1]
       */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
       * Creates an array of shuffled values, using a version of the
       * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       * @example
       *
       * _.shuffle([1, 2, 3, 4]);
       * // => [4, 1, 3, 2]
       */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
       * Gets the size of `collection` by returning its length for array-like
       * values or the number of own enumerable string keyed properties for objects.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * _.size([1, 2, 3]);
       * // => 3
       *
       * _.size({ 'a': 1, 'b': 2 });
       * // => 2
       *
       * _.size('pebbles');
       * // => 7
       */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
       * Checks if `predicate` returns truthy for **any** element of `collection`.
       * Iteration is stopped once `predicate` returns truthy. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       * @example
       *
       * _.some([null, 0, 'yes', false], Boolean);
       * // => true
       *
       * var users = [
       *   { 'user': 'barney', 'active': true },
       *   { 'user': 'fred',   'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.some(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.some(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.some(users, 'active');
       * // => true
       */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
       * Creates an array of elements, sorted in ascending order by the results of
       * running each element in a collection thru each iteratee. This method
       * performs a stable sort, that is, it preserves the original sort order of
       * equal elements. The iteratees are invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 30 },
       *   { 'user': 'barney', 'age': 34 }
       * ];
       *
       * _.sortBy(users, [function(o) { return o.user; }]);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
       *
       * _.sortBy(users, ['user', 'age']);
       * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
       */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return [];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
       * Gets the timestamp of the number of milliseconds that have elapsed since
       * the Unix epoch (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Date
       * @returns {number} Returns the timestamp.
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => Logs the number of milliseconds it took for the deferred invocation.
       */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
       * The opposite of `_.before`; this method creates a function that invokes
       * `func` once it's called `n` or more times.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {number} n The number of calls before `func` is invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var saves = ['profile', 'settings'];
       *
       * var done = _.after(saves.length, function() {
       *   console.log('done saving!');
       * });
       *
       * _.forEach(saves, function(type) {
       *   asyncSave({ 'type': type, 'complete': done });
       * });
       * // => Logs 'done saving!' after the two async saves have completed.
       */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
       * Creates a function that invokes `func`, with up to `n` arguments,
       * ignoring any additional arguments.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @param {number} [n=func.length] The arity cap.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.ary(parseInt, 1));
       * // => [6, 8, 10]
       */function ary(func,n,guard){n=guard?undefined$1:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,n);}/**
       * Creates a function that invokes `func`, with the `this` binding and arguments
       * of the created function, while it's called less than `n` times. Subsequent
       * calls to the created function return the result of the last `func` invocation.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {number} n The number of calls at which `func` is no longer invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * jQuery(element).on('click', _.before(5, addContactToList));
       * // => Allows adding up to 4 contacts to the list.
       */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined$1;}return result;};}/**
       * Creates a function that invokes `func` with the `this` binding of `thisArg`
       * and `partials` prepended to the arguments it receives.
       *
       * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for partially applied arguments.
       *
       * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
       * property of bound functions.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to bind.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * function greet(greeting, punctuation) {
       *   return greeting + ' ' + this.user + punctuation;
       * }
       *
       * var object = { 'user': 'fred' };
       *
       * var bound = _.bind(greet, object, 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bind(greet, object, _, '!');
       * bound('hi');
       * // => 'hi fred!'
       */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
       * Creates a function that invokes the method at `object[key]` with `partials`
       * prepended to the arguments it receives.
       *
       * This method differs from `_.bind` by allowing bound functions to reference
       * methods that may be redefined or don't yet exist. See
       * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
       * for more details.
       *
       * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Function
       * @param {Object} object The object to invoke the method on.
       * @param {string} key The key of the method.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * var object = {
       *   'user': 'fred',
       *   'greet': function(greeting, punctuation) {
       *     return greeting + ' ' + this.user + punctuation;
       *   }
       * };
       *
       * var bound = _.bindKey(object, 'greet', 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * object.greet = function(greeting, punctuation) {
       *   return greeting + 'ya ' + this.user + punctuation;
       * };
       *
       * bound('!');
       * // => 'hiya fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bindKey(object, 'greet', _, '!');
       * bound('hi');
       * // => 'hiya fred!'
       */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
       * Creates a function that accepts arguments of `func` and either invokes
       * `func` returning its result, if at least `arity` number of arguments have
       * been provided, or returns a function that accepts the remaining `func`
       * arguments, and so on. The arity of `func` may be specified if `func.length`
       * is not sufficient.
       *
       * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curry(abc);
       *
       * curried(1)(2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(1)(_, 3)(2);
       * // => [1, 2, 3]
       */function curry(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curry.placeholder;return result;}/**
       * This method is like `_.curry` except that arguments are applied to `func`
       * in the manner of `_.partialRight` instead of `_.partial`.
       *
       * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curryRight(abc);
       *
       * curried(3)(2)(1);
       * // => [1, 2, 3]
       *
       * curried(2, 3)(1);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(3)(1, _)(2);
       * // => [1, 2, 3]
       */function curryRight(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curryRight.placeholder;return result;}/**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked. The debounced function comes with a `cancel` method to cancel
       * delayed `func` invocations and a `flush` method to immediately invoke them.
       * Provide `options` to indicate whether `func` should be invoked on the
       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
       * with the last arguments provided to the debounced function. Subsequent
       * calls to the debounced function return the result of the last `func`
       * invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', debounced);
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel);
       */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined$1;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
  lastInvokeTime=time;// Start the timer for the trailing edge.
  timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
  return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
  // trailing edge, the system time has gone backwards and we're treating
  // it as the trailing edge, or we've hit the `maxWait` limit.
  return lastCallTime===undefined$1||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
  timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined$1;// Only invoke if we have `lastArgs` which means `func` has been
  // debounced at least once.
  if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined$1;return result;}function cancel(){if(timerId!==undefined$1){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined$1;}function flush(){return timerId===undefined$1?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined$1){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
  clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined$1){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
       * Defers invoking the `func` until the current call stack has cleared. Any
       * additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to defer.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.defer(function(text) {
       *   console.log(text);
       * }, 'deferred');
       * // => Logs 'deferred' after one millisecond.
       */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
       * Invokes `func` after `wait` milliseconds. Any additional arguments are
       * provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.delay(function(text) {
       *   console.log(text);
       * }, 1000, 'later');
       * // => Logs 'later' after one second.
       */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
       * Creates a function that invokes `func` with arguments reversed.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to flip arguments for.
       * @returns {Function} Returns the new flipped function.
       * @example
       *
       * var flipped = _.flip(function() {
       *   return _.toArray(arguments);
       * });
       *
       * flipped('a', 'b', 'c', 'd');
       * // => ['d', 'c', 'b', 'a']
       */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
       * Creates a function that memoizes the result of `func`. If `resolver` is
       * provided, it determines the cache key for storing the result based on the
       * arguments provided to the memoized function. By default, the first argument
       * provided to the memoized function is used as the map cache key. The `func`
       * is invoked with the `this` binding of the memoized function.
       *
       * **Note:** The cache is exposed as the `cache` property on the memoized
       * function. Its creation may be customized by replacing the `_.memoize.Cache`
       * constructor with one whose instances implement the
       * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
       * method interface of `clear`, `delete`, `get`, `has`, and `set`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to have its output memoized.
       * @param {Function} [resolver] The function to resolve the cache key.
       * @returns {Function} Returns the new memoized function.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       * var other = { 'c': 3, 'd': 4 };
       *
       * var values = _.memoize(_.values);
       * values(object);
       * // => [1, 2]
       *
       * values(other);
       * // => [3, 4]
       *
       * object.a = 2;
       * values(object);
       * // => [1, 2]
       *
       * // Modify the result cache.
       * values.cache.set(object, ['a', 'b']);
       * values(object);
       * // => ['a', 'b']
       *
       * // Replace `_.memoize.Cache`.
       * _.memoize.Cache = WeakMap;
       */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
  memoize.Cache=MapCache;/**
       * Creates a function that negates the result of the predicate `func`. The
       * `func` predicate is invoked with the `this` binding and arguments of the
       * created function.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} predicate The predicate to negate.
       * @returns {Function} Returns the new negated function.
       * @example
       *
       * function isEven(n) {
       *   return n % 2 == 0;
       * }
       *
       * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
       * // => [1, 3, 5]
       */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return !predicate.call(this);case 1:return !predicate.call(this,args[0]);case 2:return !predicate.call(this,args[0],args[1]);case 3:return !predicate.call(this,args[0],args[1],args[2]);}return !predicate.apply(this,args);};}/**
       * Creates a function that is restricted to invoking `func` once. Repeat calls
       * to the function return the value of the first invocation. The `func` is
       * invoked with the `this` binding and arguments of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var initialize = _.once(createApplication);
       * initialize();
       * initialize();
       * // => `createApplication` is invoked once
       */function once(func){return before(2,func);}/**
       * Creates a function that invokes `func` with its arguments transformed.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Function
       * @param {Function} func The function to wrap.
       * @param {...(Function|Function[])} [transforms=[_.identity]]
       *  The argument transforms.
       * @returns {Function} Returns the new function.
       * @example
       *
       * function doubled(n) {
       *   return n * 2;
       * }
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var func = _.overArgs(function(x, y) {
       *   return [x, y];
       * }, [square, doubled]);
       *
       * func(9, 3);
       * // => [81, 6]
       *
       * func(10, 5);
       * // => [100, 10]
       */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
       * Creates a function that invokes `func` with `partials` prepended to the
       * arguments it receives. This method is like `_.bind` except it does **not**
       * alter the `this` binding.
       *
       * The `_.partial.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 0.2.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var sayHelloTo = _.partial(greet, 'hello');
       * sayHelloTo('fred');
       * // => 'hello fred'
       *
       * // Partially applied with placeholders.
       * var greetFred = _.partial(greet, _, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined$1,partials,holders);});/**
       * This method is like `_.partial` except that partially applied arguments
       * are appended to the arguments it receives.
       *
       * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var greetFred = _.partialRight(greet, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       *
       * // Partially applied with placeholders.
       * var sayHelloTo = _.partialRight(greet, 'hello', _);
       * sayHelloTo('fred');
       * // => 'hello fred'
       */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined$1,partials,holders);});/**
       * Creates a function that invokes `func` with arguments arranged according
       * to the specified `indexes` where the argument value at the first index is
       * provided as the first argument, the argument value at the second index is
       * provided as the second argument, and so on.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to rearrange arguments for.
       * @param {...(number|number[])} indexes The arranged argument indexes.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var rearged = _.rearg(function(a, b, c) {
       *   return [a, b, c];
       * }, [2, 0, 1]);
       *
       * rearged('b', 'c', 'a')
       * // => ['a', 'b', 'c']
       */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined$1,undefined$1,undefined$1,indexes);});/**
       * Creates a function that invokes `func` with the `this` binding of the
       * created function and arguments from `start` and beyond provided as
       * an array.
       *
       * **Note:** This method is based on the
       * [rest parameter](https://mdn.io/rest_parameters).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.rest(function(what, names) {
       *   return what + ' ' + _.initial(names).join(', ') +
       *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
       * });
       *
       * say('hello', 'fred', 'barney', 'pebbles');
       * // => 'hello fred, barney, & pebbles'
       */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined$1?start:toInteger(start);return baseRest(func,start);}/**
       * Creates a function that invokes `func` with the `this` binding of the
       * create function and an array of arguments much like
       * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
       *
       * **Note:** This method is based on the
       * [spread operator](https://mdn.io/spread_operator).
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Function
       * @param {Function} func The function to spread arguments over.
       * @param {number} [start=0] The start position of the spread.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.spread(function(who, what) {
       *   return who + ' says ' + what;
       * });
       *
       * say(['fred', 'hello']);
       * // => 'fred says hello'
       *
       * var numbers = Promise.all([
       *   Promise.resolve(40),
       *   Promise.resolve(36)
       * ]);
       *
       * numbers.then(_.spread(function(x, y) {
       *   return x + y;
       * }));
       * // => a Promise of 76
       */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
       * Creates a throttled function that only invokes `func` at most once per
       * every `wait` milliseconds. The throttled function comes with a `cancel`
       * method to cancel delayed `func` invocations and a `flush` method to
       * immediately invoke them. Provide `options` to indicate whether `func`
       * should be invoked on the leading and/or trailing edge of the `wait`
       * timeout. The `func` is invoked with the last arguments provided to the
       * throttled function. Subsequent calls to the throttled function return the
       * result of the last `func` invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the throttled function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.throttle` and `_.debounce`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to throttle.
       * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=true]
       *  Specify invoking on the leading edge of the timeout.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new throttled function.
       * @example
       *
       * // Avoid excessively updating the position while scrolling.
       * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
       *
       * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
       * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
       * jQuery(element).on('click', throttled);
       *
       * // Cancel the trailing throttled invocation.
       * jQuery(window).on('popstate', throttled.cancel);
       */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
       * Creates a function that accepts up to one argument, ignoring any
       * additional arguments.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.unary(parseInt));
       * // => [6, 8, 10]
       */function unary(func){return ary(func,1);}/**
       * Creates a function that provides `value` to `wrapper` as its first
       * argument. Any additional arguments provided to the function are appended
       * to those provided to the `wrapper`. The wrapper is invoked with the `this`
       * binding of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {*} value The value to wrap.
       * @param {Function} [wrapper=identity] The wrapper function.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var p = _.wrap(_.escape, function(func, text) {
       *   return '<p>' + func(text) + '</p>';
       * });
       *
       * p('fred, barney, & pebbles');
       * // => '<p>fred, barney, &amp; pebbles</p>'
       */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
       * Casts `value` as an array if it's not one.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Lang
       * @param {*} value The value to inspect.
       * @returns {Array} Returns the cast array.
       * @example
       *
       * _.castArray(1);
       * // => [1]
       *
       * _.castArray({ 'a': 1 });
       * // => [{ 'a': 1 }]
       *
       * _.castArray('abc');
       * // => ['abc']
       *
       * _.castArray(null);
       * // => [null]
       *
       * _.castArray(undefined);
       * // => [undefined]
       *
       * _.castArray();
       * // => []
       *
       * var array = [1, 2, 3];
       * console.log(_.castArray(array) === array);
       * // => true
       */function castArray(){if(!arguments.length){return [];}var value=arguments[0];return isArray(value)?value:[value];}/**
       * Creates a shallow clone of `value`.
       *
       * **Note:** This method is loosely based on the
       * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
       * and supports cloning arrays, array buffers, booleans, date objects, maps,
       * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
       * arrays. The own enumerable properties of `arguments` objects are cloned
       * as plain objects. An empty object is returned for uncloneable values such
       * as error objects, functions, DOM nodes, and WeakMaps.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to clone.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeep
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var shallow = _.clone(objects);
       * console.log(shallow[0] === objects[0]);
       * // => true
       */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
       * This method is like `_.clone` except that it accepts `customizer` which
       * is invoked to produce the cloned value. If `customizer` returns `undefined`,
       * cloning is handled by the method instead. The `customizer` is invoked with
       * up to four arguments; (value [, index|key, object, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeepWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(false);
       *   }
       * }
       *
       * var el = _.cloneWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 0
       */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
       * This method is like `_.clone` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @returns {*} Returns the deep cloned value.
       * @see _.clone
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var deep = _.cloneDeep(objects);
       * console.log(deep[0] === objects[0]);
       * // => false
       */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
       * This method is like `_.cloneWith` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the deep cloned value.
       * @see _.cloneWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(true);
       *   }
       * }
       *
       * var el = _.cloneDeepWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 20
       */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
       * Checks if `object` conforms to `source` by invoking the predicate
       * properties of `source` with the corresponding property values of `object`.
       *
       * **Note:** This method is equivalent to `_.conforms` when `source` is
       * partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
       * // => true
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
       * // => false
       */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */function eq(value,other){return value===other||value!==value&&other!==other;}/**
       * Checks if `value` is greater than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       * @see _.lt
       * @example
       *
       * _.gt(3, 1);
       * // => true
       *
       * _.gt(3, 3);
       * // => false
       *
       * _.gt(1, 3);
       * // => false
       */var gt=createRelationalOperation(baseGt);/**
       * Checks if `value` is greater than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than or equal to
       *  `other`, else `false`.
       * @see _.lte
       * @example
       *
       * _.gte(3, 1);
       * // => true
       *
       * _.gte(3, 3);
       * // => true
       *
       * _.gte(1, 3);
       * // => false
       */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */var isArray=Array.isArray;/**
       * Checks if `value` is classified as an `ArrayBuffer` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       * @example
       *
       * _.isArrayBuffer(new ArrayBuffer(2));
       * // => true
       *
       * _.isArrayBuffer(new Array(2));
       * // => false
       */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
       * This method is like `_.isArrayLike` except that it also checks if `value`
       * is an object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array-like object,
       *  else `false`.
       * @example
       *
       * _.isArrayLikeObject([1, 2, 3]);
       * // => true
       *
       * _.isArrayLikeObject(document.body.children);
       * // => true
       *
       * _.isArrayLikeObject('abc');
       * // => false
       *
       * _.isArrayLikeObject(_.noop);
       * // => false
       */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
       * Checks if `value` is classified as a boolean primitive or object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
       * @example
       *
       * _.isBoolean(false);
       * // => true
       *
       * _.isBoolean(null);
       * // => false
       */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
       * Checks if `value` is a buffer.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
       * @example
       *
       * _.isBuffer(new Buffer(2));
       * // => true
       *
       * _.isBuffer(new Uint8Array(2));
       * // => false
       */var isBuffer=nativeIsBuffer||stubFalse;/**
       * Checks if `value` is classified as a `Date` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       * @example
       *
       * _.isDate(new Date);
       * // => true
       *
       * _.isDate('Mon April 23 2012');
       * // => false
       */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
       * Checks if `value` is likely a DOM element.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
       * @example
       *
       * _.isElement(document.body);
       * // => true
       *
       * _.isElement('<body>');
       * // => false
       */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
       * Checks if `value` is an empty object, collection, map, or set.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Array-like values such as `arguments` objects, arrays, buffers, strings, or
       * jQuery-like collections are considered empty if they have a `length` of `0`.
       * Similarly, maps and sets are considered empty if they have a `size` of `0`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * _.isEmpty(null);
       * // => true
       *
       * _.isEmpty(true);
       * // => true
       *
       * _.isEmpty(1);
       * // => true
       *
       * _.isEmpty([1, 2, 3]);
       * // => false
       *
       * _.isEmpty({ 'a': 1 });
       * // => false
       */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return !value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return !value.size;}if(isPrototype(value)){return !baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
       * Performs a deep comparison between two values to determine if they are
       * equivalent.
       *
       * **Note:** This method supports comparing arrays, array buffers, booleans,
       * date objects, error objects, maps, numbers, `Object` objects, regexes,
       * sets, strings, symbols, and typed arrays. `Object` objects are compared
       * by their own, not inherited, enumerable properties. Functions and DOM
       * nodes are compared by strict equality, i.e. `===`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.isEqual(object, other);
       * // => true
       *
       * object === other;
       * // => false
       */function isEqual(value,other){return baseIsEqual(value,other);}/**
       * This method is like `_.isEqual` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with up to
       * six arguments: (objValue, othValue [, index|key, object, other, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, othValue) {
       *   if (isGreeting(objValue) && isGreeting(othValue)) {
       *     return true;
       *   }
       * }
       *
       * var array = ['hello', 'goodbye'];
       * var other = ['hi', 'goodbye'];
       *
       * _.isEqualWith(array, other, customizer);
       * // => true
       */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;var result=customizer?customizer(value,other):undefined$1;return result===undefined$1?baseIsEqual(value,other,undefined$1,customizer):!!result;}/**
       * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
       * `SyntaxError`, `TypeError`, or `URIError` object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
       * @example
       *
       * _.isError(new Error);
       * // => true
       *
       * _.isError(Error);
       * // => false
       */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
       * Checks if `value` is a finite primitive number.
       *
       * **Note:** This method is based on
       * [`Number.isFinite`](https://mdn.io/Number/isFinite).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
       * @example
       *
       * _.isFinite(3);
       * // => true
       *
       * _.isFinite(Number.MIN_VALUE);
       * // => true
       *
       * _.isFinite(Infinity);
       * // => false
       *
       * _.isFinite('3');
       * // => false
       */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
       * Checks if `value` is an integer.
       *
       * **Note:** This method is based on
       * [`Number.isInteger`](https://mdn.io/Number/isInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
       * @example
       *
       * _.isInteger(3);
       * // => true
       *
       * _.isInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isInteger(Infinity);
       * // => false
       *
       * _.isInteger('3');
       * // => false
       */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}/**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */function isObjectLike(value){return value!=null&&_typeof(value)=='object';}/**
       * Checks if `value` is classified as a `Map` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       * @example
       *
       * _.isMap(new Map);
       * // => true
       *
       * _.isMap(new WeakMap);
       * // => false
       */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
       * Performs a partial deep comparison between `object` and `source` to
       * determine if `object` contains equivalent property values.
       *
       * **Note:** This method is equivalent to `_.matches` when `source` is
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.isMatch(object, { 'b': 2 });
       * // => true
       *
       * _.isMatch(object, { 'b': 1 });
       * // => false
       */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
       * This method is like `_.isMatch` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with five
       * arguments: (objValue, srcValue, index|key, object, source).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, srcValue) {
       *   if (isGreeting(objValue) && isGreeting(srcValue)) {
       *     return true;
       *   }
       * }
       *
       * var object = { 'greeting': 'hello' };
       * var source = { 'greeting': 'hi' };
       *
       * _.isMatchWith(object, source, customizer);
       * // => true
       */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
       * Checks if `value` is `NaN`.
       *
       * **Note:** This method is based on
       * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
       * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
       * `undefined` and other non-number values.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       * @example
       *
       * _.isNaN(NaN);
       * // => true
       *
       * _.isNaN(new Number(NaN));
       * // => true
       *
       * isNaN(undefined);
       * // => true
       *
       * _.isNaN(undefined);
       * // => false
       */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some
  // ActiveX objects in IE.
  return isNumber(value)&&value!=+value;}/**
       * Checks if `value` is a pristine native function.
       *
       * **Note:** This method can't reliably detect native functions in the presence
       * of the core-js package because core-js circumvents this kind of detection.
       * Despite multiple requests, the core-js maintainer has made it clear: any
       * attempt to fix the detection will be obstructed. As a result, we're left
       * with little choice but to throw an error. Unfortunately, this also affects
       * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
       * which rely on core-js.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       * @example
       *
       * _.isNative(Array.prototype.push);
       * // => true
       *
       * _.isNative(_);
       * // => false
       */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
       * Checks if `value` is `null`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
       * @example
       *
       * _.isNull(null);
       * // => true
       *
       * _.isNull(void 0);
       * // => false
       */function isNull(value){return value===null;}/**
       * Checks if `value` is `null` or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
       * @example
       *
       * _.isNil(null);
       * // => true
       *
       * _.isNil(void 0);
       * // => true
       *
       * _.isNil(NaN);
       * // => false
       */function isNil(value){return value==null;}/**
       * Checks if `value` is classified as a `Number` primitive or object.
       *
       * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
       * classified as numbers, use the `_.isFinite` method.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a number, else `false`.
       * @example
       *
       * _.isNumber(3);
       * // => true
       *
       * _.isNumber(Number.MIN_VALUE);
       * // => true
       *
       * _.isNumber(Infinity);
       * // => true
       *
       * _.isNumber('3');
       * // => false
       */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
       * Checks if `value` is classified as a `RegExp` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       * @example
       *
       * _.isRegExp(/abc/);
       * // => true
       *
       * _.isRegExp('/abc/');
       * // => false
       */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
       * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
       * double precision number which isn't the result of a rounded unsafe integer.
       *
       * **Note:** This method is based on
       * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
       * @example
       *
       * _.isSafeInteger(3);
       * // => true
       *
       * _.isSafeInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isSafeInteger(Infinity);
       * // => false
       *
       * _.isSafeInteger('3');
       * // => false
       */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
       * Checks if `value` is classified as a `Set` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       * @example
       *
       * _.isSet(new Set);
       * // => true
       *
       * _.isSet(new WeakSet);
       * // => false
       */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
       * Checks if `value` is classified as a `String` primitive or object.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a string, else `false`.
       * @example
       *
       * _.isString('abc');
       * // => true
       *
       * _.isString(1);
       * // => false
       */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */function isSymbol(value){return _typeof(value)=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
       * Checks if `value` is `undefined`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * _.isUndefined(void 0);
       * // => true
       *
       * _.isUndefined(null);
       * // => false
       */function isUndefined(value){return value===undefined$1;}/**
       * Checks if `value` is classified as a `WeakMap` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
       * @example
       *
       * _.isWeakMap(new WeakMap);
       * // => true
       *
       * _.isWeakMap(new Map);
       * // => false
       */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
       * Checks if `value` is classified as a `WeakSet` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
       * @example
       *
       * _.isWeakSet(new WeakSet);
       * // => true
       *
       * _.isWeakSet(new Set);
       * // => false
       */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
       * Checks if `value` is less than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       * @see _.gt
       * @example
       *
       * _.lt(1, 3);
       * // => true
       *
       * _.lt(3, 3);
       * // => false
       *
       * _.lt(3, 1);
       * // => false
       */var lt=createRelationalOperation(baseLt);/**
       * Checks if `value` is less than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than or equal to
       *  `other`, else `false`.
       * @see _.gte
       * @example
       *
       * _.lte(1, 3);
       * // => true
       *
       * _.lte(3, 3);
       * // => true
       *
       * _.lte(3, 1);
       * // => false
       */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
       * Converts `value` to an array.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Array} Returns the converted array.
       * @example
       *
       * _.toArray({ 'a': 1, 'b': 2 });
       * // => [1, 2]
       *
       * _.toArray('abc');
       * // => ['a', 'b', 'c']
       *
       * _.toArray(1);
       * // => []
       *
       * _.toArray(null);
       * // => []
       */function toArray(value){if(!value){return [];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
       * Converts `value` to a finite number.
       *
       * @static
       * @memberOf _
       * @since 4.12.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted number.
       * @example
       *
       * _.toFinite(3.2);
       * // => 3.2
       *
       * _.toFinite(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toFinite(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toFinite('3.2');
       * // => 3.2
       */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
       * Converts `value` to an integer.
       *
       * **Note:** This method is loosely based on
       * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toInteger(3.2);
       * // => 3
       *
       * _.toInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toInteger(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toInteger('3.2');
       * // => 3
       */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
       * Converts `value` to an integer suitable for use as the length of an
       * array-like object.
       *
       * **Note:** This method is based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toLength(3.2);
       * // => 3
       *
       * _.toLength(Number.MIN_VALUE);
       * // => 0
       *
       * _.toLength(Infinity);
       * // => 4294967295
       *
       * _.toLength('3.2');
       * // => 3
       */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
       * Converts `value` to a plain object flattening inherited enumerable string
       * keyed properties of `value` to own properties of the plain object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Object} Returns the converted plain object.
       * @example
       *
       * function Foo() {
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.assign({ 'a': 1 }, new Foo);
       * // => { 'a': 1, 'b': 2 }
       *
       * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
       * // => { 'a': 1, 'b': 2, 'c': 3 }
       */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
       * Converts `value` to a safe integer. A safe integer can be compared and
       * represented correctly.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toSafeInteger(3.2);
       * // => 3
       *
       * _.toSafeInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toSafeInteger(Infinity);
       * // => 9007199254740991
       *
       * _.toSafeInteger('3.2');
       * // => 3
       */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
       * Assigns own enumerable string keyed properties of source objects to the
       * destination object. Source objects are applied from left to right.
       * Subsequent sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object` and is loosely based on
       * [`Object.assign`](https://mdn.io/Object/assign).
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assignIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assign({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'c': 3 }
       */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
       * This method is like `_.assign` except that it iterates over own and
       * inherited source properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extend
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assign
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assignIn({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
       */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
       * This method is like `_.assignIn` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extendWith
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignInWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
       * This method is like `_.assign` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignInWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
       * Creates an array of values corresponding to `paths` of `object`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Array} Returns the picked values.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _.at(object, ['a[0].b.c', 'a[1]']);
       * // => [3, 4]
       */var at=flatRest(baseAt);/**
       * Creates an object that inherits from the `prototype` object. If a
       * `properties` object is given, its own enumerable string keyed properties
       * are assigned to the created object.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Object
       * @param {Object} prototype The object to inherit from.
       * @param {Object} [properties] The properties to assign to the object.
       * @returns {Object} Returns the new object.
       * @example
       *
       * function Shape() {
       *   this.x = 0;
       *   this.y = 0;
       * }
       *
       * function Circle() {
       *   Shape.call(this);
       * }
       *
       * Circle.prototype = _.create(Shape.prototype, {
       *   'constructor': Circle
       * });
       *
       * var circle = new Circle;
       * circle instanceof Circle;
       * // => true
       *
       * circle instanceof Shape;
       * // => true
       */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
       * Assigns own and inherited enumerable string keyed properties of source
       * objects to the destination object for all destination properties that
       * resolve to `undefined`. Source objects are applied from left to right.
       * Once a property is set, additional values of the same property are ignored.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaultsDeep
       * @example
       *
       * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined$1||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
       * This method is like `_.defaults` except that it recursively assigns
       * default properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaults
       * @example
       *
       * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
       * // => { 'a': { 'b': 2, 'c': 3 } }
       */var defaultsDeep=baseRest(function(args){args.push(undefined$1,customDefaultsMerge);return apply(mergeWith,undefined$1,args);});/**
       * This method is like `_.find` except that it returns the key of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findKey(users, function(o) { return o.age < 40; });
       * // => 'barney' (iteration order is not guaranteed)
       *
       * // The `_.matches` iteratee shorthand.
       * _.findKey(users, { 'age': 1, 'active': true });
       * // => 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findKey(users, 'active');
       * // => 'barney'
       */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
       * This method is like `_.findKey` except that it iterates over elements of
       * a collection in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findLastKey(users, function(o) { return o.age < 40; });
       * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastKey(users, { 'age': 36, 'active': true });
       * // => 'barney'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastKey(users, 'active');
       * // => 'pebbles'
       */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
       * Iterates over own and inherited enumerable string keyed properties of an
       * object and invokes `iteratee` for each property. The iteratee is invoked
       * with three arguments: (value, key, object). Iteratee functions may exit
       * iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forInRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forIn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
       */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
       * This method is like `_.forIn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forInRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
       */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
       * Iterates over own enumerable string keyed properties of an object and
       * invokes `iteratee` for each property. The iteratee is invoked with three
       * arguments: (value, key, object). Iteratee functions may exit iteration
       * early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwnRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
       * This method is like `_.forOwn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwnRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
       */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
       * Creates an array of function property names from own enumerable properties
       * of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functionsIn
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functions(new Foo);
       * // => ['a', 'b']
       */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
       * Creates an array of function property names from own and inherited
       * enumerable properties of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functions
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functionsIn(new Foo);
       * // => ['a', 'b', 'c']
       */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.get(object, 'a[0].b.c');
       * // => 3
       *
       * _.get(object, ['a', '0', 'b', 'c']);
       * // => 3
       *
       * _.get(object, 'a.b.c', 'default');
       * // => 'default'
       */function get(object,path,defaultValue){var result=object==null?undefined$1:baseGet(object,path);return result===undefined$1?defaultValue:result;}/**
       * Checks if `path` is a direct property of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = { 'a': { 'b': 2 } };
       * var other = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.has(object, 'a');
       * // => true
       *
       * _.has(object, 'a.b');
       * // => true
       *
       * _.has(object, ['a', 'b']);
       * // => true
       *
       * _.has(other, 'a');
       * // => false
       */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
       * Checks if `path` is a direct or inherited property of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.hasIn(object, 'a');
       * // => true
       *
       * _.hasIn(object, 'a.b');
       * // => true
       *
       * _.hasIn(object, ['a', 'b']);
       * // => true
       *
       * _.hasIn(object, 'b');
       * // => false
       */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
       * Creates an object composed of the inverted keys and values of `object`.
       * If `object` contains duplicate values, subsequent values overwrite
       * property assignments of previous values.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Object
       * @param {Object} object The object to invert.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invert(object);
       * // => { '1': 'c', '2': 'b' }
       */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
       * This method is like `_.invert` except that the inverted object is generated
       * from the results of running each element of `object` thru `iteratee`. The
       * corresponding inverted value of each inverted key is an array of keys
       * responsible for generating the inverted value. The iteratee is invoked
       * with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Object
       * @param {Object} object The object to invert.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invertBy(object);
       * // => { '1': ['a', 'c'], '2': ['b'] }
       *
       * _.invertBy(object, function(value) {
       *   return 'group' + value;
       * });
       * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
       */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else {result[value]=[key];}},getIteratee);/**
       * Invokes the method at `path` of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
       *
       * _.invoke(object, 'a[0].b.c.slice', 1, 3);
       * // => [2, 3]
       */var invoke=baseRest(baseInvoke);/**
       * Creates an array of the own enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects. See the
       * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * for more details.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keys(new Foo);
       * // => ['a', 'b'] (iteration order is not guaranteed)
       *
       * _.keys('hi');
       * // => ['0', '1']
       */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
       * The opposite of `_.mapValues`; this method creates an object with the
       * same values as `object` and keys generated by running each own enumerable
       * string keyed property of `object` thru `iteratee`. The iteratee is invoked
       * with three arguments: (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapValues
       * @example
       *
       * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
       *   return key + value;
       * });
       * // => { 'a1': 1, 'b2': 2 }
       */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
       * Creates an object with the same keys as `object` and values generated
       * by running each own enumerable string keyed property of `object` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapKeys
       * @example
       *
       * var users = {
       *   'fred':    { 'user': 'fred',    'age': 40 },
       *   'pebbles': { 'user': 'pebbles', 'age': 1 }
       * };
       *
       * _.mapValues(users, function(o) { return o.age; });
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       *
       * // The `_.property` iteratee shorthand.
       * _.mapValues(users, 'age');
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
       * This method is like `_.assign` except that it recursively merges own and
       * inherited enumerable string keyed properties of source objects into the
       * destination object. Source properties that resolve to `undefined` are
       * skipped if a destination value exists. Array and plain object properties
       * are merged recursively. Other objects and value types are overridden by
       * assignment. Source objects are applied from left to right. Subsequent
       * sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {
       *   'a': [{ 'b': 2 }, { 'd': 4 }]
       * };
       *
       * var other = {
       *   'a': [{ 'c': 3 }, { 'e': 5 }]
       * };
       *
       * _.merge(object, other);
       * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
       */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
       * This method is like `_.merge` except that it accepts `customizer` which
       * is invoked to produce the merged values of the destination and source
       * properties. If `customizer` returns `undefined`, merging is handled by the
       * method instead. The `customizer` is invoked with six arguments:
       * (objValue, srcValue, key, object, source, stack).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} customizer The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   if (_.isArray(objValue)) {
       *     return objValue.concat(srcValue);
       *   }
       * }
       *
       * var object = { 'a': [1], 'b': [2] };
       * var other = { 'a': [3], 'b': [4] };
       *
       * _.mergeWith(object, other, customizer);
       * // => { 'a': [1, 3], 'b': [2, 4] }
       */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
       * The opposite of `_.pick`; this method creates an object composed of the
       * own and inherited enumerable property paths of `object` that are not omitted.
       *
       * **Note:** This method is considerably slower than `_.pick`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to omit.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omit(object, ['a', 'c']);
       * // => { 'b': '2' }
       */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
       * The opposite of `_.pickBy`; this method creates an object composed of
       * the own and inherited enumerable string keyed properties of `object` that
       * `predicate` doesn't return truthy for. The predicate is invoked with two
       * arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omitBy(object, _.isNumber);
       * // => { 'b': '2' }
       */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
       * Creates an object composed of the picked `object` properties.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pick(object, ['a', 'c']);
       * // => { 'a': 1, 'c': 3 }
       */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
       * Creates an object composed of the `object` properties `predicate` returns
       * truthy for. The predicate is invoked with two arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pickBy(object, _.isNumber);
       * // => { 'a': 1, 'c': 3 }
       */function pickBy(object,predicate){if(object==null){return {};}var props=arrayMap(getAllKeysIn(object),function(prop){return [prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
       * This method is like `_.get` except that if the resolved value is a
       * function it's invoked with the `this` binding of its parent object and
       * its result is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to resolve.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
       *
       * _.result(object, 'a[0].b.c1');
       * // => 3
       *
       * _.result(object, 'a[0].b.c2');
       * // => 4
       *
       * _.result(object, 'a[0].b.c3', 'default');
       * // => 'default'
       *
       * _.result(object, 'a[0].b.c3', _.constant('default'));
       * // => 'default'
       */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
  if(!length){length=1;object=undefined$1;}while(++index<length){var value=object==null?undefined$1:object[toKey(path[index])];if(value===undefined$1){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
       * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
       * it's created. Arrays are created for missing index properties while objects
       * are created for all other missing properties. Use `_.setWith` to customize
       * `path` creation.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.set(object, 'a[0].b.c', 4);
       * console.log(object.a[0].b.c);
       * // => 4
       *
       * _.set(object, ['x', '0', 'y', 'z'], 5);
       * console.log(object.x[0].y.z);
       * // => 5
       */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
       * This method is like `_.set` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.setWith(object, '[0][1]', 'a', Object);
       * // => { '0': { '1': 'a' } }
       */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseSet(object,path,value,customizer);}/**
       * Creates an array of own enumerable string keyed-value pairs for `object`
       * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
       * entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entries
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairs(new Foo);
       * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
       */var toPairs=createToPairs(keys);/**
       * Creates an array of own and inherited enumerable string keyed-value pairs
       * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
       * or set, its entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entriesIn
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairsIn(new Foo);
       * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
       */var toPairsIn=createToPairs(keysIn);/**
       * An alternative to `_.reduce`; this method transforms `object` to a new
       * `accumulator` object which is the result of running each of its own
       * enumerable string keyed properties thru `iteratee`, with each invocation
       * potentially mutating the `accumulator` object. If `accumulator` is not
       * provided, a new object with the same `[[Prototype]]` will be used. The
       * iteratee is invoked with four arguments: (accumulator, value, key, object).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The custom accumulator value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * _.transform([2, 3, 4], function(result, n) {
       *   result.push(n *= n);
       *   return n % 2 == 0;
       * }, []);
       * // => [4, 9]
       *
       * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] }
       */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else {accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
       * Removes the property at `path` of `object`.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 7 } }] };
       * _.unset(object, 'a[0].b.c');
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       *
       * _.unset(object, ['a', '0', 'b', 'c']);
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
       * This method is like `_.set` except that accepts `updater` to produce the
       * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
       * is invoked with one argument: (value).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.update(object, 'a[0].b.c', function(n) { return n * n; });
       * console.log(object.a[0].b.c);
       * // => 9
       *
       * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
       * console.log(object.x[0].y.z);
       * // => 0
       */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
       * This method is like `_.update` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.updateWith(object, '[0][1]', _.constant('a'), Object);
       * // => { '0': { '1': 'a' } }
       */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
       * Creates an array of the own enumerable string keyed property values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.values(new Foo);
       * // => [1, 2] (iteration order is not guaranteed)
       *
       * _.values('hi');
       * // => ['h', 'i']
       */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
       * Creates an array of the own and inherited enumerable string keyed property
       * values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.valuesIn(new Foo);
       * // => [1, 2, 3] (iteration order is not guaranteed)
       */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
       * Clamps `number` within the inclusive `lower` and `upper` bounds.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Number
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       * @example
       *
       * _.clamp(-10, -5, 5);
       * // => -5
       *
       * _.clamp(10, -5, 5);
       * // => 5
       */function clamp(number,lower,upper){if(upper===undefined$1){upper=lower;lower=undefined$1;}if(upper!==undefined$1){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined$1){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
       * Checks if `n` is between `start` and up to, but not including, `end`. If
       * `end` is not specified, it's set to `start` with `start` then set to `0`.
       * If `start` is greater than `end` the params are swapped to support
       * negative ranges.
       *
       * @static
       * @memberOf _
       * @since 3.3.0
       * @category Number
       * @param {number} number The number to check.
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       * @see _.range, _.rangeRight
       * @example
       *
       * _.inRange(3, 2, 4);
       * // => true
       *
       * _.inRange(4, 8);
       * // => true
       *
       * _.inRange(4, 2);
       * // => false
       *
       * _.inRange(2, 2);
       * // => false
       *
       * _.inRange(1.2, 2);
       * // => true
       *
       * _.inRange(5.2, 4);
       * // => false
       *
       * _.inRange(-3, -2, -6);
       * // => true
       */function inRange(number,start,end){start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
       * Produces a random number between the inclusive `lower` and `upper` bounds.
       * If only one argument is provided a number between `0` and the given number
       * is returned. If `floating` is `true`, or either `lower` or `upper` are
       * floats, a floating-point number is returned instead of an integer.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Number
       * @param {number} [lower=0] The lower bound.
       * @param {number} [upper=1] The upper bound.
       * @param {boolean} [floating] Specify returning a floating-point number.
       * @returns {number} Returns the random number.
       * @example
       *
       * _.random(0, 5);
       * // => an integer between 0 and 5
       *
       * _.random(5);
       * // => also an integer between 0 and 5
       *
       * _.random(5, true);
       * // => a floating-point number between 0 and 5
       *
       * _.random(1.2, 5.2);
       * // => a floating-point number between 1.2 and 5.2
       */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined$1;}if(floating===undefined$1){if(typeof upper=='boolean'){floating=upper;upper=undefined$1;}else if(typeof lower=='boolean'){floating=lower;lower=undefined$1;}}if(lower===undefined$1&&upper===undefined$1){lower=0;upper=1;}else {lower=toFinite(lower);if(upper===undefined$1){upper=lower;lower=0;}else {upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
       * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the camel cased string.
       * @example
       *
       * _.camelCase('Foo Bar');
       * // => 'fooBar'
       *
       * _.camelCase('--foo-bar--');
       * // => 'fooBar'
       *
       * _.camelCase('__FOO_BAR__');
       * // => 'fooBar'
       */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * _.capitalize('FRED');
       * // => 'Fred'
       */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
       * Deburrs `string` by converting
       * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
       * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
       * letters to basic Latin letters and removing
       * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to deburr.
       * @returns {string} Returns the deburred string.
       * @example
       *
       * _.deburr('déjà vu');
       * // => 'deja vu'
       */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
       * Checks if `string` ends with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=string.length] The position to search up to.
       * @returns {boolean} Returns `true` if `string` ends with `target`,
       *  else `false`.
       * @example
       *
       * _.endsWith('abc', 'c');
       * // => true
       *
       * _.endsWith('abc', 'b');
       * // => false
       *
       * _.endsWith('abc', 'b', 2);
       * // => true
       */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined$1?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
       * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
       * corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional
       * characters use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't need escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value. See
       * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * When working with HTML you should always
       * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
       * XSS vectors.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
       * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
       * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escapeRegExp('[lodash](https://lodash.com/)');
       * // => '\[lodash\]\(https://lodash\.com/\)'
       */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
       * Converts `string` to
       * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the kebab cased string.
       * @example
       *
       * _.kebabCase('Foo Bar');
       * // => 'foo-bar'
       *
       * _.kebabCase('fooBar');
       * // => 'foo-bar'
       *
       * _.kebabCase('__FOO_BAR__');
       * // => 'foo-bar'
       */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
       * Converts `string`, as space separated words, to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.lowerCase('--Foo-Bar--');
       * // => 'foo bar'
       *
       * _.lowerCase('fooBar');
       * // => 'foo bar'
       *
       * _.lowerCase('__FOO_BAR__');
       * // => 'foo bar'
       */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
       * Converts the first character of `string` to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.lowerFirst('Fred');
       * // => 'fred'
       *
       * _.lowerFirst('FRED');
       * // => 'fRED'
       */var lowerFirst=createCaseFirst('toLowerCase');/**
       * Pads `string` on the left and right sides if it's shorter than `length`.
       * Padding characters are truncated if they can't be evenly divided by `length`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.pad('abc', 8);
       * // => '  abc   '
       *
       * _.pad('abc', 8, '_-');
       * // => '_-abc_-_'
       *
       * _.pad('abc', 3);
       * // => 'abc'
       */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
       * Pads `string` on the right side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padEnd('abc', 6);
       * // => 'abc   '
       *
       * _.padEnd('abc', 6, '_-');
       * // => 'abc_-_'
       *
       * _.padEnd('abc', 3);
       * // => 'abc'
       */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
       * Pads `string` on the left side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padStart('abc', 6);
       * // => '   abc'
       *
       * _.padStart('abc', 6, '_-');
       * // => '_-_abc'
       *
       * _.padStart('abc', 3);
       * // => 'abc'
       */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
       * Converts `string` to an integer of the specified radix. If `radix` is
       * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
       * hexadecimal, in which case a `radix` of `16` is used.
       *
       * **Note:** This method aligns with the
       * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category String
       * @param {string} string The string to convert.
       * @param {number} [radix=10] The radix to interpret `value` by.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.parseInt('08');
       * // => 8
       *
       * _.map(['6', '08', '10'], _.parseInt);
       * // => [6, 8, 10]
       */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
       * Repeats the given string `n` times.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to repeat.
       * @param {number} [n=1] The number of times to repeat the string.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the repeated string.
       * @example
       *
       * _.repeat('*', 3);
       * // => '***'
       *
       * _.repeat('abc', 2);
       * // => 'abcabc'
       *
       * _.repeat('abc', 0);
       * // => ''
       */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}return baseRepeat(toString(string),n);}/**
       * Replaces matches for `pattern` in `string` with `replacement`.
       *
       * **Note:** This method is based on
       * [`String#replace`](https://mdn.io/String/replace).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to modify.
       * @param {RegExp|string} pattern The pattern to replace.
       * @param {Function|string} replacement The match replacement.
       * @returns {string} Returns the modified string.
       * @example
       *
       * _.replace('Hi Fred', 'Fred', 'Barney');
       * // => 'Hi Barney'
       */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
       * Converts `string` to
       * [snake case](https://en.wikipedia.org/wiki/Snake_case).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the snake cased string.
       * @example
       *
       * _.snakeCase('Foo Bar');
       * // => 'foo_bar'
       *
       * _.snakeCase('fooBar');
       * // => 'foo_bar'
       *
       * _.snakeCase('--FOO-BAR--');
       * // => 'foo_bar'
       */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
       * Splits `string` by `separator`.
       *
       * **Note:** This method is based on
       * [`String#split`](https://mdn.io/String/split).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to split.
       * @param {RegExp|string} separator The separator pattern to split by.
       * @param {number} [limit] The length to truncate results to.
       * @returns {Array} Returns the string segments.
       * @example
       *
       * _.split('a-b-c', '-', 2);
       * // => ['a', 'b']
       */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined$1;}limit=limit===undefined$1?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return [];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
       * Converts `string` to
       * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
       *
       * @static
       * @memberOf _
       * @since 3.1.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the start cased string.
       * @example
       *
       * _.startCase('--foo-bar--');
       * // => 'Foo Bar'
       *
       * _.startCase('fooBar');
       * // => 'Foo Bar'
       *
       * _.startCase('__FOO_BAR__');
       * // => 'FOO BAR'
       */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
       * Checks if `string` starts with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=0] The position to search from.
       * @returns {boolean} Returns `true` if `string` starts with `target`,
       *  else `false`.
       * @example
       *
       * _.startsWith('abc', 'a');
       * // => true
       *
       * _.startsWith('abc', 'b');
       * // => false
       *
       * _.startsWith('abc', 'b', 1);
       * // => true
       */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
       * Creates a compiled template function that can interpolate data properties
       * in "interpolate" delimiters, HTML-escape interpolated data properties in
       * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
       * properties may be accessed as free variables in the template. If a setting
       * object is given, it takes precedence over `_.templateSettings` values.
       *
       * **Note:** In the development build `_.template` utilizes
       * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
       * for easier debugging.
       *
       * For more information on precompiling templates see
       * [lodash's custom builds documentation](https://lodash.com/custom-builds).
       *
       * For more information on Chrome extension sandboxes see
       * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The template string.
       * @param {Object} [options={}] The options object.
       * @param {RegExp} [options.escape=_.templateSettings.escape]
       *  The HTML "escape" delimiter.
       * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
       *  The "evaluate" delimiter.
       * @param {Object} [options.imports=_.templateSettings.imports]
       *  An object to import into the template as free variables.
       * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
       *  The "interpolate" delimiter.
       * @param {string} [options.sourceURL='lodash.templateSources[n]']
       *  The sourceURL of the compiled template.
       * @param {string} [options.variable='obj']
       *  The data object variable name.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the compiled template function.
       * @example
       *
       * // Use the "interpolate" delimiter to create a compiled template.
       * var compiled = _.template('hello <%= user %>!');
       * compiled({ 'user': 'fred' });
       * // => 'hello fred!'
       *
       * // Use the HTML "escape" delimiter to escape data property values.
       * var compiled = _.template('<b><%- value %></b>');
       * compiled({ 'value': '<script>' });
       * // => '<b>&lt;script&gt;</b>'
       *
       * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
       * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the internal `print` function in "evaluate" delimiters.
       * var compiled = _.template('<% print("hello " + user); %>!');
       * compiled({ 'user': 'barney' });
       * // => 'hello barney!'
       *
       * // Use the ES template literal delimiter as an "interpolate" delimiter.
       * // Disable support by replacing the "interpolate" delimiter.
       * var compiled = _.template('hello ${ user }!');
       * compiled({ 'user': 'pebbles' });
       * // => 'hello pebbles!'
       *
       * // Use backslashes to treat delimiters as plain text.
       * var compiled = _.template('<%= "\\<%- value %\\>" %>');
       * compiled({ 'value': 'ignored' });
       * // => '<%- value %>'
       *
       * // Use the `imports` option to import `jQuery` as `jq`.
       * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
       * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the `sourceURL` option to specify a custom sourceURL for the template.
       * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
       * compiled(data);
       * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
       *
       * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
       * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
       * compiled.source;
       * // => function(data) {
       * //   var __t, __p = '';
       * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
       * //   return __p;
       * // }
       *
       * // Use custom template delimiters.
       * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
       * var compiled = _.template('hello {{ user }}!');
       * compiled({ 'user': 'mustache' });
       * // => 'hello mustache!'
       *
       * // Use the `source` property to inline compiled templates for meaningful
       * // line numbers in error messages and stack traces.
       * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
       *   var JST = {\
       *     "main": ' + _.template(mainText).source + '\
       *   };\
       * ');
       */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined$1;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
  var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.
  var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
  source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
  if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
  // order to produce the correct `offset` value.
  return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
  source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
  source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined$1,importsValues);});// Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source=source;if(isError(result)){throw result;}return result;}/**
       * Converts `string`, as a whole, to lower case just like
       * [String#toLowerCase](https://mdn.io/toLowerCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.toLower('--Foo-Bar--');
       * // => '--foo-bar--'
       *
       * _.toLower('fooBar');
       * // => 'foobar'
       *
       * _.toLower('__FOO_BAR__');
       * // => '__foo_bar__'
       */function toLower(value){return toString(value).toLowerCase();}/**
       * Converts `string`, as a whole, to upper case just like
       * [String#toUpperCase](https://mdn.io/toUpperCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.toUpper('--foo-bar--');
       * // => '--FOO-BAR--'
       *
       * _.toUpper('fooBar');
       * // => 'FOOBAR'
       *
       * _.toUpper('__foo_bar__');
       * // => '__FOO_BAR__'
       */function toUpper(value){return toString(value).toUpperCase();}/**
       * Removes leading and trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trim('  abc  ');
       * // => 'abc'
       *
       * _.trim('-_-abc-_-', '_-');
       * // => 'abc'
       *
       * _.map(['  foo  ', '  bar  '], _.trim);
       * // => ['foo', 'bar']
       */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimEnd('  abc  ');
       * // => '  abc'
       *
       * _.trimEnd('-_-abc-_-', '_-');
       * // => '-_-abc'
       */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
       * Removes leading whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimStart('  abc  ');
       * // => 'abc  '
       *
       * _.trimStart('-_-abc-_-', '_-');
       * // => 'abc-_-'
       */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
       * Truncates `string` if it's longer than the given maximum string length.
       * The last characters of the truncated string are replaced with the omission
       * string which defaults to "...".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to truncate.
       * @param {Object} [options={}] The options object.
       * @param {number} [options.length=30] The maximum string length.
       * @param {string} [options.omission='...'] The string to indicate text is omitted.
       * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
       * @returns {string} Returns the truncated string.
       * @example
       *
       * _.truncate('hi-diddly-ho there, neighborino');
       * // => 'hi-diddly-ho there, neighbo...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': ' '
       * });
       * // => 'hi-diddly-ho there,...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': /,? +/
       * });
       * // => 'hi-diddly-ho there...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'omission': ' [...]'
       * });
       * // => 'hi-diddly-ho there, neig [...]'
       */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined$1){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined$1?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
       * The inverse of `_.escape`; this method converts the HTML entities
       * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
       * their corresponding characters.
       *
       * **Note:** No other HTML entities are unescaped. To unescape additional
       * HTML entities use a third-party library like [_he_](https://mths.be/he).
       *
       * @static
       * @memberOf _
       * @since 0.6.0
       * @category String
       * @param {string} [string=''] The string to unescape.
       * @returns {string} Returns the unescaped string.
       * @example
       *
       * _.unescape('fred, barney, &amp; pebbles');
       * // => 'fred, barney, & pebbles'
       */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
       * Converts `string`, as space separated words, to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.upperCase('--foo-bar');
       * // => 'FOO BAR'
       *
       * _.upperCase('fooBar');
       * // => 'FOO BAR'
       *
       * _.upperCase('__foo_bar__');
       * // => 'FOO BAR'
       */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
       * Converts the first character of `string` to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.upperFirst('fred');
       * // => 'Fred'
       *
       * _.upperFirst('FRED');
       * // => 'FRED'
       */var upperFirst=createCaseFirst('toUpperCase');/**
       * Splits `string` into an array of its words.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {RegExp|string} [pattern] The pattern to match words.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the words of `string`.
       * @example
       *
       * _.words('fred, barney, & pebbles');
       * // => ['fred', 'barney', 'pebbles']
       *
       * _.words('fred, barney, & pebbles', /[^, ]+/g);
       * // => ['fred', 'barney', '&', 'pebbles']
       */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined$1:pattern;if(pattern===undefined$1){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
       * Attempts to invoke `func`, returning either the result or the caught error
       * object. Any additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Function} func The function to attempt.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {*} Returns the `func` result or error object.
       * @example
       *
       * // Avoid throwing errors for invalid selectors.
       * var elements = _.attempt(function(selector) {
       *   return document.querySelectorAll(selector);
       * }, '>_>');
       *
       * if (_.isError(elements)) {
       *   elements = [];
       * }
       */var attempt=baseRest(function(func,args){try{return apply(func,undefined$1,args);}catch(e){return isError(e)?e:new Error(e);}});/**
       * Binds methods of an object to the object itself, overwriting the existing
       * method.
       *
       * **Note:** This method doesn't set the "length" property of bound functions.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Object} object The object to bind and assign the bound methods to.
       * @param {...(string|string[])} methodNames The object method names to bind.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var view = {
       *   'label': 'docs',
       *   'click': function() {
       *     console.log('clicked ' + this.label);
       *   }
       * };
       *
       * _.bindAll(view, ['click']);
       * jQuery(element).on('click', view.click);
       * // => Logs 'clicked docs' when clicked.
       */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
       * Creates a function that iterates over `pairs` and invokes the corresponding
       * function of the first predicate to return truthy. The predicate-function
       * pairs are invoked with the `this` binding and arguments of the created
       * function.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Array} pairs The predicate-function pairs.
       * @returns {Function} Returns the new composite function.
       * @example
       *
       * var func = _.cond([
       *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
       *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
       *   [_.stubTrue,                      _.constant('no match')]
       * ]);
       *
       * func({ 'a': 1, 'b': 2 });
       * // => 'matches A'
       *
       * func({ 'a': 0, 'b': 1 });
       * // => 'matches B'
       *
       * func({ 'a': '1', 'b': '2' });
       * // => 'no match'
       */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return [toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
       * Creates a function that invokes the predicate properties of `source` with
       * the corresponding property values of a given object, returning `true` if
       * all predicates return truthy, else `false`.
       *
       * **Note:** The created function is equivalent to `_.conformsTo` with
       * `source` partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 2, 'b': 1 },
       *   { 'a': 1, 'b': 2 }
       * ];
       *
       * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
       * // => [{ 'a': 1, 'b': 2 }]
       */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */function constant(value){return function(){return value;};}/**
       * Checks `value` to determine whether a default value should be returned in
       * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
       * or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Util
       * @param {*} value The value to check.
       * @param {*} defaultValue The default value.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * _.defaultTo(1, 10);
       * // => 1
       *
       * _.defaultTo(undefined, 10);
       * // => 10
       */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
       * Creates a function that returns the result of invoking the given functions
       * with the `this` binding of the created function, where each successive
       * invocation is supplied the return value of the previous.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flowRight
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flow([_.add, square]);
       * addSquare(1, 2);
       * // => 9
       */var flow=createFlow();/**
       * This method is like `_.flow` except that it creates a function that
       * invokes the given functions from right to left.
       *
       * @static
       * @since 3.0.0
       * @memberOf _
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flow
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flowRight([square, _.add]);
       * addSquare(1, 2);
       * // => 9
       */var flowRight=createFlow(true);/**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */function identity(value){return value;}/**
       * Creates a function that invokes `func` with the arguments of the created
       * function. If `func` is a property name, the created function returns the
       * property value for a given element. If `func` is an array or object, the
       * created function returns `true` for elements that contain the equivalent
       * source properties, otherwise it returns `false`.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Util
       * @param {*} [func=_.identity] The value to convert to a callback.
       * @returns {Function} Returns the callback.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
       * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, _.iteratee(['user', 'fred']));
       * // => [{ 'user': 'fred', 'age': 40 }]
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, _.iteratee('user'));
       * // => ['barney', 'fred']
       *
       * // Create custom iteratee shorthands.
       * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
       *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
       *     return func.test(string);
       *   };
       * });
       *
       * _.filter(['abc', 'def'], /ef/);
       * // => ['def']
       */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
       * Creates a function that performs a partial deep comparison between a given
       * object and `source`, returning `true` if the given object has equivalent
       * property values, else `false`.
       *
       * **Note:** The created function is equivalent to `_.isMatch` with `source`
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
       * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
       * Creates a function that performs a partial deep comparison between the
       * value at `path` of a given object to `srcValue`, returning `true` if the
       * object value is equivalent, else `false`.
       *
       * **Note:** Partial comparisons will match empty array and empty object
       * `srcValue` values against any array or object value, respectively. See
       * `_.isEqual` for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.find(objects, _.matchesProperty('a', 4));
       * // => { 'a': 4, 'b': 5, 'c': 6 }
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
       * Creates a function that invokes the method at `path` of a given object.
       * Any additional arguments are provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': _.constant(2) } },
       *   { 'a': { 'b': _.constant(1) } }
       * ];
       *
       * _.map(objects, _.method('a.b'));
       * // => [2, 1]
       *
       * _.map(objects, _.method(['a', 'b']));
       * // => [2, 1]
       */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
       * The opposite of `_.method`; this method creates a function that invokes
       * the method at a given path of `object`. Any additional arguments are
       * provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Object} object The object to query.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var array = _.times(3, _.constant),
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.methodOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
       * // => [2, 0]
       */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
       * Adds all own enumerable string keyed function properties of a source
       * object to the destination object. If `object` is a function, then methods
       * are added to its prototype as well.
       *
       * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
       * avoid conflicts caused by modifying the original.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Function|Object} [object=lodash] The destination object.
       * @param {Object} source The object of functions to add.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
       * @returns {Function|Object} Returns `object`.
       * @example
       *
       * function vowels(string) {
       *   return _.filter(string, function(v) {
       *     return /[aeiou]/i.test(v);
       *   });
       * }
       *
       * _.mixin({ 'vowels': vowels });
       * _.vowels('fred');
       * // => ['e']
       *
       * _('fred').vowels().value();
       * // => ['e']
       *
       * _.mixin({ 'vowels': vowels }, { 'chain': false });
       * _('fred').vowels();
       * // => ['e']
       */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
       * Reverts the `_` variable to its previous value and returns a reference to
       * the `lodash` function.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @returns {Function} Returns the `lodash` function.
       * @example
       *
       * var lodash = _.noConflict();
       */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
       * This method returns `undefined`.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Util
       * @example
       *
       * _.times(2, _.noop);
       * // => [undefined, undefined]
       */function noop(){// No operation performed.
  }/**
       * Creates a function that gets the argument at index `n`. If `n` is negative,
       * the nth argument from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [n=0] The index of the argument to return.
       * @returns {Function} Returns the new pass-thru function.
       * @example
       *
       * var func = _.nthArg(1);
       * func('a', 'b', 'c', 'd');
       * // => 'b'
       *
       * var func = _.nthArg(-2);
       * func('a', 'b', 'c', 'd');
       * // => 'c'
       */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
       * Creates a function that invokes `iteratees` with the arguments it receives
       * and returns their results.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to invoke.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.over([Math.max, Math.min]);
       *
       * func(1, 2, 3, 4);
       * // => [4, 1]
       */var over=createOver(arrayMap);/**
       * Creates a function that checks if **all** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overEvery([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => false
       *
       * func(NaN);
       * // => false
       */var overEvery=createOver(arrayEvery);/**
       * Creates a function that checks if **any** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overSome([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => true
       *
       * func(NaN);
       * // => false
       *
       * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
       * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
       */var overSome=createOver(arraySome);/**
       * Creates a function that returns the value at `path` of a given object.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': 2 } },
       *   { 'a': { 'b': 1 } }
       * ];
       *
       * _.map(objects, _.property('a.b'));
       * // => [2, 1]
       *
       * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
       * // => [1, 2]
       */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
       * The opposite of `_.property`; this method creates a function that returns
       * the value at a given path of `object`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var array = [0, 1, 2],
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
       * // => [2, 0]
       */function propertyOf(object){return function(path){return object==null?undefined$1:baseGet(object,path);};}/**
       * Creates an array of numbers (positive and/or negative) progressing from
       * `start` up to, but not including, `end`. A step of `-1` is used if a negative
       * `start` is specified without an `end` or `step`. If `end` is not specified,
       * it's set to `start` with `start` then set to `0`.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.rangeRight
       * @example
       *
       * _.range(4);
       * // => [0, 1, 2, 3]
       *
       * _.range(-4);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 5);
       * // => [1, 2, 3, 4]
       *
       * _.range(0, 20, 5);
       * // => [0, 5, 10, 15]
       *
       * _.range(0, -4, -1);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.range(0);
       * // => []
       */var range=createRange();/**
       * This method is like `_.range` except that it populates values in
       * descending order.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.range
       * @example
       *
       * _.rangeRight(4);
       * // => [3, 2, 1, 0]
       *
       * _.rangeRight(-4);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 5);
       * // => [4, 3, 2, 1]
       *
       * _.rangeRight(0, 20, 5);
       * // => [15, 10, 5, 0]
       *
       * _.rangeRight(0, -4, -1);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.rangeRight(0);
       * // => []
       */var rangeRight=createRange(true);/**
       * This method returns a new empty array.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Array} Returns the new empty array.
       * @example
       *
       * var arrays = _.times(2, _.stubArray);
       *
       * console.log(arrays);
       * // => [[], []]
       *
       * console.log(arrays[0] === arrays[1]);
       * // => false
       */function stubArray(){return [];}/**
       * This method returns `false`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `false`.
       * @example
       *
       * _.times(2, _.stubFalse);
       * // => [false, false]
       */function stubFalse(){return false;}/**
       * This method returns a new empty object.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Object} Returns the new empty object.
       * @example
       *
       * var objects = _.times(2, _.stubObject);
       *
       * console.log(objects);
       * // => [{}, {}]
       *
       * console.log(objects[0] === objects[1]);
       * // => false
       */function stubObject(){return {};}/**
       * This method returns an empty string.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {string} Returns the empty string.
       * @example
       *
       * _.times(2, _.stubString);
       * // => ['', '']
       */function stubString(){return '';}/**
       * This method returns `true`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `true`.
       * @example
       *
       * _.times(2, _.stubTrue);
       * // => [true, true]
       */function stubTrue(){return true;}/**
       * Invokes the iteratee `n` times, returning an array of the results of
       * each invocation. The iteratee is invoked with one argument; (index).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.times(3, String);
       * // => ['0', '1', '2']
       *
       *  _.times(4, _.constant(0));
       * // => [0, 0, 0, 0]
       */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return [];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
       * Converts `value` to a property path array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {*} value The value to convert.
       * @returns {Array} Returns the new property path array.
       * @example
       *
       * _.toPath('a.b.c');
       * // => ['a', 'b', 'c']
       *
       * _.toPath('a[0].b.c');
       * // => ['a', '0', 'b', 'c']
       */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
       * Generates a unique ID. If `prefix` is given, the ID is appended to it.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {string} [prefix=''] The value to prefix the ID with.
       * @returns {string} Returns the unique ID.
       * @example
       *
       * _.uniqueId('contact_');
       * // => 'contact_104'
       *
       * _.uniqueId();
       * // => '105'
       */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
       * Adds two numbers.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {number} augend The first number in an addition.
       * @param {number} addend The second number in an addition.
       * @returns {number} Returns the total.
       * @example
       *
       * _.add(6, 4);
       * // => 10
       */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
       * Computes `number` rounded up to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round up.
       * @param {number} [precision=0] The precision to round up to.
       * @returns {number} Returns the rounded up number.
       * @example
       *
       * _.ceil(4.006);
       * // => 5
       *
       * _.ceil(6.004, 2);
       * // => 6.01
       *
       * _.ceil(6040, -2);
       * // => 6100
       */var ceil=createRound('ceil');/**
       * Divide two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} dividend The first number in a division.
       * @param {number} divisor The second number in a division.
       * @returns {number} Returns the quotient.
       * @example
       *
       * _.divide(6, 4);
       * // => 1.5
       */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
       * Computes `number` rounded down to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round down.
       * @param {number} [precision=0] The precision to round down to.
       * @returns {number} Returns the rounded down number.
       * @example
       *
       * _.floor(4.006);
       * // => 4
       *
       * _.floor(0.046, 2);
       * // => 0.04
       *
       * _.floor(4060, -2);
       * // => 4000
       */var floor=createRound('floor');/**
       * Computes the maximum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * _.max([4, 2, 8, 6]);
       * // => 8
       *
       * _.max([]);
       * // => undefined
       */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined$1;}/**
       * This method is like `_.max` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.maxBy(objects, function(o) { return o.n; });
       * // => { 'n': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.maxBy(objects, 'n');
       * // => { 'n': 2 }
       */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined$1;}/**
       * Computes the mean of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the mean.
       * @example
       *
       * _.mean([4, 2, 8, 6]);
       * // => 5
       */function mean(array){return baseMean(array,identity);}/**
       * This method is like `_.mean` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be averaged.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the mean.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.meanBy(objects, function(o) { return o.n; });
       * // => 5
       *
       * // The `_.property` iteratee shorthand.
       * _.meanBy(objects, 'n');
       * // => 5
       */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
       * Computes the minimum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * _.min([4, 2, 8, 6]);
       * // => 2
       *
       * _.min([]);
       * // => undefined
       */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined$1;}/**
       * This method is like `_.min` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.minBy(objects, function(o) { return o.n; });
       * // => { 'n': 1 }
       *
       * // The `_.property` iteratee shorthand.
       * _.minBy(objects, 'n');
       * // => { 'n': 1 }
       */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined$1;}/**
       * Multiply two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} multiplier The first number in a multiplication.
       * @param {number} multiplicand The second number in a multiplication.
       * @returns {number} Returns the product.
       * @example
       *
       * _.multiply(6, 4);
       * // => 24
       */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
       * Computes `number` rounded to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round.
       * @param {number} [precision=0] The precision to round to.
       * @returns {number} Returns the rounded number.
       * @example
       *
       * _.round(4.006);
       * // => 4
       *
       * _.round(4.006, 2);
       * // => 4.01
       *
       * _.round(4060, -2);
       * // => 4100
       */var round=createRound('round');/**
       * Subtract two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {number} minuend The first number in a subtraction.
       * @param {number} subtrahend The second number in a subtraction.
       * @returns {number} Returns the difference.
       * @example
       *
       * _.subtract(6, 4);
       * // => 2
       */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
       * Computes the sum of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the sum.
       * @example
       *
       * _.sum([4, 2, 8, 6]);
       * // => 20
       */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
       * This method is like `_.sum` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be summed.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the sum.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.sumBy(objects, function(o) { return o.n; });
       * // => 20
       *
       * // The `_.property` iteratee shorthand.
       * _.sumBy(objects, 'n');
       * // => 20
       */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
  lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
  lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
  mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
  lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
  lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
       * The semantic version number.
       *
       * @static
       * @memberOf _
       * @type {string}
       */lodash.VERSION=VERSION;// Assign default placeholders.
  arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
  arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined$1?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else {result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
  arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
  arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
  arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined$1){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
  baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
  isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
  arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
  baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined$1,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined$1}];// Add methods to `LazyWrapper`.
  LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
  lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
  lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
  var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
  if(freeModule){// Export for Node.js.
  (freeModule.exports=_)._=_;// Export for CommonJS support.
  freeExports._=_;}else {// Export to the global object.
  root._=_;}}).call(commonjsGlobal);});

  function attributeToString(attribute) {
    if (typeof attribute !== 'string') {
      attribute += '';

      if (attribute === 'undefined') {
        attribute = '';
      }
    }

    return attribute.trim();
  }
  function toggleClass(elem, className) {
    elem.classList.toggle(className);
  }
  function removeClass(elem) {
    var _elem$classList;

    for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      classNames[_key - 1] = arguments[_key];
    }

    (_elem$classList = elem.classList).remove.apply(_elem$classList, classNames);

    return elem;
  }

  var instance = axios$1.create({
    headers: {
      'X-Requested-With': 'XMLHttpRequest'
    }
  });

  var ajaxTemplateFunc = function ajaxTemplateFunc(url) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'get';
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var encoded = encodeURI(url);
    var request;

    if (method === 'get') {
      if (lodash.isEmpty(data)) {
        request = instance.get(encoded);
      } else {
        request = instance.get(encoded, data);
      }
    } else if (lodash.isEmpty(data) && !(data instanceof FormData)) {
      request = instance.post(encoded);
    } else {
      request = instance.post(encoded, data);
    }

    return request.then(function (response) {
      return response.data;
    })["catch"](function (error) {
      return error.response.data;
    });
  }; // todo: urlencode


  var getCart = function getCart() {
    return ajaxTemplateFunc('/cart.js');
  };
  var getProduct = function getProduct(handle) {
    return ajaxTemplateFunc("/products/".concat(handle, ".js"));
  };
  var clearCart = function clearCart() {
    return ajaxTemplateFunc('/cart/clear.js', 'post');
  };
  var updateCartFromForm = function updateCartFromForm(form) {
    return ajaxTemplateFunc('/cart/update.js', 'post', new FormData(form));
  };
  var changeItemByKeyOrId = function changeItemByKeyOrId(id, quantity) {
    return ajaxTemplateFunc('/cart/change.js', 'post', {
      quantity: quantity,
      id: id
    });
  };
  var removeItemByKeyOrId = function removeItemByKeyOrId(id) {
    return ajaxTemplateFunc('/cart/change.js', 'post', {
      quantity: 0,
      id: id
    });
  };
  var changeItemByLine = function changeItemByLine(line, quantity, properties) {
    return ajaxTemplateFunc('/cart/change.js', 'post', {
      quantity: quantity,
      line: line,
      properties: properties
    });
  };
  var removeItemByLine = function removeItemByLine(line) {
    return ajaxTemplateFunc('/cart/change.js', 'post', {
      quantity: 0,
      line: line
    });
  };
  var addItem = function addItem(id, quantity) {
    var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return ajaxTemplateFunc('/cart/add.js', 'post', {
      id: id,
      quantity: quantity,
      properties: properties
    });
  };
  var addItemFromForm = function addItemFromForm(form) {
    return ajaxTemplateFunc('/cart/add.js', 'post', new FormData(form));
  };
  var updateCartAttributes = function updateCartAttributes(attributes) {
    var data = '';

    if (Array.isArray(attributes)) {
      attributes.forEach(function (attribute) {
        var key = attributeToString(attribute.key);

        if (key !== '') {
          data += "attributes[".concat(key, "]=").concat(attributeToString(attribute.value), "&");
        }
      });
    } else if (_typeof(attributes) === 'object' && attributes !== null) {
      Object.keys(attributes).forEach(function (key) {
        var value = attributes[key];
        data += "attributes[".concat(attributeToString(key), "]=").concat(attributeToString(value), "&");
      });
    }

    return ajaxTemplateFunc('/cart/update.js', 'post', data);
  };
  var updateCartNote = function updateCartNote(note) {
    return ajaxTemplateFunc('/cart/update.js', 'post', "note=".concat(attributeToString(note)));
  };
  var getRecommendedProducts = function getRecommendedProducts(productId) {
    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    return ajaxTemplateFunc("/recommendations/products.json?product_id=".concat(productId, "&limit=").concat(limit && parseInt(limit, 10) > 0 && parseInt(limit, 10) <= 10 ? parseInt(limit, 10) : 10));
  };
  var getPredictiveSearchResults = function getPredictiveSearchResults(q) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['product', 'page', 'article', 'collection'];
    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    var unavailableProducts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'last';
    var fields = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['title', 'product_type', 'variants.title', 'vendor'];
    var paramsString = '';
    paramsString += "q=".concat(q);
    paramsString += "&resources[type]=".concat(type.join(','));
    paramsString += "&resources[limit]=".concat(limit);
    paramsString += "&resources[options][unavailable_products]=".concat(unavailableProducts);
    paramsString += "&resources[options][fields]=".concat(fields.join(','));
    return ajaxTemplateFunc("/search/suggest.json?".concat(paramsString));
  };
  var apis = {
    getCart: getCart,
    getProduct: getProduct,
    clearCart: clearCart,
    updateCartFromForm: updateCartFromForm,
    changeItemByKeyOrId: changeItemByKeyOrId,
    removeItemByKeyOrId: removeItemByKeyOrId,
    changeItemByLine: changeItemByLine,
    removeItemByLine: removeItemByLine,
    addItem: addItem,
    addItemFromForm: addItemFromForm,
    updateCartAttributes: updateCartAttributes,
    updateCartNote: updateCartNote,
    getRecommendedProducts: getRecommendedProducts,
    getPredictiveSearchResults: getPredictiveSearchResults
  };

  var glider = createCommonjsModule(function (module, exports) {
    /* @preserve
        _____ __ _     __                _
       / ___// /(_)___/ /___  ____      (_)___
      / (_ // // // _  // -_)/ __/_    / /(_-<
      \___//_//_/ \_,_/ \__//_/  (_)__/ //___/
                                  |___/
    
      Version: 1.7.3
      Author: Nick Piscitelli (pickykneee)
      Website: https://nickpiscitelli.com
      Documentation: http://nickpiscitelli.github.io/Glider.js
      License: MIT License
      Release Date: October 25th, 2018
    
    */

    /* global define */
    (function (factory) {
        module.exports = factory() ;
    })(function () {

      /* globals window:true */


      var _window = typeof window !== 'undefined' ? window : this;

      var Glider = _window.Glider = function (element, settings) {
        var _ = this;

        if (element._glider) return element._glider;
        _.ele = element;

        _.ele.classList.add('glider'); // expose glider object to its DOM element


        _.ele._glider = _; // merge user setting with defaults

        _.opt = Object.assign({}, {
          slidesToScroll: 1,
          slidesToShow: 1,
          resizeLock: true,
          duration: 0.5,
          // easeInQuad
          easing: function easing(x, t, b, c, d) {
            return c * (t /= d) * t + b;
          }
        }, settings); // set defaults

        _.animate_id = _.page = _.slide = 0;
        _.arrows = {}; // preserve original options to
        // extend breakpoint settings

        _._opt = _.opt;

        if (_.opt.skipTrack) {
          // first and only child is the track
          _.track = _.ele.children[0];
        } else {
          // create track and wrap slides
          _.track = document.createElement('div');

          _.ele.appendChild(_.track);

          while (_.ele.children.length !== 1) {
            _.track.appendChild(_.ele.children[0]);
          }
        }

        _.track.classList.add('glider-track'); // start glider


        _.init(); // set events


        _.resize = _.init.bind(_, true);

        _.event(_.ele, 'add', {
          scroll: _.updateControls.bind(_)
        });

        _.event(_window, 'add', {
          resize: _.resize
        });
      };

      var gliderPrototype = Glider.prototype;

      gliderPrototype.init = function (refresh, paging) {
        var _ = this;

        var width = 0;
        var height = 0;
        _.slides = _.track.children;
        [].forEach.call(_.slides, function (_) {
          _.classList.add('glider-slide');
        });
        _.containerWidth = _.ele.clientWidth;

        var breakpointChanged = _.settingsBreakpoint();

        if (!paging) paging = breakpointChanged;

        if (_.opt.slidesToShow === 'auto' || typeof _.opt._autoSlide !== 'undefined') {
          var slideCount = _.containerWidth / _.opt.itemWidth;
          _.opt._autoSlide = _.opt.slidesToShow = _.opt.exactWidth ? slideCount : Math.floor(slideCount);
        }

        if (_.opt.slidesToScroll === 'auto') {
          _.opt.slidesToScroll = Math.floor(_.opt.slidesToShow);
        }

        _.itemWidth = _.opt.exactWidth ? _.opt.itemWidth : _.containerWidth / _.opt.slidesToShow; // set slide dimensions

        [].forEach.call(_.slides, function (__) {
          __.style.height = 'auto';
          __.style.width = _.itemWidth + 'px';
          width += _.itemWidth;
          height = Math.max(__.offsetHeight, height);
        });
        _.track.style.width = width + 'px';
        _.trackWidth = width;
        _.isDrag = false;
        _.preventClick = false;
        _.opt.resizeLock && _.scrollTo(_.slide * _.itemWidth, 0);

        if (breakpointChanged || paging) {
          _.bindArrows();

          _.buildDots();

          _.bindDrag();
        }

        _.updateControls();

        _.emit(refresh ? 'refresh' : 'loaded');
      };

      gliderPrototype.bindDrag = function () {
        var _ = this;

        _.mouse = _.mouse || _.handleMouse.bind(_);

        var mouseup = function mouseup() {
          _.mouseDown = undefined;

          _.ele.classList.remove('drag');

          if (_.isDrag) {
            _.preventClick = true;
          }

          _.isDrag = false;
        };

        var events = {
          mouseup: mouseup,
          mouseleave: mouseup,
          mousedown: function mousedown(e) {
            e.preventDefault();
            e.stopPropagation();
            _.mouseDown = e.clientX;

            _.ele.classList.add('drag');
          },
          mousemove: _.mouse,
          click: function click(e) {
            if (_.preventClick) {
              e.preventDefault();
              e.stopPropagation();
            }

            _.preventClick = false;
          }
        };

        _.ele.classList.toggle('draggable', _.opt.draggable === true);

        _.event(_.ele, 'remove', events);

        if (_.opt.draggable) _.event(_.ele, 'add', events);
      };

      gliderPrototype.buildDots = function () {
        var _ = this;

        if (!_.opt.dots) {
          if (_.dots) _.dots.innerHTML = '';
          return;
        }

        if (typeof _.opt.dots === 'string') {
          _.dots = document.querySelector(_.opt.dots);
        } else _.dots = _.opt.dots;

        if (!_.dots) return;
        _.dots.innerHTML = '';

        _.dots.classList.add('glider-dots');

        for (var i = 0; i < Math.ceil(_.slides.length / _.opt.slidesToShow); ++i) {
          var dot = document.createElement('button');
          dot.dataset.index = i;
          dot.setAttribute('aria-label', 'Page ' + (i + 1));
          dot.className = 'glider-dot ' + (i ? '' : 'active');

          _.event(dot, 'add', {
            click: _.scrollItem.bind(_, i, true)
          });

          _.dots.appendChild(dot);
        }
      };

      gliderPrototype.bindArrows = function () {
        var _ = this;

        if (!_.opt.arrows) {
          Object.keys(_.arrows).forEach(function (direction) {
            var element = _.arrows[direction];

            _.event(element, 'remove', {
              click: element._func
            });
          });
          return;
        }

        ['prev', 'next'].forEach(function (direction) {
          var arrow = _.opt.arrows[direction];

          if (arrow) {
            if (typeof arrow === 'string') arrow = document.querySelector(arrow);
            arrow._func = arrow._func || _.scrollItem.bind(_, direction);

            _.event(arrow, 'remove', {
              click: arrow._func
            });

            _.event(arrow, 'add', {
              click: arrow._func
            });

            _.arrows[direction] = arrow;
          }
        });
      };

      gliderPrototype.updateControls = function (event) {
        var _ = this;

        if (event && !_.opt.scrollPropagate) {
          event.stopPropagation();
        }

        var disableArrows = _.containerWidth >= _.trackWidth;

        if (!_.opt.rewind) {
          if (_.arrows.prev) {
            _.arrows.prev.classList.toggle('disabled', _.ele.scrollLeft <= 0 || disableArrows);
          }

          if (_.arrows.next) {
            _.arrows.next.classList.toggle('disabled', Math.ceil(_.ele.scrollLeft + _.containerWidth) >= Math.floor(_.trackWidth) || disableArrows);
          }
        }

        _.slide = Math.round(_.ele.scrollLeft / _.itemWidth);
        _.page = Math.round(_.ele.scrollLeft / _.containerWidth);
        var middle = _.slide + Math.floor(Math.floor(_.opt.slidesToShow) / 2);
        var extraMiddle = Math.floor(_.opt.slidesToShow) % 2 ? 0 : middle + 1;

        if (Math.floor(_.opt.slidesToShow) === 1) {
          extraMiddle = 0;
        } // the last page may be less than one half of a normal page width so
        // the page is rounded down. when at the end, force the page to turn


        if (_.ele.scrollLeft + _.containerWidth >= Math.floor(_.trackWidth)) {
          _.page = _.dots ? _.dots.children.length - 1 : 0;
        }

        [].forEach.call(_.slides, function (slide, index) {
          var slideClasses = slide.classList;
          var wasVisible = slideClasses.contains('visible');
          var start = _.ele.scrollLeft;
          var end = _.ele.scrollLeft + _.containerWidth;
          var itemStart = _.itemWidth * index;
          var itemEnd = itemStart + _.itemWidth;
          [].forEach.call(slideClasses, function (className) {
            /^left|right/.test(className) && slideClasses.remove(className);
          });
          slideClasses.toggle('active', _.slide === index);

          if (middle === index || extraMiddle && extraMiddle === index) {
            slideClasses.add('center');
          } else {
            slideClasses.remove('center');
            slideClasses.add([index < middle ? 'left' : 'right', Math.abs(index - (index < middle ? middle : extraMiddle || middle))].join('-'));
          }

          var isVisible = Math.ceil(itemStart) >= start && Math.floor(itemEnd) <= end;
          slideClasses.toggle('visible', isVisible);

          if (isVisible !== wasVisible) {
            _.emit('slide-' + (isVisible ? 'visible' : 'hidden'), {
              slide: index
            });
          }
        });

        if (_.dots) {
          [].forEach.call(_.dots.children, function (dot, index) {
            dot.classList.toggle('active', _.page === index);
          });
        }

        if (event && _.opt.scrollLock) {
          clearTimeout(_.scrollLock);
          _.scrollLock = setTimeout(function () {
            clearTimeout(_.scrollLock); // dont attempt to scroll less than a pixel fraction - causes looping

            if (Math.abs(_.ele.scrollLeft / _.itemWidth - _.slide) > 0.02) {
              if (!_.mouseDown) {
                _.scrollItem(_.round(_.ele.scrollLeft / _.itemWidth));
              }
            }
          }, _.opt.scrollLockDelay || 250);
        }
      };

      gliderPrototype.scrollItem = function (slide, dot, e) {
        if (e) e.preventDefault();

        var _ = this;

        var originalSlide = slide;
        ++_.animate_id;

        if (dot === true) {
          slide = slide * _.containerWidth;
          slide = Math.round(slide / _.itemWidth) * _.itemWidth;
        } else {
          if (typeof slide === 'string') {
            var backwards = slide === 'prev'; // use precise location if fractional slides are on

            if (_.opt.slidesToScroll % 1 || _.opt.slidesToShow % 1) {
              slide = _.round(_.ele.scrollLeft / _.itemWidth);
            } else {
              slide = _.slide;
            }

            if (backwards) slide -= _.opt.slidesToScroll;else slide += _.opt.slidesToScroll;

            if (_.opt.rewind) {
              var scrollLeft = _.ele.scrollLeft;
              slide = backwards && !scrollLeft ? _.slides.length : !backwards && scrollLeft + _.containerWidth >= Math.floor(_.trackWidth) ? 0 : slide;
            }
          }

          slide = Math.max(Math.min(slide, _.slides.length), 0);
          _.slide = slide;
          slide = _.itemWidth * slide;
        }

        _.scrollTo(slide, _.opt.duration * Math.abs(_.ele.scrollLeft - slide), function () {
          _.updateControls();

          _.emit('animated', {
            value: originalSlide,
            type: typeof originalSlide === 'string' ? 'arrow' : dot ? 'dot' : 'slide'
          });
        });

        return false;
      };

      gliderPrototype.settingsBreakpoint = function () {
        var _ = this;

        var resp = _._opt.responsive;

        if (resp) {
          // Sort the breakpoints in mobile first order
          resp.sort(function (a, b) {
            return b.breakpoint - a.breakpoint;
          });

          for (var i = 0; i < resp.length; ++i) {
            var size = resp[i];

            if (_window.innerWidth >= size.breakpoint) {
              if (_.breakpoint !== size.breakpoint) {
                _.opt = Object.assign({}, _._opt, size.settings);
                _.breakpoint = size.breakpoint;
                return true;
              }

              return false;
            }
          }
        } // set back to defaults in case they were overriden


        var breakpointChanged = _.breakpoint !== 0;
        _.opt = Object.assign({}, _._opt);
        _.breakpoint = 0;
        return breakpointChanged;
      };

      gliderPrototype.scrollTo = function (scrollTarget, scrollDuration, callback) {
        var _ = this;

        var start = new Date().getTime();
        var animateIndex = _.animate_id;

        var animate = function animate() {
          var now = new Date().getTime() - start;
          _.ele.scrollLeft = _.ele.scrollLeft + (scrollTarget - _.ele.scrollLeft) * _.opt.easing(0, now, 0, 1, scrollDuration);

          if (now < scrollDuration && animateIndex === _.animate_id) {
            _window.requestAnimationFrame(animate);
          } else {
            _.ele.scrollLeft = scrollTarget;
            callback && callback.call(_);
          }
        };

        _window.requestAnimationFrame(animate);
      };

      gliderPrototype.removeItem = function (index) {
        var _ = this;

        if (_.slides.length) {
          _.track.removeChild(_.slides[index]);

          _.refresh(true);

          _.emit('remove');
        }
      };

      gliderPrototype.addItem = function (ele) {
        var _ = this;

        _.track.appendChild(ele);

        _.refresh(true);

        _.emit('add');
      };

      gliderPrototype.handleMouse = function (e) {
        var _ = this;

        if (_.mouseDown) {
          _.isDrag = true;
          _.ele.scrollLeft += (_.mouseDown - e.clientX) * (_.opt.dragVelocity || 3.3);
          _.mouseDown = e.clientX;
        }
      }; // used to round to the nearest 0.XX fraction


      gliderPrototype.round = function (_double) {
        var _ = this;

        var step = _.opt.slidesToScroll % 1 || 1;
        var inv = 1.0 / step;
        return Math.round(_double * inv) / inv;
      };

      gliderPrototype.refresh = function (paging) {
        var _ = this;

        _.init(true, paging);
      };

      gliderPrototype.setOption = function (opt, global) {
        var _ = this;

        if (_.breakpoint && !global) {
          _._opt.responsive.forEach(function (v) {
            if (v.breakpoint === _.breakpoint) {
              v.settings = Object.assign({}, v.settings, opt);
            }
          });
        } else {
          _._opt = Object.assign({}, _._opt, opt);
        }

        _.breakpoint = 0;

        _.settingsBreakpoint();
      };

      gliderPrototype.destroy = function () {
        var _ = this;

        var replace = _.ele.cloneNode(true);

        var clear = function clear(ele) {
          ele.removeAttribute('style');
          [].forEach.call(ele.classList, function (className) {
            /^glider/.test(className) && ele.classList.remove(className);
          });
        }; // remove track


        replace.children[0].outerHTML = replace.children[0].innerHTML;
        clear(replace);
        [].forEach.call(replace.getElementsByTagName('*'), clear);

        _.ele.parentNode.replaceChild(replace, _.ele);

        _.event(_window, 'remove', {
          resize: _.resize
        });

        _.emit('destroy');
      };

      gliderPrototype.emit = function (name, arg) {
        var _ = this;

        var e = new _window.CustomEvent('glider-' + name, {
          bubbles: !_.opt.eventPropagate,
          detail: arg
        });

        _.ele.dispatchEvent(e);
      };

      gliderPrototype.event = function (ele, type, args) {
        var eventHandler = ele[type + 'EventListener'].bind(ele);
        Object.keys(args).forEach(function (k) {
          eventHandler(k, args[k]);
        });
      };

      return Glider;
    });
  });

  window.addEventListener('load', function setupTestimonialSlider() {
    if (document.querySelector('.glider')) {
      // eslint-disable-next-line no-new
      new glider(document.querySelector('.glider'), {
        // Mobile-first defaults
        slidesToShow: 1,
        slidesToScroll: 1,
        scrollLock: true,
        dots: '#resp-dots',
        draggable: true,
        arrows: {
          prev: '.glider-prev',
          next: '.glider-next'
        },
        responsive: [{
          // screens greater than >= 775px
          breakpoint: 0,
          settings: {
            // Set to `auto` and provide item width to adjust to viewport
            slidesToShow: 1,
            slidesToScroll: 1,
            itemWidth: 300,
            duration: 1
          }
        }, {
          // screens greater than >= 1024px
          breakpoint: 540,
          settings: {
            slidesToShow: 'auto',
            slidesToScroll: 'auto',
            itemWidth: 300,
            duration: 1
          }
        }]
      });
    }
  });

  document.addEventListener('click', function (event) {
    var target = event.target;

    if (target.closest('.dropdown-menu')) {
      event.stopPropagation();
    } // class="navbar-toggler" data-trigger="#navbar_main"


    if (target.closest('.navbar-toggler[data-trigger]')) {
      event.preventDefault();
      event.stopPropagation();
      var offcanvasId = target.closest('.navbar-toggler[data-trigger]').getAttribute('data-trigger');
      var offcanvas = document.querySelector(offcanvasId);

      if (offcanvas) {
        toggleClass(offcanvas, 'show');
      }

      toggleClass(document.body, 'offcanvas-active');
      var screenOverlay = document.querySelector('.screen-overlay');

      if (screenOverlay) {
        toggleClass(screenOverlay, 'show');
      }
    }

    if (target.closest('.btn-close, .screen-overlay')) {
      var _screenOverlay = document.querySelector('.screen-overlay');

      if (_screenOverlay) {
        removeClass(_screenOverlay, 'show');
      }

      var mobileOffcanvas = document.querySelector('.mobile-offcanvas');

      if (mobileOffcanvas) {
        removeClass(mobileOffcanvas, 'show');
      }

      removeClass(document.body, 'offcanvas-active');
    }
  });

  var macy = createCommonjsModule(function (module, exports) {
    !function (t, n) {
       module.exports = n() ;
    }(commonjsGlobal, function () {

      function t(t, n) {
        var e = void 0;
        return function () {
          e && clearTimeout(e), e = setTimeout(t, n);
        };
      }

      function n(t, n) {
        for (var e = t.length, r = e, o = []; e--;) {
          o.push(n(t[r - e - 1]));
        }

        return o;
      }

      function e(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (window.Promise) return A(t, n, e);
        t.recalculate(!0, !0);
      }

      function r(t) {
        for (var n = t.options, e = t.responsiveOptions, r = t.keys, o = t.docWidth, i = void 0, s = 0; s < r.length; s++) {
          var a = parseInt(r[s], 10);
          o >= a && (i = n.breakAt[a], O(i, e));
        }

        return e;
      }

      function o(t) {
        for (var n = t.options, e = t.responsiveOptions, r = t.keys, o = t.docWidth, i = void 0, s = r.length - 1; s >= 0; s--) {
          var a = parseInt(r[s], 10);
          o <= a && (i = n.breakAt[a], O(i, e));
        }

        return e;
      }

      function i(t) {
        var n = t.useContainerForBreakpoints ? t.container.clientWidth : window.innerWidth,
            e = {
          columns: t.columns
        };
        b(t.margin) ? e.margin = {
          x: t.margin.x,
          y: t.margin.y
        } : e.margin = {
          x: t.margin,
          y: t.margin
        };
        var i = Object.keys(t.breakAt);
        return t.mobileFirst ? r({
          options: t,
          responsiveOptions: e,
          keys: i,
          docWidth: n
        }) : o({
          options: t,
          responsiveOptions: e,
          keys: i,
          docWidth: n
        });
      }

      function s(t) {
        return i(t).columns;
      }

      function a(t) {
        return i(t).margin;
      }

      function c(t) {
        var n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            e = s(t),
            r = a(t).x,
            o = 100 / e;
        if (!n) return o;
        if (1 === e) return "100%";
        var i = "px";

        if ("string" == typeof r) {
          var c = parseFloat(r);
          i = r.replace(c, ""), r = c;
        }

        return r = (e - 1) * r / e, "%" === i ? o - r + "%" : "calc(" + o + "% - " + r + i + ")";
      }

      function u(t, n) {
        var e = s(t.options),
            r = 0,
            o = void 0,
            i = void 0;
        if (1 === ++n) return 0;
        i = a(t.options).x;
        var u = "px";

        if ("string" == typeof i) {
          var l = parseFloat(i, 10);
          u = i.replace(l, ""), i = l;
        }

        return o = (i - (e - 1) * i / e) * (n - 1), r += c(t.options, !1) * (n - 1), "%" === u ? r + o + "%" : "calc(" + r + "% + " + o + u + ")";
      }

      function l(t) {
        var n = 0,
            e = t.container,
            r = t.rows;
        v(r, function (t) {
          n = t > n ? t : n;
        }), e.style.height = n + "px";
      }

      function p(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
            r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            o = s(t.options),
            i = a(t.options).y;
        M(t, o, e), v(n, function (n) {
          var e = 0,
              o = parseInt(n.offsetHeight, 10);
          isNaN(o) || (t.rows.forEach(function (n, r) {
            n < t.rows[e] && (e = r);
          }), n.style.position = "absolute", n.style.top = t.rows[e] + "px", n.style.left = "" + t.cols[e], t.rows[e] += isNaN(o) ? 0 : o + i, r && (n.dataset.macyComplete = 1));
        }), r && (t.tmpRows = null), l(t);
      }

      function f(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
            r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            o = s(t.options),
            i = a(t.options).y;
        M(t, o, e), v(n, function (n) {
          t.lastcol === o && (t.lastcol = 0);
          var e = C(n, "height");
          e = parseInt(n.offsetHeight, 10), isNaN(e) || (n.style.position = "absolute", n.style.top = t.rows[t.lastcol] + "px", n.style.left = "" + t.cols[t.lastcol], t.rows[t.lastcol] += isNaN(e) ? 0 : e + i, t.lastcol += 1, r && (n.dataset.macyComplete = 1));
        }), r && (t.tmpRows = null), l(t);
      }

      var h = function t(n, e) {
        if (!(this instanceof t)) return new t(n, e);
        if (n && n.nodeName) return n;
        if (n = n.replace(/^\s*/, "").replace(/\s*$/, ""), e) return this.byCss(n, e);

        for (var r in this.selectors) {
          if (e = r.split("/"), new RegExp(e[1], e[2]).test(n)) return this.selectors[r](n);
        }

        return this.byCss(n);
      };

      h.prototype.byCss = function (t, n) {
        return (n || document).querySelectorAll(t);
      }, h.prototype.selectors = {}, h.prototype.selectors[/^\.[\w\-]+$/] = function (t) {
        return document.getElementsByClassName(t.substring(1));
      }, h.prototype.selectors[/^\w+$/] = function (t) {
        return document.getElementsByTagName(t);
      }, h.prototype.selectors[/^\#[\w\-]+$/] = function (t) {
        return document.getElementById(t.substring(1));
      };

      var v = function v(t, n) {
        for (var e = t.length, r = e; e--;) {
          n(t[r - e - 1]);
        }
      },
          m = function m() {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        this.running = !1, this.events = [], this.add(t);
      };

      m.prototype.run = function () {
        if (!this.running && this.events.length > 0) {
          var t = this.events.shift();
          this.running = !0, t(), this.running = !1, this.run();
        }
      }, m.prototype.add = function () {
        var t = this,
            n = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return !!n && (Array.isArray(n) ? v(n, function (n) {
          return t.add(n);
        }) : (this.events.push(n), void this.run()));
      }, m.prototype.clear = function () {
        this.events = [];
      };

      var d = function d(t) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return this.instance = t, this.data = n, this;
      },
          y = function y() {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        this.events = {}, this.instance = t;
      };

      y.prototype.on = function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
            n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return !(!t || !n) && (Array.isArray(this.events[t]) || (this.events[t] = []), this.events[t].push(n));
      }, y.prototype.emit = function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!t || !Array.isArray(this.events[t])) return !1;
        var e = new d(this.instance, n);
        v(this.events[t], function (t) {
          return t(e);
        });
      };

      var g = function g(t) {
        return !("naturalHeight" in t && t.naturalHeight + t.naturalWidth === 0) || t.width + t.height !== 0;
      },
          E = function E(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return new Promise(function (t, e) {
          if (n.complete) return g(n) ? t(n) : e(n);
          n.addEventListener("load", function () {
            return g(n) ? t(n) : e(n);
          }), n.addEventListener("error", function () {
            return e(n);
          });
        }).then(function (n) {
          e && t.emit(t.constants.EVENT_IMAGE_LOAD, {
            img: n
          });
        })["catch"](function (n) {
          return t.emit(t.constants.EVENT_IMAGE_ERROR, {
            img: n
          });
        });
      },
          w = function w(t, e) {
        var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return n(e, function (n) {
          return E(t, n, r);
        });
      },
          A = function A(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return Promise.all(w(t, n, e)).then(function () {
          t.emit(t.constants.EVENT_IMAGE_COMPLETE);
        });
      },
          I = function I(n) {
        return t(function () {
          n.emit(n.constants.EVENT_RESIZE), n.queue.add(function () {
            return n.recalculate(!0, !0);
          });
        }, 100);
      },
          N = function N(t) {
        if (t.container = h(t.options.container), t.container instanceof h || !t.container) return !!t.options.debug && console.error("Error: Container not found");
        t.container.length && (t.container = t.container[0]), t.options.container = t.container, t.container.style.position = "relative";
      },
          T = function T(t) {
        t.queue = new m(), t.events = new y(t), t.rows = [], t.resizer = I(t);
      },
          L = function L(t) {
        var n = h("img", t.container);
        window.addEventListener("resize", t.resizer), t.on(t.constants.EVENT_IMAGE_LOAD, function () {
          return t.recalculate(!1, !1);
        }), t.on(t.constants.EVENT_IMAGE_COMPLETE, function () {
          return t.recalculate(!0, !0);
        }), t.options.useOwnImageLoader || e(t, n, !t.options.waitForImages), t.emit(t.constants.EVENT_INITIALIZED);
      },
          _ = function _(t) {
        N(t), T(t), L(t);
      },
          b = function b(t) {
        return t === Object(t) && "[object Array]" !== Object.prototype.toString.call(t);
      },
          O = function O(t, n) {
        b(t) || (n.columns = t), b(t) && t.columns && (n.columns = t.columns), b(t) && t.margin && !b(t.margin) && (n.margin = {
          x: t.margin,
          y: t.margin
        }), b(t) && t.margin && b(t.margin) && t.margin.x && (n.margin.x = t.margin.x), b(t) && t.margin && b(t.margin) && t.margin.y && (n.margin.y = t.margin.y);
      },
          C = function C(t, n) {
        return window.getComputedStyle(t, null).getPropertyValue(n);
      },
          M = function M(t, n) {
        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];

        if (t.lastcol || (t.lastcol = 0), t.rows.length < 1 && (e = !0), e) {
          t.rows = [], t.cols = [], t.lastcol = 0;

          for (var r = n - 1; r >= 0; r--) {
            t.rows[r] = 0, t.cols[r] = u(t, r);
          }
        } else if (t.tmpRows) {
          t.rows = [];

          for (var r = n - 1; r >= 0; r--) {
            t.rows[r] = t.tmpRows[r];
          }
        } else {
          t.tmpRows = [];

          for (var r = n - 1; r >= 0; r--) {
            t.tmpRows[r] = t.rows[r];
          }
        }
      },
          V = function V(t) {
        var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            e = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            r = n ? t.container.children : h(':scope > *:not([data-macy-complete="1"])', t.container);
        r = Array.from(r).filter(function (t) {
          return null !== t.offsetParent;
        });
        var o = c(t.options);
        return v(r, function (t) {
          n && (t.dataset.macyComplete = 0), t.style.width = o;
        }), t.options.trueOrder ? (f(t, r, n, e), t.emit(t.constants.EVENT_RECALCULATED)) : (p(t, r, n, e), t.emit(t.constants.EVENT_RECALCULATED));
      },
          R = function R() {
        return !!window.Promise;
      },
          x = Object.assign || function (t) {
        for (var n = 1; n < arguments.length; n++) {
          var e = arguments[n];

          for (var r in e) {
            Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
          }
        }

        return t;
      };

      Array.from || (Array.from = function (t) {
        for (var n = 0, e = []; n < t.length;) {
          e.push(t[n++]);
        }

        return e;
      });
      var k = {
        columns: 4,
        margin: 2,
        trueOrder: !1,
        waitForImages: !1,
        useImageLoader: !0,
        breakAt: {},
        useOwnImageLoader: !1,
        onInit: !1,
        cancelLegacy: !1,
        useContainerForBreakpoints: !1
      };
      !function () {
        try {
          document.createElement("a").querySelector(":scope *");
        } catch (t) {
          !function () {
            function t(t) {
              return function (e) {
                if (e && n.test(e)) {
                  var r = this.getAttribute("id");
                  r || (this.id = "q" + Math.floor(9e6 * Math.random()) + 1e6), arguments[0] = e.replace(n, "#" + this.id);
                  var o = t.apply(this, arguments);
                  return null === r ? this.removeAttribute("id") : r || (this.id = r), o;
                }

                return t.apply(this, arguments);
              };
            }

            var n = /:scope\b/gi,
                e = t(Element.prototype.querySelector);

            Element.prototype.querySelector = function (t) {
              return e.apply(this, arguments);
            };

            var r = t(Element.prototype.querySelectorAll);

            Element.prototype.querySelectorAll = function (t) {
              return r.apply(this, arguments);
            };
          }();
        }
      }();

      var q = function t() {
        var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k;
        if (!(this instanceof t)) return new t(n);
        this.options = {}, x(this.options, k, n), this.options.cancelLegacy && !R() || _(this);
      };

      return q.init = function (t) {
        return console.warn("Depreciated: Macy.init will be removed in v3.0.0 opt to use Macy directly like so Macy({ /*options here*/ }) "), new q(t);
      }, q.prototype.recalculateOnImageLoad = function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return e(this, h("img", this.container), !t);
      }, q.prototype.runOnImageLoad = function (t) {
        var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            r = h("img", this.container);
        return this.on(this.constants.EVENT_IMAGE_COMPLETE, t), n && this.on(this.constants.EVENT_IMAGE_LOAD, t), e(this, r, n);
      }, q.prototype.recalculate = function () {
        var t = this,
            n = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
            e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        return e && this.queue.clear(), this.queue.add(function () {
          return V(t, n, e);
        });
      }, q.prototype.remove = function () {
        window.removeEventListener("resize", this.resizer), v(this.container.children, function (t) {
          t.removeAttribute("data-macy-complete"), t.removeAttribute("style");
        }), this.container.removeAttribute("style");
      }, q.prototype.reInit = function () {
        this.recalculate(!0, !0), this.emit(this.constants.EVENT_INITIALIZED), window.addEventListener("resize", this.resizer), this.container.style.position = "relative";
      }, q.prototype.on = function (t, n) {
        this.events.on(t, n);
      }, q.prototype.emit = function (t, n) {
        this.events.emit(t, n);
      }, q.constants = {
        EVENT_INITIALIZED: "macy.initialized",
        EVENT_RECALCULATED: "macy.recalculated",
        EVENT_IMAGE_LOAD: "macy.image.load",
        EVENT_IMAGE_ERROR: "macy.image.error",
        EVENT_IMAGE_COMPLETE: "macy.images.complete",
        EVENT_RESIZE: "macy.resize"
      }, q.prototype.constants = q.constants, q;
    });
  });

  if (document.querySelector('.index-section--masonry .images-wrapper')) {
    macy({
      container: '.index-section--masonry .images-wrapper',
      columns: 3,
      breakAt: {
        520: 2,
        400: 1
      }
    });
  }

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var directives = new WeakMap();
  var isDirective = function isDirective(o) {
    return typeof o === 'function' && directives.has(o);
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * True if the custom elements polyfill is in use.
   */
  var isCEPolyfill = typeof window !== 'undefined' && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== undefined;
  /**
   * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
   * `container`.
   */

  var removeNodes = function removeNodes(container, start) {
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    while (start !== end) {
      var n = start.nextSibling;
      container.removeChild(start);
      start = n;
    }
  };

  /**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * A sentinel value that signals that a value was handled by a directive and
   * should not be written to the DOM.
   */
  var noChange = {};
  /**
   * A sentinel value that signals a NodePart to fully clear its content.
   */

  var nothing = {};

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * An expression marker with embedded unique key to avoid collision with
   * possible text in templates.
   */
  var marker = "{{lit-".concat(String(Math.random()).slice(2), "}}");
  /**
   * An expression marker used text-positions, multi-binding attributes, and
   * attributes with markup-like text values.
   */

  var nodeMarker = "<!--".concat(marker, "-->");
  var markerRegex = new RegExp("".concat(marker, "|").concat(nodeMarker));
  /**
   * Suffix appended to all bound attribute names.
   */

  var boundAttributeSuffix = '$lit$';
  /**
   * An updatable Template that tracks the location of dynamic parts.
   */

  var Template = function Template(result, element) {
    _classCallCheck(this, Template);

    this.parts = [];
    this.element = element;
    var nodesToRemove = [];
    var stack = []; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

    var walker = document.createTreeWalker(element.content, 133
    /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
    , null, false); // Keeps track of the last index associated with a part. We try to delete
    // unnecessary nodes, but we never want to associate two different parts
    // to the same index. They must have a constant node between.

    var lastPartIndex = 0;
    var index = -1;
    var partIndex = 0;
    var strings = result.strings,
        length = result.values.length;

    while (partIndex < length) {
      var node = walker.nextNode();

      if (node === null) {
        // We've exhausted the content inside a nested template element.
        // Because we still have parts (the outer for-loop), we know:
        // - There is a template in the stack
        // - The walker will find a nextNode outside the template
        walker.currentNode = stack.pop();
        continue;
      }

      index++;

      if (node.nodeType === 1
      /* Node.ELEMENT_NODE */
      ) {
          if (node.hasAttributes()) {
            var attributes = node.attributes;
            var _length = attributes.length; // Per
            // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
            // attributes are not guaranteed to be returned in document order.
            // In particular, Edge/IE can return them out of order, so we cannot
            // assume a correspondence between part index and attribute index.

            var count = 0;

            for (var i = 0; i < _length; i++) {
              if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                count++;
              }
            }

            while (count-- > 0) {
              // Get the template literal section leading up to the first
              // expression in this attribute
              var stringForPart = strings[partIndex]; // Find the attribute name

              var name = lastAttributeNameRegex.exec(stringForPart)[2]; // Find the corresponding attribute
              // All bound attributes have had a suffix added in
              // TemplateResult#getHTML to opt out of special attribute
              // handling. To look up the attribute value we also need to add
              // the suffix.

              var attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
              var attributeValue = node.getAttribute(attributeLookupName);
              node.removeAttribute(attributeLookupName);
              var statics = attributeValue.split(markerRegex);
              this.parts.push({
                type: 'attribute',
                index: index,
                name: name,
                strings: statics
              });
              partIndex += statics.length - 1;
            }
          }

          if (node.tagName === 'TEMPLATE') {
            stack.push(node);
            walker.currentNode = node.content;
          }
        } else if (node.nodeType === 3
      /* Node.TEXT_NODE */
      ) {
          var data = node.data;

          if (data.indexOf(marker) >= 0) {
            var parent = node.parentNode;

            var _strings = data.split(markerRegex);

            var lastIndex = _strings.length - 1; // Generate a new text node for each literal section
            // These nodes are also used as the markers for node parts

            for (var _i = 0; _i < lastIndex; _i++) {
              var insert = void 0;
              var s = _strings[_i];

              if (s === '') {
                insert = createMarker();
              } else {
                var match = lastAttributeNameRegex.exec(s);

                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                  s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                }

                insert = document.createTextNode(s);
              }

              parent.insertBefore(insert, node);
              this.parts.push({
                type: 'node',
                index: ++index
              });
            } // If there's no text, we must insert a comment to mark our place.
            // Else, we can trust it will stick around after cloning.


            if (_strings[lastIndex] === '') {
              parent.insertBefore(createMarker(), node);
              nodesToRemove.push(node);
            } else {
              node.data = _strings[lastIndex];
            } // We have a part for each match found


            partIndex += lastIndex;
          }
        } else if (node.nodeType === 8
      /* Node.COMMENT_NODE */
      ) {
          if (node.data === marker) {
            var _parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of
            // the following are true:
            //  * We don't have a previousSibling
            //  * The previousSibling is already the start of a previous part

            if (node.previousSibling === null || index === lastPartIndex) {
              index++;

              _parent.insertBefore(createMarker(), node);
            }

            lastPartIndex = index;
            this.parts.push({
              type: 'node',
              index: index
            }); // If we don't have a nextSibling, keep this node so we have an end.
            // Else, we can remove it to save future costs.

            if (node.nextSibling === null) {
              node.data = '';
            } else {
              nodesToRemove.push(node);
              index--;
            }

            partIndex++;
          } else {
            var _i2 = -1;

            while ((_i2 = node.data.indexOf(marker, _i2 + 1)) !== -1) {
              // Comment node has a binding marker inside, make an inactive part
              // The binding won't work, but subsequent bindings will
              // TODO (justinfagnani): consider whether it's even worth it to
              // make bindings in comments work
              this.parts.push({
                type: 'node',
                index: -1
              });
              partIndex++;
            }
          }
        }
    } // Remove text binding nodes after the walk to not disturb the TreeWalker


    for (var _i3 = 0, _nodesToRemove = nodesToRemove; _i3 < _nodesToRemove.length; _i3++) {
      var n = _nodesToRemove[_i3];
      n.parentNode.removeChild(n);
    }
  };

  var endsWith = function endsWith(str, suffix) {
    var index = str.length - suffix.length;
    return index >= 0 && str.slice(index) === suffix;
  };

  var isTemplatePartActive = function isTemplatePartActive(part) {
    return part.index !== -1;
  }; // Allows `document.createComment('')` to be renamed for a
  // small manual size-savings.

  var createMarker = function createMarker() {
    return document.createComment('');
  };
  /**
   * This regex extracts the attribute name preceding an attribute-position
   * expression. It does this by matching the syntax allowed for attributes
   * against the string literal directly preceding the expression, assuming that
   * the expression is in an attribute-value position.
   *
   * See attributes in the HTML spec:
   * https://www.w3.org/TR/html5/syntax.html#elements-attributes
   *
   * " \x09\x0a\x0c\x0d" are HTML space characters:
   * https://www.w3.org/TR/html5/infrastructure.html#space-characters
   *
   * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
   * space character except " ".
   *
   * So an attribute is:
   *  * The name: any character except a control character, space character, ('),
   *    ("), ">", "=", or "/"
   *  * Followed by zero or more space characters
   *  * Followed by "="
   *  * Followed by zero or more space characters
   *  * Followed by:
   *    * Any character except space, ('), ("), "<", ">", "=", (`), or
   *    * (") then any non-("), or
   *    * (') then any non-(')
   */

  var lastAttributeNameRegex = // eslint-disable-next-line no-control-regex
  /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

  /**
   * An instance of a `Template` that can be attached to the DOM and updated
   * with new values.
   */

  var TemplateInstance = /*#__PURE__*/function () {
    function TemplateInstance(template, processor, options) {
      _classCallCheck(this, TemplateInstance);

      this.__parts = [];
      this.template = template;
      this.processor = processor;
      this.options = options;
    }

    _createClass(TemplateInstance, [{
      key: "update",
      value: function update(values) {
        var i = 0;

        var _iterator = _createForOfIteratorHelper(this.__parts),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var part = _step.value;

            if (part !== undefined) {
              part.setValue(values[i]);
            }

            i++;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var _iterator2 = _createForOfIteratorHelper(this.__parts),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _part = _step2.value;

            if (_part !== undefined) {
              _part.commit();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "_clone",
      value: function _clone() {
        // There are a number of steps in the lifecycle of a template instance's
        // DOM fragment:
        //  1. Clone - create the instance fragment
        //  2. Adopt - adopt into the main document
        //  3. Process - find part markers and create parts
        //  4. Upgrade - upgrade custom elements
        //  5. Update - set node, attribute, property, etc., values
        //  6. Connect - connect to the document. Optional and outside of this
        //     method.
        //
        // We have a few constraints on the ordering of these steps:
        //  * We need to upgrade before updating, so that property values will pass
        //    through any property setters.
        //  * We would like to process before upgrading so that we're sure that the
        //    cloned fragment is inert and not disturbed by self-modifying DOM.
        //  * We want custom elements to upgrade even in disconnected fragments.
        //
        // Given these constraints, with full custom elements support we would
        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
        //
        // But Safari does not implement CustomElementRegistry#upgrade, so we
        // can not implement that order and still have upgrade-before-update and
        // upgrade disconnected fragments. So we instead sacrifice the
        // process-before-upgrade constraint, since in Custom Elements v1 elements
        // must not modify their light DOM in the constructor. We still have issues
        // when co-existing with CEv0 elements like Polymer 1, and with polyfills
        // that don't strictly adhere to the no-modification rule because shadow
        // DOM, which may be created in the constructor, is emulated by being placed
        // in the light DOM.
        //
        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
        // in one step.
        //
        // The Custom Elements v1 polyfill supports upgrade(), so the order when
        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
        // Connect.
        var fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
        var stack = [];
        var parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

        var walker = document.createTreeWalker(fragment, 133
        /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
        , null, false);
        var partIndex = 0;
        var nodeIndex = 0;
        var part;
        var node = walker.nextNode(); // Loop through all the nodes and parts of a template

        while (partIndex < parts.length) {
          part = parts[partIndex];

          if (!isTemplatePartActive(part)) {
            this.__parts.push(undefined);

            partIndex++;
            continue;
          } // Progress the tree walker until we find our next part's node.
          // Note that multiple parts may share the same node (attribute parts
          // on a single element), so this loop may not run at all.


          while (nodeIndex < part.index) {
            nodeIndex++;

            if (node.nodeName === 'TEMPLATE') {
              stack.push(node);
              walker.currentNode = node.content;
            }

            if ((node = walker.nextNode()) === null) {
              // We've exhausted the content inside a nested template element.
              // Because we still have parts (the outer for-loop), we know:
              // - There is a template in the stack
              // - The walker will find a nextNode outside the template
              walker.currentNode = stack.pop();
              node = walker.nextNode();
            }
          } // We've arrived at our part's node.


          if (part.type === 'node') {
            var _part2 = this.processor.handleTextExpression(this.options);

            _part2.insertAfterNode(node.previousSibling);

            this.__parts.push(_part2);
          } else {
            var _this$__parts;

            (_this$__parts = this.__parts).push.apply(_this$__parts, _toConsumableArray(this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options)));
          }

          partIndex++;
        }

        if (isCEPolyfill) {
          document.adoptNode(fragment);
          customElements.upgrade(fragment);
        }

        return fragment;
      }
    }]);

    return TemplateInstance;
  }();

  /**
   * Our TrustedTypePolicy for HTML which is declared using the html template
   * tag function.
   *
   * That HTML is a developer-authored constant, and is parsed with innerHTML
   * before any untrusted expressions have been mixed in. Therefor it is
   * considered safe by construction.
   */

  var policy = window.trustedTypes && trustedTypes.createPolicy('lit-html', {
    createHTML: function createHTML(s) {
      return s;
    }
  });
  var commentMarker = " ".concat(marker, " ");
  /**
   * The return type of `html`, which holds a Template and the values from
   * interpolated expressions.
   */

  var TemplateResult = /*#__PURE__*/function () {
    function TemplateResult(strings, values, type, processor) {
      _classCallCheck(this, TemplateResult);

      this.strings = strings;
      this.values = values;
      this.type = type;
      this.processor = processor;
    }
    /**
     * Returns a string of HTML used to create a `<template>` element.
     */


    _createClass(TemplateResult, [{
      key: "getHTML",
      value: function getHTML() {
        var l = this.strings.length - 1;
        var html = '';
        var isCommentBinding = false;

        for (var i = 0; i < l; i++) {
          var s = this.strings[i]; // For each binding we want to determine the kind of marker to insert
          // into the template source before it's parsed by the browser's HTML
          // parser. The marker type is based on whether the expression is in an
          // attribute, text, or comment position.
          //   * For node-position bindings we insert a comment with the marker
          //     sentinel as its text content, like <!--{{lit-guid}}-->.
          //   * For attribute bindings we insert just the marker sentinel for the
          //     first binding, so that we support unquoted attribute bindings.
          //     Subsequent bindings can use a comment marker because multi-binding
          //     attributes must be quoted.
          //   * For comment bindings we insert just the marker sentinel so we don't
          //     close the comment.
          //
          // The following code scans the template source, but is *not* an HTML
          // parser. We don't need to track the tree structure of the HTML, only
          // whether a binding is inside a comment, and if not, if it appears to be
          // the first binding in an attribute.

          var commentOpen = s.lastIndexOf('<!--'); // We're in comment position if we have a comment open with no following
          // comment close. Because <-- can appear in an attribute value there can
          // be false positives.

          isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1; // Check to see if we have an attribute-like sequence preceding the
          // expression. This can match "name=value" like structures in text,
          // comments, and attribute values, so there can be false-positives.

          var attributeMatch = lastAttributeNameRegex.exec(s);

          if (attributeMatch === null) {
            // We're only in this branch if we don't have a attribute-like
            // preceding sequence. For comments, this guards against unusual
            // attribute values like <div foo="<!--${'bar'}">. Cases like
            // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
            // below.
            html += s + (isCommentBinding ? commentMarker : nodeMarker);
          } else {
            // For attributes we use just a marker sentinel, and also append a
            // $lit$ suffix to the name to opt-out of attribute-specific parsing
            // that IE and Edge do for style and certain SVG attributes.
            html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
          }
        }

        html += this.strings[l];
        return html;
      }
    }, {
      key: "getTemplateElement",
      value: function getTemplateElement() {
        var template = document.createElement('template');
        var value = this.getHTML();

        if (policy !== undefined) {
          // this is secure because `this.strings` is a TemplateStringsArray.
          // TODO: validate this when
          // https://github.com/tc39/proposal-array-is-template-object is
          // implemented.
          value = policy.createHTML(value);
        }

        template.innerHTML = value;
        return template;
      }
    }]);

    return TemplateResult;
  }();

  var isPrimitive = function isPrimitive(value) {
    return value === null || !(_typeof(value) === 'object' || typeof value === 'function');
  };
  var isIterable = function isIterable(value) {
    return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    !!(value && value[Symbol.iterator]);
  };
  /**
   * Writes attribute values to the DOM for a group of AttributeParts bound to a
   * single attribute. The value is only set once even if there are multiple parts
   * for an attribute.
   */

  var AttributeCommitter = /*#__PURE__*/function () {
    function AttributeCommitter(element, name, strings) {
      _classCallCheck(this, AttributeCommitter);

      this.dirty = true;
      this.element = element;
      this.name = name;
      this.strings = strings;
      this.parts = [];

      for (var i = 0; i < strings.length - 1; i++) {
        this.parts[i] = this._createPart();
      }
    }
    /**
     * Creates a single part. Override this to create a differnt type of part.
     */


    _createClass(AttributeCommitter, [{
      key: "_createPart",
      value: function _createPart() {
        return new AttributePart(this);
      }
    }, {
      key: "_getValue",
      value: function _getValue() {
        var strings = this.strings;
        var l = strings.length - 1;
        var parts = this.parts; // If we're assigning an attribute via syntax like:
        //    attr="${foo}"  or  attr=${foo}
        // but not
        //    attr="${foo} ${bar}" or attr="${foo} baz"
        // then we don't want to coerce the attribute value into one long
        // string. Instead we want to just return the value itself directly,
        // so that sanitizeDOMValue can get the actual value rather than
        // String(value)
        // The exception is if v is an array, in which case we do want to smash
        // it together into a string without calling String() on the array.
        //
        // This also allows trusted values (when using TrustedTypes) being
        // assigned to DOM sinks without being stringified in the process.

        if (l === 1 && strings[0] === '' && strings[1] === '') {
          var v = parts[0].value;

          if (_typeof(v) === 'symbol') {
            return String(v);
          }

          if (typeof v === 'string' || !isIterable(v)) {
            return v;
          }
        }

        var text = '';

        for (var i = 0; i < l; i++) {
          text += strings[i];
          var part = parts[i];

          if (part !== undefined) {
            var _v = part.value;

            if (isPrimitive(_v) || !isIterable(_v)) {
              text += typeof _v === 'string' ? _v : String(_v);
            } else {
              var _iterator = _createForOfIteratorHelper(_v),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var t = _step.value;
                  text += typeof t === 'string' ? t : String(t);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
          }
        }

        text += strings[l];
        return text;
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.dirty) {
          this.dirty = false;
          this.element.setAttribute(this.name, this._getValue());
        }
      }
    }]);

    return AttributeCommitter;
  }();
  /**
   * A Part that controls all or part of an attribute value.
   */

  var AttributePart = /*#__PURE__*/function () {
    function AttributePart(committer) {
      _classCallCheck(this, AttributePart);

      this.value = undefined;
      this.committer = committer;
    }

    _createClass(AttributePart, [{
      key: "setValue",
      value: function setValue(value) {
        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
          this.value = value; // If the value is a not a directive, dirty the committer so that it'll
          // call setAttribute. If the value is a directive, it'll dirty the
          // committer if it calls setValue().

          if (!isDirective(value)) {
            this.committer.dirty = true;
          }
        }
      }
    }, {
      key: "commit",
      value: function commit() {
        while (isDirective(this.value)) {
          var directive = this.value;
          this.value = noChange;
          directive(this);
        }

        if (this.value === noChange) {
          return;
        }

        this.committer.commit();
      }
    }]);

    return AttributePart;
  }();
  /**
   * A Part that controls a location within a Node tree. Like a Range, NodePart
   * has start and end locations and can set and update the Nodes between those
   * locations.
   *
   * NodeParts support several value types: primitives, Nodes, TemplateResults,
   * as well as arrays and iterables of those types.
   */

  var NodePart = /*#__PURE__*/function () {
    function NodePart(options) {
      _classCallCheck(this, NodePart);

      this.value = undefined;
      this.__pendingValue = undefined;
      this.options = options;
    }
    /**
     * Appends this part into a container.
     *
     * This part must be empty, as its contents are not automatically moved.
     */


    _createClass(NodePart, [{
      key: "appendInto",
      value: function appendInto(container) {
        this.startNode = container.appendChild(createMarker());
        this.endNode = container.appendChild(createMarker());
      }
      /**
       * Inserts this part after the `ref` node (between `ref` and `ref`'s next
       * sibling). Both `ref` and its next sibling must be static, unchanging nodes
       * such as those that appear in a literal section of a template.
       *
       * This part must be empty, as its contents are not automatically moved.
       */

    }, {
      key: "insertAfterNode",
      value: function insertAfterNode(ref) {
        this.startNode = ref;
        this.endNode = ref.nextSibling;
      }
      /**
       * Appends this part into a parent part.
       *
       * This part must be empty, as its contents are not automatically moved.
       */

    }, {
      key: "appendIntoPart",
      value: function appendIntoPart(part) {
        part.__insert(this.startNode = createMarker());

        part.__insert(this.endNode = createMarker());
      }
      /**
       * Inserts this part after the `ref` part.
       *
       * This part must be empty, as its contents are not automatically moved.
       */

    }, {
      key: "insertAfterPart",
      value: function insertAfterPart(ref) {
        ref.__insert(this.startNode = createMarker());

        this.endNode = ref.endNode;
        ref.endNode = this.startNode;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.__pendingValue = value;
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.startNode.parentNode === null) {
          return;
        }

        while (isDirective(this.__pendingValue)) {
          var directive = this.__pendingValue;
          this.__pendingValue = noChange;
          directive(this);
        }

        var value = this.__pendingValue;

        if (value === noChange) {
          return;
        }

        if (isPrimitive(value)) {
          if (value !== this.value) {
            this.__commitText(value);
          }
        } else if (value instanceof TemplateResult) {
          this.__commitTemplateResult(value);
        } else if (value instanceof Node) {
          this.__commitNode(value);
        } else if (isIterable(value)) {
          this.__commitIterable(value);
        } else if (value === nothing) {
          this.value = nothing;
          this.clear();
        } else {
          // Fallback, will render the string representation
          this.__commitText(value);
        }
      }
    }, {
      key: "__insert",
      value: function __insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
      }
    }, {
      key: "__commitNode",
      value: function __commitNode(value) {
        if (this.value === value) {
          return;
        }

        this.clear();

        this.__insert(value);

        this.value = value;
      }
    }, {
      key: "__commitText",
      value: function __commitText(value) {
        var node = this.startNode.nextSibling;
        value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case
        // it can't be implicitly converted - i.e. it's a symbol.

        var valueAsString = typeof value === 'string' ? value : String(value);

        if (node === this.endNode.previousSibling && node.nodeType === 3
        /* Node.TEXT_NODE */
        ) {
            // If we only have a single text node between the markers, we can just
            // set its value, rather than replacing it.
            // TODO(justinfagnani): Can we just check if this.value is primitive?
            node.data = valueAsString;
          } else {
          this.__commitNode(document.createTextNode(valueAsString));
        }

        this.value = value;
      }
    }, {
      key: "__commitTemplateResult",
      value: function __commitTemplateResult(value) {
        var template = this.options.templateFactory(value);

        if (this.value instanceof TemplateInstance && this.value.template === template) {
          this.value.update(value.values);
        } else {
          // Make sure we propagate the template processor from the TemplateResult
          // so that we use its syntax extension, etc. The template factory comes
          // from the render function options so that it can control template
          // caching and preprocessing.
          var instance = new TemplateInstance(template, value.processor, this.options);

          var fragment = instance._clone();

          instance.update(value.values);

          this.__commitNode(fragment);

          this.value = instance;
        }
      }
    }, {
      key: "__commitIterable",
      value: function __commitIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _value is an array, then the previous render was of an
        // iterable and _value will contain the NodeParts from the previous
        // render. If _value is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this.value)) {
          this.value = [];
          this.clear();
        } // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render


        var itemParts = this.value;
        var partIndex = 0;
        var itemPart;

        var _iterator2 = _createForOfIteratorHelper(value),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            // Try to reuse an existing part
            itemPart = itemParts[partIndex]; // If no existing part, create a new one

            if (itemPart === undefined) {
              itemPart = new NodePart(this.options);
              itemParts.push(itemPart);

              if (partIndex === 0) {
                itemPart.appendIntoPart(this);
              } else {
                itemPart.insertAfterPart(itemParts[partIndex - 1]);
              }
            }

            itemPart.setValue(item);
            itemPart.commit();
            partIndex++;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        if (partIndex < itemParts.length) {
          // Truncate the parts array so _value reflects the current state
          itemParts.length = partIndex;
          this.clear(itemPart && itemPart.endNode);
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;
        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
      }
    }]);

    return NodePart;
  }();
  /**
   * Implements a boolean attribute, roughly as defined in the HTML
   * specification.
   *
   * If the value is truthy, then the attribute is present with a value of
   * ''. If the value is falsey, the attribute is removed.
   */

  var BooleanAttributePart = /*#__PURE__*/function () {
    function BooleanAttributePart(element, name, strings) {
      _classCallCheck(this, BooleanAttributePart);

      this.value = undefined;
      this.__pendingValue = undefined;

      if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
        throw new Error('Boolean attributes can only contain a single expression');
      }

      this.element = element;
      this.name = name;
      this.strings = strings;
    }

    _createClass(BooleanAttributePart, [{
      key: "setValue",
      value: function setValue(value) {
        this.__pendingValue = value;
      }
    }, {
      key: "commit",
      value: function commit() {
        while (isDirective(this.__pendingValue)) {
          var directive = this.__pendingValue;
          this.__pendingValue = noChange;
          directive(this);
        }

        if (this.__pendingValue === noChange) {
          return;
        }

        var value = !!this.__pendingValue;

        if (this.value !== value) {
          if (value) {
            this.element.setAttribute(this.name, '');
          } else {
            this.element.removeAttribute(this.name);
          }

          this.value = value;
        }

        this.__pendingValue = noChange;
      }
    }]);

    return BooleanAttributePart;
  }();
  /**
   * Sets attribute values for PropertyParts, so that the value is only set once
   * even if there are multiple parts for a property.
   *
   * If an expression controls the whole property value, then the value is simply
   * assigned to the property under control. If there are string literals or
   * multiple expressions, then the strings are expressions are interpolated into
   * a string first.
   */

  var PropertyCommitter = /*#__PURE__*/function (_AttributeCommitter) {
    _inherits(PropertyCommitter, _AttributeCommitter);

    var _super = _createSuper(PropertyCommitter);

    function PropertyCommitter(element, name, strings) {
      var _this;

      _classCallCheck(this, PropertyCommitter);

      _this = _super.call(this, element, name, strings);
      _this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';
      return _this;
    }

    _createClass(PropertyCommitter, [{
      key: "_createPart",
      value: function _createPart() {
        return new PropertyPart(this);
      }
    }, {
      key: "_getValue",
      value: function _getValue() {
        if (this.single) {
          return this.parts[0].value;
        }

        return _get(_getPrototypeOf(PropertyCommitter.prototype), "_getValue", this).call(this);
      }
    }, {
      key: "commit",
      value: function commit() {
        if (this.dirty) {
          this.dirty = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          this.element[this.name] = this._getValue();
        }
      }
    }]);

    return PropertyCommitter;
  }(AttributeCommitter);
  var PropertyPart = /*#__PURE__*/function (_AttributePart) {
    _inherits(PropertyPart, _AttributePart);

    var _super2 = _createSuper(PropertyPart);

    function PropertyPart() {
      _classCallCheck(this, PropertyPart);

      return _super2.apply(this, arguments);
    }

    return PropertyPart;
  }(AttributePart); // Detect event listener options support. If the `capture` property is read
  // from the options object, then options are supported. If not, then the third
  // argument to add/removeEventListener is interpreted as the boolean capture
  // value so we should only pass the `capture` property.

  var eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
  // blocks right into the body of a module

  (function () {
    try {
      var options = {
        get capture() {
          eventOptionsSupported = true;
          return false;
        }

      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any

      window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any

      window.removeEventListener('test', options, options);
    } catch (_e) {// event options not supported
    }
  })();

  var EventPart = /*#__PURE__*/function () {
    function EventPart(element, eventName, eventContext) {
      var _this2 = this;

      _classCallCheck(this, EventPart);

      this.value = undefined;
      this.__pendingValue = undefined;
      this.element = element;
      this.eventName = eventName;
      this.eventContext = eventContext;

      this.__boundHandleEvent = function (e) {
        return _this2.handleEvent(e);
      };
    }

    _createClass(EventPart, [{
      key: "setValue",
      value: function setValue(value) {
        this.__pendingValue = value;
      }
    }, {
      key: "commit",
      value: function commit() {
        while (isDirective(this.__pendingValue)) {
          var directive = this.__pendingValue;
          this.__pendingValue = noChange;
          directive(this);
        }

        if (this.__pendingValue === noChange) {
          return;
        }

        var newListener = this.__pendingValue;
        var oldListener = this.value;
        var shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
        var shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);

        if (shouldRemoveListener) {
          this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }

        if (shouldAddListener) {
          this.__options = getOptions(newListener);
          this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }

        this.value = newListener;
        this.__pendingValue = noChange;
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        if (typeof this.value === 'function') {
          this.value.call(this.eventContext || this.element, event);
        } else {
          this.value.handleEvent(event);
        }
      }
    }]);

    return EventPart;
  }(); // We copy options because of the inconsistent behavior of browsers when reading
  // the third argument of add/removeEventListener. IE11 doesn't support options
  // at all. Chrome 41 only reads `capture` if the argument is an object.

  var getOptions = function getOptions(o) {
    return o && (eventOptionsSupported ? {
      capture: o.capture,
      passive: o.passive,
      once: o.once
    } : o.capture);
  };

  /**
   * Creates Parts when a template is instantiated.
   */

  var DefaultTemplateProcessor = /*#__PURE__*/function () {
    function DefaultTemplateProcessor() {
      _classCallCheck(this, DefaultTemplateProcessor);
    }

    _createClass(DefaultTemplateProcessor, [{
      key: "handleAttributeExpressions",

      /**
       * Create parts for an attribute-position binding, given the event, attribute
       * name, and string literals.
       *
       * @param element The element containing the binding
       * @param name  The attribute name
       * @param strings The string literals. There are always at least two strings,
       *   event for fully-controlled bindings with a single expression.
       */
      value: function handleAttributeExpressions(element, name, strings, options) {
        var prefix = name[0];

        if (prefix === '.') {
          var _committer = new PropertyCommitter(element, name.slice(1), strings);

          return _committer.parts;
        }

        if (prefix === '@') {
          return [new EventPart(element, name.slice(1), options.eventContext)];
        }

        if (prefix === '?') {
          return [new BooleanAttributePart(element, name.slice(1), strings)];
        }

        var committer = new AttributeCommitter(element, name, strings);
        return committer.parts;
      }
      /**
       * Create parts for a text-position binding.
       * @param templateFactory
       */

    }, {
      key: "handleTextExpression",
      value: function handleTextExpression(options) {
        return new NodePart(options);
      }
    }]);

    return DefaultTemplateProcessor;
  }();
  var defaultTemplateProcessor = new DefaultTemplateProcessor();

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * The default TemplateFactory which caches Templates keyed on
   * result.type and result.strings.
   */

  function templateFactory(result) {
    var templateCache = templateCaches.get(result.type);

    if (templateCache === undefined) {
      templateCache = {
        stringsArray: new WeakMap(),
        keyString: new Map()
      };
      templateCaches.set(result.type, templateCache);
    }

    var template = templateCache.stringsArray.get(result.strings);

    if (template !== undefined) {
      return template;
    } // If the TemplateStringsArray is new, generate a key from the strings
    // This key is shared between all templates with identical content


    var key = result.strings.join(marker); // Check if we already have a Template for this key

    template = templateCache.keyString.get(key);

    if (template === undefined) {
      // If we have not seen this key before, create a new Template
      template = new Template(result, result.getTemplateElement()); // Cache the Template for this key

      templateCache.keyString.set(key, template);
    } // Cache all future queries for this TemplateStringsArray


    templateCache.stringsArray.set(result.strings, template);
    return template;
  }
  var templateCaches = new Map();

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var parts = new WeakMap();
  /**
   * Renders a template result or other value to a container.
   *
   * To update a container with new values, reevaluate the template literal and
   * call `render` with the new result.
   *
   * @param result Any value renderable by NodePart - typically a TemplateResult
   *     created by evaluating a template tag like `html` or `svg`.
   * @param container A DOM parent to render to. The entire contents are either
   *     replaced, or efficiently updated if the same result type was previous
   *     rendered there.
   * @param options RenderOptions for the entire render tree rendered to this
   *     container. Render options must *not* change between renders to the same
   *     container, as those changes will not effect previously rendered DOM.
   */

  var render = function render(result, container, options) {
    var part = parts.get(container);

    if (part === undefined) {
      removeNodes(container, container.firstChild);
      parts.set(container, part = new NodePart(Object.assign({
        templateFactory: templateFactory
      }, options)));
      part.appendInto(container);
    }

    part.setValue(result);
    part.commit();
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  // This line will be used in regexes to search for lit-html usage.
  // TODO(justinfagnani): inject version number at build time

  if (typeof window !== 'undefined') {
    (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.3.0');
  }
  /**
   * Interprets a template literal as an HTML template that can efficiently
   * render to and update a container.
   */


  var html = function html(strings) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    return new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
  };

  var current;
  var currentId = 0;

  function setCurrent(state) {
    current = state;
  }

  function clear() {
    current = null;
    currentId = 0;
  }

  function notify() {
    return currentId++;
  }

  var phaseSymbol = Symbol('haunted.phase');
  var hookSymbol = Symbol('haunted.hook');
  var updateSymbol = Symbol('haunted.update');
  var commitSymbol = Symbol('haunted.commit');
  var effectsSymbol = Symbol('haunted.effects');
  var layoutEffectsSymbol = Symbol('haunted.layoutEffects');
  var contextEvent = 'haunted.context';

  var State = /*#__PURE__*/function () {
    function State(update, host) {
      _classCallCheck(this, State);

      this.update = update;
      this.host = host;
      this[hookSymbol] = new Map();
      this[effectsSymbol] = [];
      this[layoutEffectsSymbol] = [];
    }

    _createClass(State, [{
      key: "run",
      value: function run(cb) {
        setCurrent(this);
        var res = cb();
        clear();
        return res;
      }
    }, {
      key: "_runEffects",
      value: function _runEffects(phase) {
        var effects = this[phase];
        setCurrent(this);

        var _iterator = _createForOfIteratorHelper(effects),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var effect = _step.value;
            effect.call(this);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        clear();
      }
    }, {
      key: "runEffects",
      value: function runEffects() {
        this._runEffects(effectsSymbol);
      }
    }, {
      key: "runLayoutEffects",
      value: function runLayoutEffects() {
        this._runEffects(layoutEffectsSymbol);
      }
    }, {
      key: "teardown",
      value: function teardown() {
        var hooks = this[hookSymbol];
        hooks.forEach(function (hook) {
          if (typeof hook.teardown === 'function') {
            hook.teardown();
          }
        });
      }
    }]);

    return State;
  }();

  var defer = Promise.resolve().then.bind(Promise.resolve());

  function runner() {
    var tasks = [];
    var id;

    function runTasks() {
      id = null;
      var t = tasks;
      tasks = [];

      for (var i = 0, len = t.length; i < len; i++) {
        t[i]();
      }
    }

    return function (task) {
      tasks.push(task);

      if (id == null) {
        id = defer(runTasks);
      }
    };
  }

  var read = runner();
  var write = runner();

  var BaseScheduler = /*#__PURE__*/function () {
    function BaseScheduler(renderer, host) {
      _classCallCheck(this, BaseScheduler);

      this.renderer = renderer;
      this.host = host;
      this.state = new State(this.update.bind(this), host);
      this[phaseSymbol] = null;
      this._updateQueued = false;
    }

    _createClass(BaseScheduler, [{
      key: "update",
      value: function update() {
        var _this = this;

        if (this._updateQueued) return;
        read(function () {
          var result = _this.handlePhase(updateSymbol);

          write(function () {
            _this.handlePhase(commitSymbol, result);

            write(function () {
              _this.handlePhase(effectsSymbol);
            });
          });
          _this._updateQueued = false;
        });
        this._updateQueued = true;
      }
    }, {
      key: "handlePhase",
      value: function handlePhase(phase, arg) {
        this[phaseSymbol] = phase;

        switch (phase) {
          case commitSymbol:
            this.commit(arg);
            this.runEffects(layoutEffectsSymbol);
            return;

          case updateSymbol:
            return this.render();

          case effectsSymbol:
            return this.runEffects(effectsSymbol);
        }

        this[phaseSymbol] = null;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        return this.state.run(function () {
          return _this2.renderer.call(_this2.host, _this2.host);
        });
      }
    }, {
      key: "runEffects",
      value: function runEffects(phase) {
        this.state._runEffects(phase);
      }
    }, {
      key: "teardown",
      value: function teardown() {
        this.state.teardown();
      }
    }]);

    return BaseScheduler;
  }();

  var toCamelCase = function toCamelCase() {
    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return val.replace(/-+([a-z])?/g, function (_, _char) {
      return _char ? _char.toUpperCase() : '';
    });
  };

  function makeComponent(render) {
    var Scheduler = /*#__PURE__*/function (_BaseScheduler) {
      _inherits(Scheduler, _BaseScheduler);

      var _super = _createSuper(Scheduler);

      function Scheduler(renderer, frag, host) {
        var _this;

        _classCallCheck(this, Scheduler);

        _this = _super.call(this, renderer, host || frag);
        _this.frag = frag;
        return _this;
      }

      _createClass(Scheduler, [{
        key: "commit",
        value: function commit(result) {
          render(result, this.frag);
        }
      }]);

      return Scheduler;
    }(BaseScheduler);

    function component(renderer, baseElementOrOptions, options) {
      var BaseElement = (options || baseElementOrOptions || {}).baseElement || HTMLElement;

      var _ref = options || baseElementOrOptions || {},
          _ref$observedAttribut = _ref.observedAttributes,
          observedAttributes = _ref$observedAttribut === void 0 ? [] : _ref$observedAttribut,
          _ref$useShadowDOM = _ref.useShadowDOM,
          useShadowDOM = _ref$useShadowDOM === void 0 ? true : _ref$useShadowDOM,
          _ref$shadowRootInit = _ref.shadowRootInit,
          shadowRootInit = _ref$shadowRootInit === void 0 ? {} : _ref$shadowRootInit;

      var Element = /*#__PURE__*/function (_BaseElement) {
        _inherits(Element, _BaseElement);

        var _super2 = _createSuper(Element);

        function Element() {
          var _this2;

          _classCallCheck(this, Element);

          _this2 = _super2.call(this);

          if (useShadowDOM === false) {
            _this2._scheduler = new Scheduler(renderer, _assertThisInitialized(_this2));
          } else {
            _this2.attachShadow(_objectSpread2({
              mode: 'open'
            }, shadowRootInit));

            _this2._scheduler = new Scheduler(renderer, _this2.shadowRoot, _assertThisInitialized(_this2));
          }

          return _this2;
        }

        _createClass(Element, [{
          key: "connectedCallback",
          value: function connectedCallback() {
            this._scheduler.update();
          }
        }, {
          key: "disconnectedCallback",
          value: function disconnectedCallback() {
            this._scheduler.teardown();
          }
        }, {
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(name, oldValue, newValue) {
            if (oldValue === newValue) {
              return;
            }

            var val = newValue === '' ? true : newValue;
            Reflect.set(this, toCamelCase(name), val);
          }
        }], [{
          key: "observedAttributes",
          get: function get() {
            return renderer.observedAttributes || observedAttributes || [];
          }
        }]);

        return Element;
      }(BaseElement);

      function reflectiveProp(initialValue) {
        var value = initialValue;
        return Object.freeze({
          enumerable: true,
          configurable: true,
          get: function get() {
            return value;
          },
          set: function set(newValue) {
            value = newValue;

            this._scheduler.update();
          }
        });
      }

      var proto = new Proxy(BaseElement.prototype, {
        getPrototypeOf: function getPrototypeOf(target) {
          return target;
        },
        set: function set(target, key, value, receiver) {
          var desc;

          if (key in target) {
            desc = Object.getOwnPropertyDescriptor(target, key);

            if (desc && desc.set) {
              desc.set.call(receiver, value);
              return true;
            }

            Reflect.set(target, key, value);
          }

          if (_typeof(key) === 'symbol' || key[0] === '_') {
            desc = {
              enumerable: true,
              configurable: true,
              writable: true,
              value: value
            };
          } else {
            desc = reflectiveProp(value);
          }

          Object.defineProperty(receiver, key, desc);

          if (desc.set) {
            desc.set.call(receiver, value);
          }

          return true;
        }
      });
      Object.setPrototypeOf(Element.prototype, proto);
      return Element;
    }

    return component;
  }

  var Hook = function Hook(id, state) {
    _classCallCheck(this, Hook);

    this.id = id;
    this.state = state;
  };

  function use(Hook) {
    var _hook;

    var id = notify();
    var hooks = current[hookSymbol];
    var hook = hooks.get(id);

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (!hook) {
      hook = _construct(Hook, [id, current].concat(args));
      hooks.set(id, hook);
    }

    return (_hook = hook).update.apply(_hook, args);
  }

  function hook(Hook) {
    return use.bind(null, Hook);
  }

  function createEffect(setEffects) {
    return hook( /*#__PURE__*/function (_Hook) {
      _inherits(_class, _Hook);

      var _super = _createSuper(_class);

      function _class(id, state, ignored1, ignored2) {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this, id, state);
        setEffects(state, _assertThisInitialized(_this));
        return _this;
      }

      _createClass(_class, [{
        key: "update",
        value: function update(callback, values) {
          this.callback = callback;
          this.lastValues = this.values;
          this.values = values;
        }
      }, {
        key: "call",
        value: function call() {
          if (!this.values || this.hasChanged()) {
            this.run();
          }
        }
      }, {
        key: "run",
        value: function run() {
          this.teardown();
          this._teardown = this.callback.call(this.state);
        }
      }, {
        key: "teardown",
        value: function teardown() {
          if (typeof this._teardown === 'function') {
            this._teardown();
          }
        }
      }, {
        key: "hasChanged",
        value: function hasChanged() {
          var _this2 = this;

          return !this.lastValues || this.values.some(function (value, i) {
            return _this2.lastValues[i] !== value;
          });
        }
      }]);

      return _class;
    }(Hook));
  }

  function setEffects(state, cb) {
    state[effectsSymbol].push(cb);
  }

  var useEffect = createEffect(setEffects);

  var useContext = hook( /*#__PURE__*/function (_Hook) {
    _inherits(_class, _Hook);

    var _super = _createSuper(_class);

    function _class(id, state, _) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, id, state);
      _this._updater = _this._updater.bind(_assertThisInitialized(_this));
      _this._ranEffect = false;
      _this._unsubscribe = null;
      setEffects(state, _assertThisInitialized(_this));
      return _this;
    }

    _createClass(_class, [{
      key: "update",
      value: function update(Context) {
        if (this.state.virtual) {
          throw new Error('can\'t be used with virtual components');
        }

        if (this.Context !== Context) {
          this._subscribe(Context);

          this.Context = Context;
        }

        return this.value;
      }
    }, {
      key: "call",
      value: function call() {
        if (!this._ranEffect) {
          this._ranEffect = true;
          if (this._unsubscribe) this._unsubscribe();

          this._subscribe(this.Context);

          this.state.update();
        }
      }
    }, {
      key: "_updater",
      value: function _updater(value) {
        this.value = value;
        this.state.update();
      }
    }, {
      key: "_subscribe",
      value: function _subscribe(Context) {
        var detail = {
          Context: Context,
          callback: this._updater
        };
        this.state.host.dispatchEvent(new CustomEvent(contextEvent, {
          detail: detail,
          bubbles: true,
          cancelable: true,
          composed: true
        }));
        var unsubscribe = detail.unsubscribe,
            value = detail.value;
        this.value = unsubscribe ? value : Context.defaultValue;
        this._unsubscribe = unsubscribe;
      }
    }, {
      key: "teardown",
      value: function teardown() {
        if (this._unsubscribe) {
          this._unsubscribe();
        }
      }
    }]);

    return _class;
  }(Hook));

  function makeContext(component) {
    return function (defaultValue) {
      var Context = {
        Provider: /*#__PURE__*/function (_HTMLElement) {
          _inherits(Provider, _HTMLElement);

          var _super = _createSuper(Provider);

          function Provider() {
            var _this;

            _classCallCheck(this, Provider);

            _this = _super.call(this);
            _this.listeners = new Set();

            _this.addEventListener(contextEvent, _assertThisInitialized(_this));

            return _this;
          }

          _createClass(Provider, [{
            key: "disconnectedCallback",
            value: function disconnectedCallback() {
              this.removeEventListener(contextEvent, this);
            }
          }, {
            key: "handleEvent",
            value: function handleEvent(event) {
              var detail = event.detail;

              if (detail.Context === Context) {
                detail.value = this.value;
                detail.unsubscribe = this.unsubscribe.bind(this, detail.callback);
                this.listeners.add(detail.callback);
                event.stopPropagation();
              }
            }
          }, {
            key: "unsubscribe",
            value: function unsubscribe(callback) {
              this.listeners["delete"](callback);
            }
          }, {
            key: "value",
            set: function set(value) {
              this._value = value;

              var _iterator = _createForOfIteratorHelper(this.listeners),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var callback = _step.value;
                  callback(value);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            },
            get: function get() {
              return this._value;
            }
          }]);

          return Provider;
        }( /*#__PURE__*/_wrapNativeSuper(HTMLElement)),
        Consumer: component(function (_ref) {
          var render = _ref.render;
          var context = useContext(Context);
          return render(context);
        }),
        defaultValue: defaultValue
      };
      return Context;
    };
  }

  var useMemo = hook( /*#__PURE__*/function (_Hook) {
    _inherits(_class, _Hook);

    var _super = _createSuper(_class);

    function _class(id, state, fn, values) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, id, state);
      _this.value = fn();
      _this.values = values;
      return _this;
    }

    _createClass(_class, [{
      key: "update",
      value: function update(fn, values) {
        if (this.hasChanged(values)) {
          this.values = values;
          this.value = fn();
        }

        return this.value;
      }
    }, {
      key: "hasChanged",
      value: function hasChanged() {
        var _this2 = this;

        var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return values.some(function (value, i) {
          return _this2.values[i] !== value;
        });
      }
    }]);

    return _class;
  }(Hook));

  var useCallback = function useCallback(fn, inputs) {
    return useMemo(function () {
      return fn;
    }, inputs);
  };

  function setLayoutEffects(state, cb) {
    state[layoutEffectsSymbol].push(cb);
  }

  var useLayoutEffect = createEffect(setLayoutEffects);

  var useState = hook( /*#__PURE__*/function (_Hook) {
    _inherits(_class, _Hook);

    var _super = _createSuper(_class);

    function _class(id, state, initialValue) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, id, state);
      _this.updater = _this.updater.bind(_assertThisInitialized(_this));

      if (typeof initialValue === 'function') {
        initialValue = initialValue();
      }

      _this.makeArgs(initialValue);

      return _this;
    }

    _createClass(_class, [{
      key: "update",
      value: function update() {
        return this.args;
      }
    }, {
      key: "updater",
      value: function updater(value) {
        if (typeof value === 'function') {
          var updaterFn = value;

          var _this$args = _slicedToArray(this.args, 1),
              previousValue = _this$args[0];

          value = updaterFn(previousValue);
        }

        this.makeArgs(value);
        this.state.update();
      }
    }, {
      key: "makeArgs",
      value: function makeArgs(value) {
        this.args = Object.freeze([value, this.updater]);
      }
    }]);

    return _class;
  }(Hook));

  var useReducer = hook( /*#__PURE__*/function (_Hook) {
    _inherits(_class, _Hook);

    var _super = _createSuper(_class);

    function _class(id, state, _, initialState, init) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, id, state);
      _this.dispatch = _this.dispatch.bind(_assertThisInitialized(_this));
      _this.currentState = init !== undefined ? init(initialState) : initialState;
      return _this;
    }

    _createClass(_class, [{
      key: "update",
      value: function update(reducer) {
        this.reducer = reducer;
        return [this.currentState, this.dispatch];
      }
    }, {
      key: "dispatch",
      value: function dispatch(action) {
        this.currentState = this.reducer(this.currentState, action);
        this.state.update();
      }
    }]);

    return _class;
  }(Hook));

  var useRef = function useRef(initialValue) {
    return useMemo(function () {
      return {
        current: initialValue
      };
    }, []);
  };

  function haunted(_ref) {
    var render = _ref.render;
    var component = makeComponent(render);
    var createContext = makeContext(component);
    return {
      component: component,
      createContext: createContext
    };
  }

  var _haunted = haunted({
    render: render
  }),
      component = _haunted.component;

  function useDebouncedCallback(func, rawWait) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      leading: false,
      trailing: true
    };
    var lastCallTime = useRef(undefined);
    var lastInvokeTime = useRef(0);
    var timerId = useRef(undefined);
    var lastArgs = useRef([]);
    var lastThis = useRef(null);
    var result = useRef(null);
    var funcRef = useRef(func);
    var mounted = useRef(true);
    funcRef.current = func; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.

    var useRAF = !rawWait && rawWait !== 0 && typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function';

    if (typeof func !== 'function') {
      throw new TypeError('Expected a function');
    }

    var wait = Number(rawWait) || 0;
    var leading = !!options.leading;
    var trailing = 'trailing' in options ? !!options.trailing : true;
    var maxing = ('maxWait' in options);
    var maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : undefined;
    var invokeFunc = useCallback(function (time) {
      var args = lastArgs.current;
      var thisArg = lastThis.current;
      lastThis.current = undefined;
      lastArgs.current = undefined;
      lastInvokeTime.current = time;
      result.current = funcRef.current.apply(thisArg, args);
      return result.current;
    }, []);
    var startTimer = useCallback(function (pendingFunc, timeout) {
      if (useRAF) {
        window.cancelAnimationFrame(timerId.current);
        return window.requestAnimationFrame(pendingFunc);
      }

      return setTimeout(pendingFunc, timeout);
    }, [useRAF]);
    var cancelTimer = useCallback(function (id) {
      if (useRAF) {
        return window.cancelAnimationFrame(id);
      }

      clearTimeout(id);
      return true;
    }, [useRAF]);
    var remainingWait = useCallback(function (time) {
      var timeSinceLastCall = time - lastCallTime.current;
      var timeSinceLastInvoke = time - lastInvokeTime.current;
      var timeWaiting = wait - timeSinceLastCall;
      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }, [maxWait, maxing, wait]);
    var shouldInvoke = useCallback(function (time) {
      if (!mounted.current) return false;
      var timeSinceLastCall = time - lastCallTime.current;
      var timeSinceLastInvoke = time - lastInvokeTime.current; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime.current === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }, [maxWait, maxing, wait]);
    var trailingEdge = useCallback(function (time) {
      timerId.current = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs.current) {
        return invokeFunc(time);
      }

      lastThis.current = undefined;
      lastArgs.current = undefined;
      return result.current;
    }, [invokeFunc, trailing]);
    var timerExpired = useCallback(function () {
      var time = Date.now();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId.current = startTimer(timerExpired, remainingWait(time));
      return true;
    }, [remainingWait, shouldInvoke, startTimer, trailingEdge]);
    var leadingEdge = useCallback(function (time) {
      // Reset any `maxWait` timer.
      lastInvokeTime.current = time; // Start the timer for the trailing edge.

      timerId.current = startTimer(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result.current;
    }, [invokeFunc, startTimer, leading, timerExpired, wait]);
    var cancel = useCallback(function () {
      if (timerId.current !== undefined) {
        cancelTimer(timerId.current);
      }

      lastInvokeTime.current = 0;
      timerId.current = undefined;
      lastThis.current = undefined;
      lastCallTime.current = undefined;
      lastArgs.current = undefined;
    }, [cancelTimer]);
    var flush = useCallback(function () {
      return timerId.current === undefined ? result.current : trailingEdge(Date.now());
    }, [trailingEdge]);
    useEffect(function () {
      mounted.current = true;
      return function () {
        mounted.current = false;
      };
    }, []);
    var debounced = useCallback(function () {
      var time = Date.now();
      var isInvoking = shouldInvoke(time);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      lastArgs.current = args;
      lastThis.current = _this;
      lastCallTime.current = time;

      if (isInvoking) {
        if (timerId.current === undefined && mounted.current) {
          return leadingEdge(lastCallTime.current);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          timerId.current = startTimer(timerExpired, wait);
          return invokeFunc(lastCallTime.current);
        }
      }

      if (timerId.current === undefined) {
        timerId.current = startTimer(timerExpired, wait);
      }

      return result.current;
    }, [invokeFunc, leadingEdge, maxing, shouldInvoke, startTimer, timerExpired, wait]);
    var pending = useCallback(function () {
      return timerId.current !== undefined;
    }, []);
    var debouncedState = useMemo(function () {
      return {
        callback: debounced,
        cancel: cancel,
        flush: flush,
        pending: pending
      };
    }, [debounced, cancel, flush, pending]);
    return debouncedState;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteral(["\n    <h1>", "</h1>\n    <input type=\"text\" @keyup=", " value=", " />\n    <div>", "</div>\n  "]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  function predictiveSearch() {
    var _useState = useState(''),
        _useState2 = _slicedToArray(_useState, 2),
        q = _useState2[0],
        setQ = _useState2[1];

    var _useState3 = useState({}),
        _useState4 = _slicedToArray(_useState3, 2),
        results = _useState4[0],
        setResults = _useState4[1];

    var _useState5 = useState(false),
        _useState6 = _slicedToArray(_useState5, 2),
        loading = _useState6[0],
        setLoading = _useState6[1];

    var debounced = useDebouncedCallback(function () {
      getPredictiveSearchResults(q).then(function setValue(response) {
        setLoading(false);

        if (response.message) {
          setResults({});
        } else {
          setResults(response.resources.results);
        }
      });
    }, 500);

    var handleKeyup = function handleKeyup(event) {
      setLoading(true);
      setQ(event.target.value);
      debounced.callback(event.target.value);
    };

    return html(_templateObject(), "".concat(loading ? 'loading...' : 'loaded'), handleKeyup, q, JSON.stringify(results));
  }

  customElements.define('predictive-search', component(predictiveSearch, {
    useShadowDOM: false
  }));

  function _templateObject3() {
    var data = _taggedTemplateLiteral(["<option\n                  ?selected=", "\n                  value=\"", "\"\n                >\n                  ", "\n                </option>"]);

    _templateObject3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    var data = _taggedTemplateLiteral(["<div\n          class=\"selector-wrapper\"\n          ?hidden=", "\n        >\n          <select\n            data-option=\"option", "\"\n            @change=", "\n            class=\"form-control ", "\"\n          >\n            ", "\n          </select>\n        </div>"]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$1() {
    var data = _taggedTemplateLiteral(["<input\n      name=\"id\"\n      value=\"", "\"\n      type=\"hidden\"\n    />\n    ", "\n    <input\n      class=\"form-control quantity_input ", "\"\n      name=\"quantity\"\n      type=\"number\"\n      value=\"1\"\n      step=\"1\"\n    />\n    <button\n      ?disabled=", "\n      @click=", "\n      type=\"submit\"\n      name=\"add\"\n      class=\"form-control AddToCart btn ", "\"\n    >\n      <span class=\"AddToCartText\">Add to Cart</span>\n    </button>"]);

    _templateObject$1 = function _templateObject() {
      return data;
    };

    return data;
  }

  function addToCartFormInputs(_ref) {
    var _this = this;

    var dataProduct = _ref.dataProduct,
        dataSelectedOrFirstAvailableVariant = _ref.dataSelectedOrFirstAvailableVariant,
        dataOptionsWithValues = _ref.dataOptionsWithValues,
        _ref$selectorCustomCl = _ref.selectorCustomClasses,
        selectorCustomClasses = _ref$selectorCustomCl === void 0 ? '' : _ref$selectorCustomCl,
        _ref$quantityInputCus = _ref.quantityInputCustomClasses,
        quantityInputCustomClasses = _ref$quantityInputCus === void 0 ? '' : _ref$quantityInputCus,
        _ref$atcButtonCustomC = _ref.atcButtonCustomClasses,
        atcButtonCustomClasses = _ref$atcButtonCustomC === void 0 ? '' : _ref$atcButtonCustomC;
    var product = JSON.parse(dataProduct);
    var optionsWithValues = JSON.parse(dataOptionsWithValues);

    var _useState = useState(product.variants.find(function (variant) {
      return variant.id === parseInt(dataSelectedOrFirstAvailableVariant, 10);
    })),
        _useState2 = _slicedToArray(_useState, 2),
        currentVariant = _useState2[0],
        setCurrentVariant = _useState2[1];

    var handleOptionChange = function handleOptionChange() {
      var option1 = _this.querySelector('select[data-option="option1"]') && _this.querySelector('select[data-option="option1"]').value;

      var option2 = _this.querySelector('select[data-option="option2"]') && _this.querySelector('select[data-option="option2"]').value;

      var option3 = _this.querySelector('select[data-option="option3"]') && _this.querySelector('select[data-option="option3"]').value;

      var cVariant = product.variants.find(function (variant) {
        return variant.option1 === option1 && variant.option2 === option2 && variant.option3 === option3;
      });
      setCurrentVariant(cVariant); // dispatch a custom event to connect to other codes

      var event = new CustomEvent('variantchange', {
        bubbles: true,
        composed: true,
        detail: {
          currentVariant: cVariant,
          form: _this.closest('form')
        }
      });

      _this.dispatchEvent(event);
    };

    var handleATCButtonClick = function handleATCButtonClick(e) {
      var event = new CustomEvent('additemfromform', {
        bubbles: true,
        composed: true,
        detail: {
          originalEvent: e,
          form: _this.closest('form')
        }
      });

      _this.dispatchEvent(event);
    };

    return html(_templateObject$1(), currentVariant && currentVariant.id, optionsWithValues.map(function (option) {
      return html(_templateObject2(), option.name === 'Title' && option.values[0] === 'Default Title', option.position, handleOptionChange, selectorCustomClasses, option.values.map(function (value) {
        return html(_templateObject3(), currentVariant && currentVariant["option".concat(option.position)] === value, value, value);
      }));
    }), quantityInputCustomClasses, !currentVariant || !currentVariant.available, handleATCButtonClick, atcButtonCustomClasses);
  }

  customElements.define('add-to-cart-form-inputs', component(addToCartFormInputs, {
    useShadowDOM: false,
    observedAttributes: ['data-product', 'data-selected-or-first-available-variant', 'data-options-with-values', 'selector-custom-classes', 'quantity-input-custom-classes', 'atc-button-custom-classes']
  }));

  window.datomar = {
    BSN: index,
    apis: apis
  };

})));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ib290c3RyYXAubmF0aXZlL2Rpc3QvYm9vdHN0cmFwLW5hdGl2ZS5lc20uanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanMiLCJzcmMvc2NyaXB0cy9oZWxwZXIuanMiLCJzcmMvc2NyaXB0cy9hamF4YXBpcy5qcyIsIm5vZGVfbW9kdWxlcy9nbGlkZXItanMvZ2xpZGVyLmpzIiwic3JjL3NjcmlwdHMvc2VjdGlvbnMvdGVzdGltb25pYWxzLmpzIiwic3JjL3NjcmlwdHMvc2VjdGlvbnMvaGVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL21hY3kvZGlzdC9tYWN5LmpzIiwic3JjL3NjcmlwdHMvc2VjdGlvbnMvbWFzb25yeS1nYWxsZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9kaXJlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvcGFydC5qcyIsIm5vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL3RlbXBsYXRlLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi90ZW1wbGF0ZS1yZXN1bHQuanMiLCJub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL3BhcnRzLmpzIiwibm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcyIsIm5vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUtZmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpdC1odG1sLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL2ludGVyZmFjZS5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi9zeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi9jb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvaG9vay5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi9jcmVhdGUtZWZmZWN0LmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3VzZS1lZmZlY3QuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvdXNlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvY3JlYXRlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvdXNlLW1lbW8uanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvdXNlLWNhbGxiYWNrLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3VzZS1sYXlvdXQtZWZmZWN0LmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL3VzZS1zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi91c2UtcmVkdWNlci5qcyIsIm5vZGVfbW9kdWxlcy9oYXVudGVkL2xpYi91c2UtcmVmLmpzIiwibm9kZV9tb2R1bGVzL2hhdW50ZWQvbGliL2NvcmUuanMiLCJub2RlX21vZHVsZXMvaGF1bnRlZC9saWIvbGl0LWhhdW50ZWQuanMiLCJzcmMvc2NyaXB0cy9jb21wb25lbnRzL2N1c3RvbS1ob29rcy5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvcHJlZGljdGl2ZS1zZWFyY2guanMiLCJzcmMvc2NyaXB0cy9jb21wb25lbnRzL2FkZC10by1jYXJ0LWZvcm0taW5wdXRzLmpzIiwic3JjL3NjcmlwdHMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gICogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCB2My4wLjEwIChodHRwczovL3RoZWRucC5naXRodWIuaW8vYm9vdHN0cmFwLm5hdGl2ZS8pXG4gICogQ29weXJpZ2h0IDIwMTUtMjAyMCDCqSBkbnBfdGhlbWVcbiAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90aGVkbnAvYm9vdHN0cmFwLm5hdGl2ZS9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICAqL1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uJyBpbiBkb2N1bWVudC5oZWFkLnN0eWxlID8gJ3dlYmtpdFRyYW5zaXRpb25FbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xuXG52YXIgc3VwcG9ydFRyYW5zaXRpb24gPSAnd2Via2l0VHJhbnNpdGlvbicgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZSB8fCAndHJhbnNpdGlvbicgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZTtcblxudmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9ICd3ZWJraXRUcmFuc2l0aW9uJyBpbiBkb2N1bWVudC5oZWFkLnN0eWxlID8gJ3dlYmtpdFRyYW5zaXRpb25EdXJhdGlvbicgOiAndHJhbnNpdGlvbkR1cmF0aW9uJztcblxuZnVuY3Rpb24gZ2V0RWxlbWVudFRyYW5zaXRpb25EdXJhdGlvbihlbGVtZW50KSB7XG4gIHZhciBkdXJhdGlvbiA9IHN1cHBvcnRUcmFuc2l0aW9uID8gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW3RyYW5zaXRpb25EdXJhdGlvbl0pIDogMDtcbiAgZHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInICYmICFpc05hTihkdXJhdGlvbikgPyBkdXJhdGlvbiAqIDEwMDAgOiAwO1xuICByZXR1cm4gZHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGVsZW1lbnQsaGFuZGxlcil7XG4gIHZhciBjYWxsZWQgPSAwLCBkdXJhdGlvbiA9IGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24oZWxlbWVudCk7XG4gIGR1cmF0aW9uID8gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0cmFuc2l0aW9uRW5kRXZlbnQsIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRXcmFwcGVyKGUpe1xuICAgICAgICAgICAgICAhY2FsbGVkICYmIGhhbmRsZXIoZSksIGNhbGxlZCA9IDE7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHJhbnNpdGlvbkVuZEV2ZW50LCB0cmFuc2l0aW9uRW5kV3JhcHBlcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICA6IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7ICFjYWxsZWQgJiYgaGFuZGxlcigpLCBjYWxsZWQgPSAxOyB9LCAxNyk7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5RWxlbWVudChzZWxlY3RvciwgcGFyZW50KSB7XG4gIHZhciBsb29rVXAgPSBwYXJlbnQgJiYgcGFyZW50IGluc3RhbmNlb2YgRWxlbWVudCA/IHBhcmVudCA6IGRvY3VtZW50O1xuICByZXR1cm4gc2VsZWN0b3IgaW5zdGFuY2VvZiBFbGVtZW50ID8gc2VsZWN0b3IgOiBsb29rVXAucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGJvb3RzdHJhcEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgY29tcG9uZW50TmFtZSwgcmVsYXRlZCkge1xuICB2YXIgT3JpZ2luYWxDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudCggZXZlbnROYW1lICsgJy5icy4nICsgY29tcG9uZW50TmFtZSwge2NhbmNlbGFibGU6IHRydWV9KTtcbiAgT3JpZ2luYWxDdXN0b21FdmVudC5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZDtcbiAgcmV0dXJuIE9yaWdpbmFsQ3VzdG9tRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnQpe1xuICB0aGlzICYmIHRoaXMuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7XG59XG5cbmZ1bmN0aW9uIEFsZXJ0KGVsZW1lbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgIGFsZXJ0LFxuICAgIGNsb3NlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnY2xvc2UnLCdhbGVydCcpLFxuICAgIGNsb3NlZEN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2Nsb3NlZCcsJ2FsZXJ0Jyk7XG4gIGZ1bmN0aW9uIHRyaWdnZXJIYW5kbGVyKCkge1xuICAgIGFsZXJ0LmNsYXNzTGlzdC5jb250YWlucygnZmFkZScpID8gZW11bGF0ZVRyYW5zaXRpb25FbmQoYWxlcnQsdHJhbnNpdGlvbkVuZEhhbmRsZXIpIDogdHJhbnNpdGlvbkVuZEhhbmRsZXIoKTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWN0aW9uKXtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgZWxlbWVudFthY3Rpb25dKCdjbGljaycsY2xpY2tIYW5kbGVyLGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgIGFsZXJ0ID0gZSAmJiBlLnRhcmdldC5jbG9zZXN0KFwiLmFsZXJ0XCIpO1xuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoJ1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXScsYWxlcnQpO1xuICAgIGVsZW1lbnQgJiYgYWxlcnQgJiYgKGVsZW1lbnQgPT09IGUudGFyZ2V0IHx8IGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSAmJiBzZWxmLmNsb3NlKCk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZEhhbmRsZXIoKSB7XG4gICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgYWxlcnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhbGVydCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGFsZXJ0LGNsb3NlZEN1c3RvbUV2ZW50KTtcbiAgfVxuICBzZWxmLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICggYWxlcnQgJiYgZWxlbWVudCAmJiBhbGVydC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSApIHtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChhbGVydCxjbG9zZUN1c3RvbUV2ZW50KTtcbiAgICAgIGlmICggY2xvc2VDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICAgIHNlbGYuZGlzcG9zZSgpO1xuICAgICAgYWxlcnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgdHJpZ2dlckhhbmRsZXIoKTtcbiAgICB9XG4gIH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVFdmVudHMoKTtcbiAgICBkZWxldGUgZWxlbWVudC5BbGVydDtcbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgYWxlcnQgPSBlbGVtZW50LmNsb3Nlc3QoJy5hbGVydCcpO1xuICBlbGVtZW50LkFsZXJ0ICYmIGVsZW1lbnQuQWxlcnQuZGlzcG9zZSgpO1xuICBpZiAoICFlbGVtZW50LkFsZXJ0ICkge1xuICAgIHRvZ2dsZUV2ZW50cygxKTtcbiAgfVxuICBzZWxmLmVsZW1lbnQgPSBlbGVtZW50O1xuICBlbGVtZW50LkFsZXJ0ID0gc2VsZjtcbn1cblxuZnVuY3Rpb24gQnV0dG9uKGVsZW1lbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLCBsYWJlbHMsXG4gICAgICBjaGFuZ2VDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdjaGFuZ2UnLCAnYnV0dG9uJyk7XG4gIGZ1bmN0aW9uIHRvZ2dsZShlKSB7XG4gICAgdmFyIGlucHV0LFxuICAgICAgICBsYWJlbCA9IGUudGFyZ2V0LnRhZ05hbWUgPT09ICdMQUJFTCcgPyBlLnRhcmdldFxuICAgICAgICAgICAgICA6IGUudGFyZ2V0LmNsb3Nlc3QoJ0xBQkVMJykgPyBlLnRhcmdldC5jbG9zZXN0KCdMQUJFTCcpIDogbnVsbDtcbiAgICBpbnB1dCA9IGxhYmVsICYmIGxhYmVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdJTlBVVCcpWzBdO1xuICAgIGlmICggIWlucHV0ICkgeyByZXR1cm47IH1cbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoaW5wdXQsIGNoYW5nZUN1c3RvbUV2ZW50KTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgY2hhbmdlQ3VzdG9tRXZlbnQpO1xuICAgIGlmICggaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94JyApIHtcbiAgICAgIGlmICggY2hhbmdlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgICBpZiAoICFpbnB1dC5jaGVja2VkICkge1xuICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgaW5wdXQuZ2V0QXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsJ2NoZWNrZWQnKTtcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgaW5wdXQuZ2V0QXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgICBpbnB1dC5jaGVja2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIWVsZW1lbnQudG9nZ2xlZCkge1xuICAgICAgICBlbGVtZW50LnRvZ2dsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIGlucHV0LnR5cGUgPT09ICdyYWRpbycgJiYgIWVsZW1lbnQudG9nZ2xlZCApIHtcbiAgICAgIGlmICggY2hhbmdlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgICBpZiAoICFpbnB1dC5jaGVja2VkIHx8IChlLnNjcmVlblggPT09IDAgJiYgZS5zY3JlZW5ZID09IDApICkge1xuICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9jdXMnKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdjaGVja2VkJywnY2hlY2tlZCcpO1xuICAgICAgICBpbnB1dC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC50b2dnbGVkID0gdHJ1ZTtcbiAgICAgICAgQXJyYXkuZnJvbShsYWJlbHMpLm1hcChmdW5jdGlvbiAob3RoZXJMYWJlbCl7XG4gICAgICAgICAgdmFyIG90aGVySW5wdXQgPSBvdGhlckxhYmVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdJTlBVVCcpWzBdO1xuICAgICAgICAgIGlmICggb3RoZXJMYWJlbCAhPT0gbGFiZWwgJiYgb3RoZXJMYWJlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICkgIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChvdGhlcklucHV0LCBjaGFuZ2VDdXN0b21FdmVudCk7XG4gICAgICAgICAgICBvdGhlckxhYmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgb3RoZXJJbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgIG90aGVySW5wdXQuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHsgZWxlbWVudC50b2dnbGVkID0gZmFsc2U7IH0sIDUwICk7XG4gIH1cbiAgZnVuY3Rpb24ga2V5SGFuZGxlcihlKSB7XG4gICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgIGtleSA9PT0gMzIgJiYgZS50YXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgdG9nZ2xlKGUpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXZlbnRTY3JvbGwoZSkge1xuICAgIHZhciBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICBrZXkgPT09IDMyICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiBmb2N1c1RvZ2dsZShlKSB7XG4gICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09ICdJTlBVVCcgKSB7XG4gICAgICB2YXIgYWN0aW9uID0gZS50eXBlID09PSAnZm9jdXNpbicgPyAnYWRkJyA6ICdyZW1vdmUnO1xuICAgICAgZS50YXJnZXQuY2xvc2VzdCgnLmJ0bicpLmNsYXNzTGlzdFthY3Rpb25dKCdmb2N1cycpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWN0aW9uKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGVsZW1lbnRbYWN0aW9uXSgnY2xpY2snLHRvZ2dsZSxmYWxzZSApO1xuICAgIGVsZW1lbnRbYWN0aW9uXSgna2V5dXAnLGtleUhhbmRsZXIsZmFsc2UpLCBlbGVtZW50W2FjdGlvbl0oJ2tleWRvd24nLHByZXZlbnRTY3JvbGwsZmFsc2UpO1xuICAgIGVsZW1lbnRbYWN0aW9uXSgnZm9jdXNpbicsZm9jdXNUb2dnbGUsZmFsc2UpLCBlbGVtZW50W2FjdGlvbl0oJ2ZvY3Vzb3V0Jyxmb2N1c1RvZ2dsZSxmYWxzZSk7XG4gIH1cbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgIGRlbGV0ZSBlbGVtZW50LkJ1dHRvbjtcbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgZWxlbWVudC5CdXR0b24gJiYgZWxlbWVudC5CdXR0b24uZGlzcG9zZSgpO1xuICBsYWJlbHMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2J0bicpO1xuICBpZiAoIWxhYmVscy5sZW5ndGgpIHsgcmV0dXJuOyB9XG4gIGlmICggIWVsZW1lbnQuQnV0dG9uICkge1xuICAgIHRvZ2dsZUV2ZW50cygxKTtcbiAgfVxuICBlbGVtZW50LnRvZ2dsZWQgPSBmYWxzZTtcbiAgZWxlbWVudC5CdXR0b24gPSBzZWxmO1xuICBBcnJheS5mcm9tKGxhYmVscykubWFwKGZ1bmN0aW9uIChidG4pe1xuICAgICFidG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKVxuICAgICAgJiYgcXVlcnlFbGVtZW50KCdpbnB1dDpjaGVja2VkJyxidG4pXG4gICAgICAmJiBidG4uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgYnRuLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJylcbiAgICAgICYmICFxdWVyeUVsZW1lbnQoJ2lucHV0OmNoZWNrZWQnLGJ0bilcbiAgICAgICYmIGJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgfSk7XG59XG5cbnZhciBtb3VzZUhvdmVyRXZlbnRzID0gKCdvbm1vdXNlbGVhdmUnIGluIGRvY3VtZW50KSA/IFsgJ21vdXNlZW50ZXInLCAnbW91c2VsZWF2ZSddIDogWyAnbW91c2VvdmVyJywgJ21vdXNlb3V0JyBdO1xuXG52YXIgc3VwcG9ydFBhc3NpdmUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gd3JhcCgpe1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHdyYXAsIG9wdHMpO1xuICAgIH0sIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gcmVzdWx0O1xufSkoKTtcblxudmFyIHBhc3NpdmVIYW5kbGVyID0gc3VwcG9ydFBhc3NpdmUgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRJblNjcm9sbFJhbmdlKGVsZW1lbnQpIHtcbiAgdmFyIGJjciA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZXR1cm4gYmNyLnRvcCA8PSB2aWV3cG9ydEhlaWdodCAmJiBiY3IuYm90dG9tID49IDA7XG59XG5cbmZ1bmN0aW9uIENhcm91c2VsIChlbGVtZW50LG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICB2YXJzLCBvcHMsXG4gICAgc2xpZGVDdXN0b21FdmVudCwgc2xpZEN1c3RvbUV2ZW50LFxuICAgIHNsaWRlcywgbGVmdEFycm93LCByaWdodEFycm93LCBpbmRpY2F0b3IsIGluZGljYXRvcnM7XG4gIGZ1bmN0aW9uIHBhdXNlSGFuZGxlcigpIHtcbiAgICBpZiAoIG9wcy5pbnRlcnZhbCAhPT1mYWxzZSAmJiAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhdXNlZCcpICkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdwYXVzZWQnKTtcbiAgICAgICF2YXJzLmlzU2xpZGluZyAmJiAoIGNsZWFySW50ZXJ2YWwodmFycy50aW1lciksIHZhcnMudGltZXIgPSBudWxsICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhhbmRsZXIoKSB7XG4gICAgaWYgKCBvcHMuaW50ZXJ2YWwgIT09IGZhbHNlICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYXVzZWQnKSApIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgncGF1c2VkJyk7XG4gICAgICAhdmFycy5pc1NsaWRpbmcgJiYgKCBjbGVhckludGVydmFsKHZhcnMudGltZXIpLCB2YXJzLnRpbWVyID0gbnVsbCApO1xuICAgICAgIXZhcnMuaXNTbGlkaW5nICYmIHNlbGYuY3ljbGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5kaWNhdG9ySGFuZGxlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh2YXJzLmlzU2xpZGluZykgeyByZXR1cm47IH1cbiAgICB2YXIgZXZlbnRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICBpZiAoIGV2ZW50VGFyZ2V0ICYmICFldmVudFRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICYmIGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGlkZS10bycpICkge1xuICAgICAgdmFycy5pbmRleCA9IHBhcnNlSW50KCBldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xpZGUtdG8nKSk7XG4gICAgfSBlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgc2VsZi5zbGlkZVRvKCB2YXJzLmluZGV4ICk7XG4gIH1cbiAgZnVuY3Rpb24gY29udHJvbHNIYW5kbGVyKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHZhcnMuaXNTbGlkaW5nKSB7IHJldHVybjsgfVxuICAgIHZhciBldmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgaWYgKCBldmVudFRhcmdldCA9PT0gcmlnaHRBcnJvdyApIHtcbiAgICAgIHZhcnMuaW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKCBldmVudFRhcmdldCA9PT0gbGVmdEFycm93ICkge1xuICAgICAgdmFycy5pbmRleC0tO1xuICAgIH1cbiAgICBzZWxmLnNsaWRlVG8oIHZhcnMuaW5kZXggKTtcbiAgfVxuICBmdW5jdGlvbiBrZXlIYW5kbGVyKHJlZikge1xuICAgIHZhciB3aGljaCA9IHJlZi53aGljaDtcbiAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG4gICAgc3dpdGNoICh3aGljaCkge1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgdmFycy5pbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzc6XG4gICAgICAgIHZhcnMuaW5kZXgtLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuc2xpZGVUbyggdmFycy5pbmRleCApO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUV2ZW50cyhhY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgaWYgKCBvcHMucGF1c2UgJiYgb3BzLmludGVydmFsICkge1xuICAgICAgZWxlbWVudFthY3Rpb25dKCBtb3VzZUhvdmVyRXZlbnRzWzBdLCBwYXVzZUhhbmRsZXIsIGZhbHNlICk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oIG1vdXNlSG92ZXJFdmVudHNbMV0sIHJlc3VtZUhhbmRsZXIsIGZhbHNlICk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oICd0b3VjaHN0YXJ0JywgcGF1c2VIYW5kbGVyLCBwYXNzaXZlSGFuZGxlciApO1xuICAgICAgZWxlbWVudFthY3Rpb25dKCAndG91Y2hlbmQnLCByZXN1bWVIYW5kbGVyLCBwYXNzaXZlSGFuZGxlciApO1xuICAgIH1cbiAgICBvcHMudG91Y2ggJiYgc2xpZGVzLmxlbmd0aCA+IDEgJiYgZWxlbWVudFthY3Rpb25dKCAndG91Y2hzdGFydCcsIHRvdWNoRG93bkhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgcmlnaHRBcnJvdyAmJiByaWdodEFycm93W2FjdGlvbl0oICdjbGljaycsIGNvbnRyb2xzSGFuZGxlcixmYWxzZSApO1xuICAgIGxlZnRBcnJvdyAmJiBsZWZ0QXJyb3dbYWN0aW9uXSggJ2NsaWNrJywgY29udHJvbHNIYW5kbGVyLGZhbHNlICk7XG4gICAgaW5kaWNhdG9yICYmIGluZGljYXRvclthY3Rpb25dKCAnY2xpY2snLCBpbmRpY2F0b3JIYW5kbGVyLGZhbHNlICk7XG4gICAgb3BzLmtleWJvYXJkICYmIHdpbmRvd1thY3Rpb25dKCAna2V5ZG93bicsIGtleUhhbmRsZXIsZmFsc2UgKTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVUb3VjaEV2ZW50cyhhY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgZWxlbWVudFthY3Rpb25dKCAndG91Y2htb3ZlJywgdG91Y2hNb3ZlSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICBlbGVtZW50W2FjdGlvbl0oICd0b3VjaGVuZCcsIHRvdWNoRW5kSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgfVxuICBmdW5jdGlvbiB0b3VjaERvd25IYW5kbGVyKGUpIHtcbiAgICBpZiAoIHZhcnMuaXNUb3VjaCApIHsgcmV0dXJuOyB9XG4gICAgdmFycy50b3VjaFBvc2l0aW9uLnN0YXJ0WCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgaWYgKCBlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSApIHtcbiAgICAgIHZhcnMuaXNUb3VjaCA9IHRydWU7XG4gICAgICB0b2dnbGVUb3VjaEV2ZW50cygxKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG91Y2hNb3ZlSGFuZGxlcihlKSB7XG4gICAgaWYgKCAhdmFycy5pc1RvdWNoICkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybjsgfVxuICAgIHZhcnMudG91Y2hQb3NpdGlvbi5jdXJyZW50WCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgaWYgKCBlLnR5cGUgPT09ICd0b3VjaG1vdmUnICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMSApIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG91Y2hFbmRIYW5kbGVyIChlKSB7XG4gICAgaWYgKCAhdmFycy5pc1RvdWNoIHx8IHZhcnMuaXNTbGlkaW5nICkgeyByZXR1cm4gfVxuICAgIHZhcnMudG91Y2hQb3NpdGlvbi5lbmRYID0gdmFycy50b3VjaFBvc2l0aW9uLmN1cnJlbnRYIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgaWYgKCB2YXJzLmlzVG91Y2ggKSB7XG4gICAgICBpZiAoICghZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkgfHwgIWVsZW1lbnQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSApXG4gICAgICAgICAgJiYgTWF0aC5hYnModmFycy50b3VjaFBvc2l0aW9uLnN0YXJ0WCAtIHZhcnMudG91Y2hQb3NpdGlvbi5lbmRYKSA8IDc1ICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIHZhcnMudG91Y2hQb3NpdGlvbi5jdXJyZW50WCA8IHZhcnMudG91Y2hQb3NpdGlvbi5zdGFydFggKSB7XG4gICAgICAgICAgdmFycy5pbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKCB2YXJzLnRvdWNoUG9zaXRpb24uY3VycmVudFggPiB2YXJzLnRvdWNoUG9zaXRpb24uc3RhcnRYICkge1xuICAgICAgICAgIHZhcnMuaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgICB2YXJzLmlzVG91Y2ggPSBmYWxzZTtcbiAgICAgICAgc2VsZi5zbGlkZVRvKHZhcnMuaW5kZXgpO1xuICAgICAgfVxuICAgICAgdG9nZ2xlVG91Y2hFdmVudHMoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWN0aXZlUGFnZShwYWdlSW5kZXgpIHtcbiAgICBBcnJheS5mcm9tKGluZGljYXRvcnMpLm1hcChmdW5jdGlvbiAoeCl7eC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTt9KTtcbiAgICBpbmRpY2F0b3JzW3BhZ2VJbmRleF0gJiYgaW5kaWNhdG9yc1twYWdlSW5kZXhdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRIYW5kbGVyKGUpe1xuICAgIGlmICh2YXJzLnRvdWNoUG9zaXRpb24pe1xuICAgICAgdmFyIG5leHQgPSB2YXJzLmluZGV4LFxuICAgICAgICAgIHRpbWVvdXQgPSBlICYmIGUudGFyZ2V0ICE9PSBzbGlkZXNbbmV4dF0gPyBlLmVsYXBzZWRUaW1lKjEwMDArMTAwIDogMjAsXG4gICAgICAgICAgYWN0aXZlSXRlbSA9IHNlbGYuZ2V0QWN0aXZlSW5kZXgoKSxcbiAgICAgICAgICBvcmllbnRhdGlvbiA9IHZhcnMuZGlyZWN0aW9uID09PSAnbGVmdCcgPyAnbmV4dCcgOiAncHJldic7XG4gICAgICB2YXJzLmlzU2xpZGluZyAmJiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZhcnMudG91Y2hQb3NpdGlvbil7XG4gICAgICAgICAgdmFycy5pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgc2xpZGVzW2FjdGl2ZUl0ZW1dLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgIHNsaWRlc1tuZXh0XS5jbGFzc0xpc3QucmVtb3ZlKChcImNhcm91c2VsLWl0ZW0tXCIgKyBvcmllbnRhdGlvbikpO1xuICAgICAgICAgIHNsaWRlc1tuZXh0XS5jbGFzc0xpc3QucmVtb3ZlKChcImNhcm91c2VsLWl0ZW0tXCIgKyAodmFycy5kaXJlY3Rpb24pKSk7XG4gICAgICAgICAgc2xpZGVzW2FjdGl2ZUl0ZW1dLmNsYXNzTGlzdC5yZW1vdmUoKFwiY2Fyb3VzZWwtaXRlbS1cIiArICh2YXJzLmRpcmVjdGlvbikpKTtcbiAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2xpZEN1c3RvbUV2ZW50KTtcbiAgICAgICAgICBpZiAoICFkb2N1bWVudC5oaWRkZW4gJiYgb3BzLmludGVydmFsICYmICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGF1c2VkJykgKSB7XG4gICAgICAgICAgICBzZWxmLmN5Y2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgc2VsZi5jeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmFycy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKTtcbiAgICAgIHZhcnMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgICB2YXJzLnRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlkeCA9IHZhcnMuaW5kZXggfHwgc2VsZi5nZXRBY3RpdmVJbmRleCgpO1xuICAgICAgaXNFbGVtZW50SW5TY3JvbGxSYW5nZShlbGVtZW50KSAmJiAoaWR4KyssIHNlbGYuc2xpZGVUbyggaWR4ICkgKTtcbiAgICB9LCBvcHMuaW50ZXJ2YWwpO1xuICB9O1xuICBzZWxmLnNsaWRlVG8gPSBmdW5jdGlvbiAobmV4dCkge1xuICAgIGlmICh2YXJzLmlzU2xpZGluZykgeyByZXR1cm47IH1cbiAgICB2YXIgYWN0aXZlSXRlbSA9IHNlbGYuZ2V0QWN0aXZlSW5kZXgoKSwgb3JpZW50YXRpb247XG4gICAgaWYgKCBhY3RpdmVJdGVtID09PSBuZXh0ICkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAgKCAoYWN0aXZlSXRlbSA8IG5leHQgKSB8fCAoYWN0aXZlSXRlbSA9PT0gMCAmJiBuZXh0ID09PSBzbGlkZXMubGVuZ3RoIC0xICkgKSB7XG4gICAgICB2YXJzLmRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgICggKGFjdGl2ZUl0ZW0gPiBuZXh0KSB8fCAoYWN0aXZlSXRlbSA9PT0gc2xpZGVzLmxlbmd0aCAtIDEgJiYgbmV4dCA9PT0gMCApICkge1xuICAgICAgdmFycy5kaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgIH1cbiAgICBpZiAoIG5leHQgPCAwICkgeyBuZXh0ID0gc2xpZGVzLmxlbmd0aCAtIDE7IH1cbiAgICBlbHNlIGlmICggbmV4dCA+PSBzbGlkZXMubGVuZ3RoICl7IG5leHQgPSAwOyB9XG4gICAgb3JpZW50YXRpb24gPSB2YXJzLmRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gJ25leHQnIDogJ3ByZXYnO1xuICAgIHNsaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2xpZGUnLCAnY2Fyb3VzZWwnLCBzbGlkZXNbbmV4dF0pO1xuICAgIHNsaWRDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzbGlkJywgJ2Nhcm91c2VsJywgc2xpZGVzW25leHRdKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2xpZGVDdXN0b21FdmVudCk7XG4gICAgaWYgKHNsaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICB2YXJzLmluZGV4ID0gbmV4dDtcbiAgICB2YXJzLmlzU2xpZGluZyA9IHRydWU7XG4gICAgY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKTtcbiAgICB2YXJzLnRpbWVyID0gbnVsbDtcbiAgICBzZXRBY3RpdmVQYWdlKCBuZXh0ICk7XG4gICAgaWYgKCBnZXRFbGVtZW50VHJhbnNpdGlvbkR1cmF0aW9uKHNsaWRlc1tuZXh0XSkgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3NsaWRlJykgKSB7XG4gICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgoXCJjYXJvdXNlbC1pdGVtLVwiICsgb3JpZW50YXRpb24pKTtcbiAgICAgIHNsaWRlc1tuZXh0XS5vZmZzZXRXaWR0aDtcbiAgICAgIHNsaWRlc1tuZXh0XS5jbGFzc0xpc3QuYWRkKChcImNhcm91c2VsLWl0ZW0tXCIgKyAodmFycy5kaXJlY3Rpb24pKSk7XG4gICAgICBzbGlkZXNbYWN0aXZlSXRlbV0uY2xhc3NMaXN0LmFkZCgoXCJjYXJvdXNlbC1pdGVtLVwiICsgKHZhcnMuZGlyZWN0aW9uKSkpO1xuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoc2xpZGVzW25leHRdLCB0cmFuc2l0aW9uRW5kSGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNsaWRlc1tuZXh0XS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgIHNsaWRlc1tuZXh0XS5vZmZzZXRXaWR0aDtcbiAgICAgIHNsaWRlc1thY3RpdmVJdGVtXS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXJzLmlzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoIG9wcy5pbnRlcnZhbCAmJiBlbGVtZW50ICYmICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGF1c2VkJykgKSB7XG4gICAgICAgICAgc2VsZi5jeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkQ3VzdG9tRXZlbnQpO1xuICAgICAgfSwgMTAwICk7XG4gICAgfVxuICB9O1xuICBzZWxmLmdldEFjdGl2ZUluZGV4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbShzbGlkZXMpLmluZGV4T2YoZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1pdGVtIGFjdGl2ZScpWzBdKSB8fCAwOyB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW1DbGFzc2VzID0gWydsZWZ0JywncmlnaHQnLCdwcmV2JywnbmV4dCddO1xuICAgIEFycmF5LmZyb20oc2xpZGVzKS5tYXAoZnVuY3Rpb24gKHNsaWRlLGlkeCkge1xuICAgICAgc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSAmJiBzZXRBY3RpdmVQYWdlKCBpZHggKTtcbiAgICAgIGl0ZW1DbGFzc2VzLm1hcChmdW5jdGlvbiAoY2xzKSB7IHJldHVybiBzbGlkZS5jbGFzc0xpc3QucmVtb3ZlKChcImNhcm91c2VsLWl0ZW0tXCIgKyBjbHMpKTsgfSk7XG4gICAgfSk7XG4gICAgY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKTtcbiAgICB0b2dnbGVFdmVudHMoKTtcbiAgICB2YXJzID0ge307XG4gICAgb3BzID0ge307XG4gICAgZGVsZXRlIGVsZW1lbnQuQ2Fyb3VzZWw7XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgZWxlbWVudC5DYXJvdXNlbCAmJiBlbGVtZW50LkNhcm91c2VsLmRpc3Bvc2UoKTtcbiAgc2xpZGVzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1pdGVtJyk7XG4gIGxlZnRBcnJvdyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2Fyb3VzZWwtY29udHJvbC1wcmV2JylbMF07XG4gIHJpZ2h0QXJyb3cgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Nhcm91c2VsLWNvbnRyb2wtbmV4dCcpWzBdO1xuICBpbmRpY2F0b3IgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Nhcm91c2VsLWluZGljYXRvcnMnKVswXTtcbiAgaW5kaWNhdG9ycyA9IGluZGljYXRvciAmJiBpbmRpY2F0b3IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiTElcIiApIHx8IFtdO1xuICBpZiAoc2xpZGVzLmxlbmd0aCA8IDIpIHsgcmV0dXJuIH1cbiAgdmFyXG4gICAgaW50ZXJ2YWxBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pbnRlcnZhbCcpLFxuICAgIGludGVydmFsRGF0YSA9IGludGVydmFsQXR0cmlidXRlID09PSAnZmFsc2UnID8gMCA6IHBhcnNlSW50KGludGVydmFsQXR0cmlidXRlKSxcbiAgICB0b3VjaERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10b3VjaCcpID09PSAnZmFsc2UnID8gMCA6IDEsXG4gICAgcGF1c2VEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGF1c2UnKSA9PT0gJ2hvdmVyJyB8fCBmYWxzZSxcbiAgICBrZXlib2FyZERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1rZXlib2FyZCcpID09PSAndHJ1ZScgfHwgZmFsc2UsXG4gICAgaW50ZXJ2YWxPcHRpb24gPSBvcHRpb25zLmludGVydmFsLFxuICAgIHRvdWNoT3B0aW9uID0gb3B0aW9ucy50b3VjaDtcbiAgb3BzID0ge307XG4gIG9wcy5rZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQgPT09IHRydWUgfHwga2V5Ym9hcmREYXRhO1xuICBvcHMucGF1c2UgPSAob3B0aW9ucy5wYXVzZSA9PT0gJ2hvdmVyJyB8fCBwYXVzZURhdGEpID8gJ2hvdmVyJyA6IGZhbHNlO1xuICBvcHMudG91Y2ggPSB0b3VjaE9wdGlvbiB8fCB0b3VjaERhdGE7XG4gIG9wcy5pbnRlcnZhbCA9IHR5cGVvZiBpbnRlcnZhbE9wdGlvbiA9PT0gJ251bWJlcicgPyBpbnRlcnZhbE9wdGlvblxuICAgICAgICAgICAgICA6IGludGVydmFsT3B0aW9uID09PSBmYWxzZSB8fCBpbnRlcnZhbERhdGEgPT09IDAgfHwgaW50ZXJ2YWxEYXRhID09PSBmYWxzZSA/IDBcbiAgICAgICAgICAgICAgOiBpc05hTihpbnRlcnZhbERhdGEpID8gNTAwMFxuICAgICAgICAgICAgICA6IGludGVydmFsRGF0YTtcbiAgaWYgKHNlbGYuZ2V0QWN0aXZlSW5kZXgoKTwwKSB7XG4gICAgc2xpZGVzLmxlbmd0aCAmJiBzbGlkZXNbMF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgaW5kaWNhdG9ycy5sZW5ndGggJiYgc2V0QWN0aXZlUGFnZSgwKTtcbiAgfVxuICB2YXJzID0ge307XG4gIHZhcnMuZGlyZWN0aW9uID0gJ2xlZnQnO1xuICB2YXJzLmluZGV4ID0gMDtcbiAgdmFycy50aW1lciA9IG51bGw7XG4gIHZhcnMuaXNTbGlkaW5nID0gZmFsc2U7XG4gIHZhcnMuaXNUb3VjaCA9IGZhbHNlO1xuICB2YXJzLnRvdWNoUG9zaXRpb24gPSB7XG4gICAgc3RhcnRYIDogMCxcbiAgICBjdXJyZW50WCA6IDAsXG4gICAgZW5kWCA6IDBcbiAgfTtcbiAgdG9nZ2xlRXZlbnRzKDEpO1xuICBpZiAoIG9wcy5pbnRlcnZhbCApeyBzZWxmLmN5Y2xlKCk7IH1cbiAgZWxlbWVudC5DYXJvdXNlbCA9IHNlbGY7XG59XG5cbmZ1bmN0aW9uIENvbGxhcHNlKGVsZW1lbnQsb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYWNjb3JkaW9uID0gbnVsbCxcbiAgICAgIGNvbGxhcHNlID0gbnVsbCxcbiAgICAgIGFjdGl2ZUNvbGxhcHNlLFxuICAgICAgYWN0aXZlRWxlbWVudCxcbiAgICAgIHNob3dDdXN0b21FdmVudCxcbiAgICAgIHNob3duQ3VzdG9tRXZlbnQsXG4gICAgICBoaWRlQ3VzdG9tRXZlbnQsXG4gICAgICBoaWRkZW5DdXN0b21FdmVudDtcbiAgZnVuY3Rpb24gb3BlbkFjdGlvbihjb2xsYXBzZUVsZW1lbnQsIHRvZ2dsZSkge1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIHNob3dDdXN0b21FdmVudCk7XG4gICAgaWYgKCBzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgY29sbGFwc2VFbGVtZW50LmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2luZycpO1xuICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzZScpO1xuICAgIGNvbGxhcHNlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoY29sbGFwc2VFbGVtZW50LnNjcm9sbEhlaWdodCkgKyBcInB4XCI7XG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoY29sbGFwc2VFbGVtZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCd0cnVlJyk7XG4gICAgICB0b2dnbGUuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywndHJ1ZScpO1xuICAgICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbGxhcHNpbmcnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZScpO1xuICAgICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIHNob3duQ3VzdG9tRXZlbnQpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNsb3NlQWN0aW9uKGNvbGxhcHNlRWxlbWVudCwgdG9nZ2xlKSB7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGNvbGxhcHNlRWxlbWVudCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICBpZiAoIGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICBjb2xsYXBzZUVsZW1lbnQuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgIGNvbGxhcHNlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoY29sbGFwc2VFbGVtZW50LnNjcm9sbEhlaWdodCkgKyBcInB4XCI7XG4gICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbGxhcHNlJyk7XG4gICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2luZycpO1xuICAgIGNvbGxhcHNlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICBjb2xsYXBzZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoY29sbGFwc2VFbGVtZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCdmYWxzZScpO1xuICAgICAgdG9nZ2xlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsJ2ZhbHNlJyk7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2luZycpO1xuICAgICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlJyk7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBoaWRkZW5DdXN0b21FdmVudCk7XG4gICAgfSk7XG4gIH1cbiAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlICYmIGUudGFyZ2V0LnRhZ05hbWUgPT09ICdBJyB8fCBlbGVtZW50LnRhZ05hbWUgPT09ICdBJykge2UucHJldmVudERlZmF1bHQoKTt9XG4gICAgaWYgKGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpIHx8IGUudGFyZ2V0ID09PSBlbGVtZW50KSB7XG4gICAgICBpZiAoIWNvbGxhcHNlLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7IHNlbGYuc2hvdygpOyB9XG4gICAgICBlbHNlIHsgc2VsZi5oaWRlKCk7IH1cbiAgICB9XG4gIH07XG4gIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIGNvbGxhcHNlLmlzQW5pbWF0aW5nICkgeyByZXR1cm47IH1cbiAgICBjbG9zZUFjdGlvbihjb2xsYXBzZSxlbGVtZW50KTtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlZCcpO1xuICB9O1xuICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCBhY2NvcmRpb24gKSB7XG4gICAgICBhY3RpdmVDb2xsYXBzZSA9IGFjY29yZGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiY29sbGFwc2Ugc2hvd1wiKVswXTtcbiAgICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVDb2xsYXBzZSAmJiAocXVlcnlFbGVtZW50KChcIltkYXRhLXRhcmdldD1cXFwiI1wiICsgKGFjdGl2ZUNvbGxhcHNlLmlkKSArIFwiXFxcIl1cIiksYWNjb3JkaW9uKVxuICAgICAgICAgICAgICAgICAgICB8fCBxdWVyeUVsZW1lbnQoKFwiW2hyZWY9XFxcIiNcIiArIChhY3RpdmVDb2xsYXBzZS5pZCkgKyBcIlxcXCJdXCIpLGFjY29yZGlvbikgKTtcbiAgICB9XG4gICAgaWYgKCAhY29sbGFwc2UuaXNBbmltYXRpbmcgKSB7XG4gICAgICBpZiAoIGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlQ29sbGFwc2UgIT09IGNvbGxhcHNlICkge1xuICAgICAgICBjbG9zZUFjdGlvbihhY3RpdmVDb2xsYXBzZSxhY3RpdmVFbGVtZW50KTtcbiAgICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcbiAgICAgIH1cbiAgICAgIG9wZW5BY3Rpb24oY29sbGFwc2UsZWxlbWVudCk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbGxhcHNlZCcpO1xuICAgIH1cbiAgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLHNlbGYudG9nZ2xlLGZhbHNlKTtcbiAgICBkZWxldGUgZWxlbWVudC5Db2xsYXBzZTtcbiAgfTtcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuQ29sbGFwc2UgJiYgZWxlbWVudC5Db2xsYXBzZS5kaXNwb3NlKCk7XG4gICAgdmFyIGFjY29yZGlvbkRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1wYXJlbnQnKTtcbiAgICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICdjb2xsYXBzZScpO1xuICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAnY29sbGFwc2UnKTtcbiAgICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZScsICdjb2xsYXBzZScpO1xuICAgIGhpZGRlbkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGRlbicsICdjb2xsYXBzZScpO1xuICAgIGNvbGxhcHNlID0gcXVlcnlFbGVtZW50KG9wdGlvbnMudGFyZ2V0IHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJykpO1xuICAgIGNvbGxhcHNlLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgYWNjb3JkaW9uID0gZWxlbWVudC5jbG9zZXN0KG9wdGlvbnMucGFyZW50IHx8IGFjY29yZGlvbkRhdGEpO1xuICAgIGlmICggIWVsZW1lbnQuQ29sbGFwc2UgKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxzZWxmLnRvZ2dsZSxmYWxzZSk7XG4gICAgfVxuICAgIGVsZW1lbnQuQ29sbGFwc2UgPSBzZWxmO1xufVxuXG5mdW5jdGlvbiBzZXRGb2N1cyAoZWxlbWVudCl7XG4gIGVsZW1lbnQuZm9jdXMgPyBlbGVtZW50LmZvY3VzKCkgOiBlbGVtZW50LnNldEFjdGl2ZSgpO1xufVxuXG5mdW5jdGlvbiBEcm9wZG93bihlbGVtZW50LG9wdGlvbikge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBzaG93Q3VzdG9tRXZlbnQsXG4gICAgICBzaG93bkN1c3RvbUV2ZW50LFxuICAgICAgaGlkZUN1c3RvbUV2ZW50LFxuICAgICAgaGlkZGVuQ3VzdG9tRXZlbnQsXG4gICAgICByZWxhdGVkVGFyZ2V0ID0gbnVsbCxcbiAgICAgIHBhcmVudCwgbWVudSwgbWVudUl0ZW1zID0gW10sXG4gICAgICBwZXJzaXN0O1xuICBmdW5jdGlvbiBwcmV2ZW50RW1wdHlBbmNob3IoYW5jaG9yKSB7XG4gICAgKGFuY2hvci5ocmVmICYmIGFuY2hvci5ocmVmLnNsaWNlKC0xKSA9PT0gJyMnIHx8IGFuY2hvci5wYXJlbnROb2RlICYmIGFuY2hvci5wYXJlbnROb2RlLmhyZWZcbiAgICAgICYmIGFuY2hvci5wYXJlbnROb2RlLmhyZWYuc2xpY2UoLTEpID09PSAnIycpICYmIHRoaXMucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVEaXNtaXNzKCkge1xuICAgIHZhciBhY3Rpb24gPSBlbGVtZW50Lm9wZW4gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgZG9jdW1lbnRbYWN0aW9uXSgnY2xpY2snLGRpc21pc3NIYW5kbGVyLGZhbHNlKTtcbiAgICBkb2N1bWVudFthY3Rpb25dKCdrZXlkb3duJyxwcmV2ZW50U2Nyb2xsLGZhbHNlKTtcbiAgICBkb2N1bWVudFthY3Rpb25dKCdrZXl1cCcsa2V5SGFuZGxlcixmYWxzZSk7XG4gICAgZG9jdW1lbnRbYWN0aW9uXSgnZm9jdXMnLGRpc21pc3NIYW5kbGVyLGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNtaXNzSGFuZGxlcihlKSB7XG4gICAgdmFyIGV2ZW50VGFyZ2V0ID0gZS50YXJnZXQsXG4gICAgICAgICAgaGFzRGF0YSA9IGV2ZW50VGFyZ2V0ICYmIChldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9nZ2xlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZXZlbnRUYXJnZXQucGFyZW50Tm9kZSAmJiBldmVudFRhcmdldC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBldmVudFRhcmdldC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS10b2dnbGUnKSk7XG4gICAgaWYgKCBlLnR5cGUgPT09ICdmb2N1cycgJiYgKGV2ZW50VGFyZ2V0ID09PSBlbGVtZW50IHx8IGV2ZW50VGFyZ2V0ID09PSBtZW51IHx8IG1lbnUuY29udGFpbnMoZXZlbnRUYXJnZXQpICkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICggKGV2ZW50VGFyZ2V0ID09PSBtZW51IHx8IG1lbnUuY29udGFpbnMoZXZlbnRUYXJnZXQpKSAmJiAocGVyc2lzdCB8fCBoYXNEYXRhKSApIHsgcmV0dXJuOyB9XG4gICAgZWxzZSB7XG4gICAgICByZWxhdGVkVGFyZ2V0ID0gZXZlbnRUYXJnZXQgPT09IGVsZW1lbnQgfHwgZWxlbWVudC5jb250YWlucyhldmVudFRhcmdldCkgPyBlbGVtZW50IDogbnVsbDtcbiAgICAgIHNlbGYuaGlkZSgpO1xuICAgIH1cbiAgICBwcmV2ZW50RW1wdHlBbmNob3IuY2FsbChlLGV2ZW50VGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgIHJlbGF0ZWRUYXJnZXQgPSBlbGVtZW50O1xuICAgIHNlbGYuc2hvdygpO1xuICAgIHByZXZlbnRFbXB0eUFuY2hvci5jYWxsKGUsZS50YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXZlbnRTY3JvbGwoZSkge1xuICAgIHZhciBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICBpZigga2V5ID09PSAzOCB8fCBrZXkgPT09IDQwICkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgfVxuICBmdW5jdGlvbiBrZXlIYW5kbGVyKGUpIHtcbiAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGUsXG4gICAgICAgIGFjdGl2ZUl0ZW0gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50LFxuICAgICAgICBpc1NhbWVFbGVtZW50ID0gYWN0aXZlSXRlbSA9PT0gZWxlbWVudCxcbiAgICAgICAgaXNJbnNpZGVNZW51ID0gbWVudS5jb250YWlucyhhY3RpdmVJdGVtKSxcbiAgICAgICAgaXNNZW51SXRlbSA9IGFjdGl2ZUl0ZW0ucGFyZW50Tm9kZSA9PT0gbWVudSB8fCBhY3RpdmVJdGVtLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PT0gbWVudSxcbiAgICAgICAgaWR4ID0gbWVudUl0ZW1zLmluZGV4T2YoYWN0aXZlSXRlbSk7XG4gICAgaWYgKCBpc01lbnVJdGVtICkge1xuICAgICAgaWR4ID0gaXNTYW1lRWxlbWVudCA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBrZXkgPT09IDM4ID8gKGlkeD4xP2lkeC0xOjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDoga2V5ID09PSA0MCA/IChpZHg8bWVudUl0ZW1zLmxlbmd0aC0xP2lkeCsxOmlkeCkgOiBpZHg7XG4gICAgICBtZW51SXRlbXNbaWR4XSAmJiBzZXRGb2N1cyhtZW51SXRlbXNbaWR4XSk7XG4gICAgfVxuICAgIGlmICggKG1lbnVJdGVtcy5sZW5ndGggJiYgaXNNZW51SXRlbVxuICAgICAgICAgIHx8ICFtZW51SXRlbXMubGVuZ3RoICYmIChpc0luc2lkZU1lbnUgfHwgaXNTYW1lRWxlbWVudClcbiAgICAgICAgICB8fCAhaXNJbnNpZGVNZW51IClcbiAgICAgICAgICAmJiBlbGVtZW50Lm9wZW4gJiYga2V5ID09PSAyN1xuICAgICkge1xuICAgICAgc2VsZi50b2dnbGUoKTtcbiAgICAgIHJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAnZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBzaG93Q3VzdG9tRXZlbnQpO1xuICAgIGlmICggc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgIG1lbnUuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgIHBhcmVudC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLHRydWUpO1xuICAgIGVsZW1lbnQub3BlbiA9IHRydWU7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tIYW5kbGVyLGZhbHNlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldEZvY3VzKCBtZW51LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdJTlBVVCcpWzBdIHx8IGVsZW1lbnQgKTtcbiAgICAgIHRvZ2dsZURpc21pc3MoKTtcbiAgICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCggJ3Nob3duJywgJ2Ryb3Bkb3duJywgcmVsYXRlZFRhcmdldCk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgICB9LDEpO1xuICB9O1xuICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAnZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgIGlmICggaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgIG1lbnUuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLGZhbHNlKTtcbiAgICBlbGVtZW50Lm9wZW4gPSBmYWxzZTtcbiAgICB0b2dnbGVEaXNtaXNzKCk7XG4gICAgc2V0Rm9jdXMoZWxlbWVudCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50LkRyb3Bkb3duICYmIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSGFuZGxlcixmYWxzZSk7XG4gICAgfSwxKTtcbiAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAnZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBoaWRkZW5DdXN0b21FdmVudCk7XG4gIH07XG4gIHNlbGYudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgZWxlbWVudC5vcGVuKSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgZWxzZSB7IHNlbGYuc2hvdygpOyB9XG4gIH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmIGVsZW1lbnQub3BlbikgeyBzZWxmLmhpZGUoKTsgfVxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSGFuZGxlcixmYWxzZSk7XG4gICAgZGVsZXRlIGVsZW1lbnQuRHJvcGRvd247XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIGVsZW1lbnQuRHJvcGRvd24gJiYgZWxlbWVudC5Ecm9wZG93bi5kaXNwb3NlKCk7XG4gIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgbWVudSA9IHF1ZXJ5RWxlbWVudCgnLmRyb3Bkb3duLW1lbnUnLCBwYXJlbnQpO1xuICBBcnJheS5mcm9tKG1lbnUuY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoY2hpbGQpe1xuICAgIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCAmJiAoY2hpbGQuY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gJ0EnICYmIG1lbnVJdGVtcy5wdXNoKGNoaWxkLmNoaWxkcmVuWzBdKSk7XG4gICAgY2hpbGQudGFnTmFtZSA9PT0gJ0EnICYmIG1lbnVJdGVtcy5wdXNoKGNoaWxkKTtcbiAgfSk7XG4gIGlmICggIWVsZW1lbnQuRHJvcGRvd24gKSB7XG4gICAgISgndGFiaW5kZXgnIGluIG1lbnUpICYmIG1lbnUuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tIYW5kbGVyLGZhbHNlKTtcbiAgfVxuICBwZXJzaXN0ID0gb3B0aW9uID09PSB0cnVlIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBlcnNpc3QnKSA9PT0gJ3RydWUnIHx8IGZhbHNlO1xuICBlbGVtZW50Lm9wZW4gPSBmYWxzZTtcbiAgZWxlbWVudC5Ecm9wZG93biA9IHNlbGY7XG59XG5cbmZ1bmN0aW9uIE1vZGFsKGVsZW1lbnQsb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzLCBtb2RhbCxcbiAgICBzaG93Q3VzdG9tRXZlbnQsXG4gICAgc2hvd25DdXN0b21FdmVudCxcbiAgICBoaWRlQ3VzdG9tRXZlbnQsXG4gICAgaGlkZGVuQ3VzdG9tRXZlbnQsXG4gICAgcmVsYXRlZFRhcmdldCA9IG51bGwsXG4gICAgc2Nyb2xsQmFyV2lkdGgsXG4gICAgb3ZlcmxheSxcbiAgICBvdmVybGF5RGVsYXksXG4gICAgZml4ZWRJdGVtcyxcbiAgICBvcHMgPSB7fTtcbiAgZnVuY3Rpb24gc2V0U2Nyb2xsYmFyKCkge1xuICAgIHZhciBvcGVuTW9kYWwgPSBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnbW9kYWwtb3BlbicpLFxuICAgICAgICBib2R5UGFkID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5wYWRkaW5nUmlnaHQpLFxuICAgICAgICBib2R5T3ZlcmZsb3cgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0ICE9PSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxcbiAgICAgICAgbW9kYWxPdmVyZmxvdyA9IG1vZGFsLmNsaWVudEhlaWdodCAhPT0gbW9kYWwuc2Nyb2xsSGVpZ2h0O1xuICAgIHNjcm9sbEJhcldpZHRoID0gbWVhc3VyZVNjcm9sbGJhcigpO1xuICAgIG1vZGFsLnN0eWxlLnBhZGRpbmdSaWdodCA9ICFtb2RhbE92ZXJmbG93ICYmIHNjcm9sbEJhcldpZHRoID8gKHNjcm9sbEJhcldpZHRoICsgXCJweFwiKSA6ICcnO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gbW9kYWxPdmVyZmxvdyB8fCBib2R5T3ZlcmZsb3cgPyAoKGJvZHlQYWQgKyAob3Blbk1vZGFsID8gMDpzY3JvbGxCYXJXaWR0aCkpICsgXCJweFwiKSA6ICcnO1xuICAgIGZpeGVkSXRlbXMubGVuZ3RoICYmIGZpeGVkSXRlbXMubWFwKGZ1bmN0aW9uIChmaXhlZCl7XG4gICAgICB2YXIgaXRlbVBhZCA9IGdldENvbXB1dGVkU3R5bGUoZml4ZWQpLnBhZGRpbmdSaWdodDtcbiAgICAgIGZpeGVkLnN0eWxlLnBhZGRpbmdSaWdodCA9IG1vZGFsT3ZlcmZsb3cgfHwgYm9keU92ZXJmbG93ID8gKChwYXJzZUludChpdGVtUGFkKSArIChvcGVuTW9kYWw/MDpzY3JvbGxCYXJXaWR0aCkpICsgXCJweFwiKSA6ICgocGFyc2VJbnQoaXRlbVBhZCkpICsgXCJweFwiKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXNldFNjcm9sbGJhcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgIG1vZGFsLnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgIGZpeGVkSXRlbXMubGVuZ3RoICYmIGZpeGVkSXRlbXMubWFwKGZ1bmN0aW9uIChmaXhlZCl7XG4gICAgICBmaXhlZC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlU2Nyb2xsYmFyKCkge1xuICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgd2lkdGhWYWx1ZTtcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdik7XG4gICAgd2lkdGhWYWx1ZSA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG4gICAgcmV0dXJuIHdpZHRoVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlT3ZlcmxheSgpIHtcbiAgICB2YXIgbmV3T3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG92ZXJsYXkgPSBxdWVyeUVsZW1lbnQoJy5tb2RhbC1iYWNrZHJvcCcpO1xuICAgIGlmICggb3ZlcmxheSA9PT0gbnVsbCApIHtcbiAgICAgIG5ld092ZXJsYXkuc2V0QXR0cmlidXRlKCdjbGFzcycsICdtb2RhbC1iYWNrZHJvcCcgKyAob3BzLmFuaW1hdGlvbiA/ICcgZmFkZScgOiAnJykpO1xuICAgICAgb3ZlcmxheSA9IG5ld092ZXJsYXk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG92ZXJsYXkpO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcmxheTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPdmVybGF5ICgpIHtcbiAgICBvdmVybGF5ID0gcXVlcnlFbGVtZW50KCcubW9kYWwtYmFja2Ryb3AnKTtcbiAgICBpZiAoIG92ZXJsYXkgJiYgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsIHNob3cnKVswXSApIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheSk7IG92ZXJsYXkgPSBudWxsO1xuICAgIH1cbiAgICBvdmVybGF5ID09PSBudWxsICYmIChkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ21vZGFsLW9wZW4nKSwgcmVzZXRTY3JvbGxiYXIoKSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFjdGlvbikge1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICB3aW5kb3dbYWN0aW9uXSggJ3Jlc2l6ZScsIHNlbGYudXBkYXRlLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgbW9kYWxbYWN0aW9uXSggJ2NsaWNrJyxkaXNtaXNzSGFuZGxlcixmYWxzZSk7XG4gICAgZG9jdW1lbnRbYWN0aW9uXSggJ2tleWRvd24nLGtleUhhbmRsZXIsZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGJlZm9yZVNob3coKSB7XG4gICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgc2V0U2Nyb2xsYmFyKCk7XG4gICAgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsIHNob3cnKVswXSAmJiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ21vZGFsLW9wZW4nKTtcbiAgICBtb2RhbC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgbW9kYWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcbiAgICBtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKG1vZGFsLCB0cmlnZ2VyU2hvdykgOiB0cmlnZ2VyU2hvdygpO1xuICB9XG4gIGZ1bmN0aW9uIHRyaWdnZXJTaG93KCkge1xuICAgIHNldEZvY3VzKG1vZGFsKTtcbiAgICBtb2RhbC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIHRvZ2dsZUV2ZW50cygxKTtcbiAgICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3duJywgJ21vZGFsJywgcmVsYXRlZFRhcmdldCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKG1vZGFsLCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiB0cmlnZ2VySGlkZShmb3JjZSkge1xuICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICBlbGVtZW50ICYmIChzZXRGb2N1cyhlbGVtZW50KSk7XG4gICAgb3ZlcmxheSA9IHF1ZXJ5RWxlbWVudCgnLm1vZGFsLWJhY2tkcm9wJyk7XG4gICAgaWYgKGZvcmNlICE9PSAxICYmIG92ZXJsYXkgJiYgb3ZlcmxheS5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSAmJiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbW9kYWwgc2hvdycpWzBdKSB7XG4gICAgICBvdmVybGF5LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKG92ZXJsYXkscmVtb3ZlT3ZlcmxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU92ZXJsYXkoKTtcbiAgICB9XG4gICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgbW9kYWwuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAnbW9kYWwnKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgIGlmICggbW9kYWwuaXNBbmltYXRpbmcgKSB7IHJldHVybjsgfVxuICAgIHZhciBjbGlja1RhcmdldCA9IGUudGFyZ2V0LFxuICAgICAgICBtb2RhbElEID0gXCIjXCIgKyAobW9kYWwuZ2V0QXR0cmlidXRlKCdpZCcpKSxcbiAgICAgICAgdGFyZ2V0QXR0clZhbHVlID0gY2xpY2tUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpIHx8IGNsaWNrVGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpLFxuICAgICAgICBlbGVtQXR0clZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICBpZiAoICFtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKVxuICAgICAgICAmJiAoY2xpY2tUYXJnZXQgPT09IGVsZW1lbnQgJiYgdGFyZ2V0QXR0clZhbHVlID09PSBtb2RhbElEXG4gICAgICAgIHx8IGVsZW1lbnQuY29udGFpbnMoY2xpY2tUYXJnZXQpICYmIGVsZW1BdHRyVmFsdWUgPT09IG1vZGFsSUQpICkge1xuICAgICAgbW9kYWwubW9kYWxUcmlnZ2VyID0gZWxlbWVudDtcbiAgICAgIHJlbGF0ZWRUYXJnZXQgPSBlbGVtZW50O1xuICAgICAgc2VsZi5zaG93KCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGtleUhhbmRsZXIocmVmKSB7XG4gICAgdmFyIHdoaWNoID0gcmVmLndoaWNoO1xuICAgIGlmICghbW9kYWwuaXNBbmltYXRpbmcgJiYgb3BzLmtleWJvYXJkICYmIHdoaWNoID09IDI3ICYmIG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICkge1xuICAgICAgc2VsZi5oaWRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRpc21pc3NIYW5kbGVyKGUpIHtcbiAgICBpZiAoIG1vZGFsLmlzQW5pbWF0aW5nICkgeyByZXR1cm47IH1cbiAgICB2YXIgY2xpY2tUYXJnZXQgPSBlLnRhcmdldCxcbiAgICAgICAgaGFzRGF0YSA9IGNsaWNrVGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1kaXNtaXNzJykgPT09ICdtb2RhbCcsXG4gICAgICAgIHBhcmVudFdpdGhEYXRhID0gY2xpY2tUYXJnZXQuY2xvc2VzdCgnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJyk7XG4gICAgaWYgKCBtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSAmJiAoIHBhcmVudFdpdGhEYXRhIHx8IGhhc0RhdGFcbiAgICAgICAgfHwgY2xpY2tUYXJnZXQgPT09IG1vZGFsICYmIG9wcy5iYWNrZHJvcCAhPT0gJ3N0YXRpYycgKSApIHtcbiAgICAgIHNlbGYuaGlkZSgpOyByZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCBtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSApIHtzZWxmLmhpZGUoKTt9IGVsc2Uge3NlbGYuc2hvdygpO31cbiAgfTtcbiAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSAmJiAhIW1vZGFsLmlzQW5pbWF0aW5nICkge3JldHVybn1cbiAgICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICdtb2RhbCcsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICBpZiAoIHNob3dDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICBtb2RhbC5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRPcGVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbW9kYWwgc2hvdycpWzBdO1xuICAgIGlmIChjdXJyZW50T3BlbiAmJiBjdXJyZW50T3BlbiAhPT0gbW9kYWwpIHtcbiAgICAgIGN1cnJlbnRPcGVuLm1vZGFsVHJpZ2dlciAmJiBjdXJyZW50T3Blbi5tb2RhbFRyaWdnZXIuTW9kYWwuaGlkZSgpO1xuICAgICAgY3VycmVudE9wZW4uTW9kYWwgJiYgY3VycmVudE9wZW4uTW9kYWwuaGlkZSgpO1xuICAgIH1cbiAgICBpZiAoIG9wcy5iYWNrZHJvcCApIHtcbiAgICAgIG92ZXJsYXkgPSBjcmVhdGVPdmVybGF5KCk7XG4gICAgfVxuICAgIGlmICggb3ZlcmxheSAmJiAhY3VycmVudE9wZW4gJiYgIW92ZXJsYXkuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgKSB7XG4gICAgICBvdmVybGF5Lm9mZnNldFdpZHRoO1xuICAgICAgb3ZlcmxheURlbGF5ID0gZ2V0RWxlbWVudFRyYW5zaXRpb25EdXJhdGlvbihvdmVybGF5KTtcbiAgICAgIG92ZXJsYXkuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgIH1cbiAgICAhY3VycmVudE9wZW4gPyBzZXRUaW1lb3V0KCBiZWZvcmVTaG93LCBvdmVybGF5ICYmIG92ZXJsYXlEZWxheSA/IG92ZXJsYXlEZWxheTowICkgOiBiZWZvcmVTaG93KCk7XG4gIH07XG4gIHNlbGYuaGlkZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgIGlmICggIW1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICkge3JldHVybn1cbiAgICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCggJ2hpZGUnLCAnbW9kYWwnKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIGhpZGVDdXN0b21FdmVudCk7XG4gICAgaWYgKCBoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgbW9kYWwuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgIG1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykgJiYgZm9yY2UgIT09IDEgPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChtb2RhbCwgdHJpZ2dlckhpZGUpIDogdHJpZ2dlckhpZGUoKTtcbiAgfTtcbiAgc2VsZi5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICBxdWVyeUVsZW1lbnQoJy5tb2RhbC1jb250ZW50Jyxtb2RhbCkuaW5uZXJIVE1MID0gY29udGVudDtcbiAgfTtcbiAgc2VsZi51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICBzZXRTY3JvbGxiYXIoKTtcbiAgICB9XG4gIH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmhpZGUoMSk7XG4gICAgaWYgKGVsZW1lbnQpIHtlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja0hhbmRsZXIsZmFsc2UpOyBkZWxldGUgZWxlbWVudC5Nb2RhbDsgfVxuICAgIGVsc2Uge2RlbGV0ZSBtb2RhbC5Nb2RhbDt9XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciBjaGVja01vZGFsID0gcXVlcnlFbGVtZW50KCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpICk7XG4gIG1vZGFsID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ21vZGFsJykgPyBlbGVtZW50IDogY2hlY2tNb2RhbDtcbiAgZml4ZWRJdGVtcyA9IEFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZml4ZWQtdG9wJykpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmaXhlZC1ib3R0b20nKSkpO1xuICBpZiAoIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbCcpICkgeyBlbGVtZW50ID0gbnVsbDsgfVxuICBlbGVtZW50ICYmIGVsZW1lbnQuTW9kYWwgJiYgZWxlbWVudC5Nb2RhbC5kaXNwb3NlKCk7XG4gIG1vZGFsICYmIG1vZGFsLk1vZGFsICYmIG1vZGFsLk1vZGFsLmRpc3Bvc2UoKTtcbiAgb3BzLmtleWJvYXJkID0gb3B0aW9ucy5rZXlib2FyZCA9PT0gZmFsc2UgfHwgbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWtleWJvYXJkJykgPT09ICdmYWxzZScgPyBmYWxzZSA6IHRydWU7XG4gIG9wcy5iYWNrZHJvcCA9IG9wdGlvbnMuYmFja2Ryb3AgPT09ICdzdGF0aWMnIHx8IG1vZGFsLmdldEF0dHJpYnV0ZSgnZGF0YS1iYWNrZHJvcCcpID09PSAnc3RhdGljJyA/ICdzdGF0aWMnIDogdHJ1ZTtcbiAgb3BzLmJhY2tkcm9wID0gb3B0aW9ucy5iYWNrZHJvcCA9PT0gZmFsc2UgfHwgbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWJhY2tkcm9wJykgPT09ICdmYWxzZScgPyBmYWxzZSA6IG9wcy5iYWNrZHJvcDtcbiAgb3BzLmFuaW1hdGlvbiA9IG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnZmFkZScpID8gdHJ1ZSA6IGZhbHNlO1xuICBvcHMuY29udGVudCA9IG9wdGlvbnMuY29udGVudDtcbiAgbW9kYWwuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgaWYgKCBlbGVtZW50ICYmICFlbGVtZW50Lk1vZGFsICkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSGFuZGxlcixmYWxzZSk7XG4gIH1cbiAgaWYgKCBvcHMuY29udGVudCApIHtcbiAgICBzZWxmLnNldENvbnRlbnQoIG9wcy5jb250ZW50LnRyaW0oKSApO1xuICB9XG4gIGlmIChlbGVtZW50KSB7XG4gICAgbW9kYWwubW9kYWxUcmlnZ2VyID0gZWxlbWVudDtcbiAgICBlbGVtZW50Lk1vZGFsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICBtb2RhbC5Nb2RhbCA9IHNlbGY7XG4gIH1cbn1cblxudmFyIG1vdXNlQ2xpY2tFdmVudHMgPSB7IGRvd246ICdtb3VzZWRvd24nLCB1cDogJ21vdXNldXAnIH07XG5cbmZ1bmN0aW9uIGdldFNjcm9sbCgpIHtcbiAgcmV0dXJuIHtcbiAgICB5IDogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgeCA6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdFxuICB9XG59XG5cbmZ1bmN0aW9uIHN0eWxlVGlwKGxpbmssZWxlbWVudCxwb3NpdGlvbixwYXJlbnQpIHtcbiAgdmFyIHRpcFBvc2l0aW9ucyA9IC9cXGIodG9wfGJvdHRvbXxsZWZ0fHJpZ2h0KSsvLFxuICAgICAgZWxlbWVudERpbWVuc2lvbnMgPSB7IHcgOiBlbGVtZW50Lm9mZnNldFdpZHRoLCBoOiBlbGVtZW50Lm9mZnNldEhlaWdodCB9LFxuICAgICAgd2luZG93V2lkdGggPSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpLFxuICAgICAgd2luZG93SGVpZ2h0ID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpLFxuICAgICAgcmVjdCA9IGxpbmsuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBzY3JvbGwgPSBwYXJlbnQgPT09IGRvY3VtZW50LmJvZHkgPyBnZXRTY3JvbGwoKSA6IHsgeDogcGFyZW50Lm9mZnNldExlZnQgKyBwYXJlbnQuc2Nyb2xsTGVmdCwgeTogcGFyZW50Lm9mZnNldFRvcCArIHBhcmVudC5zY3JvbGxUb3AgfSxcbiAgICAgIGxpbmtEaW1lbnNpb25zID0geyB3OiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCBoOiByZWN0LmJvdHRvbSAtIHJlY3QudG9wIH0sXG4gICAgICBpc1BvcG92ZXIgPSBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncG9wb3ZlcicpLFxuICAgICAgYXJyb3cgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Fycm93JylbMF0sXG4gICAgICBoYWxmVG9wRXhjZWVkID0gcmVjdC50b3AgKyBsaW5rRGltZW5zaW9ucy5oLzIgLSBlbGVtZW50RGltZW5zaW9ucy5oLzIgPCAwLFxuICAgICAgaGFsZkxlZnRFeGNlZWQgPSByZWN0LmxlZnQgKyBsaW5rRGltZW5zaW9ucy53LzIgLSBlbGVtZW50RGltZW5zaW9ucy53LzIgPCAwLFxuICAgICAgaGFsZlJpZ2h0RXhjZWVkID0gcmVjdC5sZWZ0ICsgZWxlbWVudERpbWVuc2lvbnMudy8yICsgbGlua0RpbWVuc2lvbnMudy8yID49IHdpbmRvd1dpZHRoLFxuICAgICAgaGFsZkJvdHRvbUV4Y2VlZCA9IHJlY3QudG9wICsgZWxlbWVudERpbWVuc2lvbnMuaC8yICsgbGlua0RpbWVuc2lvbnMuaC8yID49IHdpbmRvd0hlaWdodCxcbiAgICAgIHRvcEV4Y2VlZCA9IHJlY3QudG9wIC0gZWxlbWVudERpbWVuc2lvbnMuaCA8IDAsXG4gICAgICBsZWZ0RXhjZWVkID0gcmVjdC5sZWZ0IC0gZWxlbWVudERpbWVuc2lvbnMudyA8IDAsXG4gICAgICBib3R0b21FeGNlZWQgPSByZWN0LnRvcCArIGVsZW1lbnREaW1lbnNpb25zLmggKyBsaW5rRGltZW5zaW9ucy5oID49IHdpbmRvd0hlaWdodCxcbiAgICAgIHJpZ2h0RXhjZWVkID0gcmVjdC5sZWZ0ICsgZWxlbWVudERpbWVuc2lvbnMudyArIGxpbmtEaW1lbnNpb25zLncgPj0gd2luZG93V2lkdGg7XG4gIHBvc2l0aW9uID0gKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpICYmIGxlZnRFeGNlZWQgJiYgcmlnaHRFeGNlZWQgPyAndG9wJyA6IHBvc2l0aW9uO1xuICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSAndG9wJyAmJiB0b3BFeGNlZWQgPyAnYm90dG9tJyA6IHBvc2l0aW9uO1xuICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSAnYm90dG9tJyAmJiBib3R0b21FeGNlZWQgPyAndG9wJyA6IHBvc2l0aW9uO1xuICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgJiYgbGVmdEV4Y2VlZCA/ICdyaWdodCcgOiBwb3NpdGlvbjtcbiAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gJ3JpZ2h0JyAmJiByaWdodEV4Y2VlZCA/ICdsZWZ0JyA6IHBvc2l0aW9uO1xuICB2YXIgdG9wUG9zaXRpb24sXG4gICAgbGVmdFBvc2l0aW9uLFxuICAgIGFycm93VG9wLFxuICAgIGFycm93TGVmdCxcbiAgICBhcnJvd1dpZHRoLFxuICAgIGFycm93SGVpZ2h0O1xuICBlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgKGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZSh0aXBQb3NpdGlvbnMscG9zaXRpb24pKTtcbiAgYXJyb3dXaWR0aCA9IGFycm93Lm9mZnNldFdpZHRoOyBhcnJvd0hlaWdodCA9IGFycm93Lm9mZnNldEhlaWdodDtcbiAgaWYgKCBwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnICkge1xuICAgIGlmICggcG9zaXRpb24gPT09ICdsZWZ0JyApIHtcbiAgICAgIGxlZnRQb3NpdGlvbiA9IHJlY3QubGVmdCArIHNjcm9sbC54IC0gZWxlbWVudERpbWVuc2lvbnMudyAtICggaXNQb3BvdmVyID8gYXJyb3dXaWR0aCA6IDAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdFBvc2l0aW9uID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnggKyBsaW5rRGltZW5zaW9ucy53O1xuICAgIH1cbiAgICBpZiAoaGFsZlRvcEV4Y2VlZCkge1xuICAgICAgdG9wUG9zaXRpb24gPSByZWN0LnRvcCArIHNjcm9sbC55O1xuICAgICAgYXJyb3dUb3AgPSBsaW5rRGltZW5zaW9ucy5oLzIgLSBhcnJvd1dpZHRoO1xuICAgIH0gZWxzZSBpZiAoaGFsZkJvdHRvbUV4Y2VlZCkge1xuICAgICAgdG9wUG9zaXRpb24gPSByZWN0LnRvcCArIHNjcm9sbC55IC0gZWxlbWVudERpbWVuc2lvbnMuaCArIGxpbmtEaW1lbnNpb25zLmg7XG4gICAgICBhcnJvd1RvcCA9IGVsZW1lbnREaW1lbnNpb25zLmggLSBsaW5rRGltZW5zaW9ucy5oLzIgLSBhcnJvd1dpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3BQb3NpdGlvbiA9IHJlY3QudG9wICsgc2Nyb2xsLnkgLSBlbGVtZW50RGltZW5zaW9ucy5oLzIgKyBsaW5rRGltZW5zaW9ucy5oLzI7XG4gICAgICBhcnJvd1RvcCA9IGVsZW1lbnREaW1lbnNpb25zLmgvMiAtIChpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCowLjkgOiBhcnJvd0hlaWdodC8yKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgKSB7XG4gICAgaWYgKCBwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRvcFBvc2l0aW9uID0gIHJlY3QudG9wICsgc2Nyb2xsLnkgLSBlbGVtZW50RGltZW5zaW9ucy5oIC0gKCBpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCA6IDAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wUG9zaXRpb24gPSByZWN0LnRvcCArIHNjcm9sbC55ICsgbGlua0RpbWVuc2lvbnMuaDtcbiAgICB9XG4gICAgaWYgKGhhbGZMZWZ0RXhjZWVkKSB7XG4gICAgICBsZWZ0UG9zaXRpb24gPSAwO1xuICAgICAgYXJyb3dMZWZ0ID0gcmVjdC5sZWZ0ICsgbGlua0RpbWVuc2lvbnMudy8yIC0gYXJyb3dXaWR0aDtcbiAgICB9IGVsc2UgaWYgKGhhbGZSaWdodEV4Y2VlZCkge1xuICAgICAgbGVmdFBvc2l0aW9uID0gd2luZG93V2lkdGggLSBlbGVtZW50RGltZW5zaW9ucy53KjEuMDE7XG4gICAgICBhcnJvd0xlZnQgPSBlbGVtZW50RGltZW5zaW9ucy53IC0gKCB3aW5kb3dXaWR0aCAtIHJlY3QubGVmdCApICsgbGlua0RpbWVuc2lvbnMudy8yIC0gYXJyb3dXaWR0aC8yO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0UG9zaXRpb24gPSByZWN0LmxlZnQgKyBzY3JvbGwueCAtIGVsZW1lbnREaW1lbnNpb25zLncvMiArIGxpbmtEaW1lbnNpb25zLncvMjtcbiAgICAgIGFycm93TGVmdCA9IGVsZW1lbnREaW1lbnNpb25zLncvMiAtICggaXNQb3BvdmVyID8gYXJyb3dXaWR0aCA6IGFycm93V2lkdGgvMiApO1xuICAgIH1cbiAgfVxuICBlbGVtZW50LnN0eWxlLnRvcCA9IHRvcFBvc2l0aW9uICsgJ3B4JztcbiAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdFBvc2l0aW9uICsgJ3B4JztcbiAgYXJyb3dUb3AgJiYgKGFycm93LnN0eWxlLnRvcCA9IGFycm93VG9wICsgJ3B4Jyk7XG4gIGFycm93TGVmdCAmJiAoYXJyb3cuc3R5bGUubGVmdCA9IGFycm93TGVmdCArICdweCcpO1xufVxuXG5mdW5jdGlvbiBQb3BvdmVyKGVsZW1lbnQsb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcG9wb3ZlciA9IG51bGwsXG4gICAgICB0aW1lciA9IDAsXG4gICAgICBpc0lwaG9uZSA9IC8oaVBob25lfGlQb2R8aVBhZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksXG4gICAgICB0aXRsZVN0cmluZyxcbiAgICAgIGNvbnRlbnRTdHJpbmcsXG4gICAgICBvcHMgPSB7fTtcbiAgdmFyIHRyaWdnZXJEYXRhLFxuICAgICAgYW5pbWF0aW9uRGF0YSxcbiAgICAgIHBsYWNlbWVudERhdGEsXG4gICAgICBkaXNtaXNzaWJsZURhdGEsXG4gICAgICBkZWxheURhdGEsXG4gICAgICBjb250YWluZXJEYXRhLFxuICAgICAgY2xvc2VCdG4sXG4gICAgICBzaG93Q3VzdG9tRXZlbnQsXG4gICAgICBzaG93bkN1c3RvbUV2ZW50LFxuICAgICAgaGlkZUN1c3RvbUV2ZW50LFxuICAgICAgaGlkZGVuQ3VzdG9tRXZlbnQsXG4gICAgICBjb250YWluZXJFbGVtZW50LFxuICAgICAgY29udGFpbmVyRGF0YUVsZW1lbnQsXG4gICAgICBtb2RhbCxcbiAgICAgIG5hdmJhckZpeGVkVG9wLFxuICAgICAgbmF2YmFyRml4ZWRCb3R0b20sXG4gICAgICBwbGFjZW1lbnRDbGFzcztcbiAgZnVuY3Rpb24gZGlzbWlzc2libGVIYW5kbGVyKGUpIHtcbiAgICBpZiAocG9wb3ZlciAhPT0gbnVsbCAmJiBlLnRhcmdldCA9PT0gcXVlcnlFbGVtZW50KCcuY2xvc2UnLHBvcG92ZXIpKSB7XG4gICAgICBzZWxmLmhpZGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q29udGVudHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIDAgOiBvcHRpb25zLnRpdGxlIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJykgfHwgbnVsbCxcbiAgICAgIDEgOiBvcHRpb25zLmNvbnRlbnQgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29udGVudCcpIHx8IG51bGxcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlUG9wb3ZlcigpIHtcbiAgICBvcHMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHBvcG92ZXIpO1xuICAgIHRpbWVyID0gbnVsbDsgcG9wb3ZlciA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUG9wb3ZlcigpIHtcbiAgICB0aXRsZVN0cmluZyA9IGdldENvbnRlbnRzKClbMF0gfHwgbnVsbDtcbiAgICBjb250ZW50U3RyaW5nID0gZ2V0Q29udGVudHMoKVsxXTtcbiAgICBjb250ZW50U3RyaW5nID0gISFjb250ZW50U3RyaW5nID8gY29udGVudFN0cmluZy50cmltKCkgOiBudWxsO1xuICAgIHBvcG92ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgcG9wb3ZlckFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcG9wb3ZlckFycm93LmNsYXNzTGlzdC5hZGQoJ2Fycm93Jyk7XG4gICAgcG9wb3Zlci5hcHBlbmRDaGlsZChwb3BvdmVyQXJyb3cpO1xuICAgIGlmICggY29udGVudFN0cmluZyAhPT0gbnVsbCAmJiBvcHMudGVtcGxhdGUgPT09IG51bGwgKSB7XG4gICAgICBwb3BvdmVyLnNldEF0dHJpYnV0ZSgncm9sZScsJ3Rvb2x0aXAnKTtcbiAgICAgIGlmICh0aXRsZVN0cmluZyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcG9wb3ZlclRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICAgICAgcG9wb3ZlclRpdGxlLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItaGVhZGVyJyk7XG4gICAgICAgIHBvcG92ZXJUaXRsZS5pbm5lckhUTUwgPSBvcHMuZGlzbWlzc2libGUgPyB0aXRsZVN0cmluZyArIGNsb3NlQnRuIDogdGl0bGVTdHJpbmc7XG4gICAgICAgIHBvcG92ZXIuYXBwZW5kQ2hpbGQocG9wb3ZlclRpdGxlKTtcbiAgICAgIH1cbiAgICAgIHZhciBwb3BvdmVyQm9keU1hcmt1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcG9wb3ZlckJvZHlNYXJrdXAuY2xhc3NMaXN0LmFkZCgncG9wb3Zlci1ib2R5Jyk7XG4gICAgICBwb3BvdmVyQm9keU1hcmt1cC5pbm5lckhUTUwgPSBvcHMuZGlzbWlzc2libGUgJiYgdGl0bGVTdHJpbmcgPT09IG51bGwgPyBjb250ZW50U3RyaW5nICsgY2xvc2VCdG4gOiBjb250ZW50U3RyaW5nO1xuICAgICAgcG9wb3Zlci5hcHBlbmRDaGlsZChwb3BvdmVyQm9keU1hcmt1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb3BvdmVyVGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBvcG92ZXJUZW1wbGF0ZS5pbm5lckhUTUwgPSBvcHMudGVtcGxhdGUudHJpbSgpO1xuICAgICAgcG9wb3Zlci5jbGFzc05hbWUgPSBwb3BvdmVyVGVtcGxhdGUuZmlyc3RDaGlsZC5jbGFzc05hbWU7XG4gICAgICBwb3BvdmVyLmlubmVySFRNTCA9IHBvcG92ZXJUZW1wbGF0ZS5maXJzdENoaWxkLmlubmVySFRNTDtcbiAgICAgIHZhciBwb3BvdmVySGVhZGVyID0gcXVlcnlFbGVtZW50KCcucG9wb3Zlci1oZWFkZXInLHBvcG92ZXIpLFxuICAgICAgICAgIHBvcG92ZXJCb2R5ID0gcXVlcnlFbGVtZW50KCcucG9wb3Zlci1ib2R5Jyxwb3BvdmVyKTtcbiAgICAgIHRpdGxlU3RyaW5nICYmIHBvcG92ZXJIZWFkZXIgJiYgKHBvcG92ZXJIZWFkZXIuaW5uZXJIVE1MID0gdGl0bGVTdHJpbmcudHJpbSgpKTtcbiAgICAgIGNvbnRlbnRTdHJpbmcgJiYgcG9wb3ZlckJvZHkgJiYgKHBvcG92ZXJCb2R5LmlubmVySFRNTCA9IGNvbnRlbnRTdHJpbmcudHJpbSgpKTtcbiAgICB9XG4gICAgb3BzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChwb3BvdmVyKTtcbiAgICBwb3BvdmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICFwb3BvdmVyLmNsYXNzTGlzdC5jb250YWlucyggJ3BvcG92ZXInKSAmJiBwb3BvdmVyLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXInKTtcbiAgICAhcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMoIG9wcy5hbmltYXRpb24pICYmIHBvcG92ZXIuY2xhc3NMaXN0LmFkZChvcHMuYW5pbWF0aW9uKTtcbiAgICAhcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMoIHBsYWNlbWVudENsYXNzKSAmJiBwb3BvdmVyLmNsYXNzTGlzdC5hZGQocGxhY2VtZW50Q2xhc3MpO1xuICB9XG4gIGZ1bmN0aW9uIHNob3dQb3BvdmVyKCkge1xuICAgICFwb3BvdmVyLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmICggcG9wb3Zlci5jbGFzc0xpc3QuYWRkKCdzaG93JykgKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQb3BvdmVyKCkge1xuICAgIHN0eWxlVGlwKGVsZW1lbnQsIHBvcG92ZXIsIG9wcy5wbGFjZW1lbnQsIG9wcy5jb250YWluZXIpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcmNlRm9jdXMgKCkge1xuICAgIGlmIChwb3BvdmVyID09PSBudWxsKSB7IGVsZW1lbnQuZm9jdXMoKTsgfVxuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUV2ZW50cyhhY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgaWYgKG9wcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oIG1vdXNlQ2xpY2tFdmVudHMuZG93biwgc2VsZi5zaG93ICk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oIG1vdXNlSG92ZXJFdmVudHNbMF0sIHNlbGYuc2hvdyApO1xuICAgICAgaWYgKCFvcHMuZGlzbWlzc2libGUpIHsgZWxlbWVudFthY3Rpb25dKCBtb3VzZUhvdmVyRXZlbnRzWzFdLCBzZWxmLmhpZGUgKTsgfVxuICAgIH0gZWxzZSBpZiAoJ2NsaWNrJyA9PSBvcHMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudFthY3Rpb25dKCBvcHMudHJpZ2dlciwgc2VsZi50b2dnbGUgKTtcbiAgICB9IGVsc2UgaWYgKCdmb2N1cycgPT0gb3BzLnRyaWdnZXIpIHtcbiAgICAgIGlzSXBob25lICYmIGVsZW1lbnRbYWN0aW9uXSggJ2NsaWNrJywgZm9yY2VGb2N1cywgZmFsc2UgKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSggb3BzLnRyaWdnZXIsIHNlbGYudG9nZ2xlICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvdWNoSGFuZGxlcihlKXtcbiAgICBpZiAoIHBvcG92ZXIgJiYgcG9wb3Zlci5jb250YWlucyhlLnRhcmdldCkgfHwgZS50YXJnZXQgPT09IGVsZW1lbnQgfHwgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpIDsgZWxzZSB7XG4gICAgICBzZWxmLmhpZGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGlzbWlzc0hhbmRsZXJUb2dnbGUoYWN0aW9uKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGlmIChvcHMuZGlzbWlzc2libGUpIHtcbiAgICAgIGRvY3VtZW50W2FjdGlvbl0oJ2NsaWNrJywgZGlzbWlzc2libGVIYW5kbGVyLCBmYWxzZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAnZm9jdXMnID09IG9wcy50cmlnZ2VyICYmIGVsZW1lbnRbYWN0aW9uXSggJ2JsdXInLCBzZWxmLmhpZGUgKTtcbiAgICAgICdob3ZlcicgPT0gb3BzLnRyaWdnZXIgJiYgZG9jdW1lbnRbYWN0aW9uXSggJ3RvdWNoc3RhcnQnLCB0b3VjaEhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgfVxuICAgIHdpbmRvd1thY3Rpb25dKCdyZXNpemUnLCBzZWxmLmhpZGUsIHBhc3NpdmVIYW5kbGVyICk7XG4gIH1cbiAgZnVuY3Rpb24gc2hvd1RyaWdnZXIoKSB7XG4gICAgZGlzbWlzc0hhbmRsZXJUb2dnbGUoMSk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3duQ3VzdG9tRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGhpZGVUcmlnZ2VyKCkge1xuICAgIGRpc21pc3NIYW5kbGVyVG9nZ2xlKCk7XG4gICAgcmVtb3ZlUG9wb3ZlcigpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRkZW5DdXN0b21FdmVudCk7XG4gIH1cbiAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHBvcG92ZXIgPT09IG51bGwpIHsgc2VsZi5zaG93KCk7IH1cbiAgICBlbHNlIHsgc2VsZi5oaWRlKCk7IH1cbiAgfTtcbiAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocG9wb3ZlciA9PT0gbnVsbCkge1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICAgICAgaWYgKCBzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgICAgIGNyZWF0ZVBvcG92ZXIoKTtcbiAgICAgICAgdXBkYXRlUG9wb3ZlcigpO1xuICAgICAgICBzaG93UG9wb3ZlcigpO1xuICAgICAgICAhIW9wcy5hbmltYXRpb24gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChwb3BvdmVyLCBzaG93VHJpZ2dlcikgOiBzaG93VHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH0sIDIwICk7XG4gIH07XG4gIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBvcG92ZXIgJiYgcG9wb3ZlciAhPT0gbnVsbCAmJiBwb3BvdmVyLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgICBpZiAoIGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICAgICAgcG9wb3Zlci5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICAgICEhb3BzLmFuaW1hdGlvbiA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHBvcG92ZXIsIGhpZGVUcmlnZ2VyKSA6IGhpZGVUcmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfSwgb3BzLmRlbGF5ICk7XG4gIH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmhpZGUoKTtcbiAgICB0b2dnbGVFdmVudHMoKTtcbiAgICBkZWxldGUgZWxlbWVudC5Qb3BvdmVyO1xuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBlbGVtZW50LlBvcG92ZXIgJiYgZWxlbWVudC5Qb3BvdmVyLmRpc3Bvc2UoKTtcbiAgdHJpZ2dlckRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10cmlnZ2VyJyk7XG4gIGFuaW1hdGlvbkRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTtcbiAgcGxhY2VtZW50RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlbWVudCcpO1xuICBkaXNtaXNzaWJsZURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kaXNtaXNzaWJsZScpO1xuICBkZWxheURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kZWxheScpO1xuICBjb250YWluZXJEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29udGFpbmVyJyk7XG4gIGNsb3NlQnRuID0gJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIj7DlzwvYnV0dG9uPic7XG4gIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ3BvcG92ZXInKTtcbiAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93bicsICdwb3BvdmVyJyk7XG4gIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ3BvcG92ZXInKTtcbiAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ3BvcG92ZXInKTtcbiAgY29udGFpbmVyRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChvcHRpb25zLmNvbnRhaW5lcik7XG4gIGNvbnRhaW5lckRhdGFFbGVtZW50ID0gcXVlcnlFbGVtZW50KGNvbnRhaW5lckRhdGEpO1xuICBtb2RhbCA9IGVsZW1lbnQuY2xvc2VzdCgnLm1vZGFsJyk7XG4gIG5hdmJhckZpeGVkVG9wID0gZWxlbWVudC5jbG9zZXN0KCcuZml4ZWQtdG9wJyk7XG4gIG5hdmJhckZpeGVkQm90dG9tID0gZWxlbWVudC5jbG9zZXN0KCcuZml4ZWQtYm90dG9tJyk7XG4gIG9wcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgPyBvcHRpb25zLnRlbXBsYXRlIDogbnVsbDtcbiAgb3BzLnRyaWdnZXIgPSBvcHRpb25zLnRyaWdnZXIgPyBvcHRpb25zLnRyaWdnZXIgOiB0cmlnZ2VyRGF0YSB8fCAnaG92ZXInO1xuICBvcHMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb24gIT09ICdmYWRlJyA/IG9wdGlvbnMuYW5pbWF0aW9uIDogYW5pbWF0aW9uRGF0YSB8fCAnZmFkZSc7XG4gIG9wcy5wbGFjZW1lbnQgPSBvcHRpb25zLnBsYWNlbWVudCA/IG9wdGlvbnMucGxhY2VtZW50IDogcGxhY2VtZW50RGF0YSB8fCAndG9wJztcbiAgb3BzLmRlbGF5ID0gcGFyc2VJbnQob3B0aW9ucy5kZWxheSB8fCBkZWxheURhdGEpIHx8IDIwMDtcbiAgb3BzLmRpc21pc3NpYmxlID0gb3B0aW9ucy5kaXNtaXNzaWJsZSB8fCBkaXNtaXNzaWJsZURhdGEgPT09ICd0cnVlJyA/IHRydWUgOiBmYWxzZTtcbiAgb3BzLmNvbnRhaW5lciA9IGNvbnRhaW5lckVsZW1lbnQgPyBjb250YWluZXJFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogY29udGFpbmVyRGF0YUVsZW1lbnQgPyBjb250YWluZXJEYXRhRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5hdmJhckZpeGVkVG9wID8gbmF2YmFyRml4ZWRUb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuYXZiYXJGaXhlZEJvdHRvbSA/IG5hdmJhckZpeGVkQm90dG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9kYWwgPyBtb2RhbCA6IGRvY3VtZW50LmJvZHk7XG4gIHBsYWNlbWVudENsYXNzID0gXCJicy1wb3BvdmVyLVwiICsgKG9wcy5wbGFjZW1lbnQpO1xuICB2YXIgcG9wb3ZlckNvbnRlbnRzID0gZ2V0Q29udGVudHMoKTtcbiAgdGl0bGVTdHJpbmcgPSBwb3BvdmVyQ29udGVudHNbMF07XG4gIGNvbnRlbnRTdHJpbmcgPSBwb3BvdmVyQ29udGVudHNbMV07XG4gIGlmICggIWNvbnRlbnRTdHJpbmcgJiYgIW9wcy50ZW1wbGF0ZSApIHsgcmV0dXJuOyB9XG4gIGlmICggIWVsZW1lbnQuUG9wb3ZlciApIHtcbiAgICB0b2dnbGVFdmVudHMoMSk7XG4gIH1cbiAgZWxlbWVudC5Qb3BvdmVyID0gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsU3B5KGVsZW1lbnQsb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgIHZhcnMsXG4gICAgdGFyZ2V0RGF0YSxcbiAgICBvZmZzZXREYXRhLFxuICAgIHNweVRhcmdldCxcbiAgICBzY3JvbGxUYXJnZXQsXG4gICAgb3BzID0ge307XG4gIGZ1bmN0aW9uIHVwZGF0ZVRhcmdldHMoKXtcbiAgICB2YXIgbGlua3MgPSBzcHlUYXJnZXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0EnKTtcbiAgICBpZiAodmFycy5sZW5ndGggIT09IGxpbmtzLmxlbmd0aCkge1xuICAgICAgdmFycy5pdGVtcyA9IFtdO1xuICAgICAgdmFycy50YXJnZXRzID0gW107XG4gICAgICBBcnJheS5mcm9tKGxpbmtzKS5tYXAoZnVuY3Rpb24gKGxpbmspe1xuICAgICAgICB2YXIgaHJlZiA9IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJyksXG4gICAgICAgICAgdGFyZ2V0SXRlbSA9IGhyZWYgJiYgaHJlZi5jaGFyQXQoMCkgPT09ICcjJyAmJiBocmVmLnNsaWNlKC0xKSAhPT0gJyMnICYmIHF1ZXJ5RWxlbWVudChocmVmKTtcbiAgICAgICAgaWYgKCB0YXJnZXRJdGVtICkge1xuICAgICAgICAgIHZhcnMuaXRlbXMucHVzaChsaW5rKTtcbiAgICAgICAgICB2YXJzLnRhcmdldHMucHVzaCh0YXJnZXRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXJzLmxlbmd0aCA9IGxpbmtzLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlSXRlbShpbmRleCkge1xuICAgIHZhciBpdGVtID0gdmFycy5pdGVtc1tpbmRleF0sXG4gICAgICB0YXJnZXRJdGVtID0gdmFycy50YXJnZXRzW2luZGV4XSxcbiAgICAgIGRyb3BtZW51ID0gaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2Ryb3Bkb3duLWl0ZW0nKSAmJiBpdGVtLmNsb3Nlc3QoJy5kcm9wZG93bi1tZW51JyksXG4gICAgICBkcm9wTGluayA9IGRyb3BtZW51ICYmIGRyb3BtZW51LnByZXZpb3VzRWxlbWVudFNpYmxpbmcsXG4gICAgICBuZXh0U2libGluZyA9IGl0ZW0ubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgYWN0aXZlU2libGluZyA9IG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FjdGl2ZScpLmxlbmd0aCxcbiAgICAgIHRhcmdldFJlY3QgPSB2YXJzLmlzV2luZG93ICYmIHRhcmdldEl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBpc0FjdGl2ZSA9IGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSB8fCBmYWxzZSxcbiAgICAgIHRvcEVkZ2UgPSAodmFycy5pc1dpbmRvdyA/IHRhcmdldFJlY3QudG9wICsgdmFycy5zY3JvbGxPZmZzZXQgOiB0YXJnZXRJdGVtLm9mZnNldFRvcCkgLSBvcHMub2Zmc2V0LFxuICAgICAgYm90dG9tRWRnZSA9IHZhcnMuaXNXaW5kb3cgPyB0YXJnZXRSZWN0LmJvdHRvbSArIHZhcnMuc2Nyb2xsT2Zmc2V0IC0gb3BzLm9mZnNldFxuICAgICAgICAgICAgICAgICA6IHZhcnMudGFyZ2V0c1tpbmRleCsxXSA/IHZhcnMudGFyZ2V0c1tpbmRleCsxXS5vZmZzZXRUb3AgLSBvcHMub2Zmc2V0XG4gICAgICAgICAgICAgICAgIDogZWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICBpbnNpZGUgPSBhY3RpdmVTaWJsaW5nIHx8IHZhcnMuc2Nyb2xsT2Zmc2V0ID49IHRvcEVkZ2UgJiYgYm90dG9tRWRnZSA+IHZhcnMuc2Nyb2xsT2Zmc2V0O1xuICAgICBpZiAoICFpc0FjdGl2ZSAmJiBpbnNpZGUgKSB7XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgaWYgKGRyb3BMaW5rICYmICFkcm9wTGluay5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICkge1xuICAgICAgICBkcm9wTGluay5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBib290c3RyYXBDdXN0b21FdmVudCggJ2FjdGl2YXRlJywgJ3Njcm9sbHNweScsIHZhcnMuaXRlbXNbaW5kZXhdKSk7XG4gICAgfSBlbHNlIGlmICggaXNBY3RpdmUgJiYgIWluc2lkZSApIHtcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICBpZiAoZHJvcExpbmsgJiYgZHJvcExpbmsuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSAmJiAhaXRlbS5wYXJlbnROb2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FjdGl2ZScpLmxlbmd0aCApIHtcbiAgICAgICAgZHJvcExpbmsuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICggaXNBY3RpdmUgJiYgaW5zaWRlIHx8ICFpbnNpZGUgJiYgIWlzQWN0aXZlICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVJdGVtcygpIHtcbiAgICB1cGRhdGVUYXJnZXRzKCk7XG4gICAgdmFycy5zY3JvbGxPZmZzZXQgPSB2YXJzLmlzV2luZG93ID8gZ2V0U2Nyb2xsKCkueSA6IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIHZhcnMuaXRlbXMubWFwKGZ1bmN0aW9uIChsLGlkeCl7IHJldHVybiB1cGRhdGVJdGVtKGlkeCk7IH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUV2ZW50cyhhY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgc2Nyb2xsVGFyZ2V0W2FjdGlvbl0oJ3Njcm9sbCcsIHNlbGYucmVmcmVzaCwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICB3aW5kb3dbYWN0aW9uXSggJ3Jlc2l6ZScsIHNlbGYucmVmcmVzaCwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgfVxuICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdXBkYXRlSXRlbXMoKTtcbiAgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgIGRlbGV0ZSBlbGVtZW50LlNjcm9sbFNweTtcbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgZWxlbWVudC5TY3JvbGxTcHkgJiYgZWxlbWVudC5TY3JvbGxTcHkuZGlzcG9zZSgpO1xuICB0YXJnZXREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0Jyk7XG4gIG9mZnNldERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vZmZzZXQnKTtcbiAgc3B5VGFyZ2V0ID0gcXVlcnlFbGVtZW50KG9wdGlvbnMudGFyZ2V0IHx8IHRhcmdldERhdGEpO1xuICBzY3JvbGxUYXJnZXQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCA8IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID8gZWxlbWVudCA6IHdpbmRvdztcbiAgaWYgKCFzcHlUYXJnZXQpIHsgcmV0dXJuIH1cbiAgb3BzLnRhcmdldCA9IHNweVRhcmdldDtcbiAgb3BzLm9mZnNldCA9IHBhcnNlSW50KG9wdGlvbnMub2Zmc2V0IHx8IG9mZnNldERhdGEpIHx8IDEwO1xuICB2YXJzID0ge307XG4gIHZhcnMubGVuZ3RoID0gMDtcbiAgdmFycy5pdGVtcyA9IFtdO1xuICB2YXJzLnRhcmdldHMgPSBbXTtcbiAgdmFycy5pc1dpbmRvdyA9IHNjcm9sbFRhcmdldCA9PT0gd2luZG93O1xuICBpZiAoICFlbGVtZW50LlNjcm9sbFNweSApIHtcbiAgICB0b2dnbGVFdmVudHMoMSk7XG4gIH1cbiAgc2VsZi5yZWZyZXNoKCk7XG4gIGVsZW1lbnQuU2Nyb2xsU3B5ID0gc2VsZjtcbn1cblxuZnVuY3Rpb24gVGFiKGVsZW1lbnQsb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgIGhlaWdodERhdGEsXG4gICAgdGFicywgZHJvcGRvd24sXG4gICAgc2hvd0N1c3RvbUV2ZW50LFxuICAgIHNob3duQ3VzdG9tRXZlbnQsXG4gICAgaGlkZUN1c3RvbUV2ZW50LFxuICAgIGhpZGRlbkN1c3RvbUV2ZW50LFxuICAgIG5leHQsXG4gICAgdGFic0NvbnRlbnRDb250YWluZXIgPSBmYWxzZSxcbiAgICBhY3RpdmVUYWIsXG4gICAgYWN0aXZlQ29udGVudCxcbiAgICBuZXh0Q29udGVudCxcbiAgICBjb250YWluZXJIZWlnaHQsXG4gICAgZXF1YWxDb250ZW50cyxcbiAgICBuZXh0SGVpZ2h0LFxuICAgIGFuaW1hdGVIZWlnaHQ7XG4gIGZ1bmN0aW9uIHRyaWdnZXJFbmQoKSB7XG4gICAgdGFic0NvbnRlbnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgdGFic0NvbnRlbnRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2luZycpO1xuICAgIHRhYnMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiB0cmlnZ2VyU2hvdygpIHtcbiAgICBpZiAodGFic0NvbnRlbnRDb250YWluZXIpIHtcbiAgICAgIGlmICggZXF1YWxDb250ZW50cyApIHtcbiAgICAgICAgdHJpZ2dlckVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFic0NvbnRlbnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gbmV4dEhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICB0YWJzQ29udGVudENvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0YWJzQ29udGVudENvbnRhaW5lciwgdHJpZ2dlckVuZCk7XG4gICAgICAgIH0sNTApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWJzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAndGFiJywgYWN0aXZlVGFiKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobmV4dCwgc2hvd25DdXN0b21FdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gdHJpZ2dlckhpZGUoKSB7XG4gICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7XG4gICAgICBhY3RpdmVDb250ZW50LnN0eWxlLmZsb2F0ID0gJ2xlZnQnO1xuICAgICAgbmV4dENvbnRlbnQuc3R5bGUuZmxvYXQgPSAnbGVmdCc7XG4gICAgICBjb250YWluZXJIZWlnaHQgPSBhY3RpdmVDb250ZW50LnNjcm9sbEhlaWdodDtcbiAgICB9XG4gICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAndGFiJywgYWN0aXZlVGFiKTtcbiAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAndGFiJywgbmV4dCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKG5leHQsIHNob3dDdXN0b21FdmVudCk7XG4gICAgaWYgKCBzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgbmV4dENvbnRlbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgYWN0aXZlQ29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICBpZiAodGFic0NvbnRlbnRDb250YWluZXIpIHtcbiAgICAgIG5leHRIZWlnaHQgPSBuZXh0Q29udGVudC5zY3JvbGxIZWlnaHQ7XG4gICAgICBlcXVhbENvbnRlbnRzID0gbmV4dEhlaWdodCA9PT0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgdGFic0NvbnRlbnRDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2luZycpO1xuICAgICAgdGFic0NvbnRlbnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0ICsgXCJweFwiO1xuICAgICAgdGFic0NvbnRlbnRDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgYWN0aXZlQ29udGVudC5zdHlsZS5mbG9hdCA9ICcnO1xuICAgICAgbmV4dENvbnRlbnQuc3R5bGUuZmxvYXQgPSAnJztcbiAgICB9XG4gICAgaWYgKCBuZXh0Q29udGVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSApIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0Q29udGVudC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKG5leHRDb250ZW50LHRyaWdnZXJTaG93KTtcbiAgICAgIH0sMjApO1xuICAgIH0gZWxzZSB7IHRyaWdnZXJTaG93KCk7IH1cbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWN0aXZlVGFiLCBoaWRkZW5DdXN0b21FdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QWN0aXZlVGFiKCkge1xuICAgIHZhciBhY3RpdmVUYWJzID0gdGFicy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhY3RpdmUnKSwgYWN0aXZlVGFiO1xuICAgIGlmICggYWN0aXZlVGFicy5sZW5ndGggPT09IDEgJiYgIWFjdGl2ZVRhYnNbMF0ucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2Ryb3Bkb3duJykgKSB7XG4gICAgICBhY3RpdmVUYWIgPSBhY3RpdmVUYWJzWzBdO1xuICAgIH0gZWxzZSBpZiAoIGFjdGl2ZVRhYnMubGVuZ3RoID4gMSApIHtcbiAgICAgIGFjdGl2ZVRhYiA9IGFjdGl2ZVRhYnNbYWN0aXZlVGFicy5sZW5ndGgtMV07XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVUYWI7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QWN0aXZlQ29udGVudCgpIHsgcmV0dXJuIHF1ZXJ5RWxlbWVudChnZXRBY3RpdmVUYWIoKS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfVxuICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBuZXh0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICF0YWJzLmlzQW5pbWF0aW5nICYmIHNlbGYuc2hvdygpO1xuICB9XG4gIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBuZXh0ID0gbmV4dCB8fCBlbGVtZW50O1xuICAgIGlmICghbmV4dC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG4gICAgICBuZXh0Q29udGVudCA9IHF1ZXJ5RWxlbWVudChuZXh0LmdldEF0dHJpYnV0ZSgnaHJlZicpKTtcbiAgICAgIGFjdGl2ZVRhYiA9IGdldEFjdGl2ZVRhYigpO1xuICAgICAgYWN0aXZlQ29udGVudCA9IGdldEFjdGl2ZUNvbnRlbnQoKTtcbiAgICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCAnaGlkZScsICd0YWInLCBuZXh0KTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChhY3RpdmVUYWIsIGhpZGVDdXN0b21FdmVudCk7XG4gICAgICBpZiAoaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICB0YWJzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgIGFjdGl2ZVRhYi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIGFjdGl2ZVRhYi5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCdmYWxzZScpO1xuICAgICAgbmV4dC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgIG5leHQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywndHJ1ZScpO1xuICAgICAgaWYgKCBkcm9wZG93biApIHtcbiAgICAgICAgaWYgKCAhZWxlbWVudC5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZHJvcGRvd24tbWVudScpICkge1xuICAgICAgICAgIGlmIChkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7IGRyb3Bkb3duLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7IGRyb3Bkb3duLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVDb250ZW50LmNsYXNzTGlzdC5jb250YWlucygnZmFkZScpKSB7XG4gICAgICAgIGFjdGl2ZUNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChhY3RpdmVDb250ZW50LCB0cmlnZ2VySGlkZSk7XG4gICAgICB9IGVsc2UgeyB0cmlnZ2VySGlkZSgpOyB9XG4gICAgfVxuICB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tIYW5kbGVyLGZhbHNlKTtcbiAgICBkZWxldGUgZWxlbWVudC5UYWI7XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIGVsZW1lbnQuVGFiICYmIGVsZW1lbnQuVGFiLmRpc3Bvc2UoKTtcbiAgaGVpZ2h0RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWhlaWdodCcpO1xuICB0YWJzID0gZWxlbWVudC5jbG9zZXN0KCcubmF2Jyk7XG4gIGRyb3Bkb3duID0gdGFicyAmJiBxdWVyeUVsZW1lbnQoJy5kcm9wZG93bi10b2dnbGUnLHRhYnMpO1xuICBhbmltYXRlSGVpZ2h0ID0gIXN1cHBvcnRUcmFuc2l0aW9uIHx8IChvcHRpb25zLmhlaWdodCA9PT0gZmFsc2UgfHwgaGVpZ2h0RGF0YSA9PT0gJ2ZhbHNlJykgPyBmYWxzZSA6IHRydWU7XG4gIHRhYnMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgaWYgKCAhZWxlbWVudC5UYWIgKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tIYW5kbGVyLGZhbHNlKTtcbiAgfVxuICBpZiAoYW5pbWF0ZUhlaWdodCkgeyB0YWJzQ29udGVudENvbnRhaW5lciA9IGdldEFjdGl2ZUNvbnRlbnQoKS5wYXJlbnROb2RlOyB9XG4gIGVsZW1lbnQuVGFiID0gc2VsZjtcbn1cblxuZnVuY3Rpb24gVG9hc3QoZWxlbWVudCxvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICB0b2FzdCwgdGltZXIgPSAwLFxuICAgICAgYW5pbWF0aW9uRGF0YSxcbiAgICAgIGF1dG9oaWRlRGF0YSxcbiAgICAgIGRlbGF5RGF0YSxcbiAgICAgIHNob3dDdXN0b21FdmVudCxcbiAgICAgIGhpZGVDdXN0b21FdmVudCxcbiAgICAgIHNob3duQ3VzdG9tRXZlbnQsXG4gICAgICBoaWRkZW5DdXN0b21FdmVudCxcbiAgICAgIG9wcyA9IHt9O1xuICBmdW5jdGlvbiBzaG93Q29tcGxldGUoKSB7XG4gICAgdG9hc3QuY2xhc3NMaXN0LnJlbW92ZSggJ3Nob3dpbmcnICk7XG4gICAgdG9hc3QuY2xhc3NMaXN0LmFkZCggJ3Nob3cnICk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHRvYXN0LHNob3duQ3VzdG9tRXZlbnQpO1xuICAgIGlmIChvcHMuYXV0b2hpZGUpIHsgc2VsZi5oaWRlKCk7IH1cbiAgfVxuICBmdW5jdGlvbiBoaWRlQ29tcGxldGUoKSB7XG4gICAgdG9hc3QuY2xhc3NMaXN0LmFkZCggJ2hpZGUnICk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHRvYXN0LGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgdG9hc3QuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycgKTtcbiAgICBvcHMuYW5pbWF0aW9uID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIGhpZGVDb21wbGV0ZSkgOiBoaWRlQ29tcGxldGUoKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwb3NlQ29tcGxldGUoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxzZWxmLmhpZGUsZmFsc2UpO1xuICAgIGRlbGV0ZSBlbGVtZW50LlRvYXN0O1xuICB9XG4gIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodG9hc3QgJiYgIXRvYXN0LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwodG9hc3Qsc2hvd0N1c3RvbUV2ZW50KTtcbiAgICAgIGlmIChzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgIG9wcy5hbmltYXRpb24gJiYgdG9hc3QuY2xhc3NMaXN0LmFkZCggJ2ZhZGUnICk7XG4gICAgICB0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJyApO1xuICAgICAgdG9hc3Qub2Zmc2V0V2lkdGg7XG4gICAgICB0b2FzdC5jbGFzc0xpc3QuYWRkKCdzaG93aW5nJyApO1xuICAgICAgb3BzLmFuaW1hdGlvbiA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRvYXN0LCBzaG93Q29tcGxldGUpIDogc2hvd0NvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAobm9UaW1lcikge1xuICAgIGlmICh0b2FzdCAmJiB0b2FzdC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHRvYXN0LGhpZGVDdXN0b21FdmVudCk7XG4gICAgICBpZihoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgIG5vVGltZXIgPyBjbG9zZSgpIDogKHRpbWVyID0gc2V0VGltZW91dCggY2xvc2UsIG9wcy5kZWxheSkpO1xuICAgIH1cbiAgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIG9wcy5hbmltYXRpb24gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b2FzdCwgZGlzcG9zZUNvbXBsZXRlKSA6IGRpc3Bvc2VDb21wbGV0ZSgpO1xuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBlbGVtZW50LlRvYXN0ICYmIGVsZW1lbnQuVG9hc3QuZGlzcG9zZSgpO1xuICB0b2FzdCA9IGVsZW1lbnQuY2xvc2VzdCgnLnRvYXN0Jyk7XG4gIGFuaW1hdGlvbkRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTtcbiAgYXV0b2hpZGVEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYXV0b2hpZGUnKTtcbiAgZGVsYXlEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGVsYXknKTtcbiAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAndG9hc3QnKTtcbiAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAndG9hc3QnKTtcbiAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93bicsICd0b2FzdCcpO1xuICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAndG9hc3QnKTtcbiAgb3BzLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uID09PSBmYWxzZSB8fCBhbmltYXRpb25EYXRhID09PSAnZmFsc2UnID8gMCA6IDE7XG4gIG9wcy5hdXRvaGlkZSA9IG9wdGlvbnMuYXV0b2hpZGUgPT09IGZhbHNlIHx8IGF1dG9oaWRlRGF0YSA9PT0gJ2ZhbHNlJyA/IDAgOiAxO1xuICBvcHMuZGVsYXkgPSBwYXJzZUludChvcHRpb25zLmRlbGF5IHx8IGRlbGF5RGF0YSkgfHwgNTAwO1xuICBpZiAoICFlbGVtZW50LlRvYXN0ICkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLHNlbGYuaGlkZSxmYWxzZSk7XG4gIH1cbiAgZWxlbWVudC5Ub2FzdCA9IHNlbGY7XG59XG5cbmZ1bmN0aW9uIFRvb2x0aXAoZWxlbWVudCxvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICB0b29sdGlwID0gbnVsbCwgdGltZXIgPSAwLCB0aXRsZVN0cmluZyxcbiAgICAgIGFuaW1hdGlvbkRhdGEsXG4gICAgICBwbGFjZW1lbnREYXRhLFxuICAgICAgZGVsYXlEYXRhLFxuICAgICAgY29udGFpbmVyRGF0YSxcbiAgICAgIHNob3dDdXN0b21FdmVudCxcbiAgICAgIHNob3duQ3VzdG9tRXZlbnQsXG4gICAgICBoaWRlQ3VzdG9tRXZlbnQsXG4gICAgICBoaWRkZW5DdXN0b21FdmVudCxcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQsXG4gICAgICBjb250YWluZXJEYXRhRWxlbWVudCxcbiAgICAgIG1vZGFsLFxuICAgICAgbmF2YmFyRml4ZWRUb3AsXG4gICAgICBuYXZiYXJGaXhlZEJvdHRvbSxcbiAgICAgIHBsYWNlbWVudENsYXNzLFxuICAgICAgb3BzID0ge307XG4gIGZ1bmN0aW9uIGdldFRpdGxlKCkge1xuICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKVxuICAgICAgICB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScpXG4gICAgICAgIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVUb29sVGlwKCkge1xuICAgIG9wcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodG9vbHRpcCk7XG4gICAgdG9vbHRpcCA9IG51bGw7IHRpbWVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVUb29sVGlwKCkge1xuICAgIHRpdGxlU3RyaW5nID0gZ2V0VGl0bGUoKTtcbiAgICBpZiAoIHRpdGxlU3RyaW5nICkge1xuICAgICAgdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaWYgKG9wcy50ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgdG9vbHRpcE1hcmt1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b29sdGlwTWFya3VwLmlubmVySFRNTCA9IG9wcy50ZW1wbGF0ZS50cmltKCk7XG4gICAgICAgIHRvb2x0aXAuY2xhc3NOYW1lID0gdG9vbHRpcE1hcmt1cC5maXJzdENoaWxkLmNsYXNzTmFtZTtcbiAgICAgICAgdG9vbHRpcC5pbm5lckhUTUwgPSB0b29sdGlwTWFya3VwLmZpcnN0Q2hpbGQuaW5uZXJIVE1MO1xuICAgICAgICBxdWVyeUVsZW1lbnQoJy50b29sdGlwLWlubmVyJyx0b29sdGlwKS5pbm5lckhUTUwgPSB0aXRsZVN0cmluZy50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdG9vbHRpcEFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvb2x0aXBBcnJvdy5jbGFzc0xpc3QuYWRkKCdhcnJvdycpO1xuICAgICAgICB0b29sdGlwLmFwcGVuZENoaWxkKHRvb2x0aXBBcnJvdyk7XG4gICAgICAgIHZhciB0b29sdGlwSW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9vbHRpcElubmVyLmNsYXNzTGlzdC5hZGQoJ3Rvb2x0aXAtaW5uZXInKTtcbiAgICAgICAgdG9vbHRpcC5hcHBlbmRDaGlsZCh0b29sdGlwSW5uZXIpO1xuICAgICAgICB0b29sdGlwSW5uZXIuaW5uZXJIVE1MID0gdGl0bGVTdHJpbmc7XG4gICAgICB9XG4gICAgICB0b29sdGlwLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICB0b29sdGlwLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdyb2xlJywndG9vbHRpcCcpO1xuICAgICAgIXRvb2x0aXAuY2xhc3NMaXN0LmNvbnRhaW5zKCd0b29sdGlwJykgJiYgdG9vbHRpcC5jbGFzc0xpc3QuYWRkKCd0b29sdGlwJyk7XG4gICAgICAhdG9vbHRpcC5jbGFzc0xpc3QuY29udGFpbnMob3BzLmFuaW1hdGlvbikgJiYgdG9vbHRpcC5jbGFzc0xpc3QuYWRkKG9wcy5hbmltYXRpb24pO1xuICAgICAgIXRvb2x0aXAuY2xhc3NMaXN0LmNvbnRhaW5zKHBsYWNlbWVudENsYXNzKSAmJiB0b29sdGlwLmNsYXNzTGlzdC5hZGQocGxhY2VtZW50Q2xhc3MpO1xuICAgICAgb3BzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b29sdGlwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlVG9vbHRpcCgpIHtcbiAgICBzdHlsZVRpcChlbGVtZW50LCB0b29sdGlwLCBvcHMucGxhY2VtZW50LCBvcHMuY29udGFpbmVyKTtcbiAgfVxuICBmdW5jdGlvbiBzaG93VG9vbHRpcCgpIHtcbiAgICAhdG9vbHRpcC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSAmJiAoIHRvb2x0aXAuY2xhc3NMaXN0LmFkZCgnc2hvdycpICk7XG4gIH1cbiAgZnVuY3Rpb24gdG91Y2hIYW5kbGVyKGUpe1xuICAgIGlmICggdG9vbHRpcCAmJiB0b29sdGlwLmNvbnRhaW5zKGUudGFyZ2V0KSB8fCBlLnRhcmdldCA9PT0gZWxlbWVudCB8fCBlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSkgOyBlbHNlIHtcbiAgICAgIHNlbGYuaGlkZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVBY3Rpb24oYWN0aW9uKXtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgZG9jdW1lbnRbYWN0aW9uXSggJ3RvdWNoc3RhcnQnLCB0b3VjaEhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgd2luZG93W2FjdGlvbl0oICdyZXNpemUnLCBzZWxmLmhpZGUsIHBhc3NpdmVIYW5kbGVyICk7XG4gIH1cbiAgZnVuY3Rpb24gc2hvd0FjdGlvbigpIHtcbiAgICB0b2dnbGVBY3Rpb24oMSk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3duQ3VzdG9tRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGhpZGVBY3Rpb24oKSB7XG4gICAgdG9nZ2xlQWN0aW9uKCk7XG4gICAgcmVtb3ZlVG9vbFRpcCgpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRkZW5DdXN0b21FdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFjdGlvbikge1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBlbGVtZW50W2FjdGlvbl0obW91c2VDbGlja0V2ZW50cy5kb3duLCBzZWxmLnNob3csZmFsc2UpO1xuICAgIGVsZW1lbnRbYWN0aW9uXShtb3VzZUhvdmVyRXZlbnRzWzBdLCBzZWxmLnNob3csZmFsc2UpO1xuICAgIGVsZW1lbnRbYWN0aW9uXShtb3VzZUhvdmVyRXZlbnRzWzFdLCBzZWxmLmhpZGUsZmFsc2UpO1xuICB9XG4gIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3dDdXN0b21FdmVudCk7XG4gICAgICAgIGlmIChzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgaWYoY3JlYXRlVG9vbFRpcCgpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHVwZGF0ZVRvb2x0aXAoKTtcbiAgICAgICAgICBzaG93VG9vbHRpcCgpO1xuICAgICAgICAgICEhb3BzLmFuaW1hdGlvbiA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRvb2x0aXAsIHNob3dBY3Rpb24pIDogc2hvd0FjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgMjAgKTtcbiAgfTtcbiAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgICBpZiAoaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgICAhIW9wcy5hbmltYXRpb24gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b29sdGlwLCBoaWRlQWN0aW9uKSA6IGhpZGVBY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9LCBvcHMuZGVsYXkpO1xuICB9O1xuICBzZWxmLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRvb2x0aXApIHsgc2VsZi5zaG93KCk7IH1cbiAgICBlbHNlIHsgc2VsZi5oaWRlKCk7IH1cbiAgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgIHNlbGYuaGlkZSgpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJykpO1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJyk7XG4gICAgZGVsZXRlIGVsZW1lbnQuVG9vbHRpcDtcbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgZWxlbWVudC5Ub29sdGlwICYmIGVsZW1lbnQuVG9vbHRpcC5kaXNwb3NlKCk7XG4gIGFuaW1hdGlvbkRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTtcbiAgcGxhY2VtZW50RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlbWVudCcpO1xuICBkZWxheURhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kZWxheScpO1xuICBjb250YWluZXJEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29udGFpbmVyJyk7XG4gIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ3Rvb2x0aXAnKTtcbiAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93bicsICd0b29sdGlwJyk7XG4gIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ3Rvb2x0aXAnKTtcbiAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ3Rvb2x0aXAnKTtcbiAgY29udGFpbmVyRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChvcHRpb25zLmNvbnRhaW5lcik7XG4gIGNvbnRhaW5lckRhdGFFbGVtZW50ID0gcXVlcnlFbGVtZW50KGNvbnRhaW5lckRhdGEpO1xuICBtb2RhbCA9IGVsZW1lbnQuY2xvc2VzdCgnLm1vZGFsJyk7XG4gIG5hdmJhckZpeGVkVG9wID0gZWxlbWVudC5jbG9zZXN0KCcuZml4ZWQtdG9wJyk7XG4gIG5hdmJhckZpeGVkQm90dG9tID0gZWxlbWVudC5jbG9zZXN0KCcuZml4ZWQtYm90dG9tJyk7XG4gIG9wcy5hbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gJ2ZhZGUnID8gb3B0aW9ucy5hbmltYXRpb24gOiBhbmltYXRpb25EYXRhIHx8ICdmYWRlJztcbiAgb3BzLnBsYWNlbWVudCA9IG9wdGlvbnMucGxhY2VtZW50ID8gb3B0aW9ucy5wbGFjZW1lbnQgOiBwbGFjZW1lbnREYXRhIHx8ICd0b3AnO1xuICBvcHMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlID8gb3B0aW9ucy50ZW1wbGF0ZSA6IG51bGw7XG4gIG9wcy5kZWxheSA9IHBhcnNlSW50KG9wdGlvbnMuZGVsYXkgfHwgZGVsYXlEYXRhKSB8fCAyMDA7XG4gIG9wcy5jb250YWluZXIgPSBjb250YWluZXJFbGVtZW50ID8gY29udGFpbmVyRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnRhaW5lckRhdGFFbGVtZW50ID8gY29udGFpbmVyRGF0YUVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuYXZiYXJGaXhlZFRvcCA/IG5hdmJhckZpeGVkVG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbmF2YmFyRml4ZWRCb3R0b20gPyBuYXZiYXJGaXhlZEJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1vZGFsID8gbW9kYWwgOiBkb2N1bWVudC5ib2R5O1xuICBwbGFjZW1lbnRDbGFzcyA9IFwiYnMtdG9vbHRpcC1cIiArIChvcHMucGxhY2VtZW50KTtcbiAgdGl0bGVTdHJpbmcgPSBnZXRUaXRsZSgpO1xuICBpZiAoICF0aXRsZVN0cmluZyApIHsgcmV0dXJuOyB9XG4gIGlmICghZWxlbWVudC5Ub29sdGlwKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLHRpdGxlU3RyaW5nKTtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICB0b2dnbGVFdmVudHMoMSk7XG4gIH1cbiAgZWxlbWVudC5Ub29sdGlwID0gc2VsZjtcbn1cblxudmFyIGNvbXBvbmVudHNJbml0ID0ge307XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVEYXRhQVBJKCBDb25zdHJ1Y3RvciwgY29sbGVjdGlvbiApe1xuICBBcnJheS5mcm9tKGNvbGxlY3Rpb24pLm1hcChmdW5jdGlvbiAoeCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IoeCk7IH0pO1xufVxuZnVuY3Rpb24gaW5pdENhbGxiYWNrKGxvb2tVcCl7XG4gIGxvb2tVcCA9IGxvb2tVcCB8fCBkb2N1bWVudDtcbiAgZm9yICh2YXIgY29tcG9uZW50IGluIGNvbXBvbmVudHNJbml0KSB7XG4gICAgaW5pdGlhbGl6ZURhdGFBUEkoIGNvbXBvbmVudHNJbml0W2NvbXBvbmVudF1bMF0sIGxvb2tVcC5xdWVyeVNlbGVjdG9yQWxsIChjb21wb25lbnRzSW5pdFtjb21wb25lbnRdWzFdKSApO1xuICB9XG59XG5cbmNvbXBvbmVudHNJbml0LkFsZXJ0ID0gWyBBbGVydCwgJ1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXSddO1xuY29tcG9uZW50c0luaXQuQnV0dG9uID0gWyBCdXR0b24sICdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJyBdO1xuY29tcG9uZW50c0luaXQuQ2Fyb3VzZWwgPSBbIENhcm91c2VsLCAnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJyBdO1xuY29tcG9uZW50c0luaXQuQ29sbGFwc2UgPSBbIENvbGxhcHNlLCAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nIF07XG5jb21wb25lbnRzSW5pdC5Ecm9wZG93biA9IFsgRHJvcGRvd24sICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSddO1xuY29tcG9uZW50c0luaXQuTW9kYWwgPSBbIE1vZGFsLCAnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nIF07XG5jb21wb25lbnRzSW5pdC5Qb3BvdmVyID0gWyBQb3BvdmVyLCAnW2RhdGEtdG9nZ2xlPVwicG9wb3ZlclwiXSxbZGF0YS10aXA9XCJwb3BvdmVyXCJdJyBdO1xuY29tcG9uZW50c0luaXQuU2Nyb2xsU3B5ID0gWyBTY3JvbGxTcHksICdbZGF0YS1zcHk9XCJzY3JvbGxcIl0nIF07XG5jb21wb25lbnRzSW5pdC5UYWIgPSBbIFRhYiwgJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScgXTtcbmNvbXBvbmVudHNJbml0LlRvYXN0ID0gWyBUb2FzdCwgJ1tkYXRhLWRpc21pc3M9XCJ0b2FzdFwiXScgXTtcbmNvbXBvbmVudHNJbml0LlRvb2x0aXAgPSBbIFRvb2x0aXAsICdbZGF0YS10b2dnbGU9XCJ0b29sdGlwXCJdLFtkYXRhLXRpcD1cInRvb2x0aXBcIl0nIF07XG5kb2N1bWVudC5ib2R5ID8gaW5pdENhbGxiYWNrKCkgOiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uIGluaXRXcmFwcGVyKCl7XG5cdGluaXRDYWxsYmFjaygpO1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJyxpbml0V3JhcHBlcixmYWxzZSk7XG59LCBmYWxzZSApO1xuXG5mdW5jdGlvbiByZW1vdmVFbGVtZW50RGF0YUFQSSggQ29uc3RydWN0b3JOYW1lLCBjb2xsZWN0aW9uICl7XG4gIEFycmF5LmZyb20oY29sbGVjdGlvbikubWFwKGZ1bmN0aW9uICh4KXsgcmV0dXJuIHhbQ29uc3RydWN0b3JOYW1lXS5kaXNwb3NlKCk7IH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlRGF0YUFQSShsb29rVXApIHtcbiAgbG9va1VwID0gbG9va1VwIHx8IGRvY3VtZW50O1xuICBmb3IgKHZhciBjb21wb25lbnQgaW4gY29tcG9uZW50c0luaXQpIHtcbiAgICByZW1vdmVFbGVtZW50RGF0YUFQSSggY29tcG9uZW50LCBsb29rVXAucXVlcnlTZWxlY3RvckFsbCAoY29tcG9uZW50c0luaXRbY29tcG9uZW50XVsxXSkgKTtcbiAgfVxufVxuXG52YXIgdmVyc2lvbiA9IFwiMy4wLjEwXCI7XG5cbnZhciBpbmRleCA9IHtcbiAgQWxlcnQ6IEFsZXJ0LFxuICBCdXR0b246IEJ1dHRvbixcbiAgQ2Fyb3VzZWw6IENhcm91c2VsLFxuICBDb2xsYXBzZTogQ29sbGFwc2UsXG4gIERyb3Bkb3duOiBEcm9wZG93bixcbiAgTW9kYWw6IE1vZGFsLFxuICBQb3BvdmVyOiBQb3BvdmVyLFxuICBTY3JvbGxTcHk6IFNjcm9sbFNweSxcbiAgVGFiOiBUYWIsXG4gIFRvYXN0OiBUb2FzdCxcbiAgVG9vbHRpcDogVG9vbHRpcCxcbiAgaW5pdENhbGxiYWNrOiBpbml0Q2FsbGJhY2ssXG4gIHJlbW92ZURhdGFBUEk6IHJlbW92ZURhdGFBUEksXG4gIGNvbXBvbmVudHNJbml0OiBjb21wb25lbnRzSW5pdCxcbiAgVmVyc2lvbjogdmVyc2lvblxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIGlmIChcbiAgICAgICh1dGlscy5pc0Jsb2IocmVxdWVzdERhdGEpIHx8IHV0aWxzLmlzRmlsZShyZXF1ZXN0RGF0YSkpICYmXG4gICAgICByZXF1ZXN0RGF0YS50eXBlXG4gICAgKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IodGltZW91dEVycm9yTWVzc2FnZSwgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICB2YXIgdmFsdWVGcm9tQ29uZmlnMktleXMgPSBbJ3VybCcsICdtZXRob2QnLCAnZGF0YSddO1xuICB2YXIgbWVyZ2VEZWVwUHJvcGVydGllc0tleXMgPSBbJ2hlYWRlcnMnLCAnYXV0aCcsICdwcm94eScsICdwYXJhbXMnXTtcbiAgdmFyIGRlZmF1bHRUb0NvbmZpZzJLZXlzID0gW1xuICAgICdiYXNlVVJMJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAndGltZW91dE1lc3NhZ2UnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLCAnZGVjb21wcmVzcycsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnLCAnbWF4Qm9keUxlbmd0aCcsICdtYXhSZWRpcmVjdHMnLCAndHJhbnNwb3J0JywgJ2h0dHBBZ2VudCcsXG4gICAgJ2h0dHBzQWdlbnQnLCAnY2FuY2VsVG9rZW4nLCAnc29ja2V0UGF0aCcsICdyZXNwb25zZUVuY29kaW5nJ1xuICBdO1xuICB2YXIgZGlyZWN0TWVyZ2VLZXlzID0gWyd2YWxpZGF0ZVN0YXR1cyddO1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdXRpbHMuZm9yRWFjaCh2YWx1ZUZyb21Db25maWcyS2V5cywgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHV0aWxzLmZvckVhY2goZGVmYXVsdFRvQ29uZmlnMktleXMsIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKGRpcmVjdE1lcmdlS2V5cywgZnVuY3Rpb24gbWVyZ2UocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGF4aW9zS2V5cyA9IHZhbHVlRnJvbUNvbmZpZzJLZXlzXG4gICAgLmNvbmNhdChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cylcbiAgICAuY29uY2F0KGRlZmF1bHRUb0NvbmZpZzJLZXlzKVxuICAgIC5jb25jYXQoZGlyZWN0TWVyZ2VLZXlzKTtcblxuICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0XG4gICAgLmtleXMoY29uZmlnMSlcbiAgICAuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQXhpb3NLZXlzKGtleSkge1xuICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG9kYXNoIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZS1FUzUgZW52aXJvbm1lbnRzLiAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi9cbiAgdmFyIFZFUlNJT04gPSAnNC4xNy4yMCc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIENPUkVfRVJST1JfVEVYVCA9ICdVbnN1cHBvcnRlZCBjb3JlLWpzIHVzZS4gVHJ5IGh0dHBzOi8vbnBtcy5pby9zZWFyY2g/cT1wb255ZmlsbC4nLFxuICAgICAgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYXRlYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuICB2YXIgSE9UX0NPVU5UID0gODAwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAvKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xuICB2YXIgd3JhcEZsYWdzID0gW1xuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gICAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG4gIF07XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZyxcbiAgICAgIHJlVHJpbVN0YXJ0ID0gL15cXHMrLyxcbiAgICAgIHJlVHJpbUVuZCA9IC9cXHMrJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG4gIHZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxcbiAgICAgIHJlV3JhcERldGFpbHMgPSAvXFx7XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAoLispXFxdIFxcKi8sXG4gICAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoXG4gICAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuICB2YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG4gIHZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG4gIHZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxuICAgICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSknLFxuICAgICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbiAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG4gIHZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICAgIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gICAgcnNPcmRVcHBlcixcbiAgICByc09yZExvd2VyLFxuICAgIHJzRGlnaXRzLFxuICAgIHJzRW1vamlcbiAgXS5qb2luKCd8JyksICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG4gIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0J1ZmZlcicsICdEYXRhVmlldycsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnU3ltYm9sJywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIlxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcbiAgICAgIG5vZGVJc0RhdGUgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0RhdGUsXG4gICAgICBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcCxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxuICAgICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgICBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgfVxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZmluZEtleWAgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZWFuYCBhbmQgYF8ubWVhbkJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IChiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkgLyBsZW5ndGgpIDogTkFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gICAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gICAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAgICogdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIGFuZCBgXy5zdW1CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSk7XG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9QYWlyc2AgYW5kIGBfLnRvUGFpcnNJbmAgd2hpY2ggY3JlYXRlcyBhbiBhcnJheVxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgdmFyIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAmJiBuYXRpdmVJc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcbiAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdIC0gcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAyNTYgLSBgXy5hcnlgXG4gICAgICogIDUxMiAtIGBfLmZsaXBgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICAgICAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgICAgIH1cbiAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gICAgICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICAgICAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICAgICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gICAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gQ29tYmluaW5nIHNldmVyYWwgcHJlZGljYXRlcyB1c2luZyBgXy5vdmVyRXZlcnlgIG9yIGBfLm92ZXJTb21lYC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbeyAnYWdlJzogMzYgfSwgWydhZ2UnLCA0MF1dKSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICAgICAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBkZXB0aCkge1xuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaFJpZ2h0KFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAyYCB0aGVuIGAxYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaFJpZ2h0IDogYmFzZUVhY2hSaWdodDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gICAgICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2VSaWdodCA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5maWx0ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZSA6IGJhc2VTYW1wbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemUgOiBiYXNlU2FtcGxlU2l6ZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgICAqIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICAgIGxhc3RUaGlzLFxuICAgICAgICAgIG1heFdhaXQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRpbWVySWQsXG4gICAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyA9PiBMb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVsYXkgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBmbGlwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxpcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZsaXBwZWQgPSBfLmZsaXAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gWydkJywgJ2MnLCAnYicsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfRkxJUF9GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgICAqXG4gICAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqXG4gICAgICogb2JqZWN0LmEgPSAyO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKlxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW52b2NhdGlvbi4gVGhlIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50cyB0cmFuc2Zvcm1lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiBbeCwgeV07XG4gICAgICogfSwgW3NxdWFyZSwgZG91YmxlZF0pO1xuICAgICAqXG4gICAgICogZnVuYyg5LCAzKTtcbiAgICAgKiAvLyA9PiBbODEsIDZdXG4gICAgICpcbiAgICAgKiBmdW5jKDEwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTAwLCAxMF1cbiAgICAgKi9cbiAgICB2YXIgb3ZlckFyZ3MgPSBjYXN0UmVzdChmdW5jdGlvbihmdW5jLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gKHRyYW5zZm9ybXMubGVuZ3RoID09IDEgJiYgaXNBcnJheSh0cmFuc2Zvcm1zWzBdKSlcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXG4gICAgICAgIDogYXJyYXlNYXAoYmFzZUZsYXR0ZW4odHJhbnNmb3JtcywgMSksIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWxSaWdodCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCBbMiwgMCwgMV0pO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXhlcyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcbiAgICAgKiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jLCBzdGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlXG4gICAgICogW2BGdW5jdGlvbiNhcHBseWBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vbWRuLmlvL3NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNwcmVhZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IG5hdGl2ZU1heCh0b0ludGVnZXIoc3RhcnQpLCAwKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLFxuICAgICAgICAgICAgb3RoZXJBcmdzID0gY2FzdFNsaWNlKGFyZ3MsIDAsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVB1c2gob3RoZXJBcmdzLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gICAgICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAgICAgKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAgICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5hcnkoZnVuYykge1xuICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIGB3cmFwcGVyYCBhcyBpdHMgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsKGNhc3RGdW5jdGlvbih3cmFwcGVyKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbbnVsbF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKiBjb25zb2xlLmxvZyhfLmNhc3RBcnJheShhcnJheSkgPT09IGFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAgICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgb2JqZWN0YCBjb25mb3JtcyB0byBgc291cmNlYCBieSBpbnZva2luZyB0aGUgcHJlZGljYXRlXG4gICAgICogcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMjsgfSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbCB8fCBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUd0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheUJ1ZmZlcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IG5vZGVJc0FycmF5QnVmZmVyID8gYmFzZVVuYXJ5KG5vZGVJc0FycmF5QnVmZmVyKSA6IGJhc2VJc0FycmF5QnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAgICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICogaXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICAgKlxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAgICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gICAgICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICAgICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gICAgICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gICAgICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCB1cCB0b1xuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAgICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcmlzdGluZSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXG4gICAgICogb2YgdGhlIGNvcmUtanMgcGFja2FnZSBiZWNhdXNlIGNvcmUtanMgY2lyY3VtdmVudHMgdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAgKiBEZXNwaXRlIG11bHRpcGxlIHJlcXVlc3RzLCB0aGUgY29yZS1qcyBtYWludGFpbmVyIGhhcyBtYWRlIGl0IGNsZWFyOiBhbnlcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcbiAgICAgKiB3aXRoIGxpdHRsZSBjaG9pY2UgYnV0IHRvIHRocm93IGFuIGVycm9yLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gYWZmZWN0c1xuICAgICAqIHBhY2thZ2VzLCBsaWtlIFtiYWJlbC1wb2x5ZmlsbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmFiZWwtcG9seWZpbGwpLFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICAgICAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuOC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIuIEFuIGludGVnZXIgaXMgc2FmZSBpZiBpdCdzIGFuIElFRUUtNzU0XG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0KDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHQgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VMdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KDEpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1JdGVyYXRvciAmJiB2YWx1ZVtzeW1JdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiAodGFnID09IHNldFRhZyA/IHNldFRvQXJyYXkgOiB2YWx1ZXMpO1xuXG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICAgKiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDQyOTQ5NjcyOTVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIDAsIE1BWF9BUlJBWV9MRU5HVEgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b051bWJlcigzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgICAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gICAgICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzYWZlIGludGVnZXIuIEEgc2FmZSBpbnRlZ2VyIGNhbiBiZSBjb21wYXJlZCBhbmRcbiAgICAgKiByZXByZXNlbnRlZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDkwMDcxOTkyNTQ3NDA5OTFcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgOiAodmFsdWUgPT09IDAgPyB2YWx1ZSA6IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZygtMCk7XG4gICAgICogLy8gPT4gJy0wJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGBwYXRoc2Agb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8uYXQob2JqZWN0LCBbJ2FbMF0uYi5jJywgJ2FbMV0nXSk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIGF0ID0gZmxhdFJlc3QoYmFzZUF0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPT0gbnVsbCA/IHJlc3VsdCA6IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gICAgICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gICAgICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyAncGViYmxlcycgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd25SaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gICAgICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdjJywgJ2InLCB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JJbmAgbG9ncyAnYScsICdiJywgdGhlbiAnYycuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYW5kXG4gICAgICogaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBhbmQgaW5oZXJpdGVkXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gICAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob3RoZXIsICdhJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZVxuICAgICAqIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnZlcnRgIGV4Y2VwdCB0aGF0IHRoZSBpbnZlcnRlZCBvYmplY3QgaXMgZ2VuZXJhdGVkXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBpbnZlcnRlZCB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gJ2dyb3VwJyArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XG4gICAgICovXG4gICAgdmFyIGludmVydEJ5ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgfVxuICAgIH0sIGdldEl0ZXJhdGVlKTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiBbMSwgMiwgMywgNF0gfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5pbnZva2Uob2JqZWN0LCAnYVswXS5iLmMuc2xpY2UnLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gYmFzZVJlc3QoYmFzZUludm9rZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gICAgICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0pO1xuICAgICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrQnlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZlxuICAgICAqIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXRcbiAgICAgKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0Qnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gICAgICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSk7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYVxuICAgICAqIGZ1bmN0aW9uIGl0J3MgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gICAgICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiB2YWx1ZSB0byBzZXQuIFVzZSBgXy51cGRhdGVXaXRoYCB0byBjdXN0b21pemUgYHBhdGhgIGNyZWF0aW9uLiBUaGUgYHVwZGF0ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ3hbMF0ueS56JywgZnVuY3Rpb24obikgeyByZXR1cm4gbiA/IG4gKyAxIDogMDsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51cGRhdGVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiAtNVxuICAgICAqXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgdXBwZXIgPSB1cHBlciA9PT0gdXBwZXIgPyB1cHBlciA6IDA7XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IHRvTnVtYmVyKGxvd2VyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsYW1wKHRvTnVtYmVyKG51bWJlciksIGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgIH1cbiAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAgICogaXMgcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYGxvd2VyYCBvciBgdXBwZXJgIGFyZVxuICAgICAqIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcj0wXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XG4gICAgICAgIHVwcGVyID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gdXBwZXI7XG4gICAgICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvd2VyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkICYmIHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB1cHBlciA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XG4gICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSB0b0Zpbml0ZSh1cHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA+IHVwcGVyKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdXBwZXI7XG4gICAgICAgIHVwcGVyID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBsb3dlciAlIDEgfHwgdXBwZXIgJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gICAgICogdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gICAgICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICAgICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAgICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBsZW5ndGgpO1xuXG4gICAgICB2YXIgZW5kID0gcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAgICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gICAgICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAgICAgKiBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICAgICAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICovXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ2ZSRUQnXG4gICAgICovXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArXG4gICAgICAgIHN0cmluZyArXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoc3RyaW5nICsgY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSlcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykgKyBzdHJpbmcpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhXG4gICAgICogaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGVcbiAgICAgKiBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuMikgb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnMDgnLCAnMTAnXSwgXy5wYXJzZUludCk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVRyaW1TdGFydCwgJycpLCByYWRpeCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHN0cmluZ2Agd2l0aCBgcmVwbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjcmVwbGFjZWBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9yZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwbGFjZSgnSGkgRnJlZCcsICdGcmVkJywgJ0Jhcm5leScpO1xuICAgICAqIC8vID0+ICdIaSBCYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZSgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuXG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPCAzID8gc3RyaW5nIDogc3RyaW5nLnJlcGxhY2UoYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1GT08tQkFSLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgJiYgdHlwZW9mIGxpbWl0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZXBhcmF0b3IgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcbiAgICAgICAgICApKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgMCwgbGltaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHVwcGVyRmlyc3Qod29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBzdHJpbmcubGVuZ3RoKTtcblxuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICAgICAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICAgICAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICAgICAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAgICAgKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICAgICAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cbiAgICAgKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgICAgIC8vIHRvIG5vcm1hbGl6ZSBhbGwga2luZHMgb2Ygd2hpdGVzcGFjZSwgc28gZS5nLiBuZXdsaW5lcyAoYW5kIHVuaWNvZGUgdmVyc2lvbnMgb2YgaXQpIGNhbid0IHNuZWFrIGluXG4gICAgICAvLyBhbmQgZXNjYXBlIHRoZSBjb21tZW50LCB0aHVzIGluamVjdGluZyBjb2RlIHRoYXQgZ2V0cyBldmFsZWQuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgICAgICAgID8gKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1xccy9nLCAnICcpXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vYmFyJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltRW5kKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltRW5kLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgaWYgKGVuZCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKVxuICAgICAgICA6IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHN0clN5bWJvbHMpIHtcbiAgICAgICAgZW5kICs9IChyZXN1bHQubGVuZ3RoIC0gZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoZW5kKS5zZWFyY2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gcmVzdWx0O1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgdG9TdHJpbmcocmVGbGFncy5leGVjKHNlcGFyYXRvcikpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT09IHVuZGVmaW5lZCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGUkVEJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldywgWydjbGljayddKTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdmlldy5jbGljayk7XG4gICAgICogLy8gPT4gTG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBgcGFpcnNgIGFuZCBpbnZva2VzIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogZnVuY3Rpb24gb2YgdGhlIGZpcnN0IHByZWRpY2F0ZSB0byByZXR1cm4gdHJ1dGh5LiBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uXG4gICAgICogcGFpcnMgYXJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmNvbmQoW1xuICAgICAqICAgW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgICAgICAgICAgIF8uY29uc3RhbnQoJ21hdGNoZXMgQScpXSxcbiAgICAgKiAgIFtfLmNvbmZvcm1zKHsgJ2InOiBfLmlzTnVtYmVyIH0pLCBfLmNvbnN0YW50KCdtYXRjaGVzIEInKV0sXG4gICAgICogICBbXy5zdHViVHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgXy5jb25zdGFudCgnbm8gbWF0Y2gnKV1cbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBBJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMCwgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEInXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAnMScsICdiJzogJzInIH0pO1xuICAgICAqIC8vID0+ICdubyBtYXRjaCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG5cbiAgICAgIHBhaXJzID0gIWxlbmd0aCA/IFtdIDogYXJyYXlNYXAocGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICBpZiAoYXBwbHkocGFpclswXSwgdGhpcywgYXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShwYWlyWzFdLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYSBnaXZlbiBvYmplY3QsIHJldHVybmluZyBgdHJ1ZWAgaWZcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc1RvYCB3aXRoXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMiwgJ2InOiAxIH0sXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUsIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XG4gICAgICogc291cmNlIHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsIF8uaXRlcmF0ZWUoJ3VzZXInKSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgY3VzdG9tIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmMudGVzdChzdHJpbmcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICAgKiAvLyA9PiBbJ2RlZiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlblxuICAgICAqIG9iamVjdCBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcywgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uaXNNYXRjaGAgd2l0aCBgc291cmNlYFxuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm1hdGNoZXMoeyAnYSc6IDQsICdjJzogNiB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCBfLm1hdGNoZXMoeyAnYSc6IDQgfSldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcbiAgICAgKiB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QgdG8gYHNyY1ZhbHVlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGVcbiAgICAgKiBvYmplY3QgdmFsdWUgaXMgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0XG4gICAgICogYHNyY1ZhbHVlYCB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZVxuICAgICAqIGBfLmlzRXF1YWxgIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQob2JqZWN0cywgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KSk7XG4gICAgICogLy8gPT4geyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlc1Byb3BlcnR5KCdhJywgMSksIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDIpIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgxKSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJ10pKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIHZhciBtZXRob2RPZiA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZVxuICAgICAqIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uLCB0aGVuIG1ldGhvZHNcbiAgICAgKiBhcmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgbWl4aW5zIGFyZSBjaGFpbmFibGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdm93ZWxzKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xuICAgICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSk7XG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcyk7XG5cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgJiZcbiAgICAgICAgICAhKGlzT2JqZWN0KHNvdXJjZSkgJiYgKG1ldGhvZE5hbWVzLmxlbmd0aCB8fCAhcHJvcHMubGVuZ3RoKSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYWluID0gIShpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHx8ICEhb3B0aW9ucy5jaGFpbixcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG5cbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgICBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuXG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFycmF5UHVzaChbdGhpcy52YWx1ZSgpXSwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLm5vb3ApO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBhcmd1bWVudCBhdCBpbmRleCBgbmAuIElmIGBuYCBpcyBuZWdhdGl2ZSxcbiAgICAgKiB0aGUgbnRoIGFyZ3VtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhc3MtdGhydSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygxKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKC0yKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2MnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gYmFzZU50aChhcmdzLCBuKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGl0ZXJhdGVlc2Agd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzXG4gICAgICogYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXIoW01hdGgubWF4LCBNYXRoLm1pbl0pO1xuICAgICAqXG4gICAgICogZnVuYygxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbNCwgMV1cbiAgICAgKi9cbiAgICB2YXIgb3ZlciA9IGNyZWF0ZU92ZXIoYXJyYXlNYXApO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYWxsKiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckV2ZXJ5KFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyRXZlcnkgPSBjcmVhdGVPdmVyKGFycmF5RXZlcnkpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlclNvbWUoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciBtYXRjaGVzRnVuYyA9IF8ub3ZlclNvbWUoW3sgJ2EnOiAxIH0sIHsgJ2EnOiAyIH1dKVxuICAgICAqIHZhciBtYXRjaGVzUHJvcGVydHlGdW5jID0gXy5vdmVyU29tZShbWydhJywgMV0sIFsnYScsIDJdXSlcbiAgICAgKi9cbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXG4gICAgICogZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoNCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoLTQpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDUpO1xuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgICAqIC8vID0+IFtbXSwgW11dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5zdHViT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7fSwge31dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJPYmplY3QoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJycsICcnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XG4gICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdG90YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiBhdWdlbmQgKyBhZGRlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaXZpZGUoNiwgNCk7XG4gICAgICogLy8gPT4gMS41XG4gICAgICovXG4gICAgdmFyIGRpdmlkZSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1heGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtZWFuIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1lYW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZWFuYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgYXZlcmFnZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpY2FuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHByb2R1Y3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubXVsdGlwbHkoNiwgNCk7XG4gICAgICogLy8gPT4gMjRcbiAgICAgKi9cbiAgICB2YXIgbXVsdGlwbHkgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG11bHRpcGxpZXIsIG11bHRpcGxpY2FuZCkge1xuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuICAgICAqIC8vID0+IDQuMDFcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQxMDBcbiAgICAgKi9cbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YnRyYWhlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1YnRyYWN0KDYsIDQpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIHN1bW1lZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zdW1CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hc3NpZ25JbiA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbmNhdCA9IGNvbmNhdDtcbiAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VXaXRoID0gZGlmZmVyZW5jZVdpdGg7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZXB0aCA9IGZsYXRNYXBEZXB0aDtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsYXR0ZW5EZXB0aCA9IGZsYXR0ZW5EZXB0aDtcbiAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5mdW5jdGlvbnNJbiA9IGZ1bmN0aW9uc0luO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICBsb2Rhc2gubWV0aG9kT2YgPSBtZXRob2RPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5udGhBcmcgPSBudGhBcmc7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgbG9kYXNoLm92ZXJBcmdzID0gb3ZlckFyZ3M7XG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcbiAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsQnkgPSBwdWxsQWxsQnk7XG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xuICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgbG9kYXNoLnNldFdpdGggPSBzZXRXaXRoO1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgIGxvZGFzaC5zcGxpdCA9IHNwbGl0O1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICBsb2Rhc2gudG9QYWlyc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaW9uQnkgPSB1bmlvbkJ5O1xuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bmlxQnkgPSB1bmlxQnk7XG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XG4gICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgIGxvZGFzaC51cGRhdGVXaXRoID0gdXBkYXRlV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcbiAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNlaWwgPSBjZWlsO1xuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xuICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgbG9kYXNoLmNvbmZvcm1zVG8gPSBjb25mb3Jtc1RvO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICBsb2Rhc2guZGl2aWRlID0gZGl2aWRlO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XG4gICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgbG9kYXNoLmd0ZSA9IGd0ZTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgIGxvZGFzaC5oZWFkID0gaGVhZDtcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICBsb2Rhc2guaXNNYXAgPSBpc01hcDtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlO1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTYWZlSW50ZWdlciA9IGlzU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzU3ltYm9sID0gaXNTeW1ib2w7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2guaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5sb3dlckNhc2UgPSBsb3dlckNhc2U7XG4gICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgIGxvZGFzaC5sdCA9IGx0O1xuICAgIGxvZGFzaC5sdGUgPSBsdGU7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcbiAgICBsb2Rhc2gubWVhbiA9IG1lYW47XG4gICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5taW5CeSA9IG1pbkJ5O1xuICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcbiAgICBsb2Rhc2guc3R1Yk9iamVjdCA9IHN0dWJPYmplY3Q7XG4gICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xuICAgIGxvZGFzaC5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZEVuZCA9IHBhZEVuZDtcbiAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleEJ5ID0gc29ydGVkSW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4QnkgPSBzb3J0ZWRMYXN0SW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC5zdW1CeSA9IHN1bUJ5O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0Zpbml0ZSA9IHRvRmluaXRlO1xuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgbG9kYXNoLnRvTGVuZ3RoID0gdG9MZW5ndGg7XG4gICAgbG9kYXNoLnRvTG93ZXIgPSB0b0xvd2VyO1xuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgIGxvZGFzaC50b1NhZmVJbnRlZ2VyID0gdG9TYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltRW5kID0gdHJpbUVuZDtcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgIGxvZGFzaC50cnVuY2F0ZSA9IHRydW5jYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC51cHBlckNhc2UgPSB1cHBlckNhc2U7XG4gICAgbG9kYXNoLnVwcGVyRmlyc3QgPSB1cHBlckZpcnN0O1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcblxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSksIHsgJ2NoYWluJzogZmFsc2UgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIG4gPSBuID09PSB1bmRlZmluZWQgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICh0aGlzLl9fZmlsdGVyZWRfXyAmJiAhaW5kZXgpXG4gICAgICAgICAgPyBuZXcgTGF6eVdyYXBwZXIodGhpcylcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXykge1xuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cbiAgICBhcnJheUVhY2goWydmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICdpdGVyYXRlZSc6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSByZXN1bHQuX19maWx0ZXJlZF9fIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmhlYWRgIGFuZCBgXy5sYXN0YC5cbiAgICBhcnJheUVhY2goWydoZWFkJywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8udGFpbGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICd0YWlsJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudGFrZVJpZ2h0KC1zdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBpc1Rha2VyID0gL14oPzpoZWFkfGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSBpc1Rha2VyIHx8IC9eZmluZC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWVdLCBhcmdzKSk7XG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNVbndyYXBwZWQgPSByZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsLFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgICByZXR1cm4gaXNVbndyYXBwZWQgPyAoaXNUYWtlciA/IHJlc3VsdC52YWx1ZSgpWzBdIDogcmVzdWx0LnZhbHVlKCkpIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgQXJyYXlgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ3BvcCcsICdwdXNoJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBtZXRob2QgbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgJyc7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICByZWFsTmFtZXNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyAnbmFtZSc6IG1ldGhvZE5hbWUsICdmdW5jJzogbG9kYXNoRnVuYyB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWxOYW1lc1tjcmVhdGVIeWJyaWQodW5kZWZpbmVkLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxuICAgICAgJ2Z1bmMnOiB1bmRlZmluZWRcbiAgICB9XTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMYXp5V3JhcHBlcmAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5hdCA9IHdyYXBwZXJBdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLm5leHQgPSB3cmFwcGVyTmV4dDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5maXJzdCA9IGxvZGFzaC5wcm90b3R5cGUuaGVhZDtcblxuICAgIGlmIChzeW1JdGVyYXRvcikge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVtzeW1JdGVyYXRvcl0gPSB3cmFwcGVyVG9JdGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBpdC5cbiAgZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cbiAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGF0dHJpYnV0ZVRvU3RyaW5nKGF0dHJpYnV0ZSkge1xuICBpZiAodHlwZW9mIGF0dHJpYnV0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICBhdHRyaWJ1dGUgKz0gJyc7XG4gICAgaWYgKGF0dHJpYnV0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGF0dHJpYnV0ZSA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXR0cmlidXRlLnRyaW0oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICBlbGVtLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW0sIC4uLmNsYXNzTmFtZXMpIHtcbiAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICByZXR1cm4gZWxlbTtcbn1cbiIsImltcG9ydCBBeGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBpc0VtcHR5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGF0dHJpYnV0ZVRvU3RyaW5nIH0gZnJvbSAnLi9oZWxwZXInO1xuXG5jb25zdCBpbnN0YW5jZSA9IEF4aW9zLmNyZWF0ZSh7XG4gIGhlYWRlcnM6IHsgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnIH0sXG59KTtcbmNvbnN0IGFqYXhUZW1wbGF0ZUZ1bmMgPSAodXJsLCBtZXRob2QgPSAnZ2V0JywgZGF0YSA9IHt9KSA9PiB7XG4gIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVVUkkodXJsKTtcbiAgbGV0IHJlcXVlc3Q7XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ2dldCcpIHtcbiAgICBpZiAoaXNFbXB0eShkYXRhKSkge1xuICAgICAgcmVxdWVzdCA9IGluc3RhbmNlLmdldChlbmNvZGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdCA9IGluc3RhbmNlLmdldChlbmNvZGVkLCBkYXRhKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbXB0eShkYXRhKSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICByZXF1ZXN0ID0gaW5zdGFuY2UucG9zdChlbmNvZGVkKTtcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0ID0gaW5zdGFuY2UucG9zdChlbmNvZGVkLCBkYXRhKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdFxuICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSlcbiAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICByZXR1cm4gZXJyb3IucmVzcG9uc2UuZGF0YTtcbiAgICB9KTtcbn07XG4vLyB0b2RvOiB1cmxlbmNvZGVcblxuZXhwb3J0IGNvbnN0IGdldENhcnQgPSAoKSA9PiB7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKCcvY2FydC5qcycpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRQcm9kdWN0ID0gKGhhbmRsZSkgPT4ge1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYyhgL3Byb2R1Y3RzLyR7aGFuZGxlfS5qc2ApO1xufTtcbmV4cG9ydCBjb25zdCBjbGVhckNhcnQgPSAoKSA9PiB7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKCcvY2FydC9jbGVhci5qcycsICdwb3N0Jyk7XG59O1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUNhcnRGcm9tRm9ybSA9IChmb3JtKSA9PiB7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKCcvY2FydC91cGRhdGUuanMnLCAncG9zdCcsIG5ldyBGb3JtRGF0YShmb3JtKSk7XG59O1xuZXhwb3J0IGNvbnN0IGNoYW5nZUl0ZW1CeUtleU9ySWQgPSAoaWQsIHF1YW50aXR5KSA9PiB7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKCcvY2FydC9jaGFuZ2UuanMnLCAncG9zdCcsIHtcbiAgICBxdWFudGl0eSxcbiAgICBpZCxcbiAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IHJlbW92ZUl0ZW1CeUtleU9ySWQgPSAoaWQpID0+IHtcbiAgcmV0dXJuIGFqYXhUZW1wbGF0ZUZ1bmMoJy9jYXJ0L2NoYW5nZS5qcycsICdwb3N0JywgeyBxdWFudGl0eTogMCwgaWQgfSk7XG59O1xuZXhwb3J0IGNvbnN0IGNoYW5nZUl0ZW1CeUxpbmUgPSAobGluZSwgcXVhbnRpdHksIHByb3BlcnRpZXMpID0+IHtcbiAgcmV0dXJuIGFqYXhUZW1wbGF0ZUZ1bmMoJy9jYXJ0L2NoYW5nZS5qcycsICdwb3N0Jywge1xuICAgIHF1YW50aXR5LFxuICAgIGxpbmUsXG4gICAgcHJvcGVydGllcyxcbiAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IHJlbW92ZUl0ZW1CeUxpbmUgPSAobGluZSkgPT4ge1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYygnL2NhcnQvY2hhbmdlLmpzJywgJ3Bvc3QnLCB7IHF1YW50aXR5OiAwLCBsaW5lIH0pO1xufTtcbmV4cG9ydCBjb25zdCBhZGRJdGVtID0gKGlkLCBxdWFudGl0eSwgcHJvcGVydGllcyA9IHt9KSA9PiB7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKCcvY2FydC9hZGQuanMnLCAncG9zdCcsIHtcbiAgICBpZCxcbiAgICBxdWFudGl0eSxcbiAgICBwcm9wZXJ0aWVzLFxuICB9KTtcbn07XG5leHBvcnQgY29uc3QgYWRkSXRlbUZyb21Gb3JtID0gKGZvcm0pID0+IHtcbiAgcmV0dXJuIGFqYXhUZW1wbGF0ZUZ1bmMoJy9jYXJ0L2FkZC5qcycsICdwb3N0JywgbmV3IEZvcm1EYXRhKGZvcm0pKTtcbn07XG5leHBvcnQgY29uc3QgdXBkYXRlQ2FydEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgZGF0YSA9ICcnO1xuICBpZiAoQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzKSkge1xuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cmlidXRlKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBhdHRyaWJ1dGVUb1N0cmluZyhhdHRyaWJ1dGUua2V5KTtcbiAgICAgIGlmIChrZXkgIT09ICcnKSB7XG4gICAgICAgIGRhdGEgKz0gYGF0dHJpYnV0ZXNbJHtrZXl9XT0ke2F0dHJpYnV0ZVRvU3RyaW5nKGF0dHJpYnV0ZS52YWx1ZSl9JmA7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF0dHJpYnV0ZXMgPT09ICdvYmplY3QnICYmIGF0dHJpYnV0ZXMgIT09IG51bGwpIHtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgZGF0YSArPSBgYXR0cmlidXRlc1ske2F0dHJpYnV0ZVRvU3RyaW5nKGtleSl9XT0ke2F0dHJpYnV0ZVRvU3RyaW5nKFxuICAgICAgICB2YWx1ZVxuICAgICAgKX0mYDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYygnL2NhcnQvdXBkYXRlLmpzJywgJ3Bvc3QnLCBkYXRhKTtcbn07XG5leHBvcnQgY29uc3QgdXBkYXRlQ2FydE5vdGUgPSAobm90ZSkgPT4ge1xuICByZXR1cm4gYWpheFRlbXBsYXRlRnVuYyhcbiAgICAnL2NhcnQvdXBkYXRlLmpzJyxcbiAgICAncG9zdCcsXG4gICAgYG5vdGU9JHthdHRyaWJ1dGVUb1N0cmluZyhub3RlKX1gXG4gICk7XG59O1xuZXhwb3J0IGNvbnN0IGdldFJlY29tbWVuZGVkUHJvZHVjdHMgPSAocHJvZHVjdElkLCBsaW1pdCA9IDEwKSA9PiB7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKFxuICAgIGAvcmVjb21tZW5kYXRpb25zL3Byb2R1Y3RzLmpzb24/cHJvZHVjdF9pZD0ke3Byb2R1Y3RJZH0mbGltaXQ9JHtcbiAgICAgIGxpbWl0ICYmIHBhcnNlSW50KGxpbWl0LCAxMCkgPiAwICYmIHBhcnNlSW50KGxpbWl0LCAxMCkgPD0gMTBcbiAgICAgICAgPyBwYXJzZUludChsaW1pdCwgMTApXG4gICAgICAgIDogMTBcbiAgICB9YFxuICApO1xufTtcbmV4cG9ydCBjb25zdCBnZXRQcmVkaWN0aXZlU2VhcmNoUmVzdWx0cyA9IChcbiAgcSxcbiAgdHlwZSA9IFsncHJvZHVjdCcsICdwYWdlJywgJ2FydGljbGUnLCAnY29sbGVjdGlvbiddLFxuICBsaW1pdCA9IDEwLFxuICB1bmF2YWlsYWJsZVByb2R1Y3RzID0gJ2xhc3QnLFxuICBmaWVsZHMgPSBbJ3RpdGxlJywgJ3Byb2R1Y3RfdHlwZScsICd2YXJpYW50cy50aXRsZScsICd2ZW5kb3InXVxuKSA9PiB7XG4gIGxldCBwYXJhbXNTdHJpbmcgPSAnJztcbiAgcGFyYW1zU3RyaW5nICs9IGBxPSR7cX1gO1xuICBwYXJhbXNTdHJpbmcgKz0gYCZyZXNvdXJjZXNbdHlwZV09JHt0eXBlLmpvaW4oJywnKX1gO1xuICBwYXJhbXNTdHJpbmcgKz0gYCZyZXNvdXJjZXNbbGltaXRdPSR7bGltaXR9YDtcbiAgcGFyYW1zU3RyaW5nICs9IGAmcmVzb3VyY2VzW29wdGlvbnNdW3VuYXZhaWxhYmxlX3Byb2R1Y3RzXT0ke3VuYXZhaWxhYmxlUHJvZHVjdHN9YDtcbiAgcGFyYW1zU3RyaW5nICs9IGAmcmVzb3VyY2VzW29wdGlvbnNdW2ZpZWxkc109JHtmaWVsZHMuam9pbignLCcpfWA7XG4gIHJldHVybiBhamF4VGVtcGxhdGVGdW5jKGAvc2VhcmNoL3N1Z2dlc3QuanNvbj8ke3BhcmFtc1N0cmluZ31gKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0Q2FydCxcbiAgZ2V0UHJvZHVjdCxcbiAgY2xlYXJDYXJ0LFxuICB1cGRhdGVDYXJ0RnJvbUZvcm0sXG4gIGNoYW5nZUl0ZW1CeUtleU9ySWQsXG4gIHJlbW92ZUl0ZW1CeUtleU9ySWQsXG4gIGNoYW5nZUl0ZW1CeUxpbmUsXG4gIHJlbW92ZUl0ZW1CeUxpbmUsXG4gIGFkZEl0ZW0sXG4gIGFkZEl0ZW1Gcm9tRm9ybSxcbiAgdXBkYXRlQ2FydEF0dHJpYnV0ZXMsXG4gIHVwZGF0ZUNhcnROb3RlLFxuICBnZXRSZWNvbW1lbmRlZFByb2R1Y3RzLFxuICBnZXRQcmVkaWN0aXZlU2VhcmNoUmVzdWx0cyxcbn07XG4iLCIvKiBAcHJlc2VydmVcbiAgICBfX19fXyBfXyBfICAgICBfXyAgICAgICAgICAgICAgICBfXG4gICAvIF9fXy8vIC8oXylfX18vIC9fX18gIF9fX18gICAgICAoXylfX19cbiAgLyAoXyAvLyAvLyAvLyBfICAvLyAtXykvIF9fL18gICAgLyAvKF8tPFxuICBcXF9fXy8vXy8vXy8gXFxfLF8vIFxcX18vL18vICAoXylfXy8gLy9fX18vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8X19fL1xuXG4gIFZlcnNpb246IDEuNy4zXG4gIEF1dGhvcjogTmljayBQaXNjaXRlbGxpIChwaWNreWtuZWVlKVxuICBXZWJzaXRlOiBodHRwczovL25pY2twaXNjaXRlbGxpLmNvbVxuICBEb2N1bWVudGF0aW9uOiBodHRwOi8vbmlja3Bpc2NpdGVsbGkuZ2l0aHViLmlvL0dsaWRlci5qc1xuICBMaWNlbnNlOiBNSVQgTGljZW5zZVxuICBSZWxlYXNlIERhdGU6IE9jdG9iZXIgMjV0aCwgMjAxOFxuXG4qL1xuXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICA/IGRlZmluZShmYWN0b3J5KVxuICAgIDogdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnXG4gICAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICAgIDogZmFjdG9yeSgpXG59KShmdW5jdGlvbiAoKSB7XG4gICgndXNlIHN0cmljdCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgLyogZ2xvYmFscyB3aW5kb3c6dHJ1ZSAqL1xuICB2YXIgX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpc1xuXG4gIHZhciBHbGlkZXIgPSAoX3dpbmRvdy5HbGlkZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIGlmIChlbGVtZW50Ll9nbGlkZXIpIHJldHVybiBlbGVtZW50Ll9nbGlkZXJcblxuICAgIF8uZWxlID0gZWxlbWVudFxuICAgIF8uZWxlLmNsYXNzTGlzdC5hZGQoJ2dsaWRlcicpXG5cbiAgICAvLyBleHBvc2UgZ2xpZGVyIG9iamVjdCB0byBpdHMgRE9NIGVsZW1lbnRcbiAgICBfLmVsZS5fZ2xpZGVyID0gX1xuXG4gICAgLy8gbWVyZ2UgdXNlciBzZXR0aW5nIHdpdGggZGVmYXVsdHNcbiAgICBfLm9wdCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIHtcbiAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gICAgICAgIHNsaWRlc1RvU2hvdzogMSxcbiAgICAgICAgcmVzaXplTG9jazogdHJ1ZSxcbiAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgLy8gZWFzZUluUXVhZFxuICAgICAgICBlYXNpbmc6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXR0aW5nc1xuICAgIClcblxuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIF8uYW5pbWF0ZV9pZCA9IF8ucGFnZSA9IF8uc2xpZGUgPSAwXG4gICAgXy5hcnJvd3MgPSB7fVxuXG4gICAgLy8gcHJlc2VydmUgb3JpZ2luYWwgb3B0aW9ucyB0b1xuICAgIC8vIGV4dGVuZCBicmVha3BvaW50IHNldHRpbmdzXG4gICAgXy5fb3B0ID0gXy5vcHRcblxuICAgIGlmIChfLm9wdC5za2lwVHJhY2spIHtcbiAgICAgIC8vIGZpcnN0IGFuZCBvbmx5IGNoaWxkIGlzIHRoZSB0cmFja1xuICAgICAgXy50cmFjayA9IF8uZWxlLmNoaWxkcmVuWzBdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB0cmFjayBhbmQgd3JhcCBzbGlkZXNcbiAgICAgIF8udHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgXy5lbGUuYXBwZW5kQ2hpbGQoXy50cmFjaylcbiAgICAgIHdoaWxlIChfLmVsZS5jaGlsZHJlbi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgXy50cmFjay5hcHBlbmRDaGlsZChfLmVsZS5jaGlsZHJlblswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfLnRyYWNrLmNsYXNzTGlzdC5hZGQoJ2dsaWRlci10cmFjaycpXG5cbiAgICAvLyBzdGFydCBnbGlkZXJcbiAgICBfLmluaXQoKVxuXG4gICAgLy8gc2V0IGV2ZW50c1xuICAgIF8ucmVzaXplID0gXy5pbml0LmJpbmQoXywgdHJ1ZSlcbiAgICBfLmV2ZW50KF8uZWxlLCAnYWRkJywge1xuICAgICAgc2Nyb2xsOiBfLnVwZGF0ZUNvbnRyb2xzLmJpbmQoXylcbiAgICB9KVxuICAgIF8uZXZlbnQoX3dpbmRvdywgJ2FkZCcsIHtcbiAgICAgIHJlc2l6ZTogXy5yZXNpemVcbiAgICB9KVxuICB9KVxuXG4gIHZhciBnbGlkZXJQcm90b3R5cGUgPSBHbGlkZXIucHJvdG90eXBlXG4gIGdsaWRlclByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHJlZnJlc2gsIHBhZ2luZykge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgdmFyIHdpZHRoID0gMFxuXG4gICAgdmFyIGhlaWdodCA9IDBcblxuICAgIF8uc2xpZGVzID0gXy50cmFjay5jaGlsZHJlbjtcblxuICAgIFtdLmZvckVhY2guY2FsbChfLnNsaWRlcywgZnVuY3Rpb24gKF8pIHtcbiAgICAgIF8uY2xhc3NMaXN0LmFkZCgnZ2xpZGVyLXNsaWRlJylcbiAgICB9KVxuXG4gICAgXy5jb250YWluZXJXaWR0aCA9IF8uZWxlLmNsaWVudFdpZHRoXG5cbiAgICB2YXIgYnJlYWtwb2ludENoYW5nZWQgPSBfLnNldHRpbmdzQnJlYWtwb2ludCgpXG4gICAgaWYgKCFwYWdpbmcpIHBhZ2luZyA9IGJyZWFrcG9pbnRDaGFuZ2VkXG5cbiAgICBpZiAoXG4gICAgICBfLm9wdC5zbGlkZXNUb1Nob3cgPT09ICdhdXRvJyB8fFxuICAgICAgdHlwZW9mIF8ub3B0Ll9hdXRvU2xpZGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICB2YXIgc2xpZGVDb3VudCA9IF8uY29udGFpbmVyV2lkdGggLyBfLm9wdC5pdGVtV2lkdGhcblxuICAgICAgXy5vcHQuX2F1dG9TbGlkZSA9IF8ub3B0LnNsaWRlc1RvU2hvdyA9IF8ub3B0LmV4YWN0V2lkdGhcbiAgICAgICAgPyBzbGlkZUNvdW50XG4gICAgICAgIDogTWF0aC5mbG9vcihzbGlkZUNvdW50KVxuICAgIH1cbiAgICBpZiAoXy5vcHQuc2xpZGVzVG9TY3JvbGwgPT09ICdhdXRvJykge1xuICAgICAgXy5vcHQuc2xpZGVzVG9TY3JvbGwgPSBNYXRoLmZsb29yKF8ub3B0LnNsaWRlc1RvU2hvdylcbiAgICB9XG5cbiAgICBfLml0ZW1XaWR0aCA9IF8ub3B0LmV4YWN0V2lkdGhcbiAgICAgID8gXy5vcHQuaXRlbVdpZHRoXG4gICAgICA6IF8uY29udGFpbmVyV2lkdGggLyBfLm9wdC5zbGlkZXNUb1Nob3c7XG5cbiAgICAvLyBzZXQgc2xpZGUgZGltZW5zaW9uc1xuICAgIFtdLmZvckVhY2guY2FsbChfLnNsaWRlcywgZnVuY3Rpb24gKF9fKSB7XG4gICAgICBfXy5zdHlsZS5oZWlnaHQgPSAnYXV0bydcbiAgICAgIF9fLnN0eWxlLndpZHRoID0gXy5pdGVtV2lkdGggKyAncHgnXG4gICAgICB3aWR0aCArPSBfLml0ZW1XaWR0aFxuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoX18ub2Zmc2V0SGVpZ2h0LCBoZWlnaHQpXG4gICAgfSlcblxuICAgIF8udHJhY2suc3R5bGUud2lkdGggPSB3aWR0aCArICdweCdcbiAgICBfLnRyYWNrV2lkdGggPSB3aWR0aFxuICAgIF8uaXNEcmFnID0gZmFsc2VcbiAgICBfLnByZXZlbnRDbGljayA9IGZhbHNlXG5cbiAgICBfLm9wdC5yZXNpemVMb2NrICYmIF8uc2Nyb2xsVG8oXy5zbGlkZSAqIF8uaXRlbVdpZHRoLCAwKVxuXG4gICAgaWYgKGJyZWFrcG9pbnRDaGFuZ2VkIHx8IHBhZ2luZykge1xuICAgICAgXy5iaW5kQXJyb3dzKClcbiAgICAgIF8uYnVpbGREb3RzKClcbiAgICAgIF8uYmluZERyYWcoKVxuICAgIH1cblxuICAgIF8udXBkYXRlQ29udHJvbHMoKVxuXG4gICAgXy5lbWl0KHJlZnJlc2ggPyAncmVmcmVzaCcgOiAnbG9hZGVkJylcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5iaW5kRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgXyA9IHRoaXNcbiAgICBfLm1vdXNlID0gXy5tb3VzZSB8fCBfLmhhbmRsZU1vdXNlLmJpbmQoXylcblxuICAgIHZhciBtb3VzZXVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgXy5tb3VzZURvd24gPSB1bmRlZmluZWRcbiAgICAgIF8uZWxlLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWcnKVxuICAgICAgaWYgKF8uaXNEcmFnKSB7XG4gICAgICAgIF8ucHJldmVudENsaWNrID0gdHJ1ZVxuICAgICAgfVxuICAgICAgXy5pc0RyYWcgPSBmYWxzZVxuICAgIH1cblxuICAgIHZhciBldmVudHMgPSB7XG4gICAgICBtb3VzZXVwOiBtb3VzZXVwLFxuICAgICAgbW91c2VsZWF2ZTogbW91c2V1cCxcbiAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgXy5tb3VzZURvd24gPSBlLmNsaWVudFhcbiAgICAgICAgXy5lbGUuY2xhc3NMaXN0LmFkZCgnZHJhZycpXG4gICAgICB9LFxuICAgICAgbW91c2Vtb3ZlOiBfLm1vdXNlLFxuICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfLnByZXZlbnRDbGljaykge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgfVxuICAgICAgICBfLnByZXZlbnRDbGljayA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgXy5lbGUuY2xhc3NMaXN0LnRvZ2dsZSgnZHJhZ2dhYmxlJywgXy5vcHQuZHJhZ2dhYmxlID09PSB0cnVlKVxuICAgIF8uZXZlbnQoXy5lbGUsICdyZW1vdmUnLCBldmVudHMpXG4gICAgaWYgKF8ub3B0LmRyYWdnYWJsZSkgXy5ldmVudChfLmVsZSwgJ2FkZCcsIGV2ZW50cylcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5idWlsZERvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICBpZiAoIV8ub3B0LmRvdHMpIHtcbiAgICAgIGlmIChfLmRvdHMpIF8uZG90cy5pbm5lckhUTUwgPSAnJ1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfLm9wdC5kb3RzID09PSAnc3RyaW5nJykge1xuICAgICAgXy5kb3RzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihfLm9wdC5kb3RzKVxuICAgIH0gZWxzZSBfLmRvdHMgPSBfLm9wdC5kb3RzXG4gICAgaWYgKCFfLmRvdHMpIHJldHVyblxuXG4gICAgXy5kb3RzLmlubmVySFRNTCA9ICcnXG4gICAgXy5kb3RzLmNsYXNzTGlzdC5hZGQoJ2dsaWRlci1kb3RzJylcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5jZWlsKF8uc2xpZGVzLmxlbmd0aCAvIF8ub3B0LnNsaWRlc1RvU2hvdyk7ICsraSkge1xuICAgICAgdmFyIGRvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgICBkb3QuZGF0YXNldC5pbmRleCA9IGlcbiAgICAgIGRvdC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnUGFnZSAnICsgKGkgKyAxKSlcbiAgICAgIGRvdC5jbGFzc05hbWUgPSAnZ2xpZGVyLWRvdCAnICsgKGkgPyAnJyA6ICdhY3RpdmUnKVxuICAgICAgXy5ldmVudChkb3QsICdhZGQnLCB7XG4gICAgICAgIGNsaWNrOiBfLnNjcm9sbEl0ZW0uYmluZChfLCBpLCB0cnVlKVxuICAgICAgfSlcbiAgICAgIF8uZG90cy5hcHBlbmRDaGlsZChkb3QpXG4gICAgfVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLmJpbmRBcnJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF8gPSB0aGlzXG4gICAgaWYgKCFfLm9wdC5hcnJvd3MpIHtcbiAgICAgIE9iamVjdC5rZXlzKF8uYXJyb3dzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBfLmFycm93c1tkaXJlY3Rpb25dXG4gICAgICAgIF8uZXZlbnQoZWxlbWVudCwgJ3JlbW92ZScsIHsgY2xpY2s6IGVsZW1lbnQuX2Z1bmMgfSlcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgWydwcmV2JywgJ25leHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBhcnJvdyA9IF8ub3B0LmFycm93c1tkaXJlY3Rpb25dXG4gICAgICBpZiAoYXJyb3cpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcnJvdyA9PT0gJ3N0cmluZycpIGFycm93ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcnJvdylcbiAgICAgICAgYXJyb3cuX2Z1bmMgPSBhcnJvdy5fZnVuYyB8fCBfLnNjcm9sbEl0ZW0uYmluZChfLCBkaXJlY3Rpb24pXG4gICAgICAgIF8uZXZlbnQoYXJyb3csICdyZW1vdmUnLCB7XG4gICAgICAgICAgY2xpY2s6IGFycm93Ll9mdW5jXG4gICAgICAgIH0pXG4gICAgICAgIF8uZXZlbnQoYXJyb3csICdhZGQnLCB7XG4gICAgICAgICAgY2xpY2s6IGFycm93Ll9mdW5jXG4gICAgICAgIH0pXG4gICAgICAgIF8uYXJyb3dzW2RpcmVjdGlvbl0gPSBhcnJvd1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUudXBkYXRlQ29udHJvbHMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIGlmIChldmVudCAmJiAhXy5vcHQuc2Nyb2xsUHJvcGFnYXRlKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIH1cblxuICAgIHZhciBkaXNhYmxlQXJyb3dzID0gXy5jb250YWluZXJXaWR0aCA+PSBfLnRyYWNrV2lkdGhcblxuICAgIGlmICghXy5vcHQucmV3aW5kKSB7XG4gICAgICBpZiAoXy5hcnJvd3MucHJldikge1xuICAgICAgICBfLmFycm93cy5wcmV2LmNsYXNzTGlzdC50b2dnbGUoXG4gICAgICAgICAgJ2Rpc2FibGVkJyxcbiAgICAgICAgICBfLmVsZS5zY3JvbGxMZWZ0IDw9IDAgfHwgZGlzYWJsZUFycm93c1xuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoXy5hcnJvd3MubmV4dCkge1xuICAgICAgICBfLmFycm93cy5uZXh0LmNsYXNzTGlzdC50b2dnbGUoXG4gICAgICAgICAgJ2Rpc2FibGVkJyxcbiAgICAgICAgICBNYXRoLmNlaWwoXy5lbGUuc2Nyb2xsTGVmdCArIF8uY29udGFpbmVyV2lkdGgpID49XG4gICAgICAgICAgICBNYXRoLmZsb29yKF8udHJhY2tXaWR0aCkgfHwgZGlzYWJsZUFycm93c1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgXy5zbGlkZSA9IE1hdGgucm91bmQoXy5lbGUuc2Nyb2xsTGVmdCAvIF8uaXRlbVdpZHRoKVxuICAgIF8ucGFnZSA9IE1hdGgucm91bmQoXy5lbGUuc2Nyb2xsTGVmdCAvIF8uY29udGFpbmVyV2lkdGgpXG5cbiAgICB2YXIgbWlkZGxlID0gXy5zbGlkZSArIE1hdGguZmxvb3IoTWF0aC5mbG9vcihfLm9wdC5zbGlkZXNUb1Nob3cpIC8gMilcblxuICAgIHZhciBleHRyYU1pZGRsZSA9IE1hdGguZmxvb3IoXy5vcHQuc2xpZGVzVG9TaG93KSAlIDIgPyAwIDogbWlkZGxlICsgMVxuICAgIGlmIChNYXRoLmZsb29yKF8ub3B0LnNsaWRlc1RvU2hvdykgPT09IDEpIHtcbiAgICAgIGV4dHJhTWlkZGxlID0gMFxuICAgIH1cblxuICAgIC8vIHRoZSBsYXN0IHBhZ2UgbWF5IGJlIGxlc3MgdGhhbiBvbmUgaGFsZiBvZiBhIG5vcm1hbCBwYWdlIHdpZHRoIHNvXG4gICAgLy8gdGhlIHBhZ2UgaXMgcm91bmRlZCBkb3duLiB3aGVuIGF0IHRoZSBlbmQsIGZvcmNlIHRoZSBwYWdlIHRvIHR1cm5cbiAgICBpZiAoXy5lbGUuc2Nyb2xsTGVmdCArIF8uY29udGFpbmVyV2lkdGggPj0gTWF0aC5mbG9vcihfLnRyYWNrV2lkdGgpKSB7XG4gICAgICBfLnBhZ2UgPSBfLmRvdHMgPyBfLmRvdHMuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDBcbiAgICB9XG5cbiAgICBbXS5mb3JFYWNoLmNhbGwoXy5zbGlkZXMsIGZ1bmN0aW9uIChzbGlkZSwgaW5kZXgpIHtcbiAgICAgIHZhciBzbGlkZUNsYXNzZXMgPSBzbGlkZS5jbGFzc0xpc3RcblxuICAgICAgdmFyIHdhc1Zpc2libGUgPSBzbGlkZUNsYXNzZXMuY29udGFpbnMoJ3Zpc2libGUnKVxuXG4gICAgICB2YXIgc3RhcnQgPSBfLmVsZS5zY3JvbGxMZWZ0XG5cbiAgICAgIHZhciBlbmQgPSBfLmVsZS5zY3JvbGxMZWZ0ICsgXy5jb250YWluZXJXaWR0aFxuXG4gICAgICB2YXIgaXRlbVN0YXJ0ID0gXy5pdGVtV2lkdGggKiBpbmRleFxuXG4gICAgICB2YXIgaXRlbUVuZCA9IGl0ZW1TdGFydCArIF8uaXRlbVdpZHRoO1xuXG4gICAgICBbXS5mb3JFYWNoLmNhbGwoc2xpZGVDbGFzc2VzLCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIC9ebGVmdHxyaWdodC8udGVzdChjbGFzc05hbWUpICYmIHNsaWRlQ2xhc3Nlcy5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgfSlcbiAgICAgIHNsaWRlQ2xhc3Nlcy50b2dnbGUoJ2FjdGl2ZScsIF8uc2xpZGUgPT09IGluZGV4KVxuICAgICAgaWYgKG1pZGRsZSA9PT0gaW5kZXggfHwgKGV4dHJhTWlkZGxlICYmIGV4dHJhTWlkZGxlID09PSBpbmRleCkpIHtcbiAgICAgICAgc2xpZGVDbGFzc2VzLmFkZCgnY2VudGVyJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsaWRlQ2xhc3Nlcy5yZW1vdmUoJ2NlbnRlcicpXG4gICAgICAgIHNsaWRlQ2xhc3Nlcy5hZGQoXG4gICAgICAgICAgW1xuICAgICAgICAgICAgaW5kZXggPCBtaWRkbGUgPyAnbGVmdCcgOiAncmlnaHQnLFxuICAgICAgICAgICAgTWF0aC5hYnMoaW5kZXggLSAoaW5kZXggPCBtaWRkbGUgPyBtaWRkbGUgOiBleHRyYU1pZGRsZSB8fCBtaWRkbGUpKVxuICAgICAgICAgIF0uam9pbignLScpXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdmFyIGlzVmlzaWJsZSA9XG4gICAgICAgIE1hdGguY2VpbChpdGVtU3RhcnQpID49IHN0YXJ0ICYmIE1hdGguZmxvb3IoaXRlbUVuZCkgPD0gZW5kXG4gICAgICBzbGlkZUNsYXNzZXMudG9nZ2xlKCd2aXNpYmxlJywgaXNWaXNpYmxlKVxuICAgICAgaWYgKGlzVmlzaWJsZSAhPT0gd2FzVmlzaWJsZSkge1xuICAgICAgICBfLmVtaXQoJ3NsaWRlLScgKyAoaXNWaXNpYmxlID8gJ3Zpc2libGUnIDogJ2hpZGRlbicpLCB7XG4gICAgICAgICAgc2xpZGU6IGluZGV4XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoXy5kb3RzKSB7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwoXy5kb3RzLmNoaWxkcmVuLCBmdW5jdGlvbiAoZG90LCBpbmRleCkge1xuICAgICAgICBkb3QuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJywgXy5wYWdlID09PSBpbmRleClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ICYmIF8ub3B0LnNjcm9sbExvY2spIHtcbiAgICAgIGNsZWFyVGltZW91dChfLnNjcm9sbExvY2spXG4gICAgICBfLnNjcm9sbExvY2sgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF8uc2Nyb2xsTG9jaylcbiAgICAgICAgLy8gZG9udCBhdHRlbXB0IHRvIHNjcm9sbCBsZXNzIHRoYW4gYSBwaXhlbCBmcmFjdGlvbiAtIGNhdXNlcyBsb29waW5nXG4gICAgICAgIGlmIChNYXRoLmFicyhfLmVsZS5zY3JvbGxMZWZ0IC8gXy5pdGVtV2lkdGggLSBfLnNsaWRlKSA+IDAuMDIpIHtcbiAgICAgICAgICBpZiAoIV8ubW91c2VEb3duKSB7XG4gICAgICAgICAgICBfLnNjcm9sbEl0ZW0oXy5yb3VuZChfLmVsZS5zY3JvbGxMZWZ0IC8gXy5pdGVtV2lkdGgpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgXy5vcHQuc2Nyb2xsTG9ja0RlbGF5IHx8IDI1MClcbiAgICB9XG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUuc2Nyb2xsSXRlbSA9IGZ1bmN0aW9uIChzbGlkZSwgZG90LCBlKSB7XG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICB2YXIgb3JpZ2luYWxTbGlkZSA9IHNsaWRlXG4gICAgKytfLmFuaW1hdGVfaWRcblxuICAgIGlmIChkb3QgPT09IHRydWUpIHtcbiAgICAgIHNsaWRlID0gc2xpZGUgKiBfLmNvbnRhaW5lcldpZHRoXG4gICAgICBzbGlkZSA9IE1hdGgucm91bmQoc2xpZGUgLyBfLml0ZW1XaWR0aCkgKiBfLml0ZW1XaWR0aFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHNsaWRlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgYmFja3dhcmRzID0gc2xpZGUgPT09ICdwcmV2J1xuXG4gICAgICAgIC8vIHVzZSBwcmVjaXNlIGxvY2F0aW9uIGlmIGZyYWN0aW9uYWwgc2xpZGVzIGFyZSBvblxuICAgICAgICBpZiAoXy5vcHQuc2xpZGVzVG9TY3JvbGwgJSAxIHx8IF8ub3B0LnNsaWRlc1RvU2hvdyAlIDEpIHtcbiAgICAgICAgICBzbGlkZSA9IF8ucm91bmQoXy5lbGUuc2Nyb2xsTGVmdCAvIF8uaXRlbVdpZHRoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNsaWRlID0gXy5zbGlkZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhY2t3YXJkcykgc2xpZGUgLT0gXy5vcHQuc2xpZGVzVG9TY3JvbGxcbiAgICAgICAgZWxzZSBzbGlkZSArPSBfLm9wdC5zbGlkZXNUb1Njcm9sbFxuXG4gICAgICAgIGlmIChfLm9wdC5yZXdpbmQpIHtcbiAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IF8uZWxlLnNjcm9sbExlZnRcbiAgICAgICAgICBzbGlkZSA9XG4gICAgICAgICAgICBiYWNrd2FyZHMgJiYgIXNjcm9sbExlZnRcbiAgICAgICAgICAgICAgPyBfLnNsaWRlcy5sZW5ndGhcbiAgICAgICAgICAgICAgOiAhYmFja3dhcmRzICYmXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCArIF8uY29udGFpbmVyV2lkdGggPj0gTWF0aC5mbG9vcihfLnRyYWNrV2lkdGgpXG4gICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgOiBzbGlkZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNsaWRlID0gTWF0aC5tYXgoTWF0aC5taW4oc2xpZGUsIF8uc2xpZGVzLmxlbmd0aCksIDApXG5cbiAgICAgIF8uc2xpZGUgPSBzbGlkZVxuICAgICAgc2xpZGUgPSBfLml0ZW1XaWR0aCAqIHNsaWRlXG4gICAgfVxuXG4gICAgXy5zY3JvbGxUbyhcbiAgICAgIHNsaWRlLFxuICAgICAgXy5vcHQuZHVyYXRpb24gKiBNYXRoLmFicyhfLmVsZS5zY3JvbGxMZWZ0IC0gc2xpZGUpLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBfLnVwZGF0ZUNvbnRyb2xzKClcbiAgICAgICAgXy5lbWl0KCdhbmltYXRlZCcsIHtcbiAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxTbGlkZSxcbiAgICAgICAgICB0eXBlOlxuICAgICAgICAgICAgdHlwZW9mIG9yaWdpbmFsU2xpZGUgPT09ICdzdHJpbmcnID8gJ2Fycm93JyA6IGRvdCA/ICdkb3QnIDogJ3NsaWRlJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIClcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLnNldHRpbmdzQnJlYWtwb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIHZhciByZXNwID0gXy5fb3B0LnJlc3BvbnNpdmVcblxuICAgIGlmIChyZXNwKSB7XG4gICAgICAvLyBTb3J0IHRoZSBicmVha3BvaW50cyBpbiBtb2JpbGUgZmlyc3Qgb3JkZXJcbiAgICAgIHJlc3Auc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYi5icmVha3BvaW50IC0gYS5icmVha3BvaW50XG4gICAgICB9KVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3AubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNpemUgPSByZXNwW2ldXG4gICAgICAgIGlmIChfd2luZG93LmlubmVyV2lkdGggPj0gc2l6ZS5icmVha3BvaW50KSB7XG4gICAgICAgICAgaWYgKF8uYnJlYWtwb2ludCAhPT0gc2l6ZS5icmVha3BvaW50KSB7XG4gICAgICAgICAgICBfLm9wdCA9IE9iamVjdC5hc3NpZ24oe30sIF8uX29wdCwgc2l6ZS5zZXR0aW5ncylcbiAgICAgICAgICAgIF8uYnJlYWtwb2ludCA9IHNpemUuYnJlYWtwb2ludFxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IGJhY2sgdG8gZGVmYXVsdHMgaW4gY2FzZSB0aGV5IHdlcmUgb3ZlcnJpZGVuXG4gICAgdmFyIGJyZWFrcG9pbnRDaGFuZ2VkID0gXy5icmVha3BvaW50ICE9PSAwXG4gICAgXy5vcHQgPSBPYmplY3QuYXNzaWduKHt9LCBfLl9vcHQpXG4gICAgXy5icmVha3BvaW50ID0gMFxuICAgIHJldHVybiBicmVha3BvaW50Q2hhbmdlZFxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLnNjcm9sbFRvID0gZnVuY3Rpb24gKHNjcm9sbFRhcmdldCwgc2Nyb2xsRHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuXG4gICAgdmFyIGFuaW1hdGVJbmRleCA9IF8uYW5pbWF0ZV9pZFxuXG4gICAgdmFyIGFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFxuICAgICAgXy5lbGUuc2Nyb2xsTGVmdCA9XG4gICAgICAgIF8uZWxlLnNjcm9sbExlZnQgK1xuICAgICAgICAoc2Nyb2xsVGFyZ2V0IC0gXy5lbGUuc2Nyb2xsTGVmdCkgKlxuICAgICAgICAgIF8ub3B0LmVhc2luZygwLCBub3csIDAsIDEsIHNjcm9sbER1cmF0aW9uKVxuICAgICAgaWYgKG5vdyA8IHNjcm9sbER1cmF0aW9uICYmIGFuaW1hdGVJbmRleCA9PT0gXy5hbmltYXRlX2lkKSB7XG4gICAgICAgIF93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfLmVsZS5zY3JvbGxMZWZ0ID0gc2Nyb2xsVGFyZ2V0XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoXylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIGlmIChfLnNsaWRlcy5sZW5ndGgpIHtcbiAgICAgIF8udHJhY2sucmVtb3ZlQ2hpbGQoXy5zbGlkZXNbaW5kZXhdKVxuICAgICAgXy5yZWZyZXNoKHRydWUpXG4gICAgICBfLmVtaXQoJ3JlbW92ZScpXG4gICAgfVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLmFkZEl0ZW0gPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICBfLnRyYWNrLmFwcGVuZENoaWxkKGVsZSlcbiAgICBfLnJlZnJlc2godHJ1ZSlcbiAgICBfLmVtaXQoJ2FkZCcpXG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUuaGFuZGxlTW91c2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfID0gdGhpc1xuICAgIGlmIChfLm1vdXNlRG93bikge1xuICAgICAgXy5pc0RyYWcgPSB0cnVlXG4gICAgICBfLmVsZS5zY3JvbGxMZWZ0ICs9XG4gICAgICAgIChfLm1vdXNlRG93biAtIGUuY2xpZW50WCkgKiAoXy5vcHQuZHJhZ1ZlbG9jaXR5IHx8IDMuMylcbiAgICAgIF8ubW91c2VEb3duID0gZS5jbGllbnRYXG4gICAgfVxuICB9XG5cbiAgLy8gdXNlZCB0byByb3VuZCB0byB0aGUgbmVhcmVzdCAwLlhYIGZyYWN0aW9uXG4gIGdsaWRlclByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uIChkb3VibGUpIHtcbiAgICB2YXIgXyA9IHRoaXNcbiAgICB2YXIgc3RlcCA9IF8ub3B0LnNsaWRlc1RvU2Nyb2xsICUgMSB8fCAxXG4gICAgdmFyIGludiA9IDEuMCAvIHN0ZXBcbiAgICByZXR1cm4gTWF0aC5yb3VuZChkb3VibGUgKiBpbnYpIC8gaW52XG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChwYWdpbmcpIHtcbiAgICB2YXIgXyA9IHRoaXNcbiAgICBfLmluaXQodHJ1ZSwgcGFnaW5nKVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHQsIGdsb2JhbCkge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgaWYgKF8uYnJlYWtwb2ludCAmJiAhZ2xvYmFsKSB7XG4gICAgICBfLl9vcHQucmVzcG9uc2l2ZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2LmJyZWFrcG9pbnQgPT09IF8uYnJlYWtwb2ludCkge1xuICAgICAgICAgIHYuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB2LnNldHRpbmdzLCBvcHQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIF8uX29wdCA9IE9iamVjdC5hc3NpZ24oe30sIF8uX29wdCwgb3B0KVxuICAgIH1cblxuICAgIF8uYnJlYWtwb2ludCA9IDBcbiAgICBfLnNldHRpbmdzQnJlYWtwb2ludCgpXG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIHZhciByZXBsYWNlID0gXy5lbGUuY2xvbmVOb2RlKHRydWUpXG5cbiAgICB2YXIgY2xlYXIgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICBlbGUucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgW10uZm9yRWFjaC5jYWxsKGVsZS5jbGFzc0xpc3QsIGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgL15nbGlkZXIvLnRlc3QoY2xhc3NOYW1lKSAmJiBlbGUuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgICB9KVxuICAgIH1cbiAgICAvLyByZW1vdmUgdHJhY2tcbiAgICByZXBsYWNlLmNoaWxkcmVuWzBdLm91dGVySFRNTCA9IHJlcGxhY2UuY2hpbGRyZW5bMF0uaW5uZXJIVE1MXG4gICAgY2xlYXIocmVwbGFjZSk7XG4gICAgW10uZm9yRWFjaC5jYWxsKHJlcGxhY2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSwgY2xlYXIpXG4gICAgXy5lbGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQocmVwbGFjZSwgXy5lbGUpXG4gICAgXy5ldmVudChfd2luZG93LCAncmVtb3ZlJywge1xuICAgICAgcmVzaXplOiBfLnJlc2l6ZVxuICAgIH0pXG4gICAgXy5lbWl0KCdkZXN0cm95JylcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZykge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgdmFyIGUgPSBuZXcgX3dpbmRvdy5DdXN0b21FdmVudCgnZ2xpZGVyLScgKyBuYW1lLCB7XG4gICAgICBidWJibGVzOiAhXy5vcHQuZXZlbnRQcm9wYWdhdGUsXG4gICAgICBkZXRhaWw6IGFyZ1xuICAgIH0pXG4gICAgXy5lbGUuZGlzcGF0Y2hFdmVudChlKVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLmV2ZW50ID0gZnVuY3Rpb24gKGVsZSwgdHlwZSwgYXJncykge1xuICAgIHZhciBldmVudEhhbmRsZXIgPSBlbGVbdHlwZSArICdFdmVudExpc3RlbmVyJ10uYmluZChlbGUpXG4gICAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgZXZlbnRIYW5kbGVyKGssIGFyZ3Nba10pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBHbGlkZXJcbn0pXG4iLCJpbXBvcnQgR2xpZGVyIGZyb20gJ2dsaWRlci1qcyc7XG4vLyBjb2RlIGZvciB0ZXN0aW1vbmlhbHNcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gc2V0dXBUZXN0aW1vbmlhbFNsaWRlcigpIHtcbiAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5nbGlkZXInKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICBuZXcgR2xpZGVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5nbGlkZXInKSwge1xuICAgICAgLy8gTW9iaWxlLWZpcnN0IGRlZmF1bHRzXG4gICAgICBzbGlkZXNUb1Nob3c6IDEsXG4gICAgICBzbGlkZXNUb1Njcm9sbDogMSxcbiAgICAgIHNjcm9sbExvY2s6IHRydWUsXG4gICAgICBkb3RzOiAnI3Jlc3AtZG90cycsXG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBhcnJvd3M6IHtcbiAgICAgICAgcHJldjogJy5nbGlkZXItcHJldicsXG4gICAgICAgIG5leHQ6ICcuZ2xpZGVyLW5leHQnLFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6IFtcbiAgICAgICAge1xuICAgICAgICAgIC8vIHNjcmVlbnMgZ3JlYXRlciB0aGFuID49IDc3NXB4XG4gICAgICAgICAgYnJlYWtwb2ludDogMCxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgLy8gU2V0IHRvIGBhdXRvYCBhbmQgcHJvdmlkZSBpdGVtIHdpZHRoIHRvIGFkanVzdCB0byB2aWV3cG9ydFxuICAgICAgICAgICAgc2xpZGVzVG9TaG93OiAxLFxuICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gICAgICAgICAgICBpdGVtV2lkdGg6IDMwMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBzY3JlZW5zIGdyZWF0ZXIgdGhhbiA+PSAxMDI0cHhcbiAgICAgICAgICBicmVha3BvaW50OiA1NDAsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvdzogJ2F1dG8nLFxuICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGw6ICdhdXRvJyxcbiAgICAgICAgICAgIGl0ZW1XaWR0aDogMzAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSk7XG4gIH1cbn0pO1xuIiwiaW1wb3J0IHsgdG9nZ2xlQ2xhc3MsIHJlbW92ZUNsYXNzIH0gZnJvbSAnLi4vaGVscGVyJztcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgY29uc3QgeyB0YXJnZXQgfSA9IGV2ZW50O1xuICBpZiAodGFyZ2V0LmNsb3Nlc3QoJy5kcm9wZG93bi1tZW51JykpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICAvLyBjbGFzcz1cIm5hdmJhci10b2dnbGVyXCIgZGF0YS10cmlnZ2VyPVwiI25hdmJhcl9tYWluXCJcbiAgaWYgKHRhcmdldC5jbG9zZXN0KCcubmF2YmFyLXRvZ2dsZXJbZGF0YS10cmlnZ2VyXScpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCBvZmZjYW52YXNJZCA9IHRhcmdldFxuICAgICAgLmNsb3Nlc3QoJy5uYXZiYXItdG9nZ2xlcltkYXRhLXRyaWdnZXJdJylcbiAgICAgIC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHJpZ2dlcicpO1xuICAgIGNvbnN0IG9mZmNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob2ZmY2FudmFzSWQpO1xuICAgIGlmIChvZmZjYW52YXMpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKG9mZmNhbnZhcywgJ3Nob3cnKTtcbiAgICB9XG4gICAgdG9nZ2xlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ29mZmNhbnZhcy1hY3RpdmUnKTtcbiAgICBjb25zdCBzY3JlZW5PdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNjcmVlbi1vdmVybGF5Jyk7XG4gICAgaWYgKHNjcmVlbk92ZXJsYXkpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKHNjcmVlbk92ZXJsYXksICdzaG93Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhcmdldC5jbG9zZXN0KCcuYnRuLWNsb3NlLCAuc2NyZWVuLW92ZXJsYXknKSkge1xuICAgIGNvbnN0IHNjcmVlbk92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2NyZWVuLW92ZXJsYXknKTtcbiAgICBpZiAoc2NyZWVuT3ZlcmxheSkge1xuICAgICAgcmVtb3ZlQ2xhc3Moc2NyZWVuT3ZlcmxheSwgJ3Nob3cnKTtcbiAgICB9XG4gICAgY29uc3QgbW9iaWxlT2ZmY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1vYmlsZS1vZmZjYW52YXMnKTtcbiAgICBpZiAobW9iaWxlT2ZmY2FudmFzKSB7XG4gICAgICByZW1vdmVDbGFzcyhtb2JpbGVPZmZjYW52YXMsICdzaG93Jyk7XG4gICAgfVxuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdvZmZjYW52YXMtYWN0aXZlJyk7XG4gIH1cbn0pO1xuIiwiIWZ1bmN0aW9uKHQsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9bigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUobik6dC5NYWN5PW4oKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQodCxuKXt2YXIgZT12b2lkIDA7cmV0dXJuIGZ1bmN0aW9uKCl7ZSYmY2xlYXJUaW1lb3V0KGUpLGU9c2V0VGltZW91dCh0LG4pfX1mdW5jdGlvbiBuKHQsbil7Zm9yKHZhciBlPXQubGVuZ3RoLHI9ZSxvPVtdO2UtLTspby5wdXNoKG4odFtyLWUtMV0pKTtyZXR1cm4gb31mdW5jdGlvbiBlKHQsbil7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtpZih3aW5kb3cuUHJvbWlzZSlyZXR1cm4gQSh0LG4sZSk7dC5yZWNhbGN1bGF0ZSghMCwhMCl9ZnVuY3Rpb24gcih0KXtmb3IodmFyIG49dC5vcHRpb25zLGU9dC5yZXNwb25zaXZlT3B0aW9ucyxyPXQua2V5cyxvPXQuZG9jV2lkdGgsaT12b2lkIDAscz0wO3M8ci5sZW5ndGg7cysrKXt2YXIgYT1wYXJzZUludChyW3NdLDEwKTtvPj1hJiYoaT1uLmJyZWFrQXRbYV0sTyhpLGUpKX1yZXR1cm4gZX1mdW5jdGlvbiBvKHQpe2Zvcih2YXIgbj10Lm9wdGlvbnMsZT10LnJlc3BvbnNpdmVPcHRpb25zLHI9dC5rZXlzLG89dC5kb2NXaWR0aCxpPXZvaWQgMCxzPXIubGVuZ3RoLTE7cz49MDtzLS0pe3ZhciBhPXBhcnNlSW50KHJbc10sMTApO288PWEmJihpPW4uYnJlYWtBdFthXSxPKGksZSkpfXJldHVybiBlfWZ1bmN0aW9uIGkodCl7dmFyIG49dC51c2VDb250YWluZXJGb3JCcmVha3BvaW50cz90LmNvbnRhaW5lci5jbGllbnRXaWR0aDp3aW5kb3cuaW5uZXJXaWR0aCxlPXtjb2x1bW5zOnQuY29sdW1uc307Yih0Lm1hcmdpbik/ZS5tYXJnaW49e3g6dC5tYXJnaW4ueCx5OnQubWFyZ2luLnl9OmUubWFyZ2luPXt4OnQubWFyZ2luLHk6dC5tYXJnaW59O3ZhciBpPU9iamVjdC5rZXlzKHQuYnJlYWtBdCk7cmV0dXJuIHQubW9iaWxlRmlyc3Q/cih7b3B0aW9uczp0LHJlc3BvbnNpdmVPcHRpb25zOmUsa2V5czppLGRvY1dpZHRoOm59KTpvKHtvcHRpb25zOnQscmVzcG9uc2l2ZU9wdGlvbnM6ZSxrZXlzOmksZG9jV2lkdGg6bn0pfWZ1bmN0aW9uIHModCl7cmV0dXJuIGkodCkuY29sdW1uc31mdW5jdGlvbiBhKHQpe3JldHVybiBpKHQpLm1hcmdpbn1mdW5jdGlvbiBjKHQpe3ZhciBuPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV0sZT1zKHQpLHI9YSh0KS54LG89MTAwL2U7aWYoIW4pcmV0dXJuIG87aWYoMT09PWUpcmV0dXJuXCIxMDAlXCI7dmFyIGk9XCJweFwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByKXt2YXIgYz1wYXJzZUZsb2F0KHIpO2k9ci5yZXBsYWNlKGMsXCJcIikscj1jfXJldHVybiByPShlLTEpKnIvZSxcIiVcIj09PWk/by1yK1wiJVwiOlwiY2FsYyhcIitvK1wiJSAtIFwiK3IraStcIilcIn1mdW5jdGlvbiB1KHQsbil7dmFyIGU9cyh0Lm9wdGlvbnMpLHI9MCxvPXZvaWQgMCxpPXZvaWQgMDtpZigxPT09KytuKXJldHVybiAwO2k9YSh0Lm9wdGlvbnMpLng7dmFyIHU9XCJweFwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpKXt2YXIgbD1wYXJzZUZsb2F0KGksMTApO3U9aS5yZXBsYWNlKGwsXCJcIiksaT1sfXJldHVybiBvPShpLShlLTEpKmkvZSkqKG4tMSkscis9Yyh0Lm9wdGlvbnMsITEpKihuLTEpLFwiJVwiPT09dT9yK28rXCIlXCI6XCJjYWxjKFwiK3IrXCIlICsgXCIrbyt1K1wiKVwifWZ1bmN0aW9uIGwodCl7dmFyIG49MCxlPXQuY29udGFpbmVyLHI9dC5yb3dzO3YocixmdW5jdGlvbih0KXtuPXQ+bj90Om59KSxlLnN0eWxlLmhlaWdodD1uK1wicHhcIn1mdW5jdGlvbiBwKHQsbil7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxyPSEoYXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10pfHxhcmd1bWVudHNbM10sbz1zKHQub3B0aW9ucyksaT1hKHQub3B0aW9ucykueTtNKHQsbyxlKSx2KG4sZnVuY3Rpb24obil7dmFyIGU9MCxvPXBhcnNlSW50KG4ub2Zmc2V0SGVpZ2h0LDEwKTtpc05hTihvKXx8KHQucm93cy5mb3JFYWNoKGZ1bmN0aW9uKG4scil7bjx0LnJvd3NbZV0mJihlPXIpfSksbi5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsbi5zdHlsZS50b3A9dC5yb3dzW2VdK1wicHhcIixuLnN0eWxlLmxlZnQ9XCJcIit0LmNvbHNbZV0sdC5yb3dzW2VdKz1pc05hTihvKT8wOm8raSxyJiYobi5kYXRhc2V0Lm1hY3lDb21wbGV0ZT0xKSl9KSxyJiYodC50bXBSb3dzPW51bGwpLGwodCl9ZnVuY3Rpb24gZih0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0scj0hKGFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdKXx8YXJndW1lbnRzWzNdLG89cyh0Lm9wdGlvbnMpLGk9YSh0Lm9wdGlvbnMpLnk7TSh0LG8sZSksdihuLGZ1bmN0aW9uKG4pe3QubGFzdGNvbD09PW8mJih0Lmxhc3Rjb2w9MCk7dmFyIGU9QyhuLFwiaGVpZ2h0XCIpO2U9cGFyc2VJbnQobi5vZmZzZXRIZWlnaHQsMTApLGlzTmFOKGUpfHwobi5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsbi5zdHlsZS50b3A9dC5yb3dzW3QubGFzdGNvbF0rXCJweFwiLG4uc3R5bGUubGVmdD1cIlwiK3QuY29sc1t0Lmxhc3Rjb2xdLHQucm93c1t0Lmxhc3Rjb2xdKz1pc05hTihlKT8wOmUraSx0Lmxhc3Rjb2wrPTEsciYmKG4uZGF0YXNldC5tYWN5Q29tcGxldGU9MSkpfSksciYmKHQudG1wUm93cz1udWxsKSxsKHQpfXZhciBoPWZ1bmN0aW9uIHQobixlKXtpZighKHRoaXMgaW5zdGFuY2VvZiB0KSlyZXR1cm4gbmV3IHQobixlKTtpZihuJiZuLm5vZGVOYW1lKXJldHVybiBuO2lmKG49bi5yZXBsYWNlKC9eXFxzKi8sXCJcIikucmVwbGFjZSgvXFxzKiQvLFwiXCIpLGUpcmV0dXJuIHRoaXMuYnlDc3MobixlKTtmb3IodmFyIHIgaW4gdGhpcy5zZWxlY3RvcnMpaWYoZT1yLnNwbGl0KFwiL1wiKSxuZXcgUmVnRXhwKGVbMV0sZVsyXSkudGVzdChuKSlyZXR1cm4gdGhpcy5zZWxlY3RvcnNbcl0obik7cmV0dXJuIHRoaXMuYnlDc3Mobil9O2gucHJvdG90eXBlLmJ5Q3NzPWZ1bmN0aW9uKHQsbil7cmV0dXJuKG58fGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHQpfSxoLnByb3RvdHlwZS5zZWxlY3RvcnM9e30saC5wcm90b3R5cGUuc2VsZWN0b3JzWy9eXFwuW1xcd1xcLV0rJC9dPWZ1bmN0aW9uKHQpe3JldHVybiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHQuc3Vic3RyaW5nKDEpKX0saC5wcm90b3R5cGUuc2VsZWN0b3JzWy9eXFx3KyQvXT1mdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodCl9LGgucHJvdG90eXBlLnNlbGVjdG9yc1svXlxcI1tcXHdcXC1dKyQvXT1mdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodC5zdWJzdHJpbmcoMSkpfTt2YXIgdj1mdW5jdGlvbih0LG4pe2Zvcih2YXIgZT10Lmxlbmd0aCxyPWU7ZS0tOyluKHRbci1lLTFdKX0sbT1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07dGhpcy5ydW5uaW5nPSExLHRoaXMuZXZlbnRzPVtdLHRoaXMuYWRkKHQpfTttLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXtpZighdGhpcy5ydW5uaW5nJiZ0aGlzLmV2ZW50cy5sZW5ndGg+MCl7dmFyIHQ9dGhpcy5ldmVudHMuc2hpZnQoKTt0aGlzLnJ1bm5pbmc9ITAsdCgpLHRoaXMucnVubmluZz0hMSx0aGlzLnJ1bigpfX0sbS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07cmV0dXJuISFuJiYoQXJyYXkuaXNBcnJheShuKT92KG4sZnVuY3Rpb24obil7cmV0dXJuIHQuYWRkKG4pfSk6KHRoaXMuZXZlbnRzLnB1c2gobiksdm9pZCB0aGlzLnJ1bigpKSl9LG0ucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5ldmVudHM9W119O3ZhciBkPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtyZXR1cm4gdGhpcy5pbnN0YW5jZT10LHRoaXMuZGF0YT1uLHRoaXN9LHk9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdO3RoaXMuZXZlbnRzPXt9LHRoaXMuaW5zdGFuY2U9dH07eS5wcm90b3R5cGUub249ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdLG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtyZXR1cm4hKCF0fHwhbikmJihBcnJheS5pc0FycmF5KHRoaXMuZXZlbnRzW3RdKXx8KHRoaXMuZXZlbnRzW3RdPVtdKSx0aGlzLmV2ZW50c1t0XS5wdXNoKG4pKX0seS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0sbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307aWYoIXR8fCFBcnJheS5pc0FycmF5KHRoaXMuZXZlbnRzW3RdKSlyZXR1cm4hMTt2YXIgZT1uZXcgZCh0aGlzLmluc3RhbmNlLG4pO3YodGhpcy5ldmVudHNbdF0sZnVuY3Rpb24odCl7cmV0dXJuIHQoZSl9KX07dmFyIGc9ZnVuY3Rpb24odCl7cmV0dXJuIShcIm5hdHVyYWxIZWlnaHRcImluIHQmJnQubmF0dXJhbEhlaWdodCt0Lm5hdHVyYWxXaWR0aD09PTApfHx0LndpZHRoK3QuaGVpZ2h0IT09MH0sRT1mdW5jdGlvbih0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQsZSl7aWYobi5jb21wbGV0ZSlyZXR1cm4gZyhuKT90KG4pOmUobik7bi5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGcobik/dChuKTplKG4pfSksbi5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbigpe3JldHVybiBlKG4pfSl9KS50aGVuKGZ1bmN0aW9uKG4pe2UmJnQuZW1pdCh0LmNvbnN0YW50cy5FVkVOVF9JTUFHRV9MT0FELHtpbWc6bn0pfSkuY2F0Y2goZnVuY3Rpb24obil7cmV0dXJuIHQuZW1pdCh0LmNvbnN0YW50cy5FVkVOVF9JTUFHRV9FUlJPUix7aW1nOm59KX0pfSx3PWZ1bmN0aW9uKHQsZSl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtyZXR1cm4gbihlLGZ1bmN0aW9uKG4pe3JldHVybiBFKHQsbixyKX0pfSxBPWZ1bmN0aW9uKHQsbil7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtyZXR1cm4gUHJvbWlzZS5hbGwodyh0LG4sZSkpLnRoZW4oZnVuY3Rpb24oKXt0LmVtaXQodC5jb25zdGFudHMuRVZFTlRfSU1BR0VfQ09NUExFVEUpfSl9LEk9ZnVuY3Rpb24obil7cmV0dXJuIHQoZnVuY3Rpb24oKXtuLmVtaXQobi5jb25zdGFudHMuRVZFTlRfUkVTSVpFKSxuLnF1ZXVlLmFkZChmdW5jdGlvbigpe3JldHVybiBuLnJlY2FsY3VsYXRlKCEwLCEwKX0pfSwxMDApfSxOPWZ1bmN0aW9uKHQpe2lmKHQuY29udGFpbmVyPWgodC5vcHRpb25zLmNvbnRhaW5lciksdC5jb250YWluZXIgaW5zdGFuY2VvZiBofHwhdC5jb250YWluZXIpcmV0dXJuISF0Lm9wdGlvbnMuZGVidWcmJmNvbnNvbGUuZXJyb3IoXCJFcnJvcjogQ29udGFpbmVyIG5vdCBmb3VuZFwiKTt0LmNvbnRhaW5lci5sZW5ndGgmJih0LmNvbnRhaW5lcj10LmNvbnRhaW5lclswXSksdC5vcHRpb25zLmNvbnRhaW5lcj10LmNvbnRhaW5lcix0LmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCJ9LFQ9ZnVuY3Rpb24odCl7dC5xdWV1ZT1uZXcgbSx0LmV2ZW50cz1uZXcgeSh0KSx0LnJvd3M9W10sdC5yZXNpemVyPUkodCl9LEw9ZnVuY3Rpb24odCl7dmFyIG49aChcImltZ1wiLHQuY29udGFpbmVyKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHQucmVzaXplciksdC5vbih0LmNvbnN0YW50cy5FVkVOVF9JTUFHRV9MT0FELGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVjYWxjdWxhdGUoITEsITEpfSksdC5vbih0LmNvbnN0YW50cy5FVkVOVF9JTUFHRV9DT01QTEVURSxmdW5jdGlvbigpe3JldHVybiB0LnJlY2FsY3VsYXRlKCEwLCEwKX0pLHQub3B0aW9ucy51c2VPd25JbWFnZUxvYWRlcnx8ZSh0LG4sIXQub3B0aW9ucy53YWl0Rm9ySW1hZ2VzKSx0LmVtaXQodC5jb25zdGFudHMuRVZFTlRfSU5JVElBTElaRUQpfSxfPWZ1bmN0aW9uKHQpe04odCksVCh0KSxMKHQpfSxiPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09T2JqZWN0KHQpJiZcIltvYmplY3QgQXJyYXldXCIhPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9LE89ZnVuY3Rpb24odCxuKXtiKHQpfHwobi5jb2x1bW5zPXQpLGIodCkmJnQuY29sdW1ucyYmKG4uY29sdW1ucz10LmNvbHVtbnMpLGIodCkmJnQubWFyZ2luJiYhYih0Lm1hcmdpbikmJihuLm1hcmdpbj17eDp0Lm1hcmdpbix5OnQubWFyZ2lufSksYih0KSYmdC5tYXJnaW4mJmIodC5tYXJnaW4pJiZ0Lm1hcmdpbi54JiYobi5tYXJnaW4ueD10Lm1hcmdpbi54KSxiKHQpJiZ0Lm1hcmdpbiYmYih0Lm1hcmdpbikmJnQubWFyZ2luLnkmJihuLm1hcmdpbi55PXQubWFyZ2luLnkpfSxDPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuKX0sTT1mdW5jdGlvbih0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07aWYodC5sYXN0Y29sfHwodC5sYXN0Y29sPTApLHQucm93cy5sZW5ndGg8MSYmKGU9ITApLGUpe3Qucm93cz1bXSx0LmNvbHM9W10sdC5sYXN0Y29sPTA7Zm9yKHZhciByPW4tMTtyPj0wO3ItLSl0LnJvd3Nbcl09MCx0LmNvbHNbcl09dSh0LHIpfWVsc2UgaWYodC50bXBSb3dzKXt0LnJvd3M9W107Zm9yKHZhciByPW4tMTtyPj0wO3ItLSl0LnJvd3Nbcl09dC50bXBSb3dzW3JdfWVsc2V7dC50bXBSb3dzPVtdO2Zvcih2YXIgcj1uLTE7cj49MDtyLS0pdC50bXBSb3dzW3JdPXQucm93c1tyXX19LFY9ZnVuY3Rpb24odCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxlPSEoYXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pfHxhcmd1bWVudHNbMl0scj1uP3QuY29udGFpbmVyLmNoaWxkcmVuOmgoJzpzY29wZSA+ICo6bm90KFtkYXRhLW1hY3ktY29tcGxldGU9XCIxXCJdKScsdC5jb250YWluZXIpO3I9QXJyYXkuZnJvbShyKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10Lm9mZnNldFBhcmVudH0pO3ZhciBvPWModC5vcHRpb25zKTtyZXR1cm4gdihyLGZ1bmN0aW9uKHQpe24mJih0LmRhdGFzZXQubWFjeUNvbXBsZXRlPTApLHQuc3R5bGUud2lkdGg9b30pLHQub3B0aW9ucy50cnVlT3JkZXI/KGYodCxyLG4sZSksdC5lbWl0KHQuY29uc3RhbnRzLkVWRU5UX1JFQ0FMQ1VMQVRFRCkpOihwKHQscixuLGUpLHQuZW1pdCh0LmNvbnN0YW50cy5FVkVOVF9SRUNBTENVTEFURUQpKX0sUj1mdW5jdGlvbigpe3JldHVybiEhd2luZG93LlByb21pc2V9LHg9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl7dmFyIGU9YXJndW1lbnRzW25dO2Zvcih2YXIgciBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKX1yZXR1cm4gdH07QXJyYXkuZnJvbXx8KEFycmF5LmZyb209ZnVuY3Rpb24odCl7Zm9yKHZhciBuPTAsZT1bXTtuPHQubGVuZ3RoOyllLnB1c2godFtuKytdKTtyZXR1cm4gZX0pO3ZhciBrPXtjb2x1bW5zOjQsbWFyZ2luOjIsdHJ1ZU9yZGVyOiExLHdhaXRGb3JJbWFnZXM6ITEsdXNlSW1hZ2VMb2FkZXI6ITAsYnJlYWtBdDp7fSx1c2VPd25JbWFnZUxvYWRlcjohMSxvbkluaXQ6ITEsY2FuY2VsTGVnYWN5OiExLHVzZUNvbnRhaW5lckZvckJyZWFrcG9pbnRzOiExfTshZnVuY3Rpb24oKXt0cnl7ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikucXVlcnlTZWxlY3RvcihcIjpzY29wZSAqXCIpfWNhdGNoKHQpeyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKGUmJm4udGVzdChlKSl7dmFyIHI9dGhpcy5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtyfHwodGhpcy5pZD1cInFcIitNYXRoLmZsb29yKDllNipNYXRoLnJhbmRvbSgpKSsxZTYpLGFyZ3VtZW50c1swXT1lLnJlcGxhY2UobixcIiNcIit0aGlzLmlkKTt2YXIgbz10LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gbnVsbD09PXI/dGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTpyfHwodGhpcy5pZD1yKSxvfXJldHVybiB0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIG49LzpzY29wZVxcYi9naSxlPXQoRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvcik7RWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvcj1mdW5jdGlvbih0KXtyZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciByPXQoRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCk7RWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbD1mdW5jdGlvbih0KXtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSgpfX0oKTt2YXIgcT1mdW5jdGlvbiB0KCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOms7aWYoISh0aGlzIGluc3RhbmNlb2YgdCkpcmV0dXJuIG5ldyB0KG4pO3RoaXMub3B0aW9ucz17fSx4KHRoaXMub3B0aW9ucyxrLG4pLHRoaXMub3B0aW9ucy5jYW5jZWxMZWdhY3kmJiFSKCl8fF8odGhpcyl9O3JldHVybiBxLmluaXQ9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIkRlcHJlY2lhdGVkOiBNYWN5LmluaXQgd2lsbCBiZSByZW1vdmVkIGluIHYzLjAuMCBvcHQgdG8gdXNlIE1hY3kgZGlyZWN0bHkgbGlrZSBzbyBNYWN5KHsgLypvcHRpb25zIGhlcmUqLyB9KSBcIiksbmV3IHEodCl9LHEucHJvdG90eXBlLnJlY2FsY3VsYXRlT25JbWFnZUxvYWQ9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdO3JldHVybiBlKHRoaXMsaChcImltZ1wiLHRoaXMuY29udGFpbmVyKSwhdCl9LHEucHJvdG90eXBlLnJ1bk9uSW1hZ2VMb2FkPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0scj1oKFwiaW1nXCIsdGhpcy5jb250YWluZXIpO3JldHVybiB0aGlzLm9uKHRoaXMuY29uc3RhbnRzLkVWRU5UX0lNQUdFX0NPTVBMRVRFLHQpLG4mJnRoaXMub24odGhpcy5jb25zdGFudHMuRVZFTlRfSU1BR0VfTE9BRCx0KSxlKHRoaXMscixuKX0scS5wcm90b3R5cGUucmVjYWxjdWxhdGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLG49YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXSxlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07cmV0dXJuIGUmJnRoaXMucXVldWUuY2xlYXIoKSx0aGlzLnF1ZXVlLmFkZChmdW5jdGlvbigpe3JldHVybiBWKHQsbixlKX0pfSxxLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMucmVzaXplciksdih0aGlzLmNvbnRhaW5lci5jaGlsZHJlbixmdW5jdGlvbih0KXt0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtbWFjeS1jb21wbGV0ZVwiKSx0LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpfSksdGhpcy5jb250YWluZXIucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIil9LHEucHJvdG90eXBlLnJlSW5pdD1mdW5jdGlvbigpe3RoaXMucmVjYWxjdWxhdGUoITAsITApLHRoaXMuZW1pdCh0aGlzLmNvbnN0YW50cy5FVkVOVF9JTklUSUFMSVpFRCksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLnJlc2l6ZXIpLHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIn0scS5wcm90b3R5cGUub249ZnVuY3Rpb24odCxuKXt0aGlzLmV2ZW50cy5vbih0LG4pfSxxLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHQsbil7dGhpcy5ldmVudHMuZW1pdCh0LG4pfSxxLmNvbnN0YW50cz17RVZFTlRfSU5JVElBTElaRUQ6XCJtYWN5LmluaXRpYWxpemVkXCIsRVZFTlRfUkVDQUxDVUxBVEVEOlwibWFjeS5yZWNhbGN1bGF0ZWRcIixFVkVOVF9JTUFHRV9MT0FEOlwibWFjeS5pbWFnZS5sb2FkXCIsRVZFTlRfSU1BR0VfRVJST1I6XCJtYWN5LmltYWdlLmVycm9yXCIsRVZFTlRfSU1BR0VfQ09NUExFVEU6XCJtYWN5LmltYWdlcy5jb21wbGV0ZVwiLEVWRU5UX1JFU0laRTpcIm1hY3kucmVzaXplXCJ9LHEucHJvdG90eXBlLmNvbnN0YW50cz1xLmNvbnN0YW50cyxxfSk7XG4iLCJpbXBvcnQgTWFjeSBmcm9tICdtYWN5JztcblxuaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbmRleC1zZWN0aW9uLS1tYXNvbnJ5IC5pbWFnZXMtd3JhcHBlcicpKSB7XG4gIE1hY3koe1xuICAgIGNvbnRhaW5lcjogJy5pbmRleC1zZWN0aW9uLS1tYXNvbnJ5IC5pbWFnZXMtd3JhcHBlcicsXG4gICAgY29sdW1uczogMyxcbiAgICBicmVha0F0OiB7XG4gICAgICA1MjA6IDIsXG4gICAgICA0MDA6IDEsXG4gICAgfSxcbiAgfSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5jb25zdCBkaXJlY3RpdmVzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQnJhbmRzIGEgZnVuY3Rpb24gYXMgYSBkaXJlY3RpdmUgZmFjdG9yeSBmdW5jdGlvbiBzbyB0aGF0IGxpdC1odG1sIHdpbGwgY2FsbFxuICogdGhlIGZ1bmN0aW9uIGR1cmluZyB0ZW1wbGF0ZSByZW5kZXJpbmcsIHJhdGhlciB0aGFuIHBhc3NpbmcgYXMgYSB2YWx1ZS5cbiAqXG4gKiBBIF9kaXJlY3RpdmVfIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIFBhcnQgYXMgYW4gYXJndW1lbnQuIEl0IGhhcyB0aGVcbiAqIHNpZ25hdHVyZTogYChwYXJ0OiBQYXJ0KSA9PiB2b2lkYC5cbiAqXG4gKiBBIGRpcmVjdGl2ZSBfZmFjdG9yeV8gaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFyZ3VtZW50cyBmb3IgZGF0YSBhbmRcbiAqIGNvbmZpZ3VyYXRpb24gYW5kIHJldHVybnMgYSBkaXJlY3RpdmUuIFVzZXJzIG9mIGRpcmVjdGl2ZSB1c3VhbGx5IHJlZmVyIHRvXG4gKiB0aGUgZGlyZWN0aXZlIGZhY3RvcnkgYXMgdGhlIGRpcmVjdGl2ZS4gRm9yIGV4YW1wbGUsIFwiVGhlIHJlcGVhdCBkaXJlY3RpdmVcIi5cbiAqXG4gKiBVc3VhbGx5IGEgdGVtcGxhdGUgYXV0aG9yIHdpbGwgaW52b2tlIGEgZGlyZWN0aXZlIGZhY3RvcnkgaW4gdGhlaXIgdGVtcGxhdGVcbiAqIHdpdGggcmVsZXZhbnQgYXJndW1lbnRzLCB3aGljaCB3aWxsIHRoZW4gcmV0dXJuIGEgZGlyZWN0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIG9mIHVzaW5nIHRoZSBgcmVwZWF0KClgIGRpcmVjdGl2ZSBmYWN0b3J5IHRoYXQgdGFrZXMgYW5cbiAqIGFycmF5IGFuZCBhIGZ1bmN0aW9uIHRvIHJlbmRlciBhbiBpdGVtOlxuICpcbiAqIGBgYGpzXG4gKiBodG1sYDx1bD48JHtyZXBlYXQoaXRlbXMsIChpdGVtKSA9PiBodG1sYDxsaT4ke2l0ZW19PC9saT5gKX08L3VsPmBcbiAqIGBgYFxuICpcbiAqIFdoZW4gYHJlcGVhdGAgaXMgaW52b2tlZCwgaXQgcmV0dXJucyBhIGRpcmVjdGl2ZSBmdW5jdGlvbiB0aGF0IGNsb3NlcyBvdmVyXG4gKiBgaXRlbXNgIGFuZCB0aGUgdGVtcGxhdGUgZnVuY3Rpb24uIFdoZW4gdGhlIG91dGVyIHRlbXBsYXRlIGlzIHJlbmRlcmVkLCB0aGVcbiAqIHJldHVybiBkaXJlY3RpdmUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIFBhcnQgZm9yIHRoZSBleHByZXNzaW9uLlxuICogYHJlcGVhdGAgdGhlbiBwZXJmb3JtcyBpdCdzIGN1c3RvbSBsb2dpYyB0byByZW5kZXIgbXVsdGlwbGUgaXRlbXMuXG4gKlxuICogQHBhcmFtIGYgVGhlIGRpcmVjdGl2ZSBmYWN0b3J5IGZ1bmN0aW9uLiBNdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFcbiAqIGZ1bmN0aW9uIG9mIHRoZSBzaWduYXR1cmUgYChwYXJ0OiBQYXJ0KSA9PiB2b2lkYC4gVGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGxcbiAqIGJlIGNhbGxlZCB3aXRoIHRoZSBwYXJ0IG9iamVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCB7ZGlyZWN0aXZlLCBodG1sfSBmcm9tICdsaXQtaHRtbCc7XG4gKlxuICogY29uc3QgaW1tdXRhYmxlID0gZGlyZWN0aXZlKCh2KSA9PiAocGFydCkgPT4ge1xuICogICBpZiAocGFydC52YWx1ZSAhPT0gdikge1xuICogICAgIHBhcnQuc2V0VmFsdWUodilcbiAqICAgfVxuICogfSk7XG4gKi9cbmV4cG9ydCBjb25zdCBkaXJlY3RpdmUgPSAoZikgPT4gKCguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgZCA9IGYoLi4uYXJncyk7XG4gICAgZGlyZWN0aXZlcy5zZXQoZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGQ7XG59KTtcbmV4cG9ydCBjb25zdCBpc0RpcmVjdGl2ZSA9IChvKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSAnZnVuY3Rpb24nICYmIGRpcmVjdGl2ZXMuaGFzKG8pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZS5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIFRydWUgaWYgdGhlIGN1c3RvbSBlbGVtZW50cyBwb2x5ZmlsbCBpcyBpbiB1c2UuXG4gKi9cbmV4cG9ydCBjb25zdCBpc0NFUG9seWZpbGwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cyAhPSBudWxsICYmXG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2sgIT09XG4gICAgICAgIHVuZGVmaW5lZDtcbi8qKlxuICogUmVwYXJlbnRzIG5vZGVzLCBzdGFydGluZyBmcm9tIGBzdGFydGAgKGluY2x1c2l2ZSkgdG8gYGVuZGAgKGV4Y2x1c2l2ZSksXG4gKiBpbnRvIGFub3RoZXIgY29udGFpbmVyIChjb3VsZCBiZSB0aGUgc2FtZSBjb250YWluZXIpLCBiZWZvcmUgYGJlZm9yZWAuIElmXG4gKiBgYmVmb3JlYCBpcyBudWxsLCBpdCBhcHBlbmRzIHRoZSBub2RlcyB0byB0aGUgY29udGFpbmVyLlxuICovXG5leHBvcnQgY29uc3QgcmVwYXJlbnROb2RlcyA9IChjb250YWluZXIsIHN0YXJ0LCBlbmQgPSBudWxsLCBiZWZvcmUgPSBudWxsKSA9PiB7XG4gICAgd2hpbGUgKHN0YXJ0ICE9PSBlbmQpIHtcbiAgICAgICAgY29uc3QgbiA9IHN0YXJ0Lm5leHRTaWJsaW5nO1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0YXJ0LCBiZWZvcmUpO1xuICAgICAgICBzdGFydCA9IG47XG4gICAgfVxufTtcbi8qKlxuICogUmVtb3ZlcyBub2Rlcywgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIChpbmNsdXNpdmUpIHRvIGBlbmRgIChleGNsdXNpdmUpLCBmcm9tXG4gKiBgY29udGFpbmVyYC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZU5vZGVzID0gKGNvbnRhaW5lciwgc3RhcnQsIGVuZCA9IG51bGwpID0+IHtcbiAgICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICBjb25zdCBuID0gc3RhcnQubmV4dFNpYmxpbmc7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gbjtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxOCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQSBzZW50aW5lbCB2YWx1ZSB0aGF0IHNpZ25hbHMgdGhhdCBhIHZhbHVlIHdhcyBoYW5kbGVkIGJ5IGEgZGlyZWN0aXZlIGFuZFxuICogc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG4gKi9cbmV4cG9ydCBjb25zdCBub0NoYW5nZSA9IHt9O1xuLyoqXG4gKiBBIHNlbnRpbmVsIHZhbHVlIHRoYXQgc2lnbmFscyBhIE5vZGVQYXJ0IHRvIGZ1bGx5IGNsZWFyIGl0cyBjb250ZW50LlxuICovXG5leHBvcnQgY29uc3Qgbm90aGluZyA9IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIEFuIGV4cHJlc3Npb24gbWFya2VyIHdpdGggZW1iZWRkZWQgdW5pcXVlIGtleSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aFxuICogcG9zc2libGUgdGV4dCBpbiB0ZW1wbGF0ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXJrZXIgPSBge3tsaXQtJHtTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMil9fX1gO1xuLyoqXG4gKiBBbiBleHByZXNzaW9uIG1hcmtlciB1c2VkIHRleHQtcG9zaXRpb25zLCBtdWx0aS1iaW5kaW5nIGF0dHJpYnV0ZXMsIGFuZFxuICogYXR0cmlidXRlcyB3aXRoIG1hcmt1cC1saWtlIHRleHQgdmFsdWVzLlxuICovXG5leHBvcnQgY29uc3Qgbm9kZU1hcmtlciA9IGA8IS0tJHttYXJrZXJ9LS0+YDtcbmV4cG9ydCBjb25zdCBtYXJrZXJSZWdleCA9IG5ldyBSZWdFeHAoYCR7bWFya2VyfXwke25vZGVNYXJrZXJ9YCk7XG4vKipcbiAqIFN1ZmZpeCBhcHBlbmRlZCB0byBhbGwgYm91bmQgYXR0cmlidXRlIG5hbWVzLlxuICovXG5leHBvcnQgY29uc3QgYm91bmRBdHRyaWJ1dGVTdWZmaXggPSAnJGxpdCQnO1xuLyoqXG4gKiBBbiB1cGRhdGFibGUgVGVtcGxhdGUgdGhhdCB0cmFja3MgdGhlIGxvY2F0aW9uIG9mIGR5bmFtaWMgcGFydHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IocmVzdWx0LCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1JlbW92ZSA9IFtdO1xuICAgICAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgICAgICAvLyBFZGdlIG5lZWRzIGFsbCA0IHBhcmFtZXRlcnMgcHJlc2VudDsgSUUxMSBuZWVkcyAzcmQgcGFyYW1ldGVyIHRvIGJlIG51bGxcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LmNvbnRlbnQsIDEzMyAvKiBOb2RlRmlsdGVyLlNIT1dfe0VMRU1FTlR8Q09NTUVOVHxURVhUfSAqLywgbnVsbCwgZmFsc2UpO1xuICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgbGFzdCBpbmRleCBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0LiBXZSB0cnkgdG8gZGVsZXRlXG4gICAgICAgIC8vIHVubmVjZXNzYXJ5IG5vZGVzLCBidXQgd2UgbmV2ZXIgd2FudCB0byBhc3NvY2lhdGUgdHdvIGRpZmZlcmVudCBwYXJ0c1xuICAgICAgICAvLyB0byB0aGUgc2FtZSBpbmRleC4gVGhleSBtdXN0IGhhdmUgYSBjb25zdGFudCBub2RlIGJldHdlZW4uXG4gICAgICAgIGxldCBsYXN0UGFydEluZGV4ID0gMDtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MsIHZhbHVlczogeyBsZW5ndGggfSB9ID0gcmVzdWx0O1xuICAgICAgICB3aGlsZSAocGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aGF1c3RlZCB0aGUgY29udGVudCBpbnNpZGUgYSBuZXN0ZWQgdGVtcGxhdGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHdlIHN0aWxsIGhhdmUgcGFydHMgKHRoZSBvdXRlciBmb3ItbG9vcCksIHdlIGtub3c6XG4gICAgICAgICAgICAgICAgLy8gLSBUaGVyZSBpcyBhIHRlbXBsYXRlIGluIHRoZSBzdGFja1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHdhbGtlciB3aWxsIGZpbmQgYSBuZXh0Tm9kZSBvdXRzaWRlIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICAvLyBQZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hbWVkTm9kZU1hcCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlcyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgcmV0dXJuZWQgaW4gZG9jdW1lbnQgb3JkZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhcnRpY3VsYXIsIEVkZ2UvSUUgY2FuIHJldHVybiB0aGVtIG91dCBvZiBvcmRlciwgc28gd2UgY2Fubm90XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZSBhIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcGFydCBpbmRleCBhbmQgYXR0cmlidXRlIGluZGV4LlxuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kc1dpdGgoYXR0cmlidXRlc1tpXS5uYW1lLCBib3VuZEF0dHJpYnV0ZVN1ZmZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0ZW1wbGF0ZSBsaXRlcmFsIHNlY3Rpb24gbGVhZGluZyB1cCB0byB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gaW4gdGhpcyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ0ZvclBhcnQgPSBzdHJpbmdzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXguZXhlYyhzdHJpbmdGb3JQYXJ0KVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgYm91bmQgYXR0cmlidXRlcyBoYXZlIGhhZCBhIHN1ZmZpeCBhZGRlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVtcGxhdGVSZXN1bHQjZ2V0SFRNTCB0byBvcHQgb3V0IG9mIHNwZWNpYWwgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGluZy4gVG8gbG9vayB1cCB0aGUgYXR0cmlidXRlIHZhbHVlIHdlIGFsc28gbmVlZCB0byBhZGRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzdWZmaXguXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVMb29rdXBOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpICsgYm91bmRBdHRyaWJ1dGVTdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZUxvb2t1cE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTG9va3VwTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0aWNzID0gYXR0cmlidXRlVmFsdWUuc3BsaXQobWFya2VyUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKHsgdHlwZTogJ2F0dHJpYnV0ZScsIGluZGV4LCBuYW1lLCBzdHJpbmdzOiBzdGF0aWNzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4ICs9IHN0YXRpY3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGUuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSAzIC8qIE5vZGUuVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5pbmRleE9mKG1hcmtlcikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ3MgPSBkYXRhLnNwbGl0KG1hcmtlclJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyB0ZXh0IG5vZGUgZm9yIGVhY2ggbGl0ZXJhbCBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIG5vZGVzIGFyZSBhbHNvIHVzZWQgYXMgdGhlIG1hcmtlcnMgZm9yIG5vZGUgcGFydHNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluc2VydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzID0gc3RyaW5nc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydCA9IGNyZWF0ZU1hcmtlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBsYXN0QXR0cmlidXRlTmFtZVJlZ2V4LmV4ZWMocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIGVuZHNXaXRoKG1hdGNoWzJdLCBib3VuZEF0dHJpYnV0ZVN1ZmZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgbWF0Y2hbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0uc2xpY2UoMCwgLWJvdW5kQXR0cmlidXRlU3VmZml4Lmxlbmd0aCkgKyBtYXRjaFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGluc2VydCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goeyB0eXBlOiAnbm9kZScsIGluZGV4OiArK2luZGV4IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gdGV4dCwgd2UgbXVzdCBpbnNlcnQgYSBjb21tZW50IHRvIG1hcmsgb3VyIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlLCB3ZSBjYW4gdHJ1c3QgaXQgd2lsbCBzdGljayBhcm91bmQgYWZ0ZXIgY2xvbmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3NbbGFzdEluZGV4XSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY3JlYXRlTWFya2VyKCksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gc3RyaW5nc1tsYXN0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBwYXJ0IGZvciBlYWNoIG1hdGNoIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCArPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBOb2RlLkNPTU1FTlRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09IG1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhIG5ldyBtYXJrZXIgbm9kZSB0byBiZSB0aGUgc3RhcnROb2RlIG9mIHRoZSBQYXJ0IGlmIGFueSBvZlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgICAgICAvLyAgKiBXZSBkb24ndCBoYXZlIGEgcHJldmlvdXNTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vICAqIFRoZSBwcmV2aW91c1NpYmxpbmcgaXMgYWxyZWFkeSB0aGUgc3RhcnQgb2YgYSBwcmV2aW91cyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnByZXZpb3VzU2libGluZyA9PT0gbnVsbCB8fCBpbmRleCA9PT0gbGFzdFBhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY3JlYXRlTWFya2VyKCksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKHsgdHlwZTogJ25vZGUnLCBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG5leHRTaWJsaW5nLCBrZWVwIHRoaXMgbm9kZSBzbyB3ZSBoYXZlIGFuIGVuZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSwgd2UgY2FuIHJlbW92ZSBpdCB0byBzYXZlIGZ1dHVyZSBjb3N0cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaSA9IG5vZGUuZGF0YS5pbmRleE9mKG1hcmtlciwgaSArIDEpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbW1lbnQgbm9kZSBoYXMgYSBiaW5kaW5nIG1hcmtlciBpbnNpZGUsIG1ha2UgYW4gaW5hY3RpdmUgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJpbmRpbmcgd29uJ3Qgd29yaywgYnV0IHN1YnNlcXVlbnQgYmluZGluZ3Mgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAoanVzdGluZmFnbmFuaSk6IGNvbnNpZGVyIHdoZXRoZXIgaXQncyBldmVuIHdvcnRoIGl0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGJpbmRpbmdzIGluIGNvbW1lbnRzIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaCh7IHR5cGU6ICdub2RlJywgaW5kZXg6IC0xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRleHQgYmluZGluZyBub2RlcyBhZnRlciB0aGUgd2FsayB0byBub3QgZGlzdHVyYiB0aGUgVHJlZVdhbGtlclxuICAgICAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXNUb1JlbW92ZSkge1xuICAgICAgICAgICAgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZW5kc1dpdGggPSAoc3RyLCBzdWZmaXgpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoO1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIHN0ci5zbGljZShpbmRleCkgPT09IHN1ZmZpeDtcbn07XG5leHBvcnQgY29uc3QgaXNUZW1wbGF0ZVBhcnRBY3RpdmUgPSAocGFydCkgPT4gcGFydC5pbmRleCAhPT0gLTE7XG4vLyBBbGxvd3MgYGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpYCB0byBiZSByZW5hbWVkIGZvciBhXG4vLyBzbWFsbCBtYW51YWwgc2l6ZS1zYXZpbmdzLlxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hcmtlciA9ICgpID0+IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpO1xuLyoqXG4gKiBUaGlzIHJlZ2V4IGV4dHJhY3RzIHRoZSBhdHRyaWJ1dGUgbmFtZSBwcmVjZWRpbmcgYW4gYXR0cmlidXRlLXBvc2l0aW9uXG4gKiBleHByZXNzaW9uLiBJdCBkb2VzIHRoaXMgYnkgbWF0Y2hpbmcgdGhlIHN5bnRheCBhbGxvd2VkIGZvciBhdHRyaWJ1dGVzXG4gKiBhZ2FpbnN0IHRoZSBzdHJpbmcgbGl0ZXJhbCBkaXJlY3RseSBwcmVjZWRpbmcgdGhlIGV4cHJlc3Npb24sIGFzc3VtaW5nIHRoYXRcbiAqIHRoZSBleHByZXNzaW9uIGlzIGluIGFuIGF0dHJpYnV0ZS12YWx1ZSBwb3NpdGlvbi5cbiAqXG4gKiBTZWUgYXR0cmlidXRlcyBpbiB0aGUgSFRNTCBzcGVjOlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnRzLWF0dHJpYnV0ZXNcbiAqXG4gKiBcIiBcXHgwOVxceDBhXFx4MGNcXHgwZFwiIGFyZSBIVE1MIHNwYWNlIGNoYXJhY3RlcnM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNzcGFjZS1jaGFyYWN0ZXJzXG4gKlxuICogXCJcXDAtXFx4MUZcXHg3Ri1cXHg5RlwiIGFyZSBVbmljb2RlIGNvbnRyb2wgY2hhcmFjdGVycywgd2hpY2ggaW5jbHVkZXMgZXZlcnlcbiAqIHNwYWNlIGNoYXJhY3RlciBleGNlcHQgXCIgXCIuXG4gKlxuICogU28gYW4gYXR0cmlidXRlIGlzOlxuICogICogVGhlIG5hbWU6IGFueSBjaGFyYWN0ZXIgZXhjZXB0IGEgY29udHJvbCBjaGFyYWN0ZXIsIHNwYWNlIGNoYXJhY3RlciwgKCcpLFxuICogICAgKFwiKSwgXCI+XCIsIFwiPVwiLCBvciBcIi9cIlxuICogICogRm9sbG93ZWQgYnkgemVybyBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnNcbiAqICAqIEZvbGxvd2VkIGJ5IFwiPVwiXG4gKiAgKiBGb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVyc1xuICogICogRm9sbG93ZWQgYnk6XG4gKiAgICAqIEFueSBjaGFyYWN0ZXIgZXhjZXB0IHNwYWNlLCAoJyksIChcIiksIFwiPFwiLCBcIj5cIiwgXCI9XCIsIChgKSwgb3JcbiAqICAgICogKFwiKSB0aGVuIGFueSBub24tKFwiKSwgb3JcbiAqICAgICogKCcpIHRoZW4gYW55IG5vbi0oJylcbiAqL1xuZXhwb3J0IGNvbnN0IGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXggPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4vKFsgXFx4MDlcXHgwYVxceDBjXFx4MGRdKShbXlxcMC1cXHgxRlxceDdGLVxceDlGIFwiJz49L10rKShbIFxceDA5XFx4MGFcXHgwY1xceDBkXSo9WyBcXHgwOVxceDBhXFx4MGNcXHgwZF0qKD86W14gXFx4MDlcXHgwYVxceDBjXFx4MGRcIidgPD49XSp8XCJbXlwiXSp8J1teJ10qKSkkLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IGlzQ0VQb2x5ZmlsbCB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IGlzVGVtcGxhdGVQYXJ0QWN0aXZlIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIGEgYFRlbXBsYXRlYCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgRE9NIGFuZCB1cGRhdGVkXG4gKiB3aXRoIG5ldyB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZUluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgcHJvY2Vzc29yLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX19wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICB1cGRhdGUodmFsdWVzKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMuX19wYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnQuc2V0VmFsdWUodmFsdWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fX3BhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFydC5jb21taXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2xvbmUoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBhIG51bWJlciBvZiBzdGVwcyBpbiB0aGUgbGlmZWN5Y2xlIG9mIGEgdGVtcGxhdGUgaW5zdGFuY2Unc1xuICAgICAgICAvLyBET00gZnJhZ21lbnQ6XG4gICAgICAgIC8vICAxLiBDbG9uZSAtIGNyZWF0ZSB0aGUgaW5zdGFuY2UgZnJhZ21lbnRcbiAgICAgICAgLy8gIDIuIEFkb3B0IC0gYWRvcHQgaW50byB0aGUgbWFpbiBkb2N1bWVudFxuICAgICAgICAvLyAgMy4gUHJvY2VzcyAtIGZpbmQgcGFydCBtYXJrZXJzIGFuZCBjcmVhdGUgcGFydHNcbiAgICAgICAgLy8gIDQuIFVwZ3JhZGUgLSB1cGdyYWRlIGN1c3RvbSBlbGVtZW50c1xuICAgICAgICAvLyAgNS4gVXBkYXRlIC0gc2V0IG5vZGUsIGF0dHJpYnV0ZSwgcHJvcGVydHksIGV0Yy4sIHZhbHVlc1xuICAgICAgICAvLyAgNi4gQ29ubmVjdCAtIGNvbm5lY3QgdG8gdGhlIGRvY3VtZW50LiBPcHRpb25hbCBhbmQgb3V0c2lkZSBvZiB0aGlzXG4gICAgICAgIC8vICAgICBtZXRob2QuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGhhdmUgYSBmZXcgY29uc3RyYWludHMgb24gdGhlIG9yZGVyaW5nIG9mIHRoZXNlIHN0ZXBzOlxuICAgICAgICAvLyAgKiBXZSBuZWVkIHRvIHVwZ3JhZGUgYmVmb3JlIHVwZGF0aW5nLCBzbyB0aGF0IHByb3BlcnR5IHZhbHVlcyB3aWxsIHBhc3NcbiAgICAgICAgLy8gICAgdGhyb3VnaCBhbnkgcHJvcGVydHkgc2V0dGVycy5cbiAgICAgICAgLy8gICogV2Ugd291bGQgbGlrZSB0byBwcm9jZXNzIGJlZm9yZSB1cGdyYWRpbmcgc28gdGhhdCB3ZSdyZSBzdXJlIHRoYXQgdGhlXG4gICAgICAgIC8vICAgIGNsb25lZCBmcmFnbWVudCBpcyBpbmVydCBhbmQgbm90IGRpc3R1cmJlZCBieSBzZWxmLW1vZGlmeWluZyBET00uXG4gICAgICAgIC8vICAqIFdlIHdhbnQgY3VzdG9tIGVsZW1lbnRzIHRvIHVwZ3JhZGUgZXZlbiBpbiBkaXNjb25uZWN0ZWQgZnJhZ21lbnRzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0aGVzZSBjb25zdHJhaW50cywgd2l0aCBmdWxsIGN1c3RvbSBlbGVtZW50cyBzdXBwb3J0IHdlIHdvdWxkXG4gICAgICAgIC8vIHByZWZlciB0aGUgb3JkZXI6IENsb25lLCBQcm9jZXNzLCBBZG9wdCwgVXBncmFkZSwgVXBkYXRlLCBDb25uZWN0XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJ1dCBTYWZhcmkgZG9lcyBub3QgaW1wbGVtZW50IEN1c3RvbUVsZW1lbnRSZWdpc3RyeSN1cGdyYWRlLCBzbyB3ZVxuICAgICAgICAvLyBjYW4gbm90IGltcGxlbWVudCB0aGF0IG9yZGVyIGFuZCBzdGlsbCBoYXZlIHVwZ3JhZGUtYmVmb3JlLXVwZGF0ZSBhbmRcbiAgICAgICAgLy8gdXBncmFkZSBkaXNjb25uZWN0ZWQgZnJhZ21lbnRzLiBTbyB3ZSBpbnN0ZWFkIHNhY3JpZmljZSB0aGVcbiAgICAgICAgLy8gcHJvY2Vzcy1iZWZvcmUtdXBncmFkZSBjb25zdHJhaW50LCBzaW5jZSBpbiBDdXN0b20gRWxlbWVudHMgdjEgZWxlbWVudHNcbiAgICAgICAgLy8gbXVzdCBub3QgbW9kaWZ5IHRoZWlyIGxpZ2h0IERPTSBpbiB0aGUgY29uc3RydWN0b3IuIFdlIHN0aWxsIGhhdmUgaXNzdWVzXG4gICAgICAgIC8vIHdoZW4gY28tZXhpc3Rpbmcgd2l0aCBDRXYwIGVsZW1lbnRzIGxpa2UgUG9seW1lciAxLCBhbmQgd2l0aCBwb2x5ZmlsbHNcbiAgICAgICAgLy8gdGhhdCBkb24ndCBzdHJpY3RseSBhZGhlcmUgdG8gdGhlIG5vLW1vZGlmaWNhdGlvbiBydWxlIGJlY2F1c2Ugc2hhZG93XG4gICAgICAgIC8vIERPTSwgd2hpY2ggbWF5IGJlIGNyZWF0ZWQgaW4gdGhlIGNvbnN0cnVjdG9yLCBpcyBlbXVsYXRlZCBieSBiZWluZyBwbGFjZWRcbiAgICAgICAgLy8gaW4gdGhlIGxpZ2h0IERPTS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIHJlc3VsdGluZyBvcmRlciBpcyBvbiBuYXRpdmUgaXM6IENsb25lLCBBZG9wdCwgVXBncmFkZSwgUHJvY2VzcyxcbiAgICAgICAgLy8gVXBkYXRlLCBDb25uZWN0LiBkb2N1bWVudC5pbXBvcnROb2RlKCkgcGVyZm9ybXMgQ2xvbmUsIEFkb3B0LCBhbmQgVXBncmFkZVxuICAgICAgICAvLyBpbiBvbmUgc3RlcC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIEN1c3RvbSBFbGVtZW50cyB2MSBwb2x5ZmlsbCBzdXBwb3J0cyB1cGdyYWRlKCksIHNvIHRoZSBvcmRlciB3aGVuXG4gICAgICAgIC8vIHBvbHlmaWxsZWQgaXMgdGhlIG1vcmUgaWRlYWw6IENsb25lLCBQcm9jZXNzLCBBZG9wdCwgVXBncmFkZSwgVXBkYXRlLFxuICAgICAgICAvLyBDb25uZWN0LlxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGlzQ0VQb2x5ZmlsbCA/XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLmVsZW1lbnQuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkgOlxuICAgICAgICAgICAgZG9jdW1lbnQuaW1wb3J0Tm9kZSh0aGlzLnRlbXBsYXRlLmVsZW1lbnQuY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy50ZW1wbGF0ZS5wYXJ0cztcbiAgICAgICAgLy8gRWRnZSBuZWVkcyBhbGwgNCBwYXJhbWV0ZXJzIHByZXNlbnQ7IElFMTEgbmVlZHMgM3JkIHBhcmFtZXRlciB0byBiZSBudWxsXG4gICAgICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZnJhZ21lbnQsIDEzMyAvKiBOb2RlRmlsdGVyLlNIT1dfe0VMRU1FTlR8Q09NTUVOVHxURVhUfSAqLywgbnVsbCwgZmFsc2UpO1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICAgICAgbGV0IG5vZGVJbmRleCA9IDA7XG4gICAgICAgIGxldCBwYXJ0O1xuICAgICAgICBsZXQgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBub2RlcyBhbmQgcGFydHMgb2YgYSB0ZW1wbGF0ZVxuICAgICAgICB3aGlsZSAocGFydEluZGV4IDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgICAgIGlmICghaXNUZW1wbGF0ZVBhcnRBY3RpdmUocGFydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcGFydHMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvZ3Jlc3MgdGhlIHRyZWUgd2Fsa2VyIHVudGlsIHdlIGZpbmQgb3VyIG5leHQgcGFydCdzIG5vZGUuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgbXVsdGlwbGUgcGFydHMgbWF5IHNoYXJlIHRoZSBzYW1lIG5vZGUgKGF0dHJpYnV0ZSBwYXJ0c1xuICAgICAgICAgICAgLy8gb24gYSBzaW5nbGUgZWxlbWVudCksIHNvIHRoaXMgbG9vcCBtYXkgbm90IHJ1biBhdCBhbGwuXG4gICAgICAgICAgICB3aGlsZSAobm9kZUluZGV4IDwgcGFydC5pbmRleCkge1xuICAgICAgICAgICAgICAgIG5vZGVJbmRleCsrO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGUuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChub2RlID0gd2Fsa2VyLm5leHROb2RlKCkpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aGF1c3RlZCB0aGUgY29udGVudCBpbnNpZGUgYSBuZXN0ZWQgdGVtcGxhdGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB3ZSBzdGlsbCBoYXZlIHBhcnRzICh0aGUgb3V0ZXIgZm9yLWxvb3ApLCB3ZSBrbm93OlxuICAgICAgICAgICAgICAgICAgICAvLyAtIFRoZXJlIGlzIGEgdGVtcGxhdGUgaW4gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gVGhlIHdhbGtlciB3aWxsIGZpbmQgYSBuZXh0Tm9kZSBvdXRzaWRlIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlJ3ZlIGFycml2ZWQgYXQgb3VyIHBhcnQncyBub2RlLlxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IHRoaXMucHJvY2Vzc29yLmhhbmRsZVRleHRFeHByZXNzaW9uKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcGFydC5pbnNlcnRBZnRlck5vZGUobm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3BhcnRzLnB1c2goLi4udGhpcy5wcm9jZXNzb3IuaGFuZGxlQXR0cmlidXRlRXhwcmVzc2lvbnMobm9kZSwgcGFydC5uYW1lLCBwYXJ0LnN0cmluZ3MsIHRoaXMub3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ0VQb2x5ZmlsbCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRvcHROb2RlKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1pbnN0YW5jZS5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIEBtb2R1bGUgbGl0LWh0bWxcbiAqL1xuaW1wb3J0IHsgcmVwYXJlbnROb2RlcyB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IGJvdW5kQXR0cmlidXRlU3VmZml4LCBsYXN0QXR0cmlidXRlTmFtZVJlZ2V4LCBtYXJrZXIsIG5vZGVNYXJrZXIgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbi8qKlxuICogT3VyIFRydXN0ZWRUeXBlUG9saWN5IGZvciBIVE1MIHdoaWNoIGlzIGRlY2xhcmVkIHVzaW5nIHRoZSBodG1sIHRlbXBsYXRlXG4gKiB0YWcgZnVuY3Rpb24uXG4gKlxuICogVGhhdCBIVE1MIGlzIGEgZGV2ZWxvcGVyLWF1dGhvcmVkIGNvbnN0YW50LCBhbmQgaXMgcGFyc2VkIHdpdGggaW5uZXJIVE1MXG4gKiBiZWZvcmUgYW55IHVudHJ1c3RlZCBleHByZXNzaW9ucyBoYXZlIGJlZW4gbWl4ZWQgaW4uIFRoZXJlZm9yIGl0IGlzXG4gKiBjb25zaWRlcmVkIHNhZmUgYnkgY29uc3RydWN0aW9uLlxuICovXG5jb25zdCBwb2xpY3kgPSB3aW5kb3cudHJ1c3RlZFR5cGVzICYmXG4gICAgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSgnbGl0LWh0bWwnLCB7IGNyZWF0ZUhUTUw6IChzKSA9PiBzIH0pO1xuY29uc3QgY29tbWVudE1hcmtlciA9IGAgJHttYXJrZXJ9IGA7XG4vKipcbiAqIFRoZSByZXR1cm4gdHlwZSBvZiBgaHRtbGAsIHdoaWNoIGhvbGRzIGEgVGVtcGxhdGUgYW5kIHRoZSB2YWx1ZXMgZnJvbVxuICogaW50ZXJwb2xhdGVkIGV4cHJlc3Npb25zLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcywgdHlwZSwgcHJvY2Vzc29yKSB7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBvZiBIVE1MIHVzZWQgdG8gY3JlYXRlIGEgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0SFRNTCgpIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgaHRtbCA9ICcnO1xuICAgICAgICBsZXQgaXNDb21tZW50QmluZGluZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMuc3RyaW5nc1tpXTtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGJpbmRpbmcgd2Ugd2FudCB0byBkZXRlcm1pbmUgdGhlIGtpbmQgb2YgbWFya2VyIHRvIGluc2VydFxuICAgICAgICAgICAgLy8gaW50byB0aGUgdGVtcGxhdGUgc291cmNlIGJlZm9yZSBpdCdzIHBhcnNlZCBieSB0aGUgYnJvd3NlcidzIEhUTUxcbiAgICAgICAgICAgIC8vIHBhcnNlci4gVGhlIG1hcmtlciB0eXBlIGlzIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGV4cHJlc3Npb24gaXMgaW4gYW5cbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSwgdGV4dCwgb3IgY29tbWVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgIC8vICAgKiBGb3Igbm9kZS1wb3NpdGlvbiBiaW5kaW5ncyB3ZSBpbnNlcnQgYSBjb21tZW50IHdpdGggdGhlIG1hcmtlclxuICAgICAgICAgICAgLy8gICAgIHNlbnRpbmVsIGFzIGl0cyB0ZXh0IGNvbnRlbnQsIGxpa2UgPCEtLXt7bGl0LWd1aWR9fS0tPi5cbiAgICAgICAgICAgIC8vICAgKiBGb3IgYXR0cmlidXRlIGJpbmRpbmdzIHdlIGluc2VydCBqdXN0IHRoZSBtYXJrZXIgc2VudGluZWwgZm9yIHRoZVxuICAgICAgICAgICAgLy8gICAgIGZpcnN0IGJpbmRpbmcsIHNvIHRoYXQgd2Ugc3VwcG9ydCB1bnF1b3RlZCBhdHRyaWJ1dGUgYmluZGluZ3MuXG4gICAgICAgICAgICAvLyAgICAgU3Vic2VxdWVudCBiaW5kaW5ncyBjYW4gdXNlIGEgY29tbWVudCBtYXJrZXIgYmVjYXVzZSBtdWx0aS1iaW5kaW5nXG4gICAgICAgICAgICAvLyAgICAgYXR0cmlidXRlcyBtdXN0IGJlIHF1b3RlZC5cbiAgICAgICAgICAgIC8vICAgKiBGb3IgY29tbWVudCBiaW5kaW5ncyB3ZSBpbnNlcnQganVzdCB0aGUgbWFya2VyIHNlbnRpbmVsIHNvIHdlIGRvbid0XG4gICAgICAgICAgICAvLyAgICAgY2xvc2UgdGhlIGNvbW1lbnQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIHNjYW5zIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGJ1dCBpcyAqbm90KiBhbiBIVE1MXG4gICAgICAgICAgICAvLyBwYXJzZXIuIFdlIGRvbid0IG5lZWQgdG8gdHJhY2sgdGhlIHRyZWUgc3RydWN0dXJlIG9mIHRoZSBIVE1MLCBvbmx5XG4gICAgICAgICAgICAvLyB3aGV0aGVyIGEgYmluZGluZyBpcyBpbnNpZGUgYSBjb21tZW50LCBhbmQgaWYgbm90LCBpZiBpdCBhcHBlYXJzIHRvIGJlXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgYmluZGluZyBpbiBhbiBhdHRyaWJ1dGUuXG4gICAgICAgICAgICBjb25zdCBjb21tZW50T3BlbiA9IHMubGFzdEluZGV4T2YoJzwhLS0nKTtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGluIGNvbW1lbnQgcG9zaXRpb24gaWYgd2UgaGF2ZSBhIGNvbW1lbnQgb3BlbiB3aXRoIG5vIGZvbGxvd2luZ1xuICAgICAgICAgICAgLy8gY29tbWVudCBjbG9zZS4gQmVjYXVzZSA8LS0gY2FuIGFwcGVhciBpbiBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhlcmUgY2FuXG4gICAgICAgICAgICAvLyBiZSBmYWxzZSBwb3NpdGl2ZXMuXG4gICAgICAgICAgICBpc0NvbW1lbnRCaW5kaW5nID0gKGNvbW1lbnRPcGVuID4gLTEgfHwgaXNDb21tZW50QmluZGluZykgJiZcbiAgICAgICAgICAgICAgICBzLmluZGV4T2YoJy0tPicsIGNvbW1lbnRPcGVuICsgMSkgPT09IC0xO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYW4gYXR0cmlidXRlLWxpa2Ugc2VxdWVuY2UgcHJlY2VkaW5nIHRoZVxuICAgICAgICAgICAgLy8gZXhwcmVzc2lvbi4gVGhpcyBjYW4gbWF0Y2ggXCJuYW1lPXZhbHVlXCIgbGlrZSBzdHJ1Y3R1cmVzIGluIHRleHQsXG4gICAgICAgICAgICAvLyBjb21tZW50cywgYW5kIGF0dHJpYnV0ZSB2YWx1ZXMsIHNvIHRoZXJlIGNhbiBiZSBmYWxzZS1wb3NpdGl2ZXMuXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVNYXRjaCA9IGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXguZXhlYyhzKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIG9ubHkgaW4gdGhpcyBicmFuY2ggaWYgd2UgZG9uJ3QgaGF2ZSBhIGF0dHJpYnV0ZS1saWtlXG4gICAgICAgICAgICAgICAgLy8gcHJlY2VkaW5nIHNlcXVlbmNlLiBGb3IgY29tbWVudHMsIHRoaXMgZ3VhcmRzIGFnYWluc3QgdW51c3VhbFxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSB2YWx1ZXMgbGlrZSA8ZGl2IGZvbz1cIjwhLS0keydiYXInfVwiPi4gQ2FzZXMgbGlrZVxuICAgICAgICAgICAgICAgIC8vIDwhLS0gZm9vPSR7J2Jhcid9LS0+IGFyZSBoYW5kbGVkIGNvcnJlY3RseSBpbiB0aGUgYXR0cmlidXRlIGJyYW5jaFxuICAgICAgICAgICAgICAgIC8vIGJlbG93LlxuICAgICAgICAgICAgICAgIGh0bWwgKz0gcyArIChpc0NvbW1lbnRCaW5kaW5nID8gY29tbWVudE1hcmtlciA6IG5vZGVNYXJrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGF0dHJpYnV0ZXMgd2UgdXNlIGp1c3QgYSBtYXJrZXIgc2VudGluZWwsIGFuZCBhbHNvIGFwcGVuZCBhXG4gICAgICAgICAgICAgICAgLy8gJGxpdCQgc3VmZml4IHRvIHRoZSBuYW1lIHRvIG9wdC1vdXQgb2YgYXR0cmlidXRlLXNwZWNpZmljIHBhcnNpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGF0IElFIGFuZCBFZGdlIGRvIGZvciBzdHlsZSBhbmQgY2VydGFpbiBTVkcgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAgICBodG1sICs9IHMuc3Vic3RyKDAsIGF0dHJpYnV0ZU1hdGNoLmluZGV4KSArIGF0dHJpYnV0ZU1hdGNoWzFdICtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTWF0Y2hbMl0gKyBib3VuZEF0dHJpYnV0ZVN1ZmZpeCArIGF0dHJpYnV0ZU1hdGNoWzNdICtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gdGhpcy5zdHJpbmdzW2xdO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgZ2V0VGVtcGxhdGVFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0SFRNTCgpO1xuICAgICAgICBpZiAocG9saWN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgc2VjdXJlIGJlY2F1c2UgYHRoaXMuc3RyaW5nc2AgaXMgYSBUZW1wbGF0ZVN0cmluZ3NBcnJheS5cbiAgICAgICAgICAgIC8vIFRPRE86IHZhbGlkYXRlIHRoaXMgd2hlblxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktaXMtdGVtcGxhdGUtb2JqZWN0IGlzXG4gICAgICAgICAgICAvLyBpbXBsZW1lbnRlZC5cbiAgICAgICAgICAgIHZhbHVlID0gcG9saWN5LmNyZWF0ZUhUTUwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxufVxuLyoqXG4gKiBBIFRlbXBsYXRlUmVzdWx0IGZvciBTVkcgZnJhZ21lbnRzLlxuICpcbiAqIFRoaXMgY2xhc3Mgd3JhcHMgSFRNTCBpbiBhbiBgPHN2Zz5gIHRhZyBpbiBvcmRlciB0byBwYXJzZSBpdHMgY29udGVudHMgaW4gdGhlXG4gKiBTVkcgbmFtZXNwYWNlLCB0aGVuIG1vZGlmaWVzIHRoZSB0ZW1wbGF0ZSB0byByZW1vdmUgdGhlIGA8c3ZnPmAgdGFnIHNvIHRoYXRcbiAqIGNsb25lcyBvbmx5IGNvbnRhaW5lciB0aGUgb3JpZ2luYWwgZnJhZ21lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTVkdUZW1wbGF0ZVJlc3VsdCBleHRlbmRzIFRlbXBsYXRlUmVzdWx0IHtcbiAgICBnZXRIVE1MKCkge1xuICAgICAgICByZXR1cm4gYDxzdmc+JHtzdXBlci5nZXRIVE1MKCl9PC9zdmc+YDtcbiAgICB9XG4gICAgZ2V0VGVtcGxhdGVFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHN1cGVyLmdldFRlbXBsYXRlRWxlbWVudCgpO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGVtcGxhdGUuY29udGVudDtcbiAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgY29udGVudC5yZW1vdmVDaGlsZChzdmdFbGVtZW50KTtcbiAgICAgICAgcmVwYXJlbnROb2Rlcyhjb250ZW50LCBzdmdFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUtcmVzdWx0LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IGlzRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHsgcmVtb3ZlTm9kZXMgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBub0NoYW5nZSwgbm90aGluZyB9IGZyb20gJy4vcGFydC5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlIH0gZnJvbSAnLi90ZW1wbGF0ZS1pbnN0YW5jZS5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJy4vdGVtcGxhdGUtcmVzdWx0LmpzJztcbmltcG9ydCB7IGNyZWF0ZU1hcmtlciB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuZXhwb3J0IGNvbnN0IGlzUHJpbWl0aXZlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAhKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSk7XG59O1xuZXhwb3J0IGNvbnN0IGlzSXRlcmFibGUgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgISEodmFsdWUgJiYgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSk7XG59O1xuLyoqXG4gKiBXcml0ZXMgYXR0cmlidXRlIHZhbHVlcyB0byB0aGUgRE9NIGZvciBhIGdyb3VwIG9mIEF0dHJpYnV0ZVBhcnRzIGJvdW5kIHRvIGFcbiAqIHNpbmdsZSBhdHRyaWJ1dGUuIFRoZSB2YWx1ZSBpcyBvbmx5IHNldCBvbmNlIGV2ZW4gaWYgdGhlcmUgYXJlIG11bHRpcGxlIHBhcnRzXG4gKiBmb3IgYW4gYXR0cmlidXRlLlxuICovXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlQ29tbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucGFydHNbaV0gPSB0aGlzLl9jcmVhdGVQYXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNpbmdsZSBwYXJ0LiBPdmVycmlkZSB0aGlzIHRvIGNyZWF0ZSBhIGRpZmZlcm50IHR5cGUgb2YgcGFydC5cbiAgICAgKi9cbiAgICBfY3JlYXRlUGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVQYXJ0KHRoaXMpO1xuICAgIH1cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSB0aGlzLnN0cmluZ3M7XG4gICAgICAgIGNvbnN0IGwgPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy5wYXJ0cztcbiAgICAgICAgLy8gSWYgd2UncmUgYXNzaWduaW5nIGFuIGF0dHJpYnV0ZSB2aWEgc3ludGF4IGxpa2U6XG4gICAgICAgIC8vICAgIGF0dHI9XCIke2Zvb31cIiAgb3IgIGF0dHI9JHtmb299XG4gICAgICAgIC8vIGJ1dCBub3RcbiAgICAgICAgLy8gICAgYXR0cj1cIiR7Zm9vfSAke2Jhcn1cIiBvciBhdHRyPVwiJHtmb299IGJhelwiXG4gICAgICAgIC8vIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byBjb2VyY2UgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBpbnRvIG9uZSBsb25nXG4gICAgICAgIC8vIHN0cmluZy4gSW5zdGVhZCB3ZSB3YW50IHRvIGp1c3QgcmV0dXJuIHRoZSB2YWx1ZSBpdHNlbGYgZGlyZWN0bHksXG4gICAgICAgIC8vIHNvIHRoYXQgc2FuaXRpemVET01WYWx1ZSBjYW4gZ2V0IHRoZSBhY3R1YWwgdmFsdWUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gU3RyaW5nKHZhbHVlKVxuICAgICAgICAvLyBUaGUgZXhjZXB0aW9uIGlzIGlmIHYgaXMgYW4gYXJyYXksIGluIHdoaWNoIGNhc2Ugd2UgZG8gd2FudCB0byBzbWFzaFxuICAgICAgICAvLyBpdCB0b2dldGhlciBpbnRvIGEgc3RyaW5nIHdpdGhvdXQgY2FsbGluZyBTdHJpbmcoKSBvbiB0aGUgYXJyYXkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgYWxzbyBhbGxvd3MgdHJ1c3RlZCB2YWx1ZXMgKHdoZW4gdXNpbmcgVHJ1c3RlZFR5cGVzKSBiZWluZ1xuICAgICAgICAvLyBhc3NpZ25lZCB0byBET00gc2lua3Mgd2l0aG91dCBiZWluZyBzdHJpbmdpZmllZCBpbiB0aGUgcHJvY2Vzcy5cbiAgICAgICAgaWYgKGwgPT09IDEgJiYgc3RyaW5nc1swXSA9PT0gJycgJiYgc3RyaW5nc1sxXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBwYXJ0c1swXS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCAhaXNJdGVyYWJsZSh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IHN0cmluZ3NbaV07XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHBhcnQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHYpIHx8ICFpc0l0ZXJhYmxlKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdiA6IFN0cmluZyh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHR5cGVvZiB0ID09PSAnc3RyaW5nJyA/IHQgOiBTdHJpbmcodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCArPSBzdHJpbmdzW2xdO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm5hbWUsIHRoaXMuX2dldFZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIFBhcnQgdGhhdCBjb250cm9scyBhbGwgb3IgcGFydCBvZiBhbiBhdHRyaWJ1dGUgdmFsdWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb21taXR0ZXIpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb21taXR0ZXIgPSBjb21taXR0ZXI7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbm9DaGFuZ2UgJiYgKCFpc1ByaW1pdGl2ZSh2YWx1ZSkgfHwgdmFsdWUgIT09IHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBub3QgYSBkaXJlY3RpdmUsIGRpcnR5IHRoZSBjb21taXR0ZXIgc28gdGhhdCBpdCdsbFxuICAgICAgICAgICAgLy8gY2FsbCBzZXRBdHRyaWJ1dGUuIElmIHRoZSB2YWx1ZSBpcyBhIGRpcmVjdGl2ZSwgaXQnbGwgZGlydHkgdGhlXG4gICAgICAgICAgICAvLyBjb21taXR0ZXIgaWYgaXQgY2FsbHMgc2V0VmFsdWUoKS5cbiAgICAgICAgICAgIGlmICghaXNEaXJlY3RpdmUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXR0ZXIuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgd2hpbGUgKGlzRGlyZWN0aXZlKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5vQ2hhbmdlO1xuICAgICAgICAgICAgZGlyZWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBub0NoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWl0dGVyLmNvbW1pdCgpO1xuICAgIH1cbn1cbi8qKlxuICogQSBQYXJ0IHRoYXQgY29udHJvbHMgYSBsb2NhdGlvbiB3aXRoaW4gYSBOb2RlIHRyZWUuIExpa2UgYSBSYW5nZSwgTm9kZVBhcnRcbiAqIGhhcyBzdGFydCBhbmQgZW5kIGxvY2F0aW9ucyBhbmQgY2FuIHNldCBhbmQgdXBkYXRlIHRoZSBOb2RlcyBiZXR3ZWVuIHRob3NlXG4gKiBsb2NhdGlvbnMuXG4gKlxuICogTm9kZVBhcnRzIHN1cHBvcnQgc2V2ZXJhbCB2YWx1ZSB0eXBlczogcHJpbWl0aXZlcywgTm9kZXMsIFRlbXBsYXRlUmVzdWx0cyxcbiAqIGFzIHdlbGwgYXMgYXJyYXlzIGFuZCBpdGVyYWJsZXMgb2YgdGhvc2UgdHlwZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoaXMgcGFydCBpbnRvIGEgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogVGhpcyBwYXJ0IG11c3QgYmUgZW1wdHksIGFzIGl0cyBjb250ZW50cyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgbW92ZWQuXG4gICAgICovXG4gICAgYXBwZW5kSW50byhjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5zdGFydE5vZGUgPSBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlTWFya2VyKCkpO1xuICAgICAgICB0aGlzLmVuZE5vZGUgPSBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlTWFya2VyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoaXMgcGFydCBhZnRlciB0aGUgYHJlZmAgbm9kZSAoYmV0d2VlbiBgcmVmYCBhbmQgYHJlZmAncyBuZXh0XG4gICAgICogc2libGluZykuIEJvdGggYHJlZmAgYW5kIGl0cyBuZXh0IHNpYmxpbmcgbXVzdCBiZSBzdGF0aWMsIHVuY2hhbmdpbmcgbm9kZXNcbiAgICAgKiBzdWNoIGFzIHRob3NlIHRoYXQgYXBwZWFyIGluIGEgbGl0ZXJhbCBzZWN0aW9uIG9mIGEgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhcnQgbXVzdCBiZSBlbXB0eSwgYXMgaXRzIGNvbnRlbnRzIGFyZSBub3QgYXV0b21hdGljYWxseSBtb3ZlZC5cbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlck5vZGUocmVmKSB7XG4gICAgICAgIHRoaXMuc3RhcnROb2RlID0gcmVmO1xuICAgICAgICB0aGlzLmVuZE5vZGUgPSByZWYubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhpcyBwYXJ0IGludG8gYSBwYXJlbnQgcGFydC5cbiAgICAgKlxuICAgICAqIFRoaXMgcGFydCBtdXN0IGJlIGVtcHR5LCBhcyBpdHMgY29udGVudHMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IG1vdmVkLlxuICAgICAqL1xuICAgIGFwcGVuZEludG9QYXJ0KHBhcnQpIHtcbiAgICAgICAgcGFydC5fX2luc2VydCh0aGlzLnN0YXJ0Tm9kZSA9IGNyZWF0ZU1hcmtlcigpKTtcbiAgICAgICAgcGFydC5fX2luc2VydCh0aGlzLmVuZE5vZGUgPSBjcmVhdGVNYXJrZXIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhpcyBwYXJ0IGFmdGVyIHRoZSBgcmVmYCBwYXJ0LlxuICAgICAqXG4gICAgICogVGhpcyBwYXJ0IG11c3QgYmUgZW1wdHksIGFzIGl0cyBjb250ZW50cyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgbW92ZWQuXG4gICAgICovXG4gICAgaW5zZXJ0QWZ0ZXJQYXJ0KHJlZikge1xuICAgICAgICByZWYuX19pbnNlcnQodGhpcy5zdGFydE5vZGUgPSBjcmVhdGVNYXJrZXIoKSk7XG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IHJlZi5lbmROb2RlO1xuICAgICAgICByZWYuZW5kTm9kZSA9IHRoaXMuc3RhcnROb2RlO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnROb2RlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXNEaXJlY3RpdmUodGhpcy5fX3BlbmRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gbm9DaGFuZ2U7XG4gICAgICAgICAgICBkaXJlY3RpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT09IG5vQ2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbW1pdFRleHQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXRUZW1wbGF0ZVJlc3VsdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9fY29tbWl0Tm9kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG5vdGhpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBub3RoaW5nO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2ssIHdpbGwgcmVuZGVyIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIHRoaXMuX19jb21taXRUZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfX2luc2VydChub2RlKSB7XG4gICAgICAgIHRoaXMuZW5kTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0aGlzLmVuZE5vZGUpO1xuICAgIH1cbiAgICBfX2NvbW1pdE5vZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9faW5zZXJ0KHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBfX2NvbW1pdFRleHQodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICAvLyBJZiBgdmFsdWVgIGlzbid0IGFscmVhZHkgYSBzdHJpbmcsIHdlIGV4cGxpY2l0bHkgY29udmVydCBpdCBoZXJlIGluIGNhc2VcbiAgICAgICAgLy8gaXQgY2FuJ3QgYmUgaW1wbGljaXRseSBjb252ZXJ0ZWQgLSBpLmUuIGl0J3MgYSBzeW1ib2wuXG4gICAgICAgIGNvbnN0IHZhbHVlQXNTdHJpbmcgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBTdHJpbmcodmFsdWUpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5lbmROb2RlLnByZXZpb3VzU2libGluZyAmJlxuICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBOb2RlLlRFWFRfTk9ERSAqLykge1xuICAgICAgICAgICAgLy8gSWYgd2Ugb25seSBoYXZlIGEgc2luZ2xlIHRleHQgbm9kZSBiZXR3ZWVuIHRoZSBtYXJrZXJzLCB3ZSBjYW4ganVzdFxuICAgICAgICAgICAgLy8gc2V0IGl0cyB2YWx1ZSwgcmF0aGVyIHRoYW4gcmVwbGFjaW5nIGl0LlxuICAgICAgICAgICAgLy8gVE9ETyhqdXN0aW5mYWduYW5pKTogQ2FuIHdlIGp1c3QgY2hlY2sgaWYgdGhpcy52YWx1ZSBpcyBwcmltaXRpdmU/XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2YWx1ZUFzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdE5vZGUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWVBc1N0cmluZykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgX19jb21taXRUZW1wbGF0ZVJlc3VsdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZUZhY3RvcnkodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlSW5zdGFuY2UgJiZcbiAgICAgICAgICAgIHRoaXMudmFsdWUudGVtcGxhdGUgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnVwZGF0ZSh2YWx1ZS52YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHByb3BhZ2F0ZSB0aGUgdGVtcGxhdGUgcHJvY2Vzc29yIGZyb20gdGhlIFRlbXBsYXRlUmVzdWx0XG4gICAgICAgICAgICAvLyBzbyB0aGF0IHdlIHVzZSBpdHMgc3ludGF4IGV4dGVuc2lvbiwgZXRjLiBUaGUgdGVtcGxhdGUgZmFjdG9yeSBjb21lc1xuICAgICAgICAgICAgLy8gZnJvbSB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9wdGlvbnMgc28gdGhhdCBpdCBjYW4gY29udHJvbCB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gY2FjaGluZyBhbmQgcHJlcHJvY2Vzc2luZy5cbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFRlbXBsYXRlSW5zdGFuY2UodGVtcGxhdGUsIHZhbHVlLnByb2Nlc3NvciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gaW5zdGFuY2UuX2Nsb25lKCk7XG4gICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUodmFsdWUudmFsdWVzKTtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXROb2RlKGZyYWdtZW50KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfX2NvbW1pdEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICAgIC8vIEZvciBhbiBJdGVyYWJsZSwgd2UgY3JlYXRlIGEgbmV3IEluc3RhbmNlUGFydCBwZXIgaXRlbSwgdGhlbiBzZXQgaXRzXG4gICAgICAgIC8vIHZhbHVlIHRvIHRoZSBpdGVtLiBUaGlzIGlzIGEgbGl0dGxlIGJpdCBvZiBvdmVyaGVhZCBmb3IgZXZlcnkgaXRlbSBpblxuICAgICAgICAvLyBhbiBJdGVyYWJsZSwgYnV0IGl0IGxldHMgdXMgcmVjdXJzZSBlYXNpbHkgYW5kIGVmZmljaWVudGx5IHVwZGF0ZSBBcnJheXNcbiAgICAgICAgLy8gb2YgVGVtcGxhdGVSZXN1bHRzIHRoYXQgd2lsbCBiZSBjb21tb25seSByZXR1cm5lZCBmcm9tIGV4cHJlc3Npb25zIGxpa2U6XG4gICAgICAgIC8vIGFycmF5Lm1hcCgoaSkgPT4gaHRtbGAke2l9YCksIGJ5IHJldXNpbmcgZXhpc3RpbmcgVGVtcGxhdGVJbnN0YW5jZXMuXG4gICAgICAgIC8vIElmIF92YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiB0aGUgcHJldmlvdXMgcmVuZGVyIHdhcyBvZiBhblxuICAgICAgICAvLyBpdGVyYWJsZSBhbmQgX3ZhbHVlIHdpbGwgY29udGFpbiB0aGUgTm9kZVBhcnRzIGZyb20gdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIHJlbmRlci4gSWYgX3ZhbHVlIGlzIG5vdCBhbiBhcnJheSwgY2xlYXIgdGhpcyBwYXJ0IGFuZCBtYWtlIGEgbmV3XG4gICAgICAgIC8vIGFycmF5IGZvciBOb2RlUGFydHMuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExldHMgdXMga2VlcCB0cmFjayBvZiBob3cgbWFueSBpdGVtcyB3ZSBzdGFtcGVkIHNvIHdlIGNhbiBjbGVhciBsZWZ0b3ZlclxuICAgICAgICAvLyBpdGVtcyBmcm9tIGEgcHJldmlvdXMgcmVuZGVyXG4gICAgICAgIGNvbnN0IGl0ZW1QYXJ0cyA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICBsZXQgaXRlbVBhcnQ7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHJldXNlIGFuIGV4aXN0aW5nIHBhcnRcbiAgICAgICAgICAgIGl0ZW1QYXJ0ID0gaXRlbVBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAvLyBJZiBubyBleGlzdGluZyBwYXJ0LCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgICAgICBpZiAoaXRlbVBhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW1QYXJ0ID0gbmV3IE5vZGVQYXJ0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaXRlbVBhcnRzLnB1c2goaXRlbVBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVBhcnQuYXBwZW5kSW50b1BhcnQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtUGFydC5pbnNlcnRBZnRlclBhcnQoaXRlbVBhcnRzW3BhcnRJbmRleCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtUGFydC5zZXRWYWx1ZShpdGVtKTtcbiAgICAgICAgICAgIGl0ZW1QYXJ0LmNvbW1pdCgpO1xuICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRJbmRleCA8IGl0ZW1QYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRydW5jYXRlIHRoZSBwYXJ0cyBhcnJheSBzbyBfdmFsdWUgcmVmbGVjdHMgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICAgIGl0ZW1QYXJ0cy5sZW5ndGggPSBwYXJ0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKGl0ZW1QYXJ0ICYmIGl0ZW1QYXJ0LmVuZE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKHN0YXJ0Tm9kZSA9IHRoaXMuc3RhcnROb2RlKSB7XG4gICAgICAgIHJlbW92ZU5vZGVzKHRoaXMuc3RhcnROb2RlLnBhcmVudE5vZGUsIHN0YXJ0Tm9kZS5uZXh0U2libGluZywgdGhpcy5lbmROb2RlKTtcbiAgICB9XG59XG4vKipcbiAqIEltcGxlbWVudHMgYSBib29sZWFuIGF0dHJpYnV0ZSwgcm91Z2hseSBhcyBkZWZpbmVkIGluIHRoZSBIVE1MXG4gKiBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyB0cnV0aHksIHRoZW4gdGhlIGF0dHJpYnV0ZSBpcyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvZlxuICogJycuIElmIHRoZSB2YWx1ZSBpcyBmYWxzZXksIHRoZSBhdHRyaWJ1dGUgaXMgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5BdHRyaWJ1dGVQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzdHJpbmdzLmxlbmd0aCAhPT0gMiB8fCBzdHJpbmdzWzBdICE9PSAnJyB8fCBzdHJpbmdzWzFdICE9PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb29sZWFuIGF0dHJpYnV0ZXMgY2FuIG9ubHkgY29udGFpbiBhIHNpbmdsZSBleHByZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIHdoaWxlIChpc0RpcmVjdGl2ZSh0aGlzLl9fcGVuZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX3BlbmRpbmdWYWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9ICEhdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICB9XG59XG4vKipcbiAqIFNldHMgYXR0cmlidXRlIHZhbHVlcyBmb3IgUHJvcGVydHlQYXJ0cywgc28gdGhhdCB0aGUgdmFsdWUgaXMgb25seSBzZXQgb25jZVxuICogZXZlbiBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgcGFydHMgZm9yIGEgcHJvcGVydHkuXG4gKlxuICogSWYgYW4gZXhwcmVzc2lvbiBjb250cm9scyB0aGUgd2hvbGUgcHJvcGVydHkgdmFsdWUsIHRoZW4gdGhlIHZhbHVlIGlzIHNpbXBseVxuICogYXNzaWduZWQgdG8gdGhlIHByb3BlcnR5IHVuZGVyIGNvbnRyb2wuIElmIHRoZXJlIGFyZSBzdHJpbmcgbGl0ZXJhbHMgb3JcbiAqIG11bHRpcGxlIGV4cHJlc3Npb25zLCB0aGVuIHRoZSBzdHJpbmdzIGFyZSBleHByZXNzaW9ucyBhcmUgaW50ZXJwb2xhdGVkIGludG9cbiAqIGEgc3RyaW5nIGZpcnN0LlxuICovXG5leHBvcnQgY2xhc3MgUHJvcGVydHlDb21taXR0ZXIgZXh0ZW5kcyBBdHRyaWJ1dGVDb21taXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudCwgbmFtZSwgc3RyaW5ncyk7XG4gICAgICAgIHRoaXMuc2luZ2xlID1cbiAgICAgICAgICAgIChzdHJpbmdzLmxlbmd0aCA9PT0gMiAmJiBzdHJpbmdzWzBdID09PSAnJyAmJiBzdHJpbmdzWzFdID09PSAnJyk7XG4gICAgfVxuICAgIF9jcmVhdGVQYXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UGFydCh0aGlzKTtcbiAgICB9XG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5zaW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnRzWzBdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFt0aGlzLm5hbWVdID0gdGhpcy5fZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eVBhcnQgZXh0ZW5kcyBBdHRyaWJ1dGVQYXJ0IHtcbn1cbi8vIERldGVjdCBldmVudCBsaXN0ZW5lciBvcHRpb25zIHN1cHBvcnQuIElmIHRoZSBgY2FwdHVyZWAgcHJvcGVydHkgaXMgcmVhZFxuLy8gZnJvbSB0aGUgb3B0aW9ucyBvYmplY3QsIHRoZW4gb3B0aW9ucyBhcmUgc3VwcG9ydGVkLiBJZiBub3QsIHRoZW4gdGhlIHRoaXJkXG4vLyBhcmd1bWVudCB0byBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lciBpcyBpbnRlcnByZXRlZCBhcyB0aGUgYm9vbGVhbiBjYXB0dXJlXG4vLyB2YWx1ZSBzbyB3ZSBzaG91bGQgb25seSBwYXNzIHRoZSBgY2FwdHVyZWAgcHJvcGVydHkuXG5sZXQgZXZlbnRPcHRpb25zU3VwcG9ydGVkID0gZmFsc2U7XG4vLyBXcmFwIGludG8gYW4gSUlGRSBiZWNhdXNlIE1TIEVkZ2UgPD0gdjQxIGRvZXMgbm90IHN1cHBvcnQgaGF2aW5nIHRyeS9jYXRjaFxuLy8gYmxvY2tzIHJpZ2h0IGludG8gdGhlIGJvZHkgb2YgYSBtb2R1bGVcbigoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGdldCBjYXB0dXJlKCkge1xuICAgICAgICAgICAgICAgIGV2ZW50T3B0aW9uc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgLy8gZXZlbnQgb3B0aW9ucyBub3Qgc3VwcG9ydGVkXG4gICAgfVxufSkoKTtcbmV4cG9ydCBjbGFzcyBFdmVudFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGV2ZW50TmFtZSwgZXZlbnRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLmV2ZW50Q29udGV4dCA9IGV2ZW50Q29udGV4dDtcbiAgICAgICAgdGhpcy5fX2JvdW5kSGFuZGxlRXZlbnQgPSAoZSkgPT4gdGhpcy5oYW5kbGVFdmVudChlKTtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIHdoaWxlIChpc0RpcmVjdGl2ZSh0aGlzLl9fcGVuZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX3BlbmRpbmdWYWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMaXN0ZW5lciA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgIGNvbnN0IG9sZExpc3RlbmVyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlTGlzdGVuZXIgPSBuZXdMaXN0ZW5lciA9PSBudWxsIHx8XG4gICAgICAgICAgICBvbGRMaXN0ZW5lciAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgKG5ld0xpc3RlbmVyLmNhcHR1cmUgIT09IG9sZExpc3RlbmVyLmNhcHR1cmUgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV3TGlzdGVuZXIub25jZSAhPT0gb2xkTGlzdGVuZXIub25jZSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXdMaXN0ZW5lci5wYXNzaXZlICE9PSBvbGRMaXN0ZW5lci5wYXNzaXZlKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkQWRkTGlzdGVuZXIgPSBuZXdMaXN0ZW5lciAhPSBudWxsICYmIChvbGRMaXN0ZW5lciA9PSBudWxsIHx8IHNob3VsZFJlbW92ZUxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHNob3VsZFJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy5fX2JvdW5kSGFuZGxlRXZlbnQsIHRoaXMuX19vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX19vcHRpb25zID0gZ2V0T3B0aW9ucyhuZXdMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy5fX2JvdW5kSGFuZGxlRXZlbnQsIHRoaXMuX19vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gbmV3TGlzdGVuZXI7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmNhbGwodGhpcy5ldmVudENvbnRleHQgfHwgdGhpcy5lbGVtZW50LCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFdlIGNvcHkgb3B0aW9ucyBiZWNhdXNlIG9mIHRoZSBpbmNvbnNpc3RlbnQgYmVoYXZpb3Igb2YgYnJvd3NlcnMgd2hlbiByZWFkaW5nXG4vLyB0aGUgdGhpcmQgYXJndW1lbnQgb2YgYWRkL3JlbW92ZUV2ZW50TGlzdGVuZXIuIElFMTEgZG9lc24ndCBzdXBwb3J0IG9wdGlvbnNcbi8vIGF0IGFsbC4gQ2hyb21lIDQxIG9ubHkgcmVhZHMgYGNhcHR1cmVgIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBvYmplY3QuXG5jb25zdCBnZXRPcHRpb25zID0gKG8pID0+IG8gJiZcbiAgICAoZXZlbnRPcHRpb25zU3VwcG9ydGVkID9cbiAgICAgICAgeyBjYXB0dXJlOiBvLmNhcHR1cmUsIHBhc3NpdmU6IG8ucGFzc2l2ZSwgb25jZTogby5vbmNlIH0gOlxuICAgICAgICBvLmNhcHR1cmUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydHMuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuaW1wb3J0IHsgQXR0cmlidXRlQ29tbWl0dGVyLCBCb29sZWFuQXR0cmlidXRlUGFydCwgRXZlbnRQYXJ0LCBOb2RlUGFydCwgUHJvcGVydHlDb21taXR0ZXIgfSBmcm9tICcuL3BhcnRzLmpzJztcbi8qKlxuICogQ3JlYXRlcyBQYXJ0cyB3aGVuIGEgdGVtcGxhdGUgaXMgaW5zdGFudGlhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcGFydHMgZm9yIGFuIGF0dHJpYnV0ZS1wb3NpdGlvbiBiaW5kaW5nLCBnaXZlbiB0aGUgZXZlbnQsIGF0dHJpYnV0ZVxuICAgICAqIG5hbWUsIGFuZCBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBiaW5kaW5nXG4gICAgICogQHBhcmFtIG5hbWUgIFRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAqIEBwYXJhbSBzdHJpbmdzIFRoZSBzdHJpbmcgbGl0ZXJhbHMuIFRoZXJlIGFyZSBhbHdheXMgYXQgbGVhc3QgdHdvIHN0cmluZ3MsXG4gICAgICogICBldmVudCBmb3IgZnVsbHktY29udHJvbGxlZCBiaW5kaW5ncyB3aXRoIGEgc2luZ2xlIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgaGFuZGxlQXR0cmlidXRlRXhwcmVzc2lvbnMoZWxlbWVudCwgbmFtZSwgc3RyaW5ncywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBuYW1lWzBdO1xuICAgICAgICBpZiAocHJlZml4ID09PSAnLicpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1pdHRlciA9IG5ldyBQcm9wZXJ0eUNvbW1pdHRlcihlbGVtZW50LCBuYW1lLnNsaWNlKDEpLCBzdHJpbmdzKTtcbiAgICAgICAgICAgIHJldHVybiBjb21taXR0ZXIucGFydHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJ0AnKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBFdmVudFBhcnQoZWxlbWVudCwgbmFtZS5zbGljZSgxKSwgb3B0aW9ucy5ldmVudENvbnRleHQpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZml4ID09PSAnPycpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IEJvb2xlYW5BdHRyaWJ1dGVQYXJ0KGVsZW1lbnQsIG5hbWUuc2xpY2UoMSksIHN0cmluZ3MpXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21taXR0ZXIgPSBuZXcgQXR0cmlidXRlQ29tbWl0dGVyKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpO1xuICAgICAgICByZXR1cm4gY29tbWl0dGVyLnBhcnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcGFydHMgZm9yIGEgdGV4dC1wb3NpdGlvbiBiaW5kaW5nLlxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZUZhY3RvcnlcbiAgICAgKi9cbiAgICBoYW5kbGVUZXh0RXhwcmVzc2lvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBhcnQob3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciA9IG5ldyBEZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHQtdGVtcGxhdGUtcHJvY2Vzc29yLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IG1hcmtlciwgVGVtcGxhdGUgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbi8qKlxuICogVGhlIGRlZmF1bHQgVGVtcGxhdGVGYWN0b3J5IHdoaWNoIGNhY2hlcyBUZW1wbGF0ZXMga2V5ZWQgb25cbiAqIHJlc3VsdC50eXBlIGFuZCByZXN1bHQuc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlRmFjdG9yeShyZXN1bHQpIHtcbiAgICBsZXQgdGVtcGxhdGVDYWNoZSA9IHRlbXBsYXRlQ2FjaGVzLmdldChyZXN1bHQudHlwZSk7XG4gICAgaWYgKHRlbXBsYXRlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0ZW1wbGF0ZUNhY2hlID0ge1xuICAgICAgICAgICAgc3RyaW5nc0FycmF5OiBuZXcgV2Vha01hcCgpLFxuICAgICAgICAgICAga2V5U3RyaW5nOiBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgdGVtcGxhdGVDYWNoZXMuc2V0KHJlc3VsdC50eXBlLCB0ZW1wbGF0ZUNhY2hlKTtcbiAgICB9XG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVDYWNoZS5zdHJpbmdzQXJyYXkuZ2V0KHJlc3VsdC5zdHJpbmdzKTtcbiAgICBpZiAodGVtcGxhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8vIElmIHRoZSBUZW1wbGF0ZVN0cmluZ3NBcnJheSBpcyBuZXcsIGdlbmVyYXRlIGEga2V5IGZyb20gdGhlIHN0cmluZ3NcbiAgICAvLyBUaGlzIGtleSBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgdGVtcGxhdGVzIHdpdGggaWRlbnRpY2FsIGNvbnRlbnRcbiAgICBjb25zdCBrZXkgPSByZXN1bHQuc3RyaW5ncy5qb2luKG1hcmtlcik7XG4gICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGEgVGVtcGxhdGUgZm9yIHRoaXMga2V5XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNhY2hlLmtleVN0cmluZy5nZXQoa2V5KTtcbiAgICBpZiAodGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vdCBzZWVuIHRoaXMga2V5IGJlZm9yZSwgY3JlYXRlIGEgbmV3IFRlbXBsYXRlXG4gICAgICAgIHRlbXBsYXRlID0gbmV3IFRlbXBsYXRlKHJlc3VsdCwgcmVzdWx0LmdldFRlbXBsYXRlRWxlbWVudCgpKTtcbiAgICAgICAgLy8gQ2FjaGUgdGhlIFRlbXBsYXRlIGZvciB0aGlzIGtleVxuICAgICAgICB0ZW1wbGF0ZUNhY2hlLmtleVN0cmluZy5zZXQoa2V5LCB0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIC8vIENhY2hlIGFsbCBmdXR1cmUgcXVlcmllcyBmb3IgdGhpcyBUZW1wbGF0ZVN0cmluZ3NBcnJheVxuICAgIHRlbXBsYXRlQ2FjaGUuc3RyaW5nc0FycmF5LnNldChyZXN1bHQuc3RyaW5ncywgdGVtcGxhdGUpO1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbn1cbmV4cG9ydCBjb25zdCB0ZW1wbGF0ZUNhY2hlcyA9IG5ldyBNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLWZhY3RvcnkuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuaW1wb3J0IHsgcmVtb3ZlTm9kZXMgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBOb2RlUGFydCB9IGZyb20gJy4vcGFydHMuanMnO1xuaW1wb3J0IHsgdGVtcGxhdGVGYWN0b3J5IH0gZnJvbSAnLi90ZW1wbGF0ZS1mYWN0b3J5LmpzJztcbmV4cG9ydCBjb25zdCBwYXJ0cyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFJlbmRlcnMgYSB0ZW1wbGF0ZSByZXN1bHQgb3Igb3RoZXIgdmFsdWUgdG8gYSBjb250YWluZXIuXG4gKlxuICogVG8gdXBkYXRlIGEgY29udGFpbmVyIHdpdGggbmV3IHZhbHVlcywgcmVldmFsdWF0ZSB0aGUgdGVtcGxhdGUgbGl0ZXJhbCBhbmRcbiAqIGNhbGwgYHJlbmRlcmAgd2l0aCB0aGUgbmV3IHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gcmVzdWx0IEFueSB2YWx1ZSByZW5kZXJhYmxlIGJ5IE5vZGVQYXJ0IC0gdHlwaWNhbGx5IGEgVGVtcGxhdGVSZXN1bHRcbiAqICAgICBjcmVhdGVkIGJ5IGV2YWx1YXRpbmcgYSB0ZW1wbGF0ZSB0YWcgbGlrZSBgaHRtbGAgb3IgYHN2Z2AuXG4gKiBAcGFyYW0gY29udGFpbmVyIEEgRE9NIHBhcmVudCB0byByZW5kZXIgdG8uIFRoZSBlbnRpcmUgY29udGVudHMgYXJlIGVpdGhlclxuICogICAgIHJlcGxhY2VkLCBvciBlZmZpY2llbnRseSB1cGRhdGVkIGlmIHRoZSBzYW1lIHJlc3VsdCB0eXBlIHdhcyBwcmV2aW91c1xuICogICAgIHJlbmRlcmVkIHRoZXJlLlxuICogQHBhcmFtIG9wdGlvbnMgUmVuZGVyT3B0aW9ucyBmb3IgdGhlIGVudGlyZSByZW5kZXIgdHJlZSByZW5kZXJlZCB0byB0aGlzXG4gKiAgICAgY29udGFpbmVyLiBSZW5kZXIgb3B0aW9ucyBtdXN0ICpub3QqIGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMgdG8gdGhlIHNhbWVcbiAqICAgICBjb250YWluZXIsIGFzIHRob3NlIGNoYW5nZXMgd2lsbCBub3QgZWZmZWN0IHByZXZpb3VzbHkgcmVuZGVyZWQgRE9NLlxuICovXG5leHBvcnQgY29uc3QgcmVuZGVyID0gKHJlc3VsdCwgY29udGFpbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgbGV0IHBhcnQgPSBwYXJ0cy5nZXQoY29udGFpbmVyKTtcbiAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbW92ZU5vZGVzKGNvbnRhaW5lciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICBwYXJ0cy5zZXQoY29udGFpbmVyLCBwYXJ0ID0gbmV3IE5vZGVQYXJ0KE9iamVjdC5hc3NpZ24oeyB0ZW1wbGF0ZUZhY3RvcnkgfSwgb3B0aW9ucykpKTtcbiAgICAgICAgcGFydC5hcHBlbmRJbnRvKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHBhcnQuc2V0VmFsdWUocmVzdWx0KTtcbiAgICBwYXJ0LmNvbW1pdCgpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqXG4gKiBNYWluIGxpdC1odG1sIG1vZHVsZS5cbiAqXG4gKiBNYWluIGV4cG9ydHM6XG4gKlxuICogLSAgW1todG1sXV1cbiAqIC0gIFtbc3ZnXV1cbiAqIC0gIFtbcmVuZGVyXV1cbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuLyoqXG4gKiBEbyBub3QgcmVtb3ZlIHRoaXMgY29tbWVudDsgaXQga2VlcHMgdHlwZWRvYyBmcm9tIG1pc3BsYWNpbmcgdGhlIG1vZHVsZVxuICogZG9jcy5cbiAqL1xuaW1wb3J0IHsgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yIH0gZnJvbSAnLi9saWIvZGVmYXVsdC10ZW1wbGF0ZS1wcm9jZXNzb3IuanMnO1xuaW1wb3J0IHsgU1ZHVGVtcGxhdGVSZXN1bHQsIFRlbXBsYXRlUmVzdWx0IH0gZnJvbSAnLi9saWIvdGVtcGxhdGUtcmVzdWx0LmpzJztcbmV4cG9ydCB7IERlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciwgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yIH0gZnJvbSAnLi9saWIvZGVmYXVsdC10ZW1wbGF0ZS1wcm9jZXNzb3IuanMnO1xuZXhwb3J0IHsgZGlyZWN0aXZlLCBpc0RpcmVjdGl2ZSB9IGZyb20gJy4vbGliL2RpcmVjdGl2ZS5qcyc7XG4vLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiByZW1vdmUgbGluZSB3aGVuIHdlIGdldCBOb2RlUGFydCBtb3ZpbmcgbWV0aG9kc1xuZXhwb3J0IHsgcmVtb3ZlTm9kZXMsIHJlcGFyZW50Tm9kZXMgfSBmcm9tICcuL2xpYi9kb20uanMnO1xuZXhwb3J0IHsgbm9DaGFuZ2UsIG5vdGhpbmcgfSBmcm9tICcuL2xpYi9wYXJ0LmpzJztcbmV4cG9ydCB7IEF0dHJpYnV0ZUNvbW1pdHRlciwgQXR0cmlidXRlUGFydCwgQm9vbGVhbkF0dHJpYnV0ZVBhcnQsIEV2ZW50UGFydCwgaXNJdGVyYWJsZSwgaXNQcmltaXRpdmUsIE5vZGVQYXJ0LCBQcm9wZXJ0eUNvbW1pdHRlciwgUHJvcGVydHlQYXJ0IH0gZnJvbSAnLi9saWIvcGFydHMuanMnO1xuZXhwb3J0IHsgcGFydHMsIHJlbmRlciB9IGZyb20gJy4vbGliL3JlbmRlci5qcyc7XG5leHBvcnQgeyB0ZW1wbGF0ZUNhY2hlcywgdGVtcGxhdGVGYWN0b3J5IH0gZnJvbSAnLi9saWIvdGVtcGxhdGUtZmFjdG9yeS5qcyc7XG5leHBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlIH0gZnJvbSAnLi9saWIvdGVtcGxhdGUtaW5zdGFuY2UuanMnO1xuZXhwb3J0IHsgU1ZHVGVtcGxhdGVSZXN1bHQsIFRlbXBsYXRlUmVzdWx0IH0gZnJvbSAnLi9saWIvdGVtcGxhdGUtcmVzdWx0LmpzJztcbmV4cG9ydCB7IGNyZWF0ZU1hcmtlciwgaXNUZW1wbGF0ZVBhcnRBY3RpdmUsIFRlbXBsYXRlIH0gZnJvbSAnLi9saWIvdGVtcGxhdGUuanMnO1xuLy8gSU1QT1JUQU5UOiBkbyBub3QgY2hhbmdlIHRoZSBwcm9wZXJ0eSBuYW1lIG9yIHRoZSBhc3NpZ25tZW50IGV4cHJlc3Npb24uXG4vLyBUaGlzIGxpbmUgd2lsbCBiZSB1c2VkIGluIHJlZ2V4ZXMgdG8gc2VhcmNoIGZvciBsaXQtaHRtbCB1c2FnZS5cbi8vIFRPRE8oanVzdGluZmFnbmFuaSk6IGluamVjdCB2ZXJzaW9uIG51bWJlciBhdCBidWlsZCB0aW1lXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAod2luZG93WydsaXRIdG1sVmVyc2lvbnMnXSB8fCAod2luZG93WydsaXRIdG1sVmVyc2lvbnMnXSA9IFtdKSkucHVzaCgnMS4zLjAnKTtcbn1cbi8qKlxuICogSW50ZXJwcmV0cyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYW4gSFRNTCB0ZW1wbGF0ZSB0aGF0IGNhbiBlZmZpY2llbnRseVxuICogcmVuZGVyIHRvIGFuZCB1cGRhdGUgYSBjb250YWluZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBodG1sID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4gbmV3IFRlbXBsYXRlUmVzdWx0KHN0cmluZ3MsIHZhbHVlcywgJ2h0bWwnLCBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IpO1xuLyoqXG4gKiBJbnRlcnByZXRzIGEgdGVtcGxhdGUgbGl0ZXJhbCBhcyBhbiBTVkcgdGVtcGxhdGUgdGhhdCBjYW4gZWZmaWNpZW50bHlcbiAqIHJlbmRlciB0byBhbmQgdXBkYXRlIGEgY29udGFpbmVyLlxuICovXG5leHBvcnQgY29uc3Qgc3ZnID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4gbmV3IFNWR1RlbXBsYXRlUmVzdWx0KHN0cmluZ3MsIHZhbHVlcywgJ3N2ZycsIGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3Nvcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXQtaHRtbC5qcy5tYXAiLCJsZXQgY3VycmVudDtcbmxldCBjdXJyZW50SWQgPSAwO1xuZnVuY3Rpb24gc2V0Q3VycmVudChzdGF0ZSkge1xuICAgIGN1cnJlbnQgPSBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGN1cnJlbnQgPSBudWxsO1xuICAgIGN1cnJlbnRJZCA9IDA7XG59XG5mdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRJZCsrO1xufVxuZXhwb3J0IHsgY2xlYXIsIGN1cnJlbnQsIHNldEN1cnJlbnQsIG5vdGlmeSB9O1xuIiwiY29uc3QgcGhhc2VTeW1ib2wgPSBTeW1ib2woJ2hhdW50ZWQucGhhc2UnKTtcbmNvbnN0IGhvb2tTeW1ib2wgPSBTeW1ib2woJ2hhdW50ZWQuaG9vaycpO1xuY29uc3QgdXBkYXRlU3ltYm9sID0gU3ltYm9sKCdoYXVudGVkLnVwZGF0ZScpO1xuY29uc3QgY29tbWl0U3ltYm9sID0gU3ltYm9sKCdoYXVudGVkLmNvbW1pdCcpO1xuY29uc3QgZWZmZWN0c1N5bWJvbCA9IFN5bWJvbCgnaGF1bnRlZC5lZmZlY3RzJyk7XG5jb25zdCBsYXlvdXRFZmZlY3RzU3ltYm9sID0gU3ltYm9sKCdoYXVudGVkLmxheW91dEVmZmVjdHMnKTtcbmNvbnN0IGNvbnRleHRFdmVudCA9ICdoYXVudGVkLmNvbnRleHQnO1xuZXhwb3J0IHsgcGhhc2VTeW1ib2wsIGhvb2tTeW1ib2wsIHVwZGF0ZVN5bWJvbCwgY29tbWl0U3ltYm9sLCBlZmZlY3RzU3ltYm9sLCBsYXlvdXRFZmZlY3RzU3ltYm9sLCBjb250ZXh0RXZlbnQsIH07XG4iLCJpbXBvcnQgeyBzZXRDdXJyZW50LCBjbGVhciB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IGhvb2tTeW1ib2wsIGVmZmVjdHNTeW1ib2wsIGxheW91dEVmZmVjdHNTeW1ib2wgfSBmcm9tICcuL3N5bWJvbHMnO1xuY2xhc3MgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHVwZGF0ZSwgaG9zdCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpc1tob29rU3ltYm9sXSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpc1tlZmZlY3RzU3ltYm9sXSA9IFtdO1xuICAgICAgICB0aGlzW2xheW91dEVmZmVjdHNTeW1ib2xdID0gW107XG4gICAgfVxuICAgIHJ1bihjYikge1xuICAgICAgICBzZXRDdXJyZW50KHRoaXMpO1xuICAgICAgICBsZXQgcmVzID0gY2IoKTtcbiAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX3J1bkVmZmVjdHMocGhhc2UpIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSB0aGlzW3BoYXNlXTtcbiAgICAgICAgc2V0Q3VycmVudCh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGVmZmVjdC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyKCk7XG4gICAgfVxuICAgIHJ1bkVmZmVjdHMoKSB7XG4gICAgICAgIHRoaXMuX3J1bkVmZmVjdHMoZWZmZWN0c1N5bWJvbCk7XG4gICAgfVxuICAgIHJ1bkxheW91dEVmZmVjdHMoKSB7XG4gICAgICAgIHRoaXMuX3J1bkVmZmVjdHMobGF5b3V0RWZmZWN0c1N5bWJvbCk7XG4gICAgfVxuICAgIHRlYXJkb3duKCkge1xuICAgICAgICBsZXQgaG9va3MgPSB0aGlzW2hvb2tTeW1ib2xdO1xuICAgICAgICBob29rcy5mb3JFYWNoKGhvb2sgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBob29rLnRlYXJkb3duID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaG9vay50ZWFyZG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgeyBTdGF0ZSB9O1xuIiwiaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuL3N0YXRlJztcbmltcG9ydCB7IGNvbW1pdFN5bWJvbCwgcGhhc2VTeW1ib2wsIHVwZGF0ZVN5bWJvbCwgZWZmZWN0c1N5bWJvbCwgbGF5b3V0RWZmZWN0c1N5bWJvbCB9IGZyb20gJy4vc3ltYm9scyc7XG5jb25zdCBkZWZlciA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSk7XG5mdW5jdGlvbiBydW5uZXIoKSB7XG4gICAgbGV0IHRhc2tzID0gW107XG4gICAgbGV0IGlkO1xuICAgIGZ1bmN0aW9uIHJ1blRhc2tzKCkge1xuICAgICAgICBpZCA9IG51bGw7XG4gICAgICAgIGxldCB0ID0gdGFza3M7XG4gICAgICAgIHRhc2tzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0W2ldKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHRhc2tzLnB1c2godGFzayk7XG4gICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZCA9IGRlZmVyKHJ1blRhc2tzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCByZWFkID0gcnVubmVyKCk7XG5jb25zdCB3cml0ZSA9IHJ1bm5lcigpO1xuY2xhc3MgQmFzZVNjaGVkdWxlciB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGhvc3QpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlKHRoaXMudXBkYXRlLmJpbmQodGhpcyksIGhvc3QpO1xuICAgICAgICB0aGlzW3BoYXNlU3ltYm9sXSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVF1ZXVlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVRdWV1ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuaGFuZGxlUGhhc2UodXBkYXRlU3ltYm9sKTtcbiAgICAgICAgICAgIHdyaXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBoYXNlKGNvbW1pdFN5bWJvbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB3cml0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGhhc2UoZWZmZWN0c1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUXVldWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaGFuZGxlUGhhc2UocGhhc2UsIGFyZykge1xuICAgICAgICB0aGlzW3BoYXNlU3ltYm9sXSA9IHBoYXNlO1xuICAgICAgICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgICAgICAgICBjYXNlIGNvbW1pdFN5bWJvbDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdChhcmcpO1xuICAgICAgICAgICAgICAgIHRoaXMucnVuRWZmZWN0cyhsYXlvdXRFZmZlY3RzU3ltYm9sKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIHVwZGF0ZVN5bWJvbDogcmV0dXJuIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICBjYXNlIGVmZmVjdHNTeW1ib2w6IHJldHVybiB0aGlzLnJ1bkVmZmVjdHMoZWZmZWN0c1N5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1twaGFzZVN5bWJvbF0gPSBudWxsO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJ1bigoKSA9PiB0aGlzLnJlbmRlcmVyLmNhbGwodGhpcy5ob3N0LCB0aGlzLmhvc3QpKTtcbiAgICB9XG4gICAgcnVuRWZmZWN0cyhwaGFzZSkge1xuICAgICAgICB0aGlzLnN0YXRlLl9ydW5FZmZlY3RzKHBoYXNlKTtcbiAgICB9XG4gICAgdGVhcmRvd24oKSB7XG4gICAgICAgIHRoaXMuc3RhdGUudGVhcmRvd24oKTtcbiAgICB9XG59XG5leHBvcnQgeyBCYXNlU2NoZWR1bGVyIH07XG4iLCJpbXBvcnQgeyBCYXNlU2NoZWR1bGVyIH0gZnJvbSAnLi9zY2hlZHVsZXInO1xuY29uc3QgdG9DYW1lbENhc2UgPSAodmFsID0gJycpID0+IHZhbC5yZXBsYWNlKC8tKyhbYS16XSk/L2csIChfLCBjaGFyKSA9PiBjaGFyID8gY2hhci50b1VwcGVyQ2FzZSgpIDogJycpO1xuZnVuY3Rpb24gbWFrZUNvbXBvbmVudChyZW5kZXIpIHtcbiAgICBjbGFzcyBTY2hlZHVsZXIgZXh0ZW5kcyBCYXNlU2NoZWR1bGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGZyYWcsIGhvc3QpIHtcbiAgICAgICAgICAgIHN1cGVyKHJlbmRlcmVyLCBob3N0IHx8IGZyYWcpO1xuICAgICAgICAgICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICAgICAgfVxuICAgICAgICBjb21taXQocmVzdWx0KSB7XG4gICAgICAgICAgICByZW5kZXIocmVzdWx0LCB0aGlzLmZyYWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBvbmVudChyZW5kZXJlciwgYmFzZUVsZW1lbnRPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgQmFzZUVsZW1lbnQgPSAob3B0aW9ucyB8fCBiYXNlRWxlbWVudE9yT3B0aW9ucyB8fCB7fSkuYmFzZUVsZW1lbnQgfHwgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHsgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gW10sIHVzZVNoYWRvd0RPTSA9IHRydWUsIHNoYWRvd1Jvb3RJbml0ID0ge30gfSA9IG9wdGlvbnMgfHwgYmFzZUVsZW1lbnRPck9wdGlvbnMgfHwge307XG4gICAgICAgIGNsYXNzIEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgICAgIGlmICh1c2VTaGFkb3dET00gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIocmVuZGVyZXIsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicsIC4uLnNoYWRvd1Jvb3RJbml0IH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKHJlbmRlcmVyLCB0aGlzLnNoYWRvd1Jvb3QsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJlci5vYnNlcnZlZEF0dHJpYnV0ZXMgfHwgb2JzZXJ2ZWRBdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVyLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVyLnRlYXJkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBuZXdWYWx1ZSA9PT0gJycgPyB0cnVlIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5zZXQodGhpcywgdG9DYW1lbENhc2UobmFtZSksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBmdW5jdGlvbiByZWZsZWN0aXZlUHJvcChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZXIudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdG8gPSBuZXcgUHJveHkoQmFzZUVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBnZXRQcm90b3R5cGVPZih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYy5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnIHx8IGtleVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IHJlZmxlY3RpdmVQcm9wKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBrZXksIGRlc2MpO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEVsZW1lbnQucHJvdG90eXBlLCBwcm90byk7XG4gICAgICAgIHJldHVybiBFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xufVxuZXhwb3J0IHsgbWFrZUNvbXBvbmVudCB9O1xuIiwiaW1wb3J0IHsgY3VycmVudCwgbm90aWZ5IH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgaG9va1N5bWJvbCB9IGZyb20gJy4vc3ltYm9scyc7XG5jbGFzcyBIb29rIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgc3RhdGUpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gdXNlKEhvb2ssIC4uLmFyZ3MpIHtcbiAgICBsZXQgaWQgPSBub3RpZnkoKTtcbiAgICBsZXQgaG9va3MgPSBjdXJyZW50W2hvb2tTeW1ib2xdO1xuICAgIGxldCBob29rID0gaG9va3MuZ2V0KGlkKTtcbiAgICBpZiAoIWhvb2spIHtcbiAgICAgICAgaG9vayA9IG5ldyBIb29rKGlkLCBjdXJyZW50LCAuLi5hcmdzKTtcbiAgICAgICAgaG9va3Muc2V0KGlkLCBob29rKTtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2sudXBkYXRlKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gaG9vayhIb29rKSB7XG4gICAgcmV0dXJuIHVzZS5iaW5kKG51bGwsIEhvb2spO1xufVxuZXhwb3J0IHsgaG9vaywgSG9vayB9O1xuIiwiaW1wb3J0IHsgSG9vaywgaG9vayB9IGZyb20gJy4vaG9vayc7XG5mdW5jdGlvbiBjcmVhdGVFZmZlY3Qoc2V0RWZmZWN0cykge1xuICAgIHJldHVybiBob29rKGNsYXNzIGV4dGVuZHMgSG9vayB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGlkLCBzdGF0ZSwgaWdub3JlZDEsIGlnbm9yZWQyKSB7XG4gICAgICAgICAgICBzdXBlcihpZCwgc3RhdGUpO1xuICAgICAgICAgICAgc2V0RWZmZWN0cyhzdGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKGNhbGxiYWNrLCB2YWx1ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy52YWx1ZXMgfHwgdGhpcy5oYXNDaGFuZ2VkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJ1bigpIHtcbiAgICAgICAgICAgIHRoaXMudGVhcmRvd24oKTtcbiAgICAgICAgICAgIHRoaXMuX3RlYXJkb3duID0gdGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRlYXJkb3duKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl90ZWFyZG93biA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlYXJkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFzQ2hhbmdlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5sYXN0VmFsdWVzIHx8IHRoaXMudmFsdWVzLnNvbWUoKHZhbHVlLCBpKSA9PiB0aGlzLmxhc3RWYWx1ZXNbaV0gIT09IHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IHsgY3JlYXRlRWZmZWN0IH07XG4iLCJpbXBvcnQgeyBlZmZlY3RzU3ltYm9sIH0gZnJvbSAnLi9zeW1ib2xzJztcbmltcG9ydCB7IGNyZWF0ZUVmZmVjdCB9IGZyb20gJy4vY3JlYXRlLWVmZmVjdCc7XG5mdW5jdGlvbiBzZXRFZmZlY3RzKHN0YXRlLCBjYikge1xuICAgIHN0YXRlW2VmZmVjdHNTeW1ib2xdLnB1c2goY2IpO1xufVxuY29uc3QgdXNlRWZmZWN0ID0gY3JlYXRlRWZmZWN0KHNldEVmZmVjdHMpO1xuZXhwb3J0IHsgc2V0RWZmZWN0cywgdXNlRWZmZWN0IH07XG4iLCJpbXBvcnQgeyBob29rLCBIb29rIH0gZnJvbSAnLi9ob29rJztcbmltcG9ydCB7IGNvbnRleHRFdmVudCB9IGZyb20gJy4vc3ltYm9scyc7XG5pbXBvcnQgeyBzZXRFZmZlY3RzIH0gZnJvbSAnLi91c2UtZWZmZWN0JztcbmNvbnN0IHVzZUNvbnRleHQgPSBob29rKGNsYXNzIGV4dGVuZHMgSG9vayB7XG4gICAgY29uc3RydWN0b3IoaWQsIHN0YXRlLCBfKSB7XG4gICAgICAgIHN1cGVyKGlkLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXIgPSB0aGlzLl91cGRhdGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3JhbkVmZmVjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICAgIHNldEVmZmVjdHMoc3RhdGUsIHRoaXMpO1xuICAgIH1cbiAgICB1cGRhdGUoQ29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aXJ0dWFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgYmUgdXNlZCB3aXRoIHZpcnR1YWwgY29tcG9uZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLkNvbnRleHQgIT09IENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShDb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuQ29udGV4dCA9IENvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIGNhbGwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmFuRWZmZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9yYW5FZmZlY3QgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlKVxuICAgICAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUodGhpcy5Db250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3VwZGF0ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBfc3Vic2NyaWJlKENvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZGV0YWlsID0geyBDb250ZXh0LCBjYWxsYmFjazogdGhpcy5fdXBkYXRlciB9O1xuICAgICAgICB0aGlzLnN0YXRlLmhvc3QuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoY29udGV4dEV2ZW50LCB7XG4gICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUsIHZhbHVlIH0gPSBkZXRhaWw7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bnN1YnNjcmliZSA/IHZhbHVlIDogQ29udGV4dC5kZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmU7XG4gICAgfVxuICAgIHRlYXJkb3duKCkge1xuICAgICAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmV4cG9ydCB7IHVzZUNvbnRleHQgfTtcbiIsImltcG9ydCB7IGNvbnRleHRFdmVudCB9IGZyb20gJy4vc3ltYm9scyc7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAnLi91c2UtY29udGV4dCc7XG5mdW5jdGlvbiBtYWtlQ29udGV4dChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gKGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBDb250ZXh0ID0ge1xuICAgICAgICAgICAgUHJvdmlkZXI6IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGNvbnRleHRFdmVudCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY29udGV4dEV2ZW50LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlsLkNvbnRleHQgPT09IENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbC52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWwudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcywgZGV0YWlsLmNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmFkZChkZXRhaWwuY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENvbnN1bWVyOiBjb21wb25lbnQoZnVuY3Rpb24gKHsgcmVuZGVyIH0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyKGNvbnRleHQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb250ZXh0O1xuICAgIH07XG59XG5leHBvcnQgeyBtYWtlQ29udGV4dCB9O1xuIiwiaW1wb3J0IHsgaG9vaywgSG9vayB9IGZyb20gJy4vaG9vayc7XG5jb25zdCB1c2VNZW1vID0gaG9vayhjbGFzcyBleHRlbmRzIEhvb2sge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBzdGF0ZSwgZm4sIHZhbHVlcykge1xuICAgICAgICBzdXBlcihpZCwgc3RhdGUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gZm4oKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHVwZGF0ZShmbiwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NoYW5nZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZm4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgaGFzQ2hhbmdlZCh2YWx1ZXMgPSBbXSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzLnNvbWUoKHZhbHVlLCBpKSA9PiB0aGlzLnZhbHVlc1tpXSAhPT0gdmFsdWUpO1xuICAgIH1cbn0pO1xuZXhwb3J0IHsgdXNlTWVtbyB9O1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJy4vdXNlLW1lbW8nO1xuY29uc3QgdXNlQ2FsbGJhY2sgPSAoZm4sIGlucHV0cykgPT4gdXNlTWVtbygoKSA9PiBmbiwgaW5wdXRzKTtcbmV4cG9ydCB7IHVzZUNhbGxiYWNrIH07XG4iLCJpbXBvcnQgeyBsYXlvdXRFZmZlY3RzU3ltYm9sIH0gZnJvbSAnLi9zeW1ib2xzJztcbmltcG9ydCB7IGNyZWF0ZUVmZmVjdCB9IGZyb20gJy4vY3JlYXRlLWVmZmVjdCc7XG5mdW5jdGlvbiBzZXRMYXlvdXRFZmZlY3RzKHN0YXRlLCBjYikge1xuICAgIHN0YXRlW2xheW91dEVmZmVjdHNTeW1ib2xdLnB1c2goY2IpO1xufVxuY29uc3QgdXNlTGF5b3V0RWZmZWN0ID0gY3JlYXRlRWZmZWN0KHNldExheW91dEVmZmVjdHMpO1xuZXhwb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH07XG4iLCJpbXBvcnQgeyBob29rLCBIb29rIH0gZnJvbSAnLi9ob29rJztcbmNvbnN0IHVzZVN0YXRlID0gaG9vayhjbGFzcyBleHRlbmRzIEhvb2sge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBzdGF0ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGlkLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlciA9IHRoaXMudXBkYXRlci5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWtlQXJncyhpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3M7XG4gICAgfVxuICAgIHVwZGF0ZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlckZuID0gdmFsdWU7XG4gICAgICAgICAgICBjb25zdCBbcHJldmlvdXNWYWx1ZV0gPSB0aGlzLmFyZ3M7XG4gICAgICAgICAgICB2YWx1ZSA9IHVwZGF0ZXJGbihwcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ha2VBcmdzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGUoKTtcbiAgICB9XG4gICAgbWFrZUFyZ3ModmFsdWUpIHtcbiAgICAgICAgdGhpcy5hcmdzID0gT2JqZWN0LmZyZWV6ZShbdmFsdWUsIHRoaXMudXBkYXRlcl0pO1xuICAgIH1cbn0pO1xuZXhwb3J0IHsgdXNlU3RhdGUgfTtcbiIsImltcG9ydCB7IGhvb2ssIEhvb2sgfSBmcm9tICcuL2hvb2snO1xuY29uc3QgdXNlUmVkdWNlciA9IGhvb2soY2xhc3MgZXh0ZW5kcyBIb29rIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgc3RhdGUsIF8sIGluaXRpYWxTdGF0ZSwgaW5pdCkge1xuICAgICAgICBzdXBlcihpZCwgc3RhdGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGluaXQgIT09IHVuZGVmaW5lZCA/IGluaXQoaW5pdGlhbFN0YXRlKSA6IGluaXRpYWxTdGF0ZTtcbiAgICB9XG4gICAgdXBkYXRlKHJlZHVjZXIpIHtcbiAgICAgICAgdGhpcy5yZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmN1cnJlbnRTdGF0ZSwgdGhpcy5kaXNwYXRjaF07XG4gICAgfVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRoaXMucmVkdWNlcih0aGlzLmN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGUoKTtcbiAgICB9XG59KTtcbmV4cG9ydCB7IHVzZVJlZHVjZXIgfTtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICcuL3VzZS1tZW1vJztcbmNvbnN0IHVzZVJlZiA9IChpbml0aWFsVmFsdWUpID0+IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbn0pLCBbXSk7XG5leHBvcnQgeyB1c2VSZWYgfTtcbiIsImltcG9ydCB7IG1ha2VDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBtYWtlQ29udGV4dCB9IGZyb20gJy4vY3JlYXRlLWNvbnRleHQnO1xuZnVuY3Rpb24gaGF1bnRlZCh7IHJlbmRlciB9KSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gbWFrZUNvbXBvbmVudChyZW5kZXIpO1xuICAgIGNvbnN0IGNyZWF0ZUNvbnRleHQgPSBtYWtlQ29udGV4dChjb21wb25lbnQpO1xuICAgIHJldHVybiB7IGNvbXBvbmVudCwgY3JlYXRlQ29udGV4dCB9O1xufVxuZXhwb3J0IHsgaGF1bnRlZCBhcyBkZWZhdWx0IH07XG5leHBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJy4vdXNlLWNhbGxiYWNrJztcbmV4cG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJy4vdXNlLWVmZmVjdCc7XG5leHBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICcuL3VzZS1sYXlvdXQtZWZmZWN0JztcbmV4cG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAnLi91c2Utc3RhdGUnO1xuZXhwb3J0IHsgdXNlUmVkdWNlciB9IGZyb20gJy4vdXNlLXJlZHVjZXInO1xuZXhwb3J0IHsgdXNlTWVtbyB9IGZyb20gJy4vdXNlLW1lbW8nO1xuZXhwb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJy4vdXNlLWNvbnRleHQnO1xuZXhwb3J0IHsgdXNlUmVmIH0gZnJvbSAnLi91c2UtcmVmJztcbmV4cG9ydCB7IGhvb2ssIEhvb2sgfSBmcm9tICcuL2hvb2snO1xuZXhwb3J0IHsgQmFzZVNjaGVkdWxlciB9IGZyb20gJy4vc2NoZWR1bGVyJztcbmV4cG9ydCB7IFN0YXRlIH0gZnJvbSAnLi9zdGF0ZSc7XG4iLCJpbXBvcnQgeyBodG1sLCByZW5kZXIgfSBmcm9tICdsaXQtaHRtbCc7XG5pbXBvcnQgaGF1bnRlZCBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IHsgbWFrZVZpcnR1YWwgfSBmcm9tICcuL3ZpcnR1YWwnO1xuY29uc3QgeyBjb21wb25lbnQsIGNyZWF0ZUNvbnRleHQgfSA9IGhhdW50ZWQoeyByZW5kZXIgfSk7XG5jb25zdCB2aXJ0dWFsID0gbWFrZVZpcnR1YWwoKTtcbmV4cG9ydCB7IGNvbXBvbmVudCwgY3JlYXRlQ29udGV4dCwgdmlydHVhbCwgaHRtbCwgcmVuZGVyIH07XG4iLCJpbXBvcnQgeyB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tICdoYXVudGVkJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYm91bmNlZENhbGxiYWNrKFxuICBmdW5jLFxuICByYXdXYWl0LFxuICBvcHRpb25zID0geyBsZWFkaW5nOiBmYWxzZSwgdHJhaWxpbmc6IHRydWUgfVxuKSB7XG4gIGNvbnN0IGxhc3RDYWxsVGltZSA9IHVzZVJlZih1bmRlZmluZWQpO1xuICBjb25zdCBsYXN0SW52b2tlVGltZSA9IHVzZVJlZigwKTtcbiAgY29uc3QgdGltZXJJZCA9IHVzZVJlZih1bmRlZmluZWQpO1xuICBjb25zdCBsYXN0QXJncyA9IHVzZVJlZihbXSk7XG4gIGNvbnN0IGxhc3RUaGlzID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCByZXN1bHQgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGZ1bmNSZWYgPSB1c2VSZWYoZnVuYyk7XG4gIGNvbnN0IG1vdW50ZWQgPSB1c2VSZWYodHJ1ZSk7XG4gIGZ1bmNSZWYuY3VycmVudCA9IGZ1bmM7XG5cbiAgLy8gQnlwYXNzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGJ5IGV4cGxpY2l0bHkgc2V0dGluZyBgd2FpdD0wYC5cbiAgY29uc3QgdXNlUkFGID1cbiAgICAhcmF3V2FpdCAmJlxuICAgIHJhd1dhaXQgIT09IDAgJiZcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgZnVuY3Rpb24nKTtcbiAgfVxuICBjb25zdCB3YWl0ID0gTnVtYmVyKHJhd1dhaXQpIHx8IDA7XG4gIGNvbnN0IGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgY29uc3QgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cnVlO1xuICBjb25zdCBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgY29uc3QgbWF4V2FpdCA9IG1heGluZ1xuICAgID8gTWF0aC5tYXgoTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdClcbiAgICA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBpbnZva2VGdW5jID0gdXNlQ2FsbGJhY2soKHRpbWUpID0+IHtcbiAgICBjb25zdCBhcmdzID0gbGFzdEFyZ3MuY3VycmVudDtcbiAgICBjb25zdCB0aGlzQXJnID0gbGFzdFRoaXMuY3VycmVudDtcblxuICAgIGxhc3RUaGlzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEFyZ3MuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZS5jdXJyZW50ID0gdGltZTtcbiAgICByZXN1bHQuY3VycmVudCA9IGZ1bmNSZWYuY3VycmVudC5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0LmN1cnJlbnQ7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzdGFydFRpbWVyID0gdXNlQ2FsbGJhY2soXG4gICAgKHBlbmRpbmdGdW5jLCB0aW1lb3V0KSA9PiB7XG4gICAgICBpZiAodXNlUkFGKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aW1lcklkLmN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShwZW5kaW5nRnVuYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChwZW5kaW5nRnVuYywgdGltZW91dCk7XG4gICAgfSxcbiAgICBbdXNlUkFGXVxuICApO1xuXG4gIGNvbnN0IGNhbmNlbFRpbWVyID0gdXNlQ2FsbGJhY2soXG4gICAgKGlkKSA9PiB7XG4gICAgICBpZiAodXNlUkFGKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgW3VzZVJBRl1cbiAgKTtcblxuICBjb25zdCByZW1haW5pbmdXYWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKHRpbWUpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZS5jdXJyZW50O1xuICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZS5jdXJyZW50O1xuICAgICAgY29uc3QgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgIHJldHVybiBtYXhpbmdcbiAgICAgICAgPyBNYXRoLm1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgfSxcbiAgICBbbWF4V2FpdCwgbWF4aW5nLCB3YWl0XVxuICApO1xuXG4gIGNvbnN0IHNob3VsZEludm9rZSA9IHVzZUNhbGxiYWNrKFxuICAgICh0aW1lKSA9PiB7XG4gICAgICBpZiAoIW1vdW50ZWQuY3VycmVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjb25zdCB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUuY3VycmVudDtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUuY3VycmVudDtcblxuICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBsYXN0Q2FsbFRpbWUuY3VycmVudCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQgfHxcbiAgICAgICAgdGltZVNpbmNlTGFzdENhbGwgPCAwIHx8XG4gICAgICAgIChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KVxuICAgICAgKTtcbiAgICB9LFxuICAgIFttYXhXYWl0LCBtYXhpbmcsIHdhaXRdXG4gICk7XG5cbiAgY29uc3QgdHJhaWxpbmdFZGdlID0gdXNlQ2FsbGJhY2soXG4gICAgKHRpbWUpID0+IHtcbiAgICAgIHRpbWVySWQuY3VycmVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgIH1cbiAgICAgIGxhc3RUaGlzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBsYXN0QXJncy5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdC5jdXJyZW50O1xuICAgIH0sXG4gICAgW2ludm9rZUZ1bmMsIHRyYWlsaW5nXVxuICApO1xuXG4gIGNvbnN0IHRpbWVyRXhwaXJlZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkLmN1cnJlbnQgPSBzdGFydFRpbWVyKHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIFtyZW1haW5pbmdXYWl0LCBzaG91bGRJbnZva2UsIHN0YXJ0VGltZXIsIHRyYWlsaW5nRWRnZV0pO1xuXG4gIGNvbnN0IGxlYWRpbmdFZGdlID0gdXNlQ2FsbGJhY2soXG4gICAgKHRpbWUpID0+IHtcbiAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgICBsYXN0SW52b2tlVGltZS5jdXJyZW50ID0gdGltZTtcbiAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICB0aW1lcklkLmN1cnJlbnQgPSBzdGFydFRpbWVyKHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdC5jdXJyZW50O1xuICAgIH0sXG4gICAgW2ludm9rZUZ1bmMsIHN0YXJ0VGltZXIsIGxlYWRpbmcsIHRpbWVyRXhwaXJlZCwgd2FpdF1cbiAgKTtcblxuICBjb25zdCBjYW5jZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHRpbWVySWQuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW5jZWxUaW1lcih0aW1lcklkLmN1cnJlbnQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZS5jdXJyZW50ID0gMDtcbiAgICB0aW1lcklkLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgbGFzdFRoaXMuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICBsYXN0Q2FsbFRpbWUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICBsYXN0QXJncy5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9LCBbY2FuY2VsVGltZXJdKTtcblxuICBjb25zdCBmbHVzaCA9IHVzZUNhbGxiYWNrKFxuICAgICgpID0+XG4gICAgICB0aW1lcklkLmN1cnJlbnQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdC5jdXJyZW50IDogdHJhaWxpbmdFZGdlKERhdGUubm93KCkpLFxuICAgIFt0cmFpbGluZ0VkZ2VdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBtb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgY29uc3QgZGVib3VuY2VkID0gdXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgbGFzdEFyZ3MuY3VycmVudCA9IGFyZ3M7XG4gICAgICBsYXN0VGhpcy5jdXJyZW50ID0gdGhpcztcbiAgICAgIGxhc3RDYWxsVGltZS5jdXJyZW50ID0gdGltZTtcblxuICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgaWYgKHRpbWVySWQuY3VycmVudCA9PT0gdW5kZWZpbmVkICYmIG1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgdGltZXJJZC5jdXJyZW50ID0gc3RhcnRUaW1lcih0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZS5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRpbWVySWQuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRpbWVySWQuY3VycmVudCA9IHN0YXJ0VGltZXIodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQuY3VycmVudDtcbiAgICB9LFxuICAgIFtcbiAgICAgIGludm9rZUZ1bmMsXG4gICAgICBsZWFkaW5nRWRnZSxcbiAgICAgIG1heGluZyxcbiAgICAgIHNob3VsZEludm9rZSxcbiAgICAgIHN0YXJ0VGltZXIsXG4gICAgICB0aW1lckV4cGlyZWQsXG4gICAgICB3YWl0LFxuICAgIF1cbiAgKTtcblxuICBjb25zdCBwZW5kaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4gdGltZXJJZC5jdXJyZW50ICE9PSB1bmRlZmluZWQsIFtdKTtcblxuICBjb25zdCBkZWJvdW5jZWRTdGF0ZSA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGNhbGxiYWNrOiBkZWJvdW5jZWQsXG4gICAgICBjYW5jZWwsXG4gICAgICBmbHVzaCxcbiAgICAgIHBlbmRpbmcsXG4gICAgfSksXG4gICAgW2RlYm91bmNlZCwgY2FuY2VsLCBmbHVzaCwgcGVuZGluZ11cbiAgKTtcblxuICByZXR1cm4gZGVib3VuY2VkU3RhdGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgdXNlRGVib3VuY2VkQ2FsbGJhY2sgfTtcbiIsImltcG9ydCB7IGh0bWwsIGNvbXBvbmVudCwgdXNlU3RhdGUgfSBmcm9tICdoYXVudGVkJztcbmltcG9ydCB7IHVzZURlYm91bmNlZENhbGxiYWNrIH0gZnJvbSAnLi9jdXN0b20taG9va3MnO1xuaW1wb3J0IHsgZ2V0UHJlZGljdGl2ZVNlYXJjaFJlc3VsdHMgfSBmcm9tICcuLi9hamF4YXBpcyc7XG5cbmZ1bmN0aW9uIHByZWRpY3RpdmVTZWFyY2goKSB7XG4gIGNvbnN0IFtxLCBzZXRRXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3Jlc3VsdHMsIHNldFJlc3VsdHNdID0gdXNlU3RhdGUoe30pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgY29uc3QgZGVib3VuY2VkID0gdXNlRGVib3VuY2VkQ2FsbGJhY2soKCkgPT4ge1xuICAgIGdldFByZWRpY3RpdmVTZWFyY2hSZXN1bHRzKHEpLnRoZW4oZnVuY3Rpb24gc2V0VmFsdWUocmVzcG9uc2UpIHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgaWYgKHJlc3BvbnNlLm1lc3NhZ2UpIHtcbiAgICAgICAgc2V0UmVzdWx0cyh7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRSZXN1bHRzKHJlc3BvbnNlLnJlc291cmNlcy5yZXN1bHRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgNTAwKTtcblxuICBjb25zdCBoYW5kbGVLZXl1cCA9IChldmVudCkgPT4ge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0UShldmVudC50YXJnZXQudmFsdWUpO1xuICAgIGRlYm91bmNlZC5jYWxsYmFjayhldmVudC50YXJnZXQudmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiBodG1sYFxuICAgIDxoMT4ke2Ake2xvYWRpbmcgPyAnbG9hZGluZy4uLicgOiAnbG9hZGVkJ31gfTwvaDE+XG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgQGtleXVwPSR7aGFuZGxlS2V5dXB9IHZhbHVlPSR7cX0gLz5cbiAgICA8ZGl2PiR7SlNPTi5zdHJpbmdpZnkocmVzdWx0cyl9PC9kaXY+XG4gIGA7XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgJ3ByZWRpY3RpdmUtc2VhcmNoJyxcbiAgY29tcG9uZW50KHByZWRpY3RpdmVTZWFyY2gsIHsgdXNlU2hhZG93RE9NOiBmYWxzZSB9KVxuKTtcbiIsImltcG9ydCB7IGh0bWwsIGNvbXBvbmVudCwgdXNlU3RhdGUgfSBmcm9tICdoYXVudGVkJztcblxuZnVuY3Rpb24gYWRkVG9DYXJ0Rm9ybUlucHV0cyh7XG4gIGRhdGFQcm9kdWN0LFxuICBkYXRhU2VsZWN0ZWRPckZpcnN0QXZhaWxhYmxlVmFyaWFudCxcbiAgZGF0YU9wdGlvbnNXaXRoVmFsdWVzLFxuICBzZWxlY3RvckN1c3RvbUNsYXNzZXMgPSAnJyxcbiAgcXVhbnRpdHlJbnB1dEN1c3RvbUNsYXNzZXMgPSAnJyxcbiAgYXRjQnV0dG9uQ3VzdG9tQ2xhc3NlcyA9ICcnLFxufSkge1xuICBjb25zdCBwcm9kdWN0ID0gSlNPTi5wYXJzZShkYXRhUHJvZHVjdCk7XG4gIGNvbnN0IG9wdGlvbnNXaXRoVmFsdWVzID0gSlNPTi5wYXJzZShkYXRhT3B0aW9uc1dpdGhWYWx1ZXMpO1xuICBjb25zdCBbY3VycmVudFZhcmlhbnQsIHNldEN1cnJlbnRWYXJpYW50XSA9IHVzZVN0YXRlKFxuICAgIHByb2R1Y3QudmFyaWFudHMuZmluZChcbiAgICAgICh2YXJpYW50KSA9PlxuICAgICAgICB2YXJpYW50LmlkID09PSBwYXJzZUludChkYXRhU2VsZWN0ZWRPckZpcnN0QXZhaWxhYmxlVmFyaWFudCwgMTApXG4gICAgKVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZU9wdGlvbkNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCBvcHRpb24xID1cbiAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0W2RhdGEtb3B0aW9uPVwib3B0aW9uMVwiXScpICYmXG4gICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdFtkYXRhLW9wdGlvbj1cIm9wdGlvbjFcIl0nKS52YWx1ZTtcbiAgICBjb25zdCBvcHRpb24yID1cbiAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0W2RhdGEtb3B0aW9uPVwib3B0aW9uMlwiXScpICYmXG4gICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdFtkYXRhLW9wdGlvbj1cIm9wdGlvbjJcIl0nKS52YWx1ZTtcbiAgICBjb25zdCBvcHRpb24zID1cbiAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0W2RhdGEtb3B0aW9uPVwib3B0aW9uM1wiXScpICYmXG4gICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdFtkYXRhLW9wdGlvbj1cIm9wdGlvbjNcIl0nKS52YWx1ZTtcbiAgICBjb25zdCBjVmFyaWFudCA9IHByb2R1Y3QudmFyaWFudHMuZmluZChcbiAgICAgICh2YXJpYW50KSA9PlxuICAgICAgICB2YXJpYW50Lm9wdGlvbjEgPT09IG9wdGlvbjEgJiZcbiAgICAgICAgdmFyaWFudC5vcHRpb24yID09PSBvcHRpb24yICYmXG4gICAgICAgIHZhcmlhbnQub3B0aW9uMyA9PT0gb3B0aW9uM1xuICAgICk7XG5cbiAgICBzZXRDdXJyZW50VmFyaWFudChjVmFyaWFudCk7XG5cbiAgICAvLyBkaXNwYXRjaCBhIGN1c3RvbSBldmVudCB0byBjb25uZWN0IHRvIG90aGVyIGNvZGVzXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3ZhcmlhbnRjaGFuZ2UnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgY3VycmVudFZhcmlhbnQ6IGNWYXJpYW50LCBmb3JtOiB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKSB9LFxuICAgIH0pO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQVRDQnV0dG9uQ2xpY2sgPSAoZSkgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdhZGRpdGVtZnJvbWZvcm0nLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgb3JpZ2luYWxFdmVudDogZSwgZm9ybTogdGhpcy5jbG9zZXN0KCdmb3JtJykgfSxcbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9O1xuXG4gIHJldHVybiBodG1sYDxpbnB1dFxuICAgICAgbmFtZT1cImlkXCJcbiAgICAgIHZhbHVlPVwiJHtjdXJyZW50VmFyaWFudCAmJiBjdXJyZW50VmFyaWFudC5pZH1cIlxuICAgICAgdHlwZT1cImhpZGRlblwiXG4gICAgLz5cbiAgICAke29wdGlvbnNXaXRoVmFsdWVzLm1hcChcbiAgICAgIChvcHRpb24pID0+XG4gICAgICAgIGh0bWxgPGRpdlxuICAgICAgICAgIGNsYXNzPVwic2VsZWN0b3Itd3JhcHBlclwiXG4gICAgICAgICAgP2hpZGRlbj0ke29wdGlvbi5uYW1lID09PSAnVGl0bGUnICYmXG4gICAgICAgICAgb3B0aW9uLnZhbHVlc1swXSA9PT0gJ0RlZmF1bHQgVGl0bGUnfVxuICAgICAgICA+XG4gICAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgZGF0YS1vcHRpb249XCJvcHRpb24ke29wdGlvbi5wb3NpdGlvbn1cIlxuICAgICAgICAgICAgQGNoYW5nZT0ke2hhbmRsZU9wdGlvbkNoYW5nZX1cbiAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sICR7c2VsZWN0b3JDdXN0b21DbGFzc2VzfVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgJHtvcHRpb24udmFsdWVzLm1hcChcbiAgICAgICAgICAgICAgKHZhbHVlKSA9PlxuICAgICAgICAgICAgICAgIGh0bWxgPG9wdGlvblxuICAgICAgICAgICAgICAgICAgP3NlbGVjdGVkPSR7Y3VycmVudFZhcmlhbnQgJiZcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYXJpYW50W2BvcHRpb24ke29wdGlvbi5wb3NpdGlvbn1gXSA9PT0gdmFsdWV9XG4gICAgICAgICAgICAgICAgICB2YWx1ZT1cIiR7dmFsdWV9XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAke3ZhbHVlfVxuICAgICAgICAgICAgICAgIDwvb3B0aW9uPmBcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PmBcbiAgICApfVxuICAgIDxpbnB1dFxuICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgcXVhbnRpdHlfaW5wdXQgJHtxdWFudGl0eUlucHV0Q3VzdG9tQ2xhc3Nlc31cIlxuICAgICAgbmFtZT1cInF1YW50aXR5XCJcbiAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgdmFsdWU9XCIxXCJcbiAgICAgIHN0ZXA9XCIxXCJcbiAgICAvPlxuICAgIDxidXR0b25cbiAgICAgID9kaXNhYmxlZD0keyFjdXJyZW50VmFyaWFudCB8fCAhY3VycmVudFZhcmlhbnQuYXZhaWxhYmxlfVxuICAgICAgQGNsaWNrPSR7aGFuZGxlQVRDQnV0dG9uQ2xpY2t9XG4gICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgIG5hbWU9XCJhZGRcIlxuICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgQWRkVG9DYXJ0IGJ0biAke2F0Y0J1dHRvbkN1c3RvbUNsYXNzZXN9XCJcbiAgICA+XG4gICAgICA8c3BhbiBjbGFzcz1cIkFkZFRvQ2FydFRleHRcIj5BZGQgdG8gQ2FydDwvc3Bhbj5cbiAgICA8L2J1dHRvbj5gO1xufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXG4gICdhZGQtdG8tY2FydC1mb3JtLWlucHV0cycsXG4gIGNvbXBvbmVudChhZGRUb0NhcnRGb3JtSW5wdXRzLCB7XG4gICAgdXNlU2hhZG93RE9NOiBmYWxzZSxcbiAgICBvYnNlcnZlZEF0dHJpYnV0ZXM6IFtcbiAgICAgICdkYXRhLXByb2R1Y3QnLFxuICAgICAgJ2RhdGEtc2VsZWN0ZWQtb3ItZmlyc3QtYXZhaWxhYmxlLXZhcmlhbnQnLFxuICAgICAgJ2RhdGEtb3B0aW9ucy13aXRoLXZhbHVlcycsXG4gICAgICAnc2VsZWN0b3ItY3VzdG9tLWNsYXNzZXMnLFxuICAgICAgJ3F1YW50aXR5LWlucHV0LWN1c3RvbS1jbGFzc2VzJyxcbiAgICAgICdhdGMtYnV0dG9uLWN1c3RvbS1jbGFzc2VzJyxcbiAgICBdLFxuICB9KVxuKTtcbiIsImltcG9ydCBCU04gZnJvbSAnYm9vdHN0cmFwLm5hdGl2ZSc7XG5pbXBvcnQgYXBpcyBmcm9tICcuL2FqYXhhcGlzJztcbmltcG9ydCAnLi9zZWN0aW9ucy90ZXN0aW1vbmlhbHMnO1xuaW1wb3J0ICcuL3NlY3Rpb25zL2hlYWRlcic7XG5pbXBvcnQgJy4vc2VjdGlvbnMvbWFzb25yeS1nYWxsZXJ5JztcbmltcG9ydCAnLi9jb21wb25lbnRzL3ByZWRpY3RpdmUtc2VhcmNoJztcbmltcG9ydCAnLi9jb21wb25lbnRzL2FkZC10by1jYXJ0LWZvcm0taW5wdXRzJztcblxud2luZG93LmRhdG9tYXIgPSB7XG4gIEJTTixcbiAgYXBpcyxcbn07XG4iXSwibmFtZXMiOlsidHJhbnNpdGlvbkVuZEV2ZW50IiwiZG9jdW1lbnQiLCJoZWFkIiwic3R5bGUiLCJzdXBwb3J0VHJhbnNpdGlvbiIsInRyYW5zaXRpb25EdXJhdGlvbiIsImdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24iLCJlbGVtZW50IiwiZHVyYXRpb24iLCJwYXJzZUZsb2F0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzTmFOIiwiZW11bGF0ZVRyYW5zaXRpb25FbmQiLCJoYW5kbGVyIiwiY2FsbGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInRyYW5zaXRpb25FbmRXcmFwcGVyIiwiZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZXRUaW1lb3V0IiwicXVlcnlFbGVtZW50Iiwic2VsZWN0b3IiLCJwYXJlbnQiLCJsb29rVXAiLCJFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImJvb3RzdHJhcEN1c3RvbUV2ZW50IiwiZXZlbnROYW1lIiwiY29tcG9uZW50TmFtZSIsInJlbGF0ZWQiLCJPcmlnaW5hbEN1c3RvbUV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJjYW5jZWxhYmxlIiwicmVsYXRlZFRhcmdldCIsImRpc3BhdGNoQ3VzdG9tRXZlbnQiLCJjdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJBbGVydCIsInNlbGYiLCJhbGVydCIsImNsb3NlQ3VzdG9tRXZlbnQiLCJjbG9zZWRDdXN0b21FdmVudCIsInRyaWdnZXJIYW5kbGVyIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJ0cmFuc2l0aW9uRW5kSGFuZGxlciIsInRvZ2dsZUV2ZW50cyIsImFjdGlvbiIsImNsaWNrSGFuZGxlciIsInRhcmdldCIsImNsb3Nlc3QiLCJjbG9zZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNhbGwiLCJkZWZhdWx0UHJldmVudGVkIiwiZGlzcG9zZSIsInJlbW92ZSIsIkJ1dHRvbiIsImxhYmVscyIsImNoYW5nZUN1c3RvbUV2ZW50IiwidG9nZ2xlIiwiaW5wdXQiLCJsYWJlbCIsInRhZ05hbWUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInR5cGUiLCJjaGVja2VkIiwiYWRkIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwidG9nZ2xlZCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiQXJyYXkiLCJmcm9tIiwibWFwIiwib3RoZXJMYWJlbCIsIm90aGVySW5wdXQiLCJrZXlIYW5kbGVyIiwia2V5Iiwid2hpY2giLCJrZXlDb2RlIiwiYWN0aXZlRWxlbWVudCIsInByZXZlbnRTY3JvbGwiLCJwcmV2ZW50RGVmYXVsdCIsImZvY3VzVG9nZ2xlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImxlbmd0aCIsImJ0biIsIm1vdXNlSG92ZXJFdmVudHMiLCJzdXBwb3J0UGFzc2l2ZSIsInJlc3VsdCIsIm9wdHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsIndyYXAiLCJwYXNzaXZlSGFuZGxlciIsInBhc3NpdmUiLCJpc0VsZW1lbnRJblNjcm9sbFJhbmdlIiwiYmNyIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwidmlld3BvcnRIZWlnaHQiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsInRvcCIsImJvdHRvbSIsIkNhcm91c2VsIiwib3B0aW9ucyIsInZhcnMiLCJvcHMiLCJzbGlkZUN1c3RvbUV2ZW50Iiwic2xpZEN1c3RvbUV2ZW50Iiwic2xpZGVzIiwibGVmdEFycm93IiwicmlnaHRBcnJvdyIsImluZGljYXRvciIsImluZGljYXRvcnMiLCJwYXVzZUhhbmRsZXIiLCJpbnRlcnZhbCIsImlzU2xpZGluZyIsImNsZWFySW50ZXJ2YWwiLCJ0aW1lciIsInJlc3VtZUhhbmRsZXIiLCJjeWNsZSIsImluZGljYXRvckhhbmRsZXIiLCJldmVudFRhcmdldCIsImluZGV4IiwicGFyc2VJbnQiLCJzbGlkZVRvIiwiY29udHJvbHNIYW5kbGVyIiwiY3VycmVudFRhcmdldCIsInNyY0VsZW1lbnQiLCJyZWYiLCJwYXVzZSIsInRvdWNoIiwidG91Y2hEb3duSGFuZGxlciIsImtleWJvYXJkIiwidG9nZ2xlVG91Y2hFdmVudHMiLCJ0b3VjaE1vdmVIYW5kbGVyIiwidG91Y2hFbmRIYW5kbGVyIiwiaXNUb3VjaCIsInRvdWNoUG9zaXRpb24iLCJzdGFydFgiLCJjaGFuZ2VkVG91Y2hlcyIsInBhZ2VYIiwiY3VycmVudFgiLCJlbmRYIiwiTWF0aCIsImFicyIsInNldEFjdGl2ZVBhZ2UiLCJwYWdlSW5kZXgiLCJ4IiwibmV4dCIsInRpbWVvdXQiLCJlbGFwc2VkVGltZSIsImFjdGl2ZUl0ZW0iLCJnZXRBY3RpdmVJbmRleCIsIm9yaWVudGF0aW9uIiwiZGlyZWN0aW9uIiwiaGlkZGVuIiwic2V0SW50ZXJ2YWwiLCJpZHgiLCJvZmZzZXRXaWR0aCIsImluZGV4T2YiLCJpdGVtQ2xhc3NlcyIsInNsaWRlIiwiY2xzIiwiaW50ZXJ2YWxBdHRyaWJ1dGUiLCJpbnRlcnZhbERhdGEiLCJ0b3VjaERhdGEiLCJwYXVzZURhdGEiLCJrZXlib2FyZERhdGEiLCJpbnRlcnZhbE9wdGlvbiIsInRvdWNoT3B0aW9uIiwiQ29sbGFwc2UiLCJhY2NvcmRpb24iLCJjb2xsYXBzZSIsImFjdGl2ZUNvbGxhcHNlIiwic2hvd0N1c3RvbUV2ZW50Iiwic2hvd25DdXN0b21FdmVudCIsImhpZGVDdXN0b21FdmVudCIsImhpZGRlbkN1c3RvbUV2ZW50Iiwib3BlbkFjdGlvbiIsImNvbGxhcHNlRWxlbWVudCIsImlzQW5pbWF0aW5nIiwiaGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiY2xvc2VBY3Rpb24iLCJzaG93IiwiaGlkZSIsImlkIiwiYWNjb3JkaW9uRGF0YSIsInNldEZvY3VzIiwiZm9jdXMiLCJzZXRBY3RpdmUiLCJEcm9wZG93biIsIm9wdGlvbiIsIm1lbnUiLCJtZW51SXRlbXMiLCJwZXJzaXN0IiwicHJldmVudEVtcHR5QW5jaG9yIiwiYW5jaG9yIiwiaHJlZiIsInNsaWNlIiwidG9nZ2xlRGlzbWlzcyIsIm9wZW4iLCJkaXNtaXNzSGFuZGxlciIsImhhc0RhdGEiLCJpc1NhbWVFbGVtZW50IiwiaXNJbnNpZGVNZW51IiwiaXNNZW51SXRlbSIsImNoaWxkcmVuIiwiY2hpbGQiLCJwdXNoIiwiTW9kYWwiLCJtb2RhbCIsInNjcm9sbEJhcldpZHRoIiwib3ZlcmxheSIsIm92ZXJsYXlEZWxheSIsImZpeGVkSXRlbXMiLCJzZXRTY3JvbGxiYXIiLCJvcGVuTW9kYWwiLCJib2R5IiwiYm9keVBhZCIsInBhZGRpbmdSaWdodCIsImJvZHlPdmVyZmxvdyIsIm1vZGFsT3ZlcmZsb3ciLCJtZWFzdXJlU2Nyb2xsYmFyIiwiZml4ZWQiLCJpdGVtUGFkIiwicmVzZXRTY3JvbGxiYXIiLCJzY3JvbGxEaXYiLCJjcmVhdGVFbGVtZW50Iiwid2lkdGhWYWx1ZSIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwiY2xpZW50V2lkdGgiLCJjcmVhdGVPdmVybGF5IiwibmV3T3ZlcmxheSIsImFuaW1hdGlvbiIsInJlbW92ZU92ZXJsYXkiLCJ1cGRhdGUiLCJiZWZvcmVTaG93IiwiZGlzcGxheSIsInRyaWdnZXJTaG93IiwidHJpZ2dlckhpZGUiLCJmb3JjZSIsImNsaWNrVGFyZ2V0IiwibW9kYWxJRCIsInRhcmdldEF0dHJWYWx1ZSIsImVsZW1BdHRyVmFsdWUiLCJtb2RhbFRyaWdnZXIiLCJwYXJlbnRXaXRoRGF0YSIsImJhY2tkcm9wIiwiY3VycmVudE9wZW4iLCJzZXRDb250ZW50IiwiY29udGVudCIsImlubmVySFRNTCIsImNoZWNrTW9kYWwiLCJjb25jYXQiLCJ0cmltIiwibW91c2VDbGlja0V2ZW50cyIsImRvd24iLCJ1cCIsImdldFNjcm9sbCIsInkiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsInN0eWxlVGlwIiwibGluayIsInBvc2l0aW9uIiwidGlwUG9zaXRpb25zIiwiZWxlbWVudERpbWVuc2lvbnMiLCJ3IiwiaCIsIm9mZnNldEhlaWdodCIsIndpbmRvd1dpZHRoIiwid2luZG93SGVpZ2h0IiwicmVjdCIsInNjcm9sbCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJsaW5rRGltZW5zaW9ucyIsInJpZ2h0IiwibGVmdCIsImlzUG9wb3ZlciIsImFycm93IiwiaGFsZlRvcEV4Y2VlZCIsImhhbGZMZWZ0RXhjZWVkIiwiaGFsZlJpZ2h0RXhjZWVkIiwiaGFsZkJvdHRvbUV4Y2VlZCIsInRvcEV4Y2VlZCIsImxlZnRFeGNlZWQiLCJib3R0b21FeGNlZWQiLCJyaWdodEV4Y2VlZCIsInRvcFBvc2l0aW9uIiwibGVmdFBvc2l0aW9uIiwiYXJyb3dUb3AiLCJhcnJvd0xlZnQiLCJhcnJvd1dpZHRoIiwiYXJyb3dIZWlnaHQiLCJyZXBsYWNlIiwiUG9wb3ZlciIsInBvcG92ZXIiLCJpc0lwaG9uZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0aXRsZVN0cmluZyIsImNvbnRlbnRTdHJpbmciLCJ0cmlnZ2VyRGF0YSIsImFuaW1hdGlvbkRhdGEiLCJwbGFjZW1lbnREYXRhIiwiZGlzbWlzc2libGVEYXRhIiwiZGVsYXlEYXRhIiwiY29udGFpbmVyRGF0YSIsImNsb3NlQnRuIiwiY29udGFpbmVyRWxlbWVudCIsImNvbnRhaW5lckRhdGFFbGVtZW50IiwibmF2YmFyRml4ZWRUb3AiLCJuYXZiYXJGaXhlZEJvdHRvbSIsInBsYWNlbWVudENsYXNzIiwiZGlzbWlzc2libGVIYW5kbGVyIiwiZ2V0Q29udGVudHMiLCJ0aXRsZSIsInJlbW92ZVBvcG92ZXIiLCJjb250YWluZXIiLCJjcmVhdGVQb3BvdmVyIiwicG9wb3ZlckFycm93IiwidGVtcGxhdGUiLCJwb3BvdmVyVGl0bGUiLCJkaXNtaXNzaWJsZSIsInBvcG92ZXJCb2R5TWFya3VwIiwicG9wb3ZlclRlbXBsYXRlIiwiZmlyc3RDaGlsZCIsInBvcG92ZXJIZWFkZXIiLCJwb3BvdmVyQm9keSIsInNob3dQb3BvdmVyIiwidXBkYXRlUG9wb3ZlciIsInBsYWNlbWVudCIsImZvcmNlRm9jdXMiLCJ0cmlnZ2VyIiwidG91Y2hIYW5kbGVyIiwiZGlzbWlzc0hhbmRsZXJUb2dnbGUiLCJzaG93VHJpZ2dlciIsImhpZGVUcmlnZ2VyIiwiY2xlYXJUaW1lb3V0IiwiZGVsYXkiLCJwb3BvdmVyQ29udGVudHMiLCJTY3JvbGxTcHkiLCJ0YXJnZXREYXRhIiwib2Zmc2V0RGF0YSIsInNweVRhcmdldCIsInNjcm9sbFRhcmdldCIsInVwZGF0ZVRhcmdldHMiLCJsaW5rcyIsIml0ZW1zIiwidGFyZ2V0cyIsInRhcmdldEl0ZW0iLCJjaGFyQXQiLCJ1cGRhdGVJdGVtIiwiaXRlbSIsImRyb3BtZW51IiwiZHJvcExpbmsiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJuZXh0RWxlbWVudFNpYmxpbmciLCJhY3RpdmVTaWJsaW5nIiwidGFyZ2V0UmVjdCIsImlzV2luZG93IiwiaXNBY3RpdmUiLCJ0b3BFZGdlIiwic2Nyb2xsT2Zmc2V0Iiwib2Zmc2V0IiwiYm90dG9tRWRnZSIsImluc2lkZSIsInVwZGF0ZUl0ZW1zIiwibCIsInJlZnJlc2giLCJUYWIiLCJoZWlnaHREYXRhIiwidGFicyIsImRyb3Bkb3duIiwidGFic0NvbnRlbnRDb250YWluZXIiLCJhY3RpdmVUYWIiLCJhY3RpdmVDb250ZW50IiwibmV4dENvbnRlbnQiLCJjb250YWluZXJIZWlnaHQiLCJlcXVhbENvbnRlbnRzIiwibmV4dEhlaWdodCIsImFuaW1hdGVIZWlnaHQiLCJ0cmlnZ2VyRW5kIiwiZ2V0QWN0aXZlVGFiIiwiYWN0aXZlVGFicyIsImdldEFjdGl2ZUNvbnRlbnQiLCJUb2FzdCIsInRvYXN0IiwiYXV0b2hpZGVEYXRhIiwic2hvd0NvbXBsZXRlIiwiYXV0b2hpZGUiLCJoaWRlQ29tcGxldGUiLCJkaXNwb3NlQ29tcGxldGUiLCJub1RpbWVyIiwiVG9vbHRpcCIsInRvb2x0aXAiLCJnZXRUaXRsZSIsInJlbW92ZVRvb2xUaXAiLCJjcmVhdGVUb29sVGlwIiwidG9vbHRpcE1hcmt1cCIsInRvb2x0aXBBcnJvdyIsInRvb2x0aXBJbm5lciIsInVwZGF0ZVRvb2x0aXAiLCJzaG93VG9vbHRpcCIsInRvZ2dsZUFjdGlvbiIsInNob3dBY3Rpb24iLCJoaWRlQWN0aW9uIiwiY29tcG9uZW50c0luaXQiLCJpbml0aWFsaXplRGF0YUFQSSIsIkNvbnN0cnVjdG9yIiwiY29sbGVjdGlvbiIsImluaXRDYWxsYmFjayIsImNvbXBvbmVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpbml0V3JhcHBlciIsInJlbW92ZUVsZW1lbnREYXRhQVBJIiwiQ29uc3RydWN0b3JOYW1lIiwicmVtb3ZlRGF0YUFQSSIsInZlcnNpb24iLCJWZXJzaW9uIiwiYmluZCIsImZuIiwidGhpc0FyZyIsImFyZ3MiLCJhcmd1bWVudHMiLCJpIiwiYXBwbHkiLCJ0b1N0cmluZyIsInByb3RvdHlwZSIsImlzQXJyYXkiLCJ2YWwiLCJpc1VuZGVmaW5lZCIsImlzQnVmZmVyIiwiY29uc3RydWN0b3IiLCJpc0FycmF5QnVmZmVyIiwiaXNGb3JtRGF0YSIsIkZvcm1EYXRhIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc09iamVjdCIsImlzUGxhaW5PYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImlzRGF0ZSIsImlzRmlsZSIsImlzQmxvYiIsImlzRnVuY3Rpb24iLCJpc1N0cmVhbSIsInBpcGUiLCJpc1VSTFNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInN0ciIsImlzU3RhbmRhcmRCcm93c2VyRW52IiwicHJvZHVjdCIsImZvckVhY2giLCJvYmoiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlIiwiYXNzaWduVmFsdWUiLCJleHRlbmQiLCJhIiwiYiIsInN0cmlwQk9NIiwiY2hhckNvZGVBdCIsImVuY29kZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImJ1aWxkVVJMIiwidXJsIiwicGFyYW1zIiwicGFyYW1zU2VyaWFsaXplciIsInNlcmlhbGl6ZWRQYXJhbXMiLCJ1dGlscyIsInBhcnRzIiwic2VyaWFsaXplIiwicGFyc2VWYWx1ZSIsInYiLCJ0b0lTT1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJqb2luIiwiaGFzaG1hcmtJbmRleCIsIkludGVyY2VwdG9yTWFuYWdlciIsImhhbmRsZXJzIiwidXNlIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJlamVjdCIsImZvckVhY2hIYW5kbGVyIiwidHJhbnNmb3JtRGF0YSIsImRhdGEiLCJoZWFkZXJzIiwiZm5zIiwidHJhbnNmb3JtIiwiaXNDYW5jZWwiLCJ2YWx1ZSIsIl9fQ0FOQ0VMX18iLCJub3JtYWxpemVIZWFkZXJOYW1lIiwibm9ybWFsaXplZE5hbWUiLCJwcm9jZXNzSGVhZGVyIiwibmFtZSIsInRvVXBwZXJDYXNlIiwiZW5oYW5jZUVycm9yIiwiZXJyb3IiLCJjb25maWciLCJjb2RlIiwicmVxdWVzdCIsInJlc3BvbnNlIiwiaXNBeGlvc0Vycm9yIiwidG9KU09OIiwibWVzc2FnZSIsImRlc2NyaXB0aW9uIiwibnVtYmVyIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiY29sdW1uTnVtYmVyIiwic3RhY2siLCJjcmVhdGVFcnJvciIsIkVycm9yIiwic2V0dGxlIiwicmVzb2x2ZSIsInJlamVjdCIsInZhbGlkYXRlU3RhdHVzIiwic3RhdHVzIiwic3RhbmRhcmRCcm93c2VyRW52Iiwid3JpdGUiLCJleHBpcmVzIiwicGF0aCIsImRvbWFpbiIsInNlY3VyZSIsImNvb2tpZSIsIkRhdGUiLCJ0b0dNVFN0cmluZyIsInJlYWQiLCJtYXRjaCIsIlJlZ0V4cCIsImRlY29kZVVSSUNvbXBvbmVudCIsIm5vdyIsIm5vblN0YW5kYXJkQnJvd3NlckVudiIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsImJhc2VVUkwiLCJyZWxhdGl2ZVVSTCIsImJ1aWxkRnVsbFBhdGgiLCJyZXF1ZXN0ZWRVUkwiLCJpZ25vcmVEdXBsaWNhdGVPZiIsInBhcnNlSGVhZGVycyIsInBhcnNlZCIsInNwbGl0IiwicGFyc2VyIiwibGluZSIsInN1YnN0ciIsInRvTG93ZXJDYXNlIiwibXNpZSIsInVybFBhcnNpbmdOb2RlIiwib3JpZ2luVVJMIiwicmVzb2x2ZVVSTCIsInByb3RvY29sIiwiaG9zdCIsInNlYXJjaCIsImhhc2giLCJob3N0bmFtZSIsInBvcnQiLCJwYXRobmFtZSIsImxvY2F0aW9uIiwiaXNVUkxTYW1lT3JpZ2luIiwicmVxdWVzdFVSTCIsInhockFkYXB0ZXIiLCJQcm9taXNlIiwiZGlzcGF0Y2hYaHJSZXF1ZXN0IiwicmVxdWVzdERhdGEiLCJyZXF1ZXN0SGVhZGVycyIsIlhNTEh0dHBSZXF1ZXN0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ1bmVzY2FwZSIsIkF1dGhvcml6YXRpb24iLCJidG9hIiwiZnVsbFBhdGgiLCJtZXRob2QiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJoYW5kbGVMb2FkIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVVJMIiwicmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwicmVzcG9uc2VEYXRhIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzVGV4dCIsIm9uYWJvcnQiLCJoYW5kbGVBYm9ydCIsIm9uZXJyb3IiLCJoYW5kbGVFcnJvciIsIm9udGltZW91dCIsImhhbmRsZVRpbWVvdXQiLCJ0aW1lb3V0RXJyb3JNZXNzYWdlIiwieHNyZlZhbHVlIiwid2l0aENyZWRlbnRpYWxzIiwieHNyZkNvb2tpZU5hbWUiLCJjb29raWVzIiwidW5kZWZpbmVkIiwieHNyZkhlYWRlck5hbWUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25Eb3dubG9hZFByb2dyZXNzIiwib25VcGxvYWRQcm9ncmVzcyIsInVwbG9hZCIsImNhbmNlbFRva2VuIiwicHJvbWlzZSIsInRoZW4iLCJvbkNhbmNlbGVkIiwiY2FuY2VsIiwiYWJvcnQiLCJzZW5kIiwiREVGQVVMVF9DT05URU5UX1RZUEUiLCJzZXRDb250ZW50VHlwZUlmVW5zZXQiLCJnZXREZWZhdWx0QWRhcHRlciIsImFkYXB0ZXIiLCJyZXF1aXJlJCQwIiwicHJvY2VzcyIsInJlcXVpcmUkJDEiLCJkZWZhdWx0cyIsInRyYW5zZm9ybVJlcXVlc3QiLCJ0cmFuc2Zvcm1SZXNwb25zZSIsInBhcnNlIiwibWF4Q29udGVudExlbmd0aCIsIm1heEJvZHlMZW5ndGgiLCJjb21tb24iLCJmb3JFYWNoTWV0aG9kTm9EYXRhIiwiZm9yRWFjaE1ldGhvZFdpdGhEYXRhIiwidGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZCIsInRocm93SWZSZXF1ZXN0ZWQiLCJkaXNwYXRjaFJlcXVlc3QiLCJjbGVhbkhlYWRlckNvbmZpZyIsIm9uQWRhcHRlclJlc29sdXRpb24iLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJyZWFzb24iLCJtZXJnZUNvbmZpZyIsImNvbmZpZzEiLCJjb25maWcyIiwidmFsdWVGcm9tQ29uZmlnMktleXMiLCJtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyIsImRlZmF1bHRUb0NvbmZpZzJLZXlzIiwiZGlyZWN0TWVyZ2VLZXlzIiwiZ2V0TWVyZ2VkVmFsdWUiLCJzb3VyY2UiLCJtZXJnZURlZXBQcm9wZXJ0aWVzIiwicHJvcCIsInZhbHVlRnJvbUNvbmZpZzIiLCJkZWZhdWx0VG9Db25maWcyIiwiYXhpb3NLZXlzIiwib3RoZXJLZXlzIiwia2V5cyIsImZpbHRlciIsImZpbHRlckF4aW9zS2V5cyIsIkF4aW9zIiwiaW5zdGFuY2VDb25maWciLCJpbnRlcmNlcHRvcnMiLCJjaGFpbiIsInVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3IiLCJ1bnNoaWZ0IiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwic2hpZnQiLCJnZXRVcmkiLCJDYW5jZWwiLCJDYW5jZWxUb2tlbiIsImV4ZWN1dG9yIiwiVHlwZUVycm9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJ0b2tlbiIsImMiLCJzcHJlYWQiLCJjYWxsYmFjayIsImFyciIsImNyZWF0ZUluc3RhbmNlIiwiZGVmYXVsdENvbmZpZyIsImNvbnRleHQiLCJpbnN0YW5jZSIsImF4aW9zIiwiY3JlYXRlIiwicmVxdWlyZSQkMiIsImFsbCIsInByb21pc2VzIiwicmVxdWlyZSQkMyIsIlZFUlNJT04iLCJMQVJHRV9BUlJBWV9TSVpFIiwiQ09SRV9FUlJPUl9URVhUIiwiRlVOQ19FUlJPUl9URVhUIiwiSEFTSF9VTkRFRklORUQiLCJNQVhfTUVNT0laRV9TSVpFIiwiUExBQ0VIT0xERVIiLCJDTE9ORV9ERUVQX0ZMQUciLCJDTE9ORV9GTEFUX0ZMQUciLCJDTE9ORV9TWU1CT0xTX0ZMQUciLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJXUkFQX0JJTkRfRkxBRyIsIldSQVBfQklORF9LRVlfRkxBRyIsIldSQVBfQ1VSUllfQk9VTkRfRkxBRyIsIldSQVBfQ1VSUllfRkxBRyIsIldSQVBfQ1VSUllfUklHSFRfRkxBRyIsIldSQVBfUEFSVElBTF9GTEFHIiwiV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUciLCJXUkFQX0FSWV9GTEFHIiwiV1JBUF9SRUFSR19GTEFHIiwiV1JBUF9GTElQX0ZMQUciLCJERUZBVUxUX1RSVU5DX0xFTkdUSCIsIkRFRkFVTFRfVFJVTkNfT01JU1NJT04iLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIkxBWllfRklMVEVSX0ZMQUciLCJMQVpZX01BUF9GTEFHIiwiTEFaWV9XSElMRV9GTEFHIiwiSU5GSU5JVFkiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUFYX0lOVEVHRVIiLCJOQU4iLCJNQVhfQVJSQVlfTEVOR1RIIiwiTUFYX0FSUkFZX0lOREVYIiwiSEFMRl9NQVhfQVJSQVlfTEVOR1RIIiwid3JhcEZsYWdzIiwiYXJnc1RhZyIsImFycmF5VGFnIiwiYXN5bmNUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImRvbUV4Y1RhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm51bGxUYWciLCJvYmplY3RUYWciLCJwcm9taXNlVGFnIiwicHJveHlUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJzeW1ib2xUYWciLCJ1bmRlZmluZWRUYWciLCJ3ZWFrTWFwVGFnIiwid2Vha1NldFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZUVtcHR5U3RyaW5nTGVhZGluZyIsInJlRW1wdHlTdHJpbmdNaWRkbGUiLCJyZUVtcHR5U3RyaW5nVHJhaWxpbmciLCJyZUVzY2FwZWRIdG1sIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNFc2NhcGVkSHRtbCIsInJlSGFzVW5lc2NhcGVkSHRtbCIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsInJlSW50ZXJwb2xhdGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwicmVQcm9wTmFtZSIsInJlUmVnRXhwQ2hhciIsInJlSGFzUmVnRXhwQ2hhciIsInJlVHJpbSIsInJlVHJpbVN0YXJ0IiwicmVUcmltRW5kIiwicmVXcmFwQ29tbWVudCIsInJlV3JhcERldGFpbHMiLCJyZVNwbGl0RGV0YWlscyIsInJlQXNjaWlXb3JkIiwicmVFc2NhcGVDaGFyIiwicmVFc1RlbXBsYXRlIiwicmVGbGFncyIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc0hvc3RDdG9yIiwicmVJc09jdGFsIiwicmVJc1VpbnQiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNEaW5nYmF0UmFuZ2UiLCJyc0xvd2VyUmFuZ2UiLCJyc01hdGhPcFJhbmdlIiwicnNOb25DaGFyUmFuZ2UiLCJyc1B1bmN0dWF0aW9uUmFuZ2UiLCJyc1NwYWNlUmFuZ2UiLCJyc1VwcGVyUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNBc3RyYWwiLCJyc0JyZWFrIiwicnNDb21ibyIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNVcHBlciIsInJzWldKIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc09yZExvd2VyIiwicnNPcmRVcHBlciIsInJzU2VxIiwicnNFbW9qaSIsInJzU3ltYm9sIiwicmVBcG9zIiwicmVDb21ib01hcmsiLCJyZVVuaWNvZGUiLCJyZVVuaWNvZGVXb3JkIiwicmVIYXNVbmljb2RlIiwicmVIYXNVbmljb2RlV29yZCIsImNvbnRleHRQcm9wcyIsInRlbXBsYXRlQ291bnRlciIsInR5cGVkQXJyYXlUYWdzIiwiY2xvbmVhYmxlVGFncyIsImRlYnVycmVkTGV0dGVycyIsImh0bWxFc2NhcGVzIiwiaHRtbFVuZXNjYXBlcyIsInN0cmluZ0VzY2FwZXMiLCJmcmVlUGFyc2VGbG9hdCIsImZyZWVQYXJzZUludCIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJGdW5jdGlvbiIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJmcmVlUHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJyZXF1aXJlIiwiYmluZGluZyIsIm5vZGVJc0FycmF5QnVmZmVyIiwibm9kZUlzRGF0ZSIsIm5vZGVJc01hcCIsImlzTWFwIiwibm9kZUlzUmVnRXhwIiwiaXNSZWdFeHAiLCJub2RlSXNTZXQiLCJpc1NldCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJmdW5jIiwiYXJyYXlBZ2dyZWdhdG9yIiwiYXJyYXkiLCJzZXR0ZXIiLCJpdGVyYXRlZSIsImFjY3VtdWxhdG9yIiwiYXJyYXlFYWNoIiwiYXJyYXlFYWNoUmlnaHQiLCJhcnJheUV2ZXJ5IiwicHJlZGljYXRlIiwiYXJyYXlGaWx0ZXIiLCJyZXNJbmRleCIsImFycmF5SW5jbHVkZXMiLCJiYXNlSW5kZXhPZiIsImFycmF5SW5jbHVkZXNXaXRoIiwiY29tcGFyYXRvciIsImFycmF5TWFwIiwiYXJyYXlQdXNoIiwidmFsdWVzIiwiYXJyYXlSZWR1Y2UiLCJpbml0QWNjdW0iLCJhcnJheVJlZHVjZVJpZ2h0IiwiYXJyYXlTb21lIiwiYXNjaWlTaXplIiwiYmFzZVByb3BlcnR5IiwiYXNjaWlUb0FycmF5Iiwic3RyaW5nIiwiYXNjaWlXb3JkcyIsImJhc2VGaW5kS2V5IiwiZWFjaEZ1bmMiLCJiYXNlRmluZEluZGV4IiwiZnJvbUluZGV4IiwiZnJvbVJpZ2h0Iiwic3RyaWN0SW5kZXhPZiIsImJhc2VJc05hTiIsImJhc2VJbmRleE9mV2l0aCIsImJhc2VNZWFuIiwiYmFzZVN1bSIsIm9iamVjdCIsImJhc2VQcm9wZXJ0eU9mIiwiYmFzZVJlZHVjZSIsImJhc2VTb3J0QnkiLCJjb21wYXJlciIsInNvcnQiLCJjdXJyZW50IiwiYmFzZVRpbWVzIiwibiIsImJhc2VUb1BhaXJzIiwicHJvcHMiLCJiYXNlVW5hcnkiLCJiYXNlVmFsdWVzIiwiY2FjaGVIYXMiLCJjYWNoZSIsImhhcyIsImNoYXJzU3RhcnRJbmRleCIsInN0clN5bWJvbHMiLCJjaHJTeW1ib2xzIiwiY2hhcnNFbmRJbmRleCIsImNvdW50SG9sZGVycyIsInBsYWNlaG9sZGVyIiwiZGVidXJyTGV0dGVyIiwiZXNjYXBlSHRtbENoYXIiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiZ2V0VmFsdWUiLCJoYXNVbmljb2RlIiwiaGFzVW5pY29kZVdvcmQiLCJpdGVyYXRvclRvQXJyYXkiLCJpdGVyYXRvciIsImRvbmUiLCJtYXBUb0FycmF5Iiwic2l6ZSIsIm92ZXJBcmciLCJhcmciLCJyZXBsYWNlSG9sZGVycyIsInNldFRvQXJyYXkiLCJzZXQiLCJzZXRUb1BhaXJzIiwic3RyaWN0TGFzdEluZGV4T2YiLCJzdHJpbmdTaXplIiwidW5pY29kZVNpemUiLCJzdHJpbmdUb0FycmF5IiwidW5pY29kZVRvQXJyYXkiLCJ1bmVzY2FwZUh0bWxDaGFyIiwibGFzdEluZGV4IiwidW5pY29kZVdvcmRzIiwicnVuSW5Db250ZXh0IiwiXyIsInBpY2siLCJTdHJpbmciLCJhcnJheVByb3RvIiwiZnVuY1Byb3RvIiwib2JqZWN0UHJvdG8iLCJjb3JlSnNEYXRhIiwiZnVuY1RvU3RyaW5nIiwiaWRDb3VudGVyIiwibWFza1NyY0tleSIsInVpZCIsImV4ZWMiLCJJRV9QUk9UTyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwib2JqZWN0Q3RvclN0cmluZyIsIm9sZERhc2giLCJyZUlzTmF0aXZlIiwiQnVmZmVyIiwiU3ltYm9sIiwiVWludDhBcnJheSIsImFsbG9jVW5zYWZlIiwiZ2V0UHJvdG90eXBlIiwib2JqZWN0Q3JlYXRlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzcGxpY2UiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwic3ltSXRlcmF0b3IiLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiZ2V0TmF0aXZlIiwiY3R4Q2xlYXJUaW1lb3V0IiwiY3R4Tm93IiwiY3R4U2V0VGltZW91dCIsIm5hdGl2ZUNlaWwiLCJjZWlsIiwibmF0aXZlRmxvb3IiLCJmbG9vciIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJuYXRpdmVJc0J1ZmZlciIsIm5hdGl2ZUlzRmluaXRlIiwiaXNGaW5pdGUiLCJuYXRpdmVKb2luIiwibmF0aXZlS2V5cyIsIm5hdGl2ZU1heCIsIm1heCIsIm5hdGl2ZU1pbiIsIm1pbiIsIm5hdGl2ZU5vdyIsIm5hdGl2ZVBhcnNlSW50IiwibmF0aXZlUmFuZG9tIiwicmFuZG9tIiwibmF0aXZlUmV2ZXJzZSIsInJldmVyc2UiLCJEYXRhVmlldyIsIk1hcCIsIlNldCIsIldlYWtNYXAiLCJuYXRpdmVDcmVhdGUiLCJtZXRhTWFwIiwicmVhbE5hbWVzIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwidG9Tb3VyY2UiLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwic3ltYm9sVG9TdHJpbmciLCJsb2Rhc2giLCJpc09iamVjdExpa2UiLCJMYXp5V3JhcHBlciIsIkxvZGFzaFdyYXBwZXIiLCJ3cmFwcGVyQ2xvbmUiLCJiYXNlQ3JlYXRlIiwicHJvdG8iLCJiYXNlTG9kYXNoIiwiY2hhaW5BbGwiLCJfX3dyYXBwZWRfXyIsIl9fYWN0aW9uc19fIiwiX19jaGFpbl9fIiwiX19pbmRleF9fIiwiX192YWx1ZXNfXyIsInRlbXBsYXRlU2V0dGluZ3MiLCJfX2Rpcl9fIiwiX19maWx0ZXJlZF9fIiwiX19pdGVyYXRlZXNfXyIsIl9fdGFrZUNvdW50X18iLCJfX3ZpZXdzX18iLCJsYXp5Q2xvbmUiLCJjb3B5QXJyYXkiLCJsYXp5UmV2ZXJzZSIsImNsb25lIiwibGF6eVZhbHVlIiwiZGlyIiwiaXNBcnIiLCJpc1JpZ2h0IiwiYXJyTGVuZ3RoIiwidmlldyIsImdldFZpZXciLCJzdGFydCIsImVuZCIsIml0ZXJhdGVlcyIsIml0ZXJMZW5ndGgiLCJ0YWtlQ291bnQiLCJiYXNlV3JhcHBlclZhbHVlIiwib3V0ZXIiLCJpdGVySW5kZXgiLCJjb21wdXRlZCIsIkhhc2giLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkxpc3RDYWNoZSIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwiYXNzb2NJbmRleE9mIiwicG9wIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiU2V0Q2FjaGUiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU3RhY2siLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJwYWlycyIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyZyIsImlzQXJndW1lbnRzIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJpc0luZGV4IiwiYXJyYXlTYW1wbGUiLCJiYXNlUmFuZG9tIiwiYXJyYXlTYW1wbGVTaXplIiwic2h1ZmZsZVNlbGYiLCJiYXNlQ2xhbXAiLCJhcnJheVNodWZmbGUiLCJhc3NpZ25NZXJnZVZhbHVlIiwiZXEiLCJiYXNlQXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImJhc2VBZ2dyZWdhdG9yIiwiYmFzZUVhY2giLCJiYXNlQXNzaWduIiwiY29weU9iamVjdCIsImJhc2VBc3NpZ25JbiIsImtleXNJbiIsImJhc2VBdCIsInBhdGhzIiwic2tpcCIsImxvd2VyIiwidXBwZXIiLCJiYXNlQ2xvbmUiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsImlzRGVlcCIsImlzRmxhdCIsImlzRnVsbCIsImluaXRDbG9uZUFycmF5IiwidGFnIiwiZ2V0VGFnIiwiaXNGdW5jIiwiY2xvbmVCdWZmZXIiLCJpbml0Q2xvbmVPYmplY3QiLCJjb3B5U3ltYm9sc0luIiwiY29weVN5bWJvbHMiLCJpbml0Q2xvbmVCeVRhZyIsInN0YWNrZWQiLCJzdWJWYWx1ZSIsImtleXNGdW5jIiwiZ2V0QWxsS2V5c0luIiwiZ2V0QWxsS2V5cyIsImJhc2VDb25mb3JtcyIsImJhc2VDb25mb3Jtc1RvIiwiYmFzZURlbGF5Iiwid2FpdCIsImJhc2VEaWZmZXJlbmNlIiwiaW5jbHVkZXMiLCJpc0NvbW1vbiIsInZhbHVlc0xlbmd0aCIsInZhbHVlc0luZGV4IiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRm9yT3duIiwiYmFzZUVhY2hSaWdodCIsImJhc2VGb3JPd25SaWdodCIsImJhc2VFdmVyeSIsImJhc2VFeHRyZW11bSIsImlzU3ltYm9sIiwiYmFzZUZpbGwiLCJ0b0ludGVnZXIiLCJ0b0xlbmd0aCIsImJhc2VGaWx0ZXIiLCJiYXNlRmxhdHRlbiIsImRlcHRoIiwiaXNTdHJpY3QiLCJpc0ZsYXR0ZW5hYmxlIiwiYmFzZUZvciIsImNyZWF0ZUJhc2VGb3IiLCJiYXNlRm9yUmlnaHQiLCJiYXNlRnVuY3Rpb25zIiwiYmFzZUdldCIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiYmFzZUdldFRhZyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwiYmFzZUd0Iiwib3RoZXIiLCJiYXNlSGFzIiwiYmFzZUhhc0luIiwiYmFzZUluUmFuZ2UiLCJiYXNlSW50ZXJzZWN0aW9uIiwiYXJyYXlzIiwib3RoTGVuZ3RoIiwib3RoSW5kZXgiLCJjYWNoZXMiLCJtYXhMZW5ndGgiLCJJbmZpbml0eSIsInNlZW4iLCJiYXNlSW52ZXJ0ZXIiLCJiYXNlSW52b2tlIiwibGFzdCIsImJhc2VJc0FyZ3VtZW50cyIsImJhc2VJc0FycmF5QnVmZmVyIiwiYmFzZUlzRGF0ZSIsImJhc2VJc0VxdWFsIiwiYmFzZUlzRXF1YWxEZWVwIiwiZXF1YWxGdW5jIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJlcXVhbE9iamVjdHMiLCJiYXNlSXNNYXAiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsInNyY1ZhbHVlIiwiYmFzZUlzTmF0aXZlIiwiaXNNYXNrZWQiLCJwYXR0ZXJuIiwiYmFzZUlzUmVnRXhwIiwiYmFzZUlzU2V0IiwiYmFzZUlzVHlwZWRBcnJheSIsImlzTGVuZ3RoIiwiYmFzZUl0ZXJhdGVlIiwiaWRlbnRpdHkiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJwcm9wZXJ0eSIsImJhc2VLZXlzIiwiaXNQcm90b3R5cGUiLCJiYXNlS2V5c0luIiwibmF0aXZlS2V5c0luIiwiaXNQcm90byIsImJhc2VMdCIsImJhc2VNYXAiLCJpc0FycmF5TGlrZSIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiaXNLZXkiLCJpc1N0cmljdENvbXBhcmFibGUiLCJoYXNJbiIsImJhc2VNZXJnZSIsInNyY0luZGV4IiwiYmFzZU1lcmdlRGVlcCIsIm5ld1ZhbHVlIiwic2FmZUdldCIsIm1lcmdlRnVuYyIsImlzVHlwZWQiLCJpc0FycmF5TGlrZU9iamVjdCIsImNsb25lVHlwZWRBcnJheSIsInRvUGxhaW5PYmplY3QiLCJiYXNlTnRoIiwiYmFzZU9yZGVyQnkiLCJvcmRlcnMiLCJnZXRJdGVyYXRlZSIsImNyaXRlcmlhIiwiY29tcGFyZU11bHRpcGxlIiwiYmFzZVBpY2siLCJiYXNlUGlja0J5IiwiYmFzZVNldCIsImJhc2VQcm9wZXJ0eURlZXAiLCJiYXNlUHVsbEFsbCIsImJhc2VQdWxsQXQiLCJpbmRleGVzIiwicHJldmlvdXMiLCJiYXNlVW5zZXQiLCJiYXNlUmFuZ2UiLCJzdGVwIiwiYmFzZVJlcGVhdCIsImJhc2VSZXN0Iiwic2V0VG9TdHJpbmciLCJvdmVyUmVzdCIsImJhc2VTYW1wbGUiLCJiYXNlU2FtcGxlU2l6ZSIsIm5lc3RlZCIsImJhc2VTZXREYXRhIiwiYmFzZVNldFRvU3RyaW5nIiwiY29uc3RhbnQiLCJiYXNlU2h1ZmZsZSIsImJhc2VTbGljZSIsImJhc2VTb21lIiwiYmFzZVNvcnRlZEluZGV4IiwicmV0SGlnaGVzdCIsImxvdyIsImhpZ2giLCJtaWQiLCJiYXNlU29ydGVkSW5kZXhCeSIsInZhbElzTmFOIiwidmFsSXNOdWxsIiwidmFsSXNTeW1ib2wiLCJ2YWxJc1VuZGVmaW5lZCIsIm90aElzRGVmaW5lZCIsIm90aElzTnVsbCIsIm90aElzUmVmbGV4aXZlIiwib3RoSXNTeW1ib2wiLCJzZXRMb3ciLCJiYXNlU29ydGVkVW5pcSIsImJhc2VUb051bWJlciIsImJhc2VUb1N0cmluZyIsImJhc2VVbmlxIiwiY3JlYXRlU2V0Iiwic2VlbkluZGV4IiwiYmFzZVVwZGF0ZSIsInVwZGF0ZXIiLCJiYXNlV2hpbGUiLCJpc0Ryb3AiLCJhY3Rpb25zIiwiYmFzZVhvciIsImJhc2VaaXBPYmplY3QiLCJhc3NpZ25GdW5jIiwidmFsc0xlbmd0aCIsImNhc3RBcnJheUxpa2VPYmplY3QiLCJjYXN0RnVuY3Rpb24iLCJzdHJpbmdUb1BhdGgiLCJjYXN0UmVzdCIsImNhc3RTbGljZSIsImNvcHkiLCJjbG9uZUFycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiY2xvbmVEYXRhVmlldyIsImRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImNsb25lUmVnRXhwIiwicmVnZXhwIiwiY2xvbmVTeW1ib2wiLCJzeW1ib2wiLCJ0eXBlZEFycmF5IiwiY29tcGFyZUFzY2VuZGluZyIsInZhbElzRGVmaW5lZCIsInZhbElzUmVmbGV4aXZlIiwib2JqQ3JpdGVyaWEiLCJvdGhDcml0ZXJpYSIsIm9yZGVyc0xlbmd0aCIsIm9yZGVyIiwiY29tcG9zZUFyZ3MiLCJwYXJ0aWFscyIsImhvbGRlcnMiLCJpc0N1cnJpZWQiLCJhcmdzSW5kZXgiLCJhcmdzTGVuZ3RoIiwiaG9sZGVyc0xlbmd0aCIsImxlZnRJbmRleCIsImxlZnRMZW5ndGgiLCJyYW5nZUxlbmd0aCIsImlzVW5jdXJyaWVkIiwiY29tcG9zZUFyZ3NSaWdodCIsImhvbGRlcnNJbmRleCIsInJpZ2h0SW5kZXgiLCJyaWdodExlbmd0aCIsImlzTmV3IiwiZ2V0U3ltYm9scyIsImdldFN5bWJvbHNJbiIsImNyZWF0ZUFnZ3JlZ2F0b3IiLCJpbml0aWFsaXplciIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJpc0l0ZXJhdGVlQ2FsbCIsIml0ZXJhYmxlIiwiY3JlYXRlQmluZCIsImlzQmluZCIsIkN0b3IiLCJjcmVhdGVDdG9yIiwid3JhcHBlciIsImNyZWF0ZUNhc2VGaXJzdCIsIm1ldGhvZE5hbWUiLCJ0cmFpbGluZyIsImNyZWF0ZUNvbXBvdW5kZXIiLCJ3b3JkcyIsImRlYnVyciIsInRoaXNCaW5kaW5nIiwiY3JlYXRlQ3VycnkiLCJhcml0eSIsImdldEhvbGRlciIsImNyZWF0ZVJlY3VycnkiLCJjcmVhdGVIeWJyaWQiLCJjcmVhdGVGaW5kIiwiZmluZEluZGV4RnVuYyIsImNyZWF0ZUZsb3ciLCJmbGF0UmVzdCIsImZ1bmNzIiwicHJlcmVxIiwidGhydSIsImdldEZ1bmNOYW1lIiwiZnVuY05hbWUiLCJnZXREYXRhIiwiaXNMYXppYWJsZSIsInBsYW50IiwicGFydGlhbHNSaWdodCIsImhvbGRlcnNSaWdodCIsImFyZ1BvcyIsImFyeSIsImlzQXJ5IiwiaXNCaW5kS2V5IiwiaXNGbGlwIiwiaG9sZGVyc0NvdW50IiwibmV3SG9sZGVycyIsInJlb3JkZXIiLCJjcmVhdGVJbnZlcnRlciIsInRvSXRlcmF0ZWUiLCJjcmVhdGVNYXRoT3BlcmF0aW9uIiwib3BlcmF0b3IiLCJkZWZhdWx0VmFsdWUiLCJjcmVhdGVPdmVyIiwiYXJyYXlGdW5jIiwiY3JlYXRlUGFkZGluZyIsImNoYXJzIiwiY2hhcnNMZW5ndGgiLCJjcmVhdGVQYXJ0aWFsIiwiY3JlYXRlUmFuZ2UiLCJ0b0Zpbml0ZSIsImNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24iLCJ0b051bWJlciIsIndyYXBGdW5jIiwiaXNDdXJyeSIsIm5ld0hvbGRlcnNSaWdodCIsIm5ld1BhcnRpYWxzIiwibmV3UGFydGlhbHNSaWdodCIsIm5ld0RhdGEiLCJzZXREYXRhIiwic2V0V3JhcFRvU3RyaW5nIiwiY3JlYXRlUm91bmQiLCJwcmVjaXNpb24iLCJwYWlyIiwibm9vcCIsImNyZWF0ZVRvUGFpcnMiLCJjcmVhdGVXcmFwIiwibWVyZ2VEYXRhIiwiY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiIsImN1c3RvbURlZmF1bHRzTWVyZ2UiLCJjdXN0b21PbWl0Q2xvbmUiLCJpc1BhcnRpYWwiLCJhcnJTdGFja2VkIiwib3RoU3RhY2tlZCIsImFyclZhbHVlIiwib3RoVmFsdWUiLCJjb21wYXJlZCIsImNvbnZlcnQiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwib2JqU3RhY2tlZCIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJmbGF0dGVuIiwib3RoZXJGdW5jIiwiaXNLZXlhYmxlIiwiaXNPd24iLCJ1bm1hc2tlZCIsInN0dWJBcnJheSIsImN0b3JTdHJpbmciLCJ0cmFuc2Zvcm1zIiwiZ2V0V3JhcERldGFpbHMiLCJoYXNQYXRoIiwiaGFzRnVuYyIsImluc2VydFdyYXBEZXRhaWxzIiwiZGV0YWlscyIsImlzTWFza2FibGUiLCJzdHViRmFsc2UiLCJtZW1vaXplQ2FwcGVkIiwibWVtb2l6ZSIsInNyY0JpdG1hc2siLCJuZXdCaXRtYXNrIiwiaXNDb21ibyIsIm90aGVyQXJncyIsIm9sZEFycmF5Iiwic2hvcnRPdXQiLCJyZWZlcmVuY2UiLCJ1cGRhdGVXcmFwRGV0YWlscyIsImNvdW50IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwicmFuZCIsInF1b3RlIiwic3ViU3RyaW5nIiwiY2h1bmsiLCJjb21wYWN0IiwiZGlmZmVyZW5jZSIsImRpZmZlcmVuY2VCeSIsImRpZmZlcmVuY2VXaXRoIiwiZHJvcCIsImRyb3BSaWdodCIsImRyb3BSaWdodFdoaWxlIiwiZHJvcFdoaWxlIiwiZmlsbCIsImZpbmRJbmRleCIsImZpbmRMYXN0SW5kZXgiLCJmbGF0dGVuRGVlcCIsImZsYXR0ZW5EZXB0aCIsImZyb21QYWlycyIsImluaXRpYWwiLCJpbnRlcnNlY3Rpb24iLCJtYXBwZWQiLCJpbnRlcnNlY3Rpb25CeSIsImludGVyc2VjdGlvbldpdGgiLCJzZXBhcmF0b3IiLCJsYXN0SW5kZXhPZiIsIm50aCIsInB1bGwiLCJwdWxsQWxsIiwicHVsbEFsbEJ5IiwicHVsbEFsbFdpdGgiLCJwdWxsQXQiLCJzb3J0ZWRJbmRleCIsInNvcnRlZEluZGV4QnkiLCJzb3J0ZWRJbmRleE9mIiwic29ydGVkTGFzdEluZGV4Iiwic29ydGVkTGFzdEluZGV4QnkiLCJzb3J0ZWRMYXN0SW5kZXhPZiIsInNvcnRlZFVuaXEiLCJzb3J0ZWRVbmlxQnkiLCJ0YWlsIiwidGFrZSIsInRha2VSaWdodCIsInRha2VSaWdodFdoaWxlIiwidGFrZVdoaWxlIiwidW5pb24iLCJ1bmlvbkJ5IiwidW5pb25XaXRoIiwidW5pcSIsInVuaXFCeSIsInVuaXFXaXRoIiwidW56aXAiLCJncm91cCIsInVuemlwV2l0aCIsIndpdGhvdXQiLCJ4b3IiLCJ4b3JCeSIsInhvcldpdGgiLCJ6aXAiLCJ6aXBPYmplY3QiLCJ6aXBPYmplY3REZWVwIiwiemlwV2l0aCIsInRhcCIsIndyYXBwZXJBdCIsIndyYXBwZXJDaGFpbiIsIndyYXBwZXJDb21taXQiLCJ3cmFwcGVyTmV4dCIsInRvQXJyYXkiLCJ3cmFwcGVyVG9JdGVyYXRvciIsIndyYXBwZXJQbGFudCIsIndyYXBwZXJSZXZlcnNlIiwid3JhcHBlZCIsIndyYXBwZXJWYWx1ZSIsImNvdW50QnkiLCJldmVyeSIsImZpbmQiLCJmaW5kTGFzdCIsImZsYXRNYXAiLCJmbGF0TWFwRGVlcCIsImZsYXRNYXBEZXB0aCIsImZvckVhY2hSaWdodCIsImdyb3VwQnkiLCJpbnZva2VNYXAiLCJrZXlCeSIsIm9yZGVyQnkiLCJwYXJ0aXRpb24iLCJyZWR1Y2UiLCJyZWR1Y2VSaWdodCIsIm5lZ2F0ZSIsInNhbXBsZSIsInNhbXBsZVNpemUiLCJzaHVmZmxlIiwic29tZSIsInNvcnRCeSIsImFmdGVyIiwiYmVmb3JlIiwiYmluZEtleSIsImN1cnJ5IiwiY3VycnlSaWdodCIsImRlYm91bmNlIiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwiaW52b2tlRnVuYyIsInRpbWUiLCJsZWFkaW5nRWRnZSIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImZsdXNoIiwiZGVib3VuY2VkIiwiaXNJbnZva2luZyIsImRlZmVyIiwiZmxpcCIsInJlc29sdmVyIiwibWVtb2l6ZWQiLCJDYWNoZSIsIm9uY2UiLCJvdmVyQXJncyIsImZ1bmNzTGVuZ3RoIiwicGFydGlhbCIsInBhcnRpYWxSaWdodCIsInJlYXJnIiwicmVzdCIsInRocm90dGxlIiwidW5hcnkiLCJjYXN0QXJyYXkiLCJjbG9uZVdpdGgiLCJjbG9uZURlZXAiLCJjbG9uZURlZXBXaXRoIiwiY29uZm9ybXNUbyIsImd0IiwiZ3RlIiwiaXNCb29sZWFuIiwiaXNFbGVtZW50IiwiaXNFbXB0eSIsImlzRXF1YWwiLCJpc0VxdWFsV2l0aCIsImlzRXJyb3IiLCJpc0ludGVnZXIiLCJpc01hdGNoIiwiaXNNYXRjaFdpdGgiLCJpc05hdGl2ZSIsImlzTnVsbCIsImlzTmlsIiwiaXNTYWZlSW50ZWdlciIsImlzV2Vha01hcCIsImlzV2Vha1NldCIsImx0IiwibHRlIiwic2lnbiIsInJlbWFpbmRlciIsImlzQmluYXJ5IiwidG9TYWZlSW50ZWdlciIsImFzc2lnbiIsImFzc2lnbkluIiwiYXNzaWduSW5XaXRoIiwiYXNzaWduV2l0aCIsImF0IiwicHJvcGVydGllcyIsInByb3BzSW5kZXgiLCJwcm9wc0xlbmd0aCIsImRlZmF1bHRzRGVlcCIsIm1lcmdlV2l0aCIsImZpbmRLZXkiLCJmaW5kTGFzdEtleSIsImZvckluIiwiZm9ySW5SaWdodCIsImZvck93biIsImZvck93blJpZ2h0IiwiZnVuY3Rpb25zIiwiZnVuY3Rpb25zSW4iLCJpbnZlcnQiLCJpbnZlcnRCeSIsImludm9rZSIsIm1hcEtleXMiLCJtYXBWYWx1ZXMiLCJvbWl0Iiwib21pdEJ5IiwicGlja0J5Iiwic2V0V2l0aCIsInRvUGFpcnMiLCJ0b1BhaXJzSW4iLCJpc0Fyckxpa2UiLCJ1bnNldCIsInVwZGF0ZVdpdGgiLCJ2YWx1ZXNJbiIsImNsYW1wIiwiaW5SYW5nZSIsImZsb2F0aW5nIiwidGVtcCIsImNhbWVsQ2FzZSIsIndvcmQiLCJjYXBpdGFsaXplIiwidXBwZXJGaXJzdCIsImVuZHNXaXRoIiwiZXNjYXBlIiwiZXNjYXBlUmVnRXhwIiwia2ViYWJDYXNlIiwibG93ZXJDYXNlIiwibG93ZXJGaXJzdCIsInBhZCIsInN0ckxlbmd0aCIsInBhZEVuZCIsInBhZFN0YXJ0IiwicmFkaXgiLCJyZXBlYXQiLCJzbmFrZUNhc2UiLCJsaW1pdCIsInN0YXJ0Q2FzZSIsInN0YXJ0c1dpdGgiLCJzZXR0aW5ncyIsImltcG9ydHMiLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwiaW50ZXJwb2xhdGUiLCJyZURlbGltaXRlcnMiLCJldmFsdWF0ZSIsInNvdXJjZVVSTCIsImVzY2FwZVZhbHVlIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImVzVGVtcGxhdGVWYWx1ZSIsImV2YWx1YXRlVmFsdWUiLCJ2YXJpYWJsZSIsImF0dGVtcHQiLCJ0b0xvd2VyIiwidG9VcHBlciIsInRyaW1FbmQiLCJ0cmltU3RhcnQiLCJ0cnVuY2F0ZSIsIm9taXNzaW9uIiwic3Vic3RyaW5nIiwibmV3RW5kIiwidXBwZXJDYXNlIiwiYmluZEFsbCIsIm1ldGhvZE5hbWVzIiwiY29uZCIsImNvbmZvcm1zIiwiZGVmYXVsdFRvIiwiZmxvdyIsImZsb3dSaWdodCIsIm1hdGNoZXMiLCJtYXRjaGVzUHJvcGVydHkiLCJtZXRob2RPZiIsIm1peGluIiwibm9Db25mbGljdCIsIm50aEFyZyIsIm92ZXIiLCJvdmVyRXZlcnkiLCJvdmVyU29tZSIsInByb3BlcnR5T2YiLCJyYW5nZSIsInJhbmdlUmlnaHQiLCJzdHViT2JqZWN0Iiwic3R1YlN0cmluZyIsInN0dWJUcnVlIiwidGltZXMiLCJ0b1BhdGgiLCJ1bmlxdWVJZCIsInByZWZpeCIsImF1Z2VuZCIsImFkZGVuZCIsImRpdmlkZSIsImRpdmlkZW5kIiwiZGl2aXNvciIsIm1heEJ5IiwibWVhbiIsIm1lYW5CeSIsIm1pbkJ5IiwibXVsdGlwbHkiLCJtdWx0aXBsaWVyIiwibXVsdGlwbGljYW5kIiwicm91bmQiLCJzdWJ0cmFjdCIsIm1pbnVlbmQiLCJzdWJ0cmFoZW5kIiwic3VtIiwic3VtQnkiLCJlbnRyaWVzSW4iLCJleHRlbmRXaXRoIiwiZWFjaCIsImVhY2hSaWdodCIsImZpcnN0IiwiaXNGaWx0ZXIiLCJ0YWtlTmFtZSIsImRyb3BOYW1lIiwiY2hlY2tJdGVyYXRlZSIsImlzVGFrZXIiLCJsb2Rhc2hGdW5jIiwicmV0VW53cmFwcGVkIiwiaXNMYXp5IiwidXNlTGF6eSIsImlzSHlicmlkIiwiaXNVbndyYXBwZWQiLCJvbmx5TGF6eSIsImNoYWluTmFtZSIsImNvbW1pdCIsInRoaXMiLCJhdHRyaWJ1dGVUb1N0cmluZyIsImF0dHJpYnV0ZSIsInRvZ2dsZUNsYXNzIiwiZWxlbSIsInJlbW92ZUNsYXNzIiwiY2xhc3NOYW1lcyIsImFqYXhUZW1wbGF0ZUZ1bmMiLCJlbmNvZGVkIiwiZW5jb2RlVVJJIiwicG9zdCIsImdldENhcnQiLCJnZXRQcm9kdWN0IiwiaGFuZGxlIiwiY2xlYXJDYXJ0IiwidXBkYXRlQ2FydEZyb21Gb3JtIiwiZm9ybSIsImNoYW5nZUl0ZW1CeUtleU9ySWQiLCJxdWFudGl0eSIsInJlbW92ZUl0ZW1CeUtleU9ySWQiLCJjaGFuZ2VJdGVtQnlMaW5lIiwicmVtb3ZlSXRlbUJ5TGluZSIsImFkZEl0ZW0iLCJhZGRJdGVtRnJvbUZvcm0iLCJ1cGRhdGVDYXJ0QXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJ1cGRhdGVDYXJ0Tm90ZSIsIm5vdGUiLCJnZXRSZWNvbW1lbmRlZFByb2R1Y3RzIiwicHJvZHVjdElkIiwiZ2V0UHJlZGljdGl2ZVNlYXJjaFJlc3VsdHMiLCJxIiwidW5hdmFpbGFibGVQcm9kdWN0cyIsImZpZWxkcyIsInBhcmFtc1N0cmluZyIsImZhY3RvcnkiLCJfd2luZG93IiwiR2xpZGVyIiwiX2dsaWRlciIsImVsZSIsIm9wdCIsInNsaWRlc1RvU2Nyb2xsIiwic2xpZGVzVG9TaG93IiwicmVzaXplTG9jayIsImVhc2luZyIsInQiLCJkIiwiYW5pbWF0ZV9pZCIsInBhZ2UiLCJhcnJvd3MiLCJfb3B0Iiwic2tpcFRyYWNrIiwidHJhY2siLCJpbml0IiwicmVzaXplIiwiZXZlbnQiLCJ1cGRhdGVDb250cm9scyIsImdsaWRlclByb3RvdHlwZSIsInBhZ2luZyIsIndpZHRoIiwiY29udGFpbmVyV2lkdGgiLCJicmVha3BvaW50Q2hhbmdlZCIsInNldHRpbmdzQnJlYWtwb2ludCIsIl9hdXRvU2xpZGUiLCJzbGlkZUNvdW50IiwiaXRlbVdpZHRoIiwiZXhhY3RXaWR0aCIsIl9fIiwidHJhY2tXaWR0aCIsImlzRHJhZyIsInByZXZlbnRDbGljayIsInNjcm9sbFRvIiwiYmluZEFycm93cyIsImJ1aWxkRG90cyIsImJpbmREcmFnIiwiZW1pdCIsIm1vdXNlIiwiaGFuZGxlTW91c2UiLCJtb3VzZXVwIiwibW91c2VEb3duIiwiZXZlbnRzIiwibW91c2VsZWF2ZSIsIm1vdXNlZG93biIsInN0b3BQcm9wYWdhdGlvbiIsImNsaWVudFgiLCJtb3VzZW1vdmUiLCJjbGljayIsImRyYWdnYWJsZSIsImRvdHMiLCJkb3QiLCJkYXRhc2V0Iiwic2Nyb2xsSXRlbSIsIl9mdW5jIiwic2Nyb2xsUHJvcGFnYXRlIiwiZGlzYWJsZUFycm93cyIsInJld2luZCIsInByZXYiLCJtaWRkbGUiLCJleHRyYU1pZGRsZSIsInNsaWRlQ2xhc3NlcyIsIndhc1Zpc2libGUiLCJpdGVtU3RhcnQiLCJpdGVtRW5kIiwiaXNWaXNpYmxlIiwic2Nyb2xsTG9jayIsInNjcm9sbExvY2tEZWxheSIsIm9yaWdpbmFsU2xpZGUiLCJiYWNrd2FyZHMiLCJyZXNwIiwicmVzcG9uc2l2ZSIsImJyZWFrcG9pbnQiLCJpbm5lcldpZHRoIiwic2Nyb2xsRHVyYXRpb24iLCJnZXRUaW1lIiwiYW5pbWF0ZUluZGV4IiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlbW92ZUl0ZW0iLCJkcmFnVmVsb2NpdHkiLCJkb3VibGUiLCJpbnYiLCJzZXRPcHRpb24iLCJkZXN0cm95IiwiY2xvbmVOb2RlIiwib3V0ZXJIVE1MIiwicmVwbGFjZUNoaWxkIiwiYnViYmxlcyIsImV2ZW50UHJvcGFnYXRlIiwiZGV0YWlsIiwiZXZlbnRIYW5kbGVyIiwiayIsInNldHVwVGVzdGltb25pYWxTbGlkZXIiLCJvZmZjYW52YXNJZCIsIm9mZmNhbnZhcyIsInNjcmVlbk92ZXJsYXkiLCJtb2JpbGVPZmZjYW52YXMiLCJyIiwibyIsIkEiLCJyZWNhbGN1bGF0ZSIsInJlc3BvbnNpdmVPcHRpb25zIiwiZG9jV2lkdGgiLCJzIiwiYnJlYWtBdCIsIk8iLCJ1c2VDb250YWluZXJGb3JCcmVha3BvaW50cyIsImNvbHVtbnMiLCJtYXJnaW4iLCJtb2JpbGVGaXJzdCIsInUiLCJyb3dzIiwicCIsIk0iLCJjb2xzIiwibWFjeUNvbXBsZXRlIiwidG1wUm93cyIsImYiLCJsYXN0Y29sIiwiQyIsIm5vZGVOYW1lIiwiYnlDc3MiLCJzZWxlY3RvcnMiLCJnZXRFbGVtZW50QnlJZCIsIm0iLCJydW5uaW5nIiwicnVuIiwib24iLCJnIiwibmF0dXJhbEhlaWdodCIsIm5hdHVyYWxXaWR0aCIsIkUiLCJjb21wbGV0ZSIsImNvbnN0YW50cyIsIkVWRU5UX0lNQUdFX0xPQUQiLCJpbWciLCJFVkVOVF9JTUFHRV9FUlJPUiIsIkVWRU5UX0lNQUdFX0NPTVBMRVRFIiwiSSIsIkVWRU5UX1JFU0laRSIsInF1ZXVlIiwiTiIsImRlYnVnIiwiY29uc29sZSIsIlQiLCJyZXNpemVyIiwiTCIsInVzZU93bkltYWdlTG9hZGVyIiwid2FpdEZvckltYWdlcyIsIkVWRU5UX0lOSVRJQUxJWkVEIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIlYiLCJvZmZzZXRQYXJlbnQiLCJ0cnVlT3JkZXIiLCJFVkVOVF9SRUNBTENVTEFURUQiLCJSIiwidXNlSW1hZ2VMb2FkZXIiLCJvbkluaXQiLCJjYW5jZWxMZWdhY3kiLCJ3YXJuIiwicmVjYWxjdWxhdGVPbkltYWdlTG9hZCIsInJ1bk9uSW1hZ2VMb2FkIiwicmVJbml0IiwiTWFjeSIsImN1cnJlbnRJZCIsInNldEN1cnJlbnQiLCJzdGF0ZSIsIm5vdGlmeSIsInBoYXNlU3ltYm9sIiwiaG9va1N5bWJvbCIsInVwZGF0ZVN5bWJvbCIsImNvbW1pdFN5bWJvbCIsImVmZmVjdHNTeW1ib2wiLCJsYXlvdXRFZmZlY3RzU3ltYm9sIiwiY29udGV4dEV2ZW50IiwiU3RhdGUiLCJjYiIsInJlcyIsInBoYXNlIiwiZWZmZWN0cyIsImVmZmVjdCIsIl9ydW5FZmZlY3RzIiwiaG9va3MiLCJob29rIiwidGVhcmRvd24iLCJydW5uZXIiLCJ0YXNrcyIsInJ1blRhc2tzIiwibGVuIiwidGFzayIsIkJhc2VTY2hlZHVsZXIiLCJyZW5kZXJlciIsIl91cGRhdGVRdWV1ZWQiLCJoYW5kbGVQaGFzZSIsInJ1bkVmZmVjdHMiLCJyZW5kZXIiLCJ0b0NhbWVsQ2FzZSIsImNoYXIiLCJtYWtlQ29tcG9uZW50IiwiU2NoZWR1bGVyIiwiZnJhZyIsImJhc2VFbGVtZW50T3JPcHRpb25zIiwiQmFzZUVsZW1lbnQiLCJiYXNlRWxlbWVudCIsIkhUTUxFbGVtZW50Iiwib2JzZXJ2ZWRBdHRyaWJ1dGVzIiwidXNlU2hhZG93RE9NIiwic2hhZG93Um9vdEluaXQiLCJfc2NoZWR1bGVyIiwiYXR0YWNoU2hhZG93IiwibW9kZSIsInNoYWRvd1Jvb3QiLCJvbGRWYWx1ZSIsIlJlZmxlY3QiLCJyZWZsZWN0aXZlUHJvcCIsImluaXRpYWxWYWx1ZSIsImZyZWV6ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJQcm94eSIsInJlY2VpdmVyIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIndyaXRhYmxlIiwic2V0UHJvdG90eXBlT2YiLCJIb29rIiwiY3JlYXRlRWZmZWN0Iiwic2V0RWZmZWN0cyIsImlnbm9yZWQxIiwiaWdub3JlZDIiLCJsYXN0VmFsdWVzIiwiaGFzQ2hhbmdlZCIsIl90ZWFyZG93biIsInVzZUVmZmVjdCIsInVzZUNvbnRleHQiLCJfdXBkYXRlciIsIl9yYW5FZmZlY3QiLCJfdW5zdWJzY3JpYmUiLCJDb250ZXh0IiwidmlydHVhbCIsIl9zdWJzY3JpYmUiLCJjb21wb3NlZCIsInVuc3Vic2NyaWJlIiwibWFrZUNvbnRleHQiLCJQcm92aWRlciIsImxpc3RlbmVycyIsIl92YWx1ZSIsIkNvbnN1bWVyIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiaW5wdXRzIiwic2V0TGF5b3V0RWZmZWN0cyIsInVzZUxheW91dEVmZmVjdCIsInVzZVN0YXRlIiwibWFrZUFyZ3MiLCJ1cGRhdGVyRm4iLCJwcmV2aW91c1ZhbHVlIiwidXNlUmVkdWNlciIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwiY3VycmVudFN0YXRlIiwicmVkdWNlciIsInVzZVJlZiIsImhhdW50ZWQiLCJjcmVhdGVDb250ZXh0IiwidXNlRGVib3VuY2VkQ2FsbGJhY2siLCJyYXdXYWl0IiwiZnVuY1JlZiIsIm1vdW50ZWQiLCJ1c2VSQUYiLCJOdW1iZXIiLCJzdGFydFRpbWVyIiwicGVuZGluZ0Z1bmMiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNhbmNlbFRpbWVyIiwicGVuZGluZyIsImRlYm91bmNlZFN0YXRlIiwicHJlZGljdGl2ZVNlYXJjaCIsInNldFEiLCJyZXN1bHRzIiwic2V0UmVzdWx0cyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwic2V0VmFsdWUiLCJyZXNvdXJjZXMiLCJoYW5kbGVLZXl1cCIsImh0bWwiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSIsImFkZFRvQ2FydEZvcm1JbnB1dHMiLCJkYXRhUHJvZHVjdCIsImRhdGFTZWxlY3RlZE9yRmlyc3RBdmFpbGFibGVWYXJpYW50IiwiZGF0YU9wdGlvbnNXaXRoVmFsdWVzIiwic2VsZWN0b3JDdXN0b21DbGFzc2VzIiwicXVhbnRpdHlJbnB1dEN1c3RvbUNsYXNzZXMiLCJhdGNCdXR0b25DdXN0b21DbGFzc2VzIiwib3B0aW9uc1dpdGhWYWx1ZXMiLCJ2YXJpYW50cyIsInZhcmlhbnQiLCJjdXJyZW50VmFyaWFudCIsInNldEN1cnJlbnRWYXJpYW50IiwiaGFuZGxlT3B0aW9uQ2hhbmdlIiwib3B0aW9uMSIsIm9wdGlvbjIiLCJvcHRpb24zIiwiY1ZhcmlhbnQiLCJoYW5kbGVBVENCdXR0b25DbGljayIsIm9yaWdpbmFsRXZlbnQiLCJhdmFpbGFibGUiLCJkYXRvbWFyIiwiQlNOIiwiYXBpcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQTs7Ozs7RUFLQSxJQUFJQSxrQkFBa0IsR0FBRyxzQkFBc0JDLFFBQVEsQ0FBQ0MsSUFBVCxDQUFjQyxLQUFwQyxHQUE0QyxxQkFBNUMsR0FBb0UsZUFBN0Y7RUFFQSxJQUFJQyxpQkFBaUIsR0FBRyxzQkFBc0JILFFBQVEsQ0FBQ0MsSUFBVCxDQUFjQyxLQUFwQyxJQUE2QyxnQkFBZ0JGLFFBQVEsQ0FBQ0MsSUFBVCxDQUFjQyxLQUFuRztFQUVBLElBQUlFLGtCQUFrQixHQUFHLHNCQUFzQkosUUFBUSxDQUFDQyxJQUFULENBQWNDLEtBQXBDLEdBQTRDLDBCQUE1QyxHQUF5RSxvQkFBbEc7O0VBRUEsU0FBU0csNEJBQVQsQ0FBc0NDLE9BQXRDLEVBQStDO0VBQzdDLE1BQUlDLFFBQVEsR0FBR0osaUJBQWlCLEdBQUdLLFVBQVUsQ0FBQ0MsZ0JBQWdCLENBQUNILE9BQUQsQ0FBaEIsQ0FBMEJGLGtCQUExQixDQUFELENBQWIsR0FBK0QsQ0FBL0Y7RUFDQUcsRUFBQUEsUUFBUSxHQUFHLE9BQU9BLFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0MsQ0FBQ0csS0FBSyxDQUFDSCxRQUFELENBQXRDLEdBQW1EQSxRQUFRLEdBQUcsSUFBOUQsR0FBcUUsQ0FBaEY7RUFDQSxTQUFPQSxRQUFQO0VBQ0Q7O0VBRUQsU0FBU0ksb0JBQVQsQ0FBOEJMLE9BQTlCLEVBQXNDTSxPQUF0QyxFQUE4QztFQUM1QyxNQUFJQyxNQUFNLEdBQUcsQ0FBYjtFQUFBLE1BQWdCTixRQUFRLEdBQUdG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
